/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "GameFrameworkNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_GAMEFRAMEWORK_ENUMS
#define INCLUDED_GAMEFRAMEWORK_ENUMS 1

enum EShakeParam
{
    ESP_OffsetRandom        =0,
    ESP_OffsetZero          =1,
    ESP_MAX                 =2,
};
#define FOREACH_ENUM_ESHAKEPARAM(op) \
    op(ESP_OffsetRandom) \
    op(ESP_OffsetZero) 
enum ECrowdBehaviorEvent
{
    CBE_None                =0,
    CBE_Spawn               =1,
    CBE_Random              =2,
    CBE_SeePlayer           =3,
    CBE_EncounterAgent      =4,
    CBE_TakeDamage          =5,
    CBE_GroupWaiting        =6,
    CBE_Uneasy              =7,
    CBE_Alert               =8,
    CBE_Panic               =9,
    CBE_MAX                 =10,
};
#define FOREACH_ENUM_ECROWDBEHAVIOREVENT(op) \
    op(CBE_None) \
    op(CBE_Spawn) \
    op(CBE_Random) \
    op(CBE_SeePlayer) \
    op(CBE_EncounterAgent) \
    op(CBE_TakeDamage) \
    op(CBE_GroupWaiting) \
    op(CBE_Uneasy) \
    op(CBE_Alert) \
    op(CBE_Panic) 
enum EConformType
{
    CFM_NavMesh             =0,
    CFM_BSP                 =1,
    CFM_World               =2,
    CFM_None                =3,
    CFM_MAX                 =4,
};
#define FOREACH_ENUM_ECONFORMTYPE(op) \
    op(CFM_NavMesh) \
    op(CFM_BSP) \
    op(CFM_World) \
    op(CFM_None) 
enum EZoneSlideType
{
    ZoneSlide_UpDown        =0,
    ZoneSlide_LeftRight     =1,
    ZoneSlide_MAX           =2,
};
#define FOREACH_ENUM_EZONESLIDETYPE(op) \
    op(ZoneSlide_UpDown) \
    op(ZoneSlide_LeftRight) 
enum EZoneState
{
    ZoneState_Inactive      =0,
    ZoneState_Activating    =1,
    ZoneState_Active        =2,
    ZoneState_Deactivating  =3,
    ZoneState_MAX           =4,
};
#define FOREACH_ENUM_EZONESTATE(op) \
    op(ZoneState_Inactive) \
    op(ZoneState_Activating) \
    op(ZoneState_Active) \
    op(ZoneState_Deactivating) 
enum EZoneType
{
    ZoneType_Button         =0,
    ZoneType_Joystick       =1,
    ZoneType_Trackball      =2,
    ZoneType_Slider         =3,
    ZoneType_SubClassed     =4,
    ZoneType_MAX            =5,
};
#define FOREACH_ENUM_EZONETYPE(op) \
    op(ZoneType_Button) \
    op(ZoneType_Joystick) \
    op(ZoneType_Trackball) \
    op(ZoneType_Slider) \
    op(ZoneType_SubClassed) 
enum EUIOrientation
{
    UI_Unknown              =0,
    UI_Portait              =1,
    UI_PortaitUpsideDown    =2,
    UI_LandscapeRight       =3,
    UI_LandscapeLeft        =4,
    UI_MAX                  =5,
};
#define FOREACH_ENUM_EUIORIENTATION(op) \
    op(UI_Unknown) \
    op(UI_Portait) \
    op(UI_PortaitUpsideDown) \
    op(UI_LandscapeRight) \
    op(UI_LandscapeLeft) 
enum MenuImageDrawStyle
{
    IDS_Normal              =0,
    IDS_Stretched           =1,
    IDS_Tile                =2,
    IDS_MAX                 =3,
};
#define FOREACH_ENUM_MENUIMAGEDRAWSTYLE(op) \
    op(IDS_Normal) \
    op(IDS_Stretched) \
    op(IDS_Tile) 

#endif // !INCLUDED_GAMEFRAMEWORK_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_GAMEFRAMEWORK_CLASSES
#define INCLUDED_GAMEFRAMEWORK_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UDynamicSpriteComponent : public USpriteComponent
{
public:
    //## BEGIN PROPS DynamicSpriteComponent
    FInterpCurveFloat AnimatedScale;
    FInterpCurveLinearColor AnimatedColor;
    FInterpCurveVector2D AnimatedPosition;
    FVector LocationOffset;
    INT LoopCount;
    //## END PROPS DynamicSpriteComponent

    DECLARE_CLASS(UDynamicSpriteComponent,USpriteComponent,0,GameFramework)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
};

struct FRequiredMobileInputConfig
{
    FStringNoInit GroupName;
    TArray<FString> RequireZoneNames;
    BITFIELD bIsAttractModeGroup:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FRequiredMobileInputConfig() {}
    FRequiredMobileInputConfig(EEventParm)
    {
        appMemzero(this, sizeof(FRequiredMobileInputConfig));
    }
};

class AFrameworkGame : public AGameInfo
{
public:
    //## BEGIN PROPS FrameworkGame
    TArrayNoInit<struct FRequiredMobileInputConfig> RequiredMobileInputConfigs;
    //## END PROPS FrameworkGame

    DECLARE_CLASS(AFrameworkGame,AGameInfo,0|CLASS_Config,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(AFrameworkGame)
};

struct GameAICommand_eventGetDebugVerboseText_Parms
{
    FString ReturnValue;
    GameAICommand_eventGetDebugVerboseText_Parms(EEventParm)
    {
    }
};
struct GameAICommand_eventDrawDebug_Parms
{
    class AHUD* H;
    FName Category;
    GameAICommand_eventDrawDebug_Parms(EEventParm)
    {
    }
};
struct GameAICommand_eventGetDumpString_Parms
{
    FString ReturnValue;
    GameAICommand_eventGetDumpString_Parms(EEventParm)
    {
    }
};
struct GameAICommand_eventInternalTick_Parms
{
    FLOAT DeltaTime;
    GameAICommand_eventInternalTick_Parms(EEventParm)
    {
    }
};
struct GameAICommand_eventInternalResumed_Parms
{
    FName OldCommandName;
    GameAICommand_eventInternalResumed_Parms(EEventParm)
    {
    }
};
struct GameAICommand_eventInternalPaused_Parms
{
    class UGameAICommand* NewCommand;
    GameAICommand_eventInternalPaused_Parms(EEventParm)
    {
    }
};
struct GameAICommand_eventInternalPopped_Parms
{
    GameAICommand_eventInternalPopped_Parms(EEventParm)
    {
    }
};
struct GameAICommand_eventInternalPushed_Parms
{
    GameAICommand_eventInternalPushed_Parms(EEventParm)
    {
    }
};
struct GameAICommand_eventInternalPrePushed_Parms
{
    class AGameAIController* AI;
    GameAICommand_eventInternalPrePushed_Parms(EEventParm)
    {
    }
};
class UGameAICommand : public UAICommandBase
{
public:
    //## BEGIN PROPS GameAICommand
    class UGameAICommand* ChildCommand;
    FName ChildStatus;
    class AGameAIController* GameAIOwner;
    FName Status;
    BITFIELD bAllowNewSameClassInstance:1;
    BITFIELD bReplaceActiveSameClassInstance:1;
    BITFIELD bAborted:1;
    BITFIELD bIgnoreNotifies:1;
    BITFIELD bIgnoreStepAside:1;
    BITFIELD bPendingPop:1;
    SCRIPT_ALIGN;
    //## END PROPS GameAICommand

    UBOOL ShouldIgnoreNotifies() const;
    DECLARE_FUNCTION(execShouldIgnoreNotifies)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ShouldIgnoreNotifies();
    }
    FString eventGetDebugVerboseText()
    {
        GameAICommand_eventGetDebugVerboseText_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_GetDebugVerboseText),&Parms);
        return Parms.ReturnValue;
    }
    void eventDrawDebug(class AHUD* H,FName Category)
    {
        GameAICommand_eventDrawDebug_Parms Parms(EC_EventParm);
        Parms.H=H;
        Parms.Category=Category;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_DrawDebug),&Parms);
    }
    FString eventGetDumpString()
    {
        GameAICommand_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    void eventInternalTick(FLOAT DeltaTime)
    {
        GameAICommand_eventInternalTick_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_InternalTick),&Parms);
    }
    void eventInternalResumed(FName OldCommandName)
    {
        GameAICommand_eventInternalResumed_Parms Parms(EC_EventParm);
        Parms.OldCommandName=OldCommandName;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_InternalResumed),&Parms);
    }
    void eventInternalPaused(class UGameAICommand* NewCommand)
    {
        GameAICommand_eventInternalPaused_Parms Parms(EC_EventParm);
        Parms.NewCommand=NewCommand;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_InternalPaused),&Parms);
    }
    void eventInternalPopped()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_InternalPopped),NULL);
    }
    void eventInternalPushed()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_InternalPushed),NULL);
    }
    void eventInternalPrePushed(class AGameAIController* AI)
    {
        GameAICommand_eventInternalPrePushed_Parms Parms(EC_EventParm);
        Parms.AI=AI;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_InternalPrePushed),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UGameAICommand,UAICommandBase,0,GameFramework)
    DECLARE_WITHIN(AGameAIController)
    virtual void TickCommand(FLOAT DeltaTime);
    void ProcessState(FLOAT DeltaSeconds);
    virtual EGotoState GotoState( FName State, UBOOL bForceEvents = 0, UBOOL bKeepStack = 0 );
    void PopChildCommand();
};

#define UCONST_LOADING_MOVIE TEXT("LoadingMovie")

struct FScreenShakeAnimStruct
{
    class UCameraAnim* Anim;
    BITFIELD bUseDirectionalAnimVariants:1;
    class UCameraAnim* Anim_Left;
    class UCameraAnim* Anim_Right;
    class UCameraAnim* Anim_Rear;
    FLOAT AnimPlayRate;
    FLOAT AnimScale;
    FLOAT AnimBlendInTime;
    FLOAT AnimBlendOutTime;
    BITFIELD bRandomSegment:1;
    FLOAT RandomSegmentDuration;
    BITFIELD bSingleInstance:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FScreenShakeAnimStruct() {}
    FScreenShakeAnimStruct(EEventParm)
    {
        appMemzero(this, sizeof(FScreenShakeAnimStruct));
    }
};

struct FShakeParams
{
    MS_ALIGN(4) BYTE X GCC_ALIGN(4); // Extra alignment flags needed because all properties are bytes
    BYTE Y;
    BYTE Z;
    BYTE Padding;
    SCRIPT_ALIGN;

    /** Constructors */
    FShakeParams() {}
    FShakeParams(EEventParm)
    {
        appMemzero(this, sizeof(FShakeParams));
    }
};

struct FScreenShakeStruct
{
    FLOAT TimeToGo;
    FLOAT TimeDuration;
    FVector RotAmplitude;
    FVector RotFrequency;
    FVector RotSinOffset;
    struct FShakeParams RotParam;
    FVector LocAmplitude;
    FVector LocFrequency;
    FVector LocSinOffset;
    struct FShakeParams LocParam;
    FLOAT FOVAmplitude;
    FLOAT FOVFrequency;
    FLOAT FOVSinOffset;
    BYTE FOVParam;
    FName ShakeName;
    BITFIELD bOverrideTargetingDampening:1;
    FLOAT TargetingDampening;

    /** Constructors */
    FScreenShakeStruct() {}
    FScreenShakeStruct(EEventParm)
    {
        appMemzero(this, sizeof(FScreenShakeStruct));
    }
};

struct FTakeHitInfo
{
    FVector HitLocation;
    FVector Momentum;
    class UClass* DamageType;
    class APawn* InstigatedBy;
    BYTE HitBoneIndex;
    class UPhysicalMaterial* PhysicalMaterial;
    FLOAT Damage;
    FVector RadialDamageOrigin;

    /** Constructors */
    FTakeHitInfo() {}
    FTakeHitInfo(EEventParm)
    {
        appMemzero(this, sizeof(FTakeHitInfo));
    }
};

struct FGameSpecialMoveInfo
{
    FName SpecialMoveName;
    class UClass* SpecialMoveClass;
    class UGameSpecialMove* SpecialMoveInstance;

    /** Constructors */
    FGameSpecialMoveInfo() {}
    FGameSpecialMoveInfo(EEventParm)
    {
        appMemzero(this, sizeof(FGameSpecialMoveInfo));
    }
};

struct FSpecialMoveStruct
{
    FName SpecialMoveName;
    class AGamePawn* InteractionPawn;
    class AActor* InteractionActor;
    INT Flags;

    /** Constructors */
    FSpecialMoveStruct() {}
    FSpecialMoveStruct(EEventParm)
    {
        appMemzero(this, sizeof(FSpecialMoveStruct));
    }
};

struct FAICmdHistoryItem
{
    class UClass* CmdClass;
    FLOAT TimeStamp;
    FStringNoInit VerboseString;

    /** Constructors */
    FAICmdHistoryItem() {}
    FAICmdHistoryItem(EEventParm)
    {
        appMemzero(this, sizeof(FAICmdHistoryItem));
    }
};

struct FNearbyDynamicItem
{
    class AActor* Dynamic;

		FORCEINLINE UBOOL operator==(const AActor* Other) const
		{
			return (Dynamic==Other);
		}
	
};

struct FCrowdSpawnerPlayerInfo
{
    FVector ViewLocation;
    FRotator ViewRotation;
    FVector PredictLocation;
    class APlayerController* PC;

    /** Constructors */
    FCrowdSpawnerPlayerInfo() {}
    FCrowdSpawnerPlayerInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCrowdSpawnerPlayerInfo));
    }
};

struct FAgentArchetypeInfo
{
    class UObject* AgentArchetype;
    FLOAT FrequencyModifier;
    INT MaxAllowed;
    INT CurrSpawned;
    TArrayNoInit<class UObject*> GroupMembers;

    /** Constructors */
    FAgentArchetypeInfo() {}
    FAgentArchetypeInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAgentArchetypeInfo));
    }
};

struct FCrowdSpawnInfoItem
{
    class USeqAct_GameCrowdPopulationManagerToggle* SeqSpawner;
    BITFIELD bSpawningActive:1;
    FLOAT SpawnRate;
    INT SpawnNum;
    FLOAT Remainder;
    TArrayNoInit<class AGameCrowdAgent*> ActiveAgents;
    TArrayNoInit<struct FAgentArchetypeInfo> AgentArchetypes;
    FLOAT AgentFrequencySum;
    FLOAT MaxSpawnDist;
    FLOAT MaxSpawnDistSq;
    FLOAT MinBehindSpawnDist;
    FLOAT MinBehindSpawnDistSq;
    FLOAT AgentWarmupTime;
    BITFIELD bForceObstacleChecking:1;
    BITFIELD bForceNavMeshPathing:1;
    BITFIELD bEnableCrowdLightEnvironment:1;
    BITFIELD bCastShadows:1;
    SCRIPT_ALIGN;
    FLightingChannelContainer AgentLightingChannel;
    INT NumAgentsToTickPerFrame;
    INT LastAgentTickedIndex;
    TArrayNoInit<class AGameCrowdDestination*> PotentialSpawnPoints;
    FLOAT SpawnPrioritizationInterval;
    INT PrioritizationIndex;
    INT PrioritizationUpdateIndex;
    TArrayNoInit<class AGameCrowdDestination*> PrioritizedSpawnPoints;
    FLOAT PlayerPositionPredictionTime;

    /** Constructors */
    FCrowdSpawnInfoItem() {}
    FCrowdSpawnInfoItem(EEventParm)
    {
        appMemzero(this, sizeof(FCrowdSpawnInfoItem));
    }
};

class UGameTypes : public UObject
{
public:
    //## BEGIN PROPS GameTypes
    //## END PROPS GameTypes

    DECLARE_CLASS(UGameTypes,UObject,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UGameTypes)
};

struct GameAIController_eventGetActionString_Parms
{
    FString ReturnValue;
    GameAIController_eventGetActionString_Parms(EEventParm)
    {
    }
};
struct GameAIController_eventAILog_Internal_Parms
{
    FString LogText;
    FName LogCategory;
    UBOOL bForce;
    GameAIController_eventAILog_Internal_Parms(EEventParm)
    {
    }
};
class AGameAIController : public AAIController
{
public:
    //## BEGIN PROPS GameAIController
    class UGameAICommand* CommandList;
    BITFIELD bHasRunawayCommandList:1;
    BITFIELD bAILogging:1;
    BITFIELD bAILogToWindow:1;
    BITFIELD bFlushAILogEachLine:1;
    BITFIELD bMapBasedLogName:1;
    BITFIELD bAIDrawDebug:1;
    BITFIELD bAIBroken:1;
    class AFileLog* AILogFile;
    FLOAT DebugTextMaxLen;
    TArrayNoInit<struct FAICmdHistoryItem> CommandHistory;
    INT CommandHistoryNum;
    TArrayNoInit<FName> AILogFilter;
    FStringNoInit DemoActionString;
    //## END PROPS GameAIController

    virtual void PushCommand(class UGameAICommand* NewCommand);
    virtual void PopCommand(class UGameAICommand* ToBePoppedCommand);
    virtual UBOOL AbortCommand(class UGameAICommand* AbortCmd,class UClass* AbortClass=NULL);
    class UGameAICommand* GetActiveCommand();
    void CheckCommandCount();
    void DumpCommandStack();
    class UGameAICommand* FindCommandOfClass(class UClass* SearchClass) const;
    virtual class UGameAICommand* GetAICommandInStack(const class UClass* InClass);
    DECLARE_FUNCTION(execAllCommands);
    DECLARE_FUNCTION(execPushCommand)
    {
        P_GET_OBJECT(UGameAICommand,NewCommand);
        P_FINISH;
        this->PushCommand(NewCommand);
    }
    DECLARE_FUNCTION(execPopCommand)
    {
        P_GET_OBJECT(UGameAICommand,ToBePoppedCommand);
        P_FINISH;
        this->PopCommand(ToBePoppedCommand);
    }
    DECLARE_FUNCTION(execAbortCommand)
    {
        P_GET_OBJECT(UGameAICommand,AbortCmd);
        P_GET_OBJECT_OPTX(UClass,AbortClass,NULL);
        P_FINISH;
        *(UBOOL*)Result=this->AbortCommand(AbortCmd,AbortClass);
    }
    DECLARE_FUNCTION(execGetActiveCommand)
    {
        P_FINISH;
        *(class UGameAICommand**)Result=this->GetActiveCommand();
    }
    DECLARE_FUNCTION(execCheckCommandCount)
    {
        P_FINISH;
        this->CheckCommandCount();
    }
    DECLARE_FUNCTION(execDumpCommandStack)
    {
        P_FINISH;
        this->DumpCommandStack();
    }
    DECLARE_FUNCTION(execFindCommandOfClass)
    {
        P_GET_OBJECT(UClass,SearchClass);
        P_FINISH;
        *(class UGameAICommand**)Result=this->FindCommandOfClass(SearchClass);
    }
    DECLARE_FUNCTION(execGetAICommandInStack)
    {
        P_GET_OBJECT(UClass,InClass);
        P_FINISH;
        *(class UGameAICommand**)Result=this->GetAICommandInStack(InClass);
    }
    FString eventGetActionString()
    {
        GameAIController_eventGetActionString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_GetActionString),&Parms);
        return Parms.ReturnValue;
    }
    void eventAILog_Internal(const FString& LogText,FName LogCategory=NAME_None,UBOOL bForce=FALSE)
    {
        GameAIController_eventAILog_Internal_Parms Parms(EC_EventParm);
        Parms.LogText=LogText;
        Parms.LogCategory=LogCategory;
        Parms.bForce=bForce ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_AILog_Internal),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AGameAIController,AAIController,0|CLASS_Config,GameFramework)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

#if !DO_AI_LOGGING

#if COMPILER_SUPPORTS_NOOP
#define AIObjLog	__noop
#define AILog		__noop
#define AI_LOG		__noop
#elif SUPPORTS_VARIADIC_MACROS
#define AIObjLog(...)
#define AILog(...)
#define AI_LOG(...)
#else
#define AIObjLog	GNull->Logf
#define AILog		GNull->Logf
#define AI_LOG		GNull->Logf
#endif

#else
#define AI_LOG(Object, FuncParams) \
	if(RUNTIME_DO_AI_LOGGING)\
	{\
		Object->AILog FuncParams;\
	}

#define AIObjLog(FuncParams) AI_LOG(AI,FuncParams)
	VARARG_DECL(void,void,{},AILog,VARARG_NONE,const TCHAR*,VARARG_NONE,VARARG_NONE);
	VARARG_DECL(void,void,{},AILog,VARARG_NONE,const TCHAR*,VARARG_EXTRA(enum EName E),VARARG_EXTRA(E));
#endif

	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );

	virtual EGotoState GotoState( FName State, UBOOL bForceEvents = 0, UBOOL bKeepStack = 0 );
	virtual void ProcessState( FLOAT DeltaSeconds );

	virtual void StoreCommandHistory( UGameAICommand* Cmd );
	/**
	 * DebugLog function which is called to log information specific to this AI (call NAVHANDLE_DEBUG_LOG macro, don't call this directly)
	 * @param LogText - text to log for this AI
	 */
	virtual void DebugLogInternal(const TCHAR* LogText)
	{
		AI_LOG(this,(LogText));
	}
};

class AGameCameraBlockingVolume : public ABlockingVolume
{
public:
    //## BEGIN PROPS GameCameraBlockingVolume
    //## END PROPS GameCameraBlockingVolume

    DECLARE_CLASS(AGameCameraBlockingVolume,ABlockingVolume,0,GameFramework)
	// overidden to ignore blocking by anything except a camera actor
	virtual UBOOL IgnoreBlockingBy( const AActor *Other) const;		
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
#if WITH_EDITOR
	virtual void SetCollisionForPathBuilding(UBOOL bNowPathBuilding);
#endif
};

class UGameCheatManager : public UCheatManager
{
public:
    //## BEGIN PROPS GameCheatManager
    class ADebugCameraController* DebugCameraControllerRef;
    class UClass* DebugCameraControllerClass;
    FStringNoInit DebugCameraControllerClassName;
    //## END PROPS GameCheatManager

    DECLARE_CLASS(UGameCheatManager,UCheatManager,0|CLASS_Config,GameFramework)
    DECLARE_WITHIN(AGamePlayerController)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(UGameCheatManager)
};

struct GameCrowdAgentBehavior_eventPropagateViralBehaviorTo_Parms
{
    class AGameCrowdAgent* OtherAgent;
    GameCrowdAgentBehavior_eventPropagateViralBehaviorTo_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgentBehavior_eventOnAnimEnd_Parms
{
    class UAnimNodeSequence* SeqNode;
    FLOAT PlayedTime;
    FLOAT ExcessTime;
    GameCrowdAgentBehavior_eventOnAnimEnd_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgentBehavior_eventFinishedTargetRotation_Parms
{
    GameCrowdAgentBehavior_eventFinishedTargetRotation_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgentBehavior_eventTick_Parms
{
    FLOAT DeltaTime;
    GameCrowdAgentBehavior_eventTick_Parms(EEventParm)
    {
    }
};
class UGameCrowdAgentBehavior : public UObject
{
public:
    //## BEGIN PROPS GameCrowdAgentBehavior
    BYTE MyEventType;
    BYTE ViralBehaviorEvent;
    FLOAT DurationOfBehavior;
    FLOAT TimeUntilStopBehavior;
    BITFIELD bIdleBehavior:1;
    BITFIELD bFaceActionTargetFirst:1;
    BITFIELD bIsViralBehavior:1;
    BITFIELD bPassOnIsViralBehaviorFlag:1;
    class AActor* ActionTarget;
    FLOAT MaxPlayerDistance;
    FLOAT ViralRadius;
    FLOAT DurationBeforeBecomesViral;
    FLOAT TimeToBecomeViral;
    FLOAT DurationOfViralBehaviorPropagation;
    FLOAT TimeToStopPropagatingViralBehavior;
    class AGameCrowdAgent* MyAgent;
    FColor DebugBehaviorColor;
    //## END PROPS GameCrowdAgentBehavior

    class AGameCrowdBehaviorPoint* TriggerCrowdBehavior(BYTE EventType,class AActor* Instigator,FVector AtLocation,FLOAT InRange,FLOAT InDuration,class AActor* BaseActor=NULL,UBOOL bRequireLOS=FALSE);
    virtual UBOOL ShouldEndIdle();
    virtual void Tick(FLOAT DeltaTime);
    virtual UBOOL HandleMovement();
    DECLARE_FUNCTION(execTriggerCrowdBehavior)
    {
        P_GET_BYTE(EventType);
        P_GET_OBJECT(AActor,Instigator);
        P_GET_STRUCT(FVector,AtLocation);
        P_GET_FLOAT(InRange);
        P_GET_FLOAT(InDuration);
        P_GET_OBJECT_OPTX(AActor,BaseActor,NULL);
        P_GET_UBOOL_OPTX(bRequireLOS,FALSE);
        P_FINISH;
        *(class AGameCrowdBehaviorPoint**)Result=this->TriggerCrowdBehavior(EventType,Instigator,AtLocation,InRange,InDuration,BaseActor,bRequireLOS);
    }
    DECLARE_FUNCTION(execShouldEndIdle)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ShouldEndIdle();
    }
    DECLARE_FUNCTION(execTick)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        this->Tick(DeltaTime);
    }
    DECLARE_FUNCTION(execHandleMovement)
    {
        P_FINISH;
        *(UBOOL*)Result=this->HandleMovement();
    }
    void eventPropagateViralBehaviorTo(class AGameCrowdAgent* OtherAgent)
    {
        GameCrowdAgentBehavior_eventPropagateViralBehaviorTo_Parms Parms(EC_EventParm);
        Parms.OtherAgent=OtherAgent;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_PropagateViralBehaviorTo),&Parms);
    }
    void eventOnAnimEnd(class UAnimNodeSequence* SeqNode,FLOAT PlayedTime,FLOAT ExcessTime)
    {
        GameCrowdAgentBehavior_eventOnAnimEnd_Parms Parms(EC_EventParm);
        Parms.SeqNode=SeqNode;
        Parms.PlayedTime=PlayedTime;
        Parms.ExcessTime=ExcessTime;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_OnAnimEnd),&Parms);
    }
    void eventFinishedTargetRotation()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_FinishedTargetRotation),NULL);
    }
    void eventTick(FLOAT DeltaTime)
    {
        GameCrowdAgentBehavior_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_Tick),&Parms);
        }
    }
    DECLARE_ABSTRACT_CLASS(UGameCrowdAgentBehavior,UObject,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UGameCrowdAgentBehavior)
};

struct FAvoidOtherSampleItem
{
    INT RotOffset;
    BYTE NumMagSamples;
    SCRIPT_ALIGN;
    BITFIELD bFallbackOnly:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FAvoidOtherSampleItem() {}
    FAvoidOtherSampleItem(EEventParm)
    {
        appMemzero(this, sizeof(FAvoidOtherSampleItem));
    }
};

struct FRecentInteraction
{
    FName InteractionTag;
    FLOAT InteractionDelay;

    /** Constructors */
    FRecentInteraction() {}
    FRecentInteraction(EEventParm)
    {
        appMemzero(this, sizeof(FRecentInteraction));
    }
};

struct FBehaviorEntry
{
    class UGameCrowdAgentBehavior* BehaviorArchetype;
    class AActor* LookAtActor;
    FLOAT BehaviorFrequency;
    BITFIELD bNeverRepeat:1;
    BITFIELD bHasBeenUsed:1;
    BITFIELD bCanBeUsed:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FBehaviorEntry() {}
    FBehaviorEntry(EEventParm)
    {
        appMemzero(this, sizeof(FBehaviorEntry));
    }
};

struct GameCrowdAgent_eventGeneratePathToActor_Parms
{
    class AActor* Goal;
    FLOAT WithinDistance;
    UBOOL bAllowPartialPath;
    FVector ReturnValue;
    GameCrowdAgent_eventGeneratePathToActor_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventInitNavigationHandle_Parms
{
    GameCrowdAgent_eventInitNavigationHandle_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventOverlappedActorEvent_Parms
{
    class AActor* A;
    GameCrowdAgent_eventOverlappedActorEvent_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventFireDeathEvent_Parms
{
    GameCrowdAgent_eventFireDeathEvent_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventUpdateIntermediatePoint_Parms
{
    class AActor* DestinationActor;
    GameCrowdAgent_eventUpdateIntermediatePoint_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventStopBehavior_Parms
{
    GameCrowdAgent_eventStopBehavior_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventHandleBehaviorEvent_Parms
{
    BYTE EventType;
    class AActor* InInstigator;
    UBOOL bViralCause;
    UBOOL bPropagateViralFlag;
    GameCrowdAgent_eventHandleBehaviorEvent_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventActivateBehavior_Parms
{
    class UGameCrowdAgentBehavior* NewBehaviorArchetype;
    class AActor* LookAtActor;
    GameCrowdAgent_eventActivateBehavior_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventNotifySeePlayer_Parms
{
    class APlayerController* PC;
    GameCrowdAgent_eventNotifySeePlayer_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventHandlePotentialAgentEncounter_Parms
{
    GameCrowdAgent_eventHandlePotentialAgentEncounter_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventStopIdleAnimation_Parms
{
    GameCrowdAgent_eventStopIdleAnimation_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventPlayIdleAnimation_Parms
{
    GameCrowdAgent_eventPlayIdleAnimation_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventKillAgent_Parms
{
    GameCrowdAgent_eventKillAgent_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventSetCurrentDestination_Parms
{
    class AGameCrowdDestination* NewDest;
    GameCrowdAgent_eventSetCurrentDestination_Parms(EEventParm)
    {
    }
};
struct GameCrowdAgent_eventWaitForGroupMembers_Parms
{
    GameCrowdAgent_eventWaitForGroupMembers_Parms(EEventParm)
    {
    }
};
class AGameCrowdAgent : public ACrowdAgentBase, public IInterface_RVO
{
public:
    //## BEGIN PROPS GameCrowdAgent
    class UGameCrowdGroup* MyGroup;
    FVector PreferredVelocity;
    FVector PendingVelocity;
    class AGameCrowdDestination* CurrentDestination;
    class AGameCrowdDestination* BehaviorDestination;
    class AGameCrowdDestination* PreviousDestination;
    FLOAT InterpZTranslation;
    INT Health;
    FLOAT DeadBodyDuration;
    class UDynamicLightEnvironmentComponent* LightEnvironment;
    INT ConformTraceFrameCount;
    TArrayNoInit<struct FNearbyDynamicItem> NearbyDynamics;
    BITFIELD bUniformScale:1;
    BITFIELD bCheckForObstacles:1;
    BITFIELD bUseNavMeshPathing:1;
    BITFIELD bWantsSeePlayerNotification:1;
    BITFIELD bAllowPitching:1;
    BITFIELD bHitObstacle:1;
    BITFIELD bBadHitNormal:1;
    BITFIELD bSimulateThisTick:1;
    BITFIELD bPotentialEncounter:1;
    BITFIELD bIsPanicked:1;
    BITFIELD bWantsGroupIdle:1;
    BITFIELD bPreferVisibleDestination:1;
    BITFIELD bPreferVisibleDestinationOnSpawn:1;
    BITFIELD bHasNotifiedSpawner:1;
    BITFIELD bIsInSpawnPool:1;
    BITFIELD bPaused:1;
    SCRIPT_ALIGN;
    BYTE ConformType;
    FLOAT ConformTraceDist;
    INT ConformTraceInterval;
    INT CurrentConformTraceInterval;
    FLOAT LastGroundZ;
    FLOAT AwareRadius;
    FLOAT AvoidOtherRadius;
    TArrayNoInit<struct FAvoidOtherSampleItem> AvoidOtherSampleList;
    FLOAT PENALTY_COEFF_ANGLETOGOAL;
    FLOAT PENALTY_COEFF_ANGLETOVEL;
    FLOAT PENALTY_COEFF_MAG;
    FLOAT MIN_PENALTY_THRESHOLD;
    FLOAT LastProgressTime;
    FLOAT LastFallbackActiveTime;
    FLOAT MaxPathLaneValue;
    FLOAT CurrentPathLaneValue;
    INT ExtraPathCost;
    FLOAT RotateToTargetSpeed;
    FLOAT MaxYawRate;
    FVector MeshMinScale3D;
    FVector MeshMaxScale3D;
    FLOAT EyeZOffset;
    FLOAT ProximityLODDist;
    FLOAT VisibleProximityLODDist;
    FVector LastKnownGoodPosition;
    FLOAT GroundOffset;
    FVector IntermediatePoint;
    FVector SearchExtent;
    class UClass* NavigationHandleClass;
    class UNavigationHandle* NavigationHandle;
    INT ObstacleCheckCount;
    FLOAT WalkableFloorZ;
    FLOAT LastPathingAttempt;
    FLOAT LastUpdateTime;
    FLOAT NotVisibleLifeSpan;
    class AGameCrowdAgent* MyArchetype;
    FLOAT MaxWalkingSpeed;
    FLOAT MaxRunningSpeed;
    FLOAT MaxSpeed;
    TArrayNoInit<struct FRecentInteraction> RecentInteractions;
    FLOAT BeaconMaxDist;
    FVector BeaconOffset;
    class UTexture2D* BeaconTexture;
    FLinearColor BeaconColor;
    class USoundCue* AmbientSoundCue;
    class UAudioComponent* AmbientSoundComponent;
    class UGameCrowdAgentBehavior* CurrentBehavior;
    FLOAT CurrentBehaviorActivationTime;
    TArrayNoInit<struct FBehaviorEntry> EncounterAgentBehaviors;
    TArrayNoInit<struct FBehaviorEntry> SeePlayerBehaviors;
    FLOAT MaxSeePlayerDistSq;
    FLOAT SeePlayerInterval;
    TArrayNoInit<struct FBehaviorEntry> SpawnBehaviors;
    TArrayNoInit<struct FBehaviorEntry> UneasyBehaviors;
    TArrayNoInit<struct FBehaviorEntry> AlertBehaviors;
    TArrayNoInit<struct FBehaviorEntry> PanicBehaviors;
    TArrayNoInit<struct FBehaviorEntry> RandomBehaviors;
    TArrayNoInit<struct FBehaviorEntry> TakeDamageBehaviors;
    FLOAT RandomBehaviorInterval;
    FLOAT ForceUpdateTime;
    FLOAT ReachThreshold;
    TArrayNoInit<struct FBehaviorEntry> GroupWaitingBehaviors;
    FLOAT DesiredGroupRadius;
    FLOAT DesiredGroupRadiusSq;
    FLOAT MaxLOSLifeDistanceSq;
    TScriptInterface<class IInterface> MySpawner;
    FVector SpawnOffset;
    FLOAT InitialLastRenderTime;
    FColor DebugAgentColor;
    class AGameCrowdDestination* DebugSpawnDest;
    //## END PROPS GameCrowdAgent

    virtual FVector GetCollisionExtent();
    virtual UBOOL IsPanicked();
    void SetCurrentBehavior(class UGameCrowdAgentBehavior* BehaviorArchetype);
    virtual UBOOL IsIdle();
    virtual void PlayDeath(FVector KillMomentum);
    virtual void NativePostRenderFor(class APlayerController* PC,class UCanvas* Canvas,FVector CameraPosition,FVector CameraDir);
    DECLARE_FUNCTION(execGetCollisionExtent)
    {
        P_FINISH;
        *(FVector*)Result=this->GetCollisionExtent();
    }
    DECLARE_FUNCTION(execIsPanicked)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsPanicked();
    }
    DECLARE_FUNCTION(execSetCurrentBehavior)
    {
        P_GET_OBJECT(UGameCrowdAgentBehavior,BehaviorArchetype);
        P_FINISH;
        this->SetCurrentBehavior(BehaviorArchetype);
    }
    DECLARE_FUNCTION(execIsIdle)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsIdle();
    }
    DECLARE_FUNCTION(execPlayDeath)
    {
        P_GET_STRUCT(FVector,KillMomentum);
        P_FINISH;
        this->PlayDeath(KillMomentum);
    }
    FVector eventGeneratePathToActor(class AActor* Goal,FLOAT WithinDistance=0,UBOOL bAllowPartialPath=FALSE)
    {
        GameCrowdAgent_eventGeneratePathToActor_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.Goal=Goal;
        Parms.WithinDistance=WithinDistance;
        Parms.bAllowPartialPath=bAllowPartialPath ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_GeneratePathToActor),&Parms);
        return Parms.ReturnValue;
    }
    void eventInitNavigationHandle()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_InitNavigationHandle),NULL);
    }
    void eventOverlappedActorEvent(class AActor* A)
    {
        GameCrowdAgent_eventOverlappedActorEvent_Parms Parms(EC_EventParm);
        Parms.A=A;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_OverlappedActorEvent),&Parms);
    }
    void eventFireDeathEvent()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_FireDeathEvent),NULL);
    }
    void eventUpdateIntermediatePoint(class AActor* DestinationActor=NULL)
    {
        GameCrowdAgent_eventUpdateIntermediatePoint_Parms Parms(EC_EventParm);
        Parms.DestinationActor=DestinationActor;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_UpdateIntermediatePoint),&Parms);
    }
    void eventStopBehavior()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_StopBehavior),NULL);
    }
    void eventHandleBehaviorEvent(BYTE EventType,class AActor* InInstigator,UBOOL bViralCause,UBOOL bPropagateViralFlag)
    {
        GameCrowdAgent_eventHandleBehaviorEvent_Parms Parms(EC_EventParm);
        Parms.EventType=EventType;
        Parms.InInstigator=InInstigator;
        Parms.bViralCause=bViralCause ? FIRST_BITFIELD : FALSE;
        Parms.bPropagateViralFlag=bPropagateViralFlag ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_HandleBehaviorEvent),&Parms);
    }
    void eventActivateBehavior(class UGameCrowdAgentBehavior* NewBehaviorArchetype,class AActor* LookAtActor=NULL)
    {
        GameCrowdAgent_eventActivateBehavior_Parms Parms(EC_EventParm);
        Parms.NewBehaviorArchetype=NewBehaviorArchetype;
        Parms.LookAtActor=LookAtActor;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_ActivateBehavior),&Parms);
    }
    void eventNotifySeePlayer(class APlayerController* PC)
    {
        GameCrowdAgent_eventNotifySeePlayer_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_NotifySeePlayer),&Parms);
    }
    void eventHandlePotentialAgentEncounter()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_HandlePotentialAgentEncounter),NULL);
    }
    void eventStopIdleAnimation()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_StopIdleAnimation),NULL);
    }
    void eventPlayIdleAnimation()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_PlayIdleAnimation),NULL);
    }
    void eventKillAgent()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_KillAgent),NULL);
    }
    void eventSetCurrentDestination(class AGameCrowdDestination* NewDest)
    {
        GameCrowdAgent_eventSetCurrentDestination_Parms Parms(EC_EventParm);
        Parms.NewDest=NewDest;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_SetCurrentDestination),&Parms);
    }
    void eventWaitForGroupMembers()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_WaitForGroupMembers),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AGameCrowdAgent,ACrowdAgentBase,0,GameFramework)
    virtual UObject* GetUObjectInterfaceInterface_RVO(){return this;}
	virtual void PreBeginPlay();
	virtual void PostBeginPlay();
	virtual void PostScriptDestroyed();
	virtual void GetActorReferences(TArray<FActorReference*>& ActorRefs, UBOOL bIsRemovingLevel);

	virtual UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );

	virtual void performPhysics(FLOAT DeltaTime);
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);

	virtual void TickSpecial( FLOAT DeltaSeconds );

	/**
	 *	If desired, take the current location, and using a line check, update its Z to match the ground better.
	 *	Returns FALSE if could not be conformed, and agent was killed.
	 */
	UBOOL UpdateInterpZTranslation(const FVector& NewLocation);

	/**
	 *	Update NearbyDynamics, RelevantAttractors
	 *	Also checks ReportOverlapsWithClass and calls OverlappedActorEvent if necessary
	 */
	void UpdateProximityInfo();
	void CheckSeePlayer();
	virtual void UpdatePendingVelocity( FLOAT DeltaTime );
	UBOOL IsVelocityWithinConstraints( const FRotator& Dir, FLOAT Speed, FLOAT DeltaTime );
	UBOOL VerifyDestinationIsClear();
	UBOOL IsDestinationObstructed( const FVector& Dest );

	virtual UBOOL IsValidNearbyDynamic( AActor* A );
	virtual FLOAT GetInfluencePct( INT PriB );

	virtual UBOOL WantsOverlapCheckWith(AActor* TestActor);

	/**
	 * This will allow subclasses to implement specialized behavior for whether or not to actually simulate.
	 * Example: You have hundreds of crowd agents and not all can be seen.  So doing a distance check before simulating them
	 *          could save CPU.  (distance check in stead of LastRender as you might want them moving before the viewer sees them).
	 **/
	virtual UBOOL ShouldPerformCrowdSimulation(FLOAT DeltaTime);

	/** Whether agent should end idling now */
	virtual UBOOL ShouldEndIdle();

	/** Check if reached intermediate point in route to destination */
	UBOOL ReachedIntermediatePoint();

	/** Clamp velocity to reach destination exactly */
	virtual void ExactVelocity(FLOAT DeltaTime);

	/** Interface_NavigationHandle implementation to grab search params */
	virtual void SetupPathfindingParams( FNavMeshPathParams& out_ParamCache );
	virtual void InitForPathfinding();
	virtual INT ExtraEdgeCostToAddWhenActive(FNavMeshEdgeBase* Edge);
	virtual FVector GetEdgeZAdjust(FNavMeshEdgeBase* Edge);

    /** 
     * This function actually does the work for the GetDetailInfo and is virtual.  
     * It should only be called from GetDetailedInfo as GetDetailedInfo is safe to call on NULL object pointers
     **/
	virtual FString GetDetailedInfoInternal() const;

	virtual UBOOL   IsActiveObstacle() { return TRUE; }
	virtual FLOAT   GetAvoidRadius();
	virtual INT     GetInfluencePriority();
	virtual FColor  GetDebugAgentColor();
	
};

struct FGameCrowdAttachmentInfo
{
    class UStaticMesh* StaticMesh;
    FLOAT Chance;
    FVector Scale3D;

    /** Constructors */
    FGameCrowdAttachmentInfo() {}
    FGameCrowdAttachmentInfo(EEventParm)
    {
        appMemzero(this, sizeof(FGameCrowdAttachmentInfo));
    }
};

struct FGameCrowdAttachmentList
{
    FName SocketName;
    TArrayNoInit<struct FGameCrowdAttachmentInfo> List;

    /** Constructors */
    FGameCrowdAttachmentList() {}
    FGameCrowdAttachmentList(EEventParm)
    {
        appMemzero(this, sizeof(FGameCrowdAttachmentList));
    }
};

struct GameCrowdAgentSkeletal_eventClearLatentAnimation_Parms
{
    GameCrowdAgentSkeletal_eventClearLatentAnimation_Parms(EEventParm)
    {
    }
};
class AGameCrowdAgentSkeletal : public AGameCrowdAgent
{
public:
    //## BEGIN PROPS GameCrowdAgentSkeletal
    class USkeletalMeshComponent* SkeletalMeshComponent;
    class UAnimNodeBlend* SpeedBlendNode;
    class UAnimNodeSlot* FullBodySlot;
    class UAnimNodeSequence* ActionSeqNode;
    class UAnimNodeSequence* WalkSeqNode;
    class UAnimNodeSequence* RunSeqNode;
    class UAnimTree* AgentTree;
    TArrayNoInit<FName> WalkAnimNames;
    TArrayNoInit<FName> RunAnimNames;
    TArrayNoInit<FName> IdleAnimNames;
    TArrayNoInit<FName> DeathAnimNames;
    FLOAT SpeedBlendStart;
    FLOAT SpeedBlendEnd;
    FLOAT AnimVelRate;
    FLOAT MaxSpeedBlendChangeSpeed;
    FName MoveSyncGroupName;
    TArrayNoInit<struct FGameCrowdAttachmentList> Attachments;
    FLOAT MaxTargetAcquireTime;
    BITFIELD bUseRootMotionVelocity:1;
    BITFIELD bAllowSkeletonUpdateChangeBasedOnTickResult:1;
    BITFIELD bTickWhenNotVisible:1;
    BITFIELD bIsPlayingIdleAnimation:1;
    BITFIELD bIsPlayingDeathAnimation:1;
    BITFIELD bIsPlayingImportantAnimation:1;
    BITFIELD bAnimateThisTick:1;
    FLOAT NotVisibleDisableTickTime;
    FLOAT MaxAnimationDistance;
    FLOAT MaxAnimationDistanceSq;
    //## END PROPS GameCrowdAgentSkeletal

    virtual void PlayDeath(FVector KillMomentum);
    virtual void SetRootMotion(UBOOL bRootMotionEnabled);
    DECLARE_FUNCTION(execSetRootMotion)
    {
        P_GET_UBOOL(bRootMotionEnabled);
        P_FINISH;
        this->SetRootMotion(bRootMotionEnabled);
    }
    void eventClearLatentAnimation()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_ClearLatentAnimation),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AGameCrowdAgentSkeletal,AGameCrowdAgent,0,GameFramework)
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual void UpdatePendingVelocity( FLOAT DeltaTime );
};

class AGameCrowdAgentSM : public AGameCrowdAgent
{
public:
    //## BEGIN PROPS GameCrowdAgentSM
    class UStaticMeshComponent* Mesh;
    class UMaterialInstanceConstant* MeshColor;
    //## END PROPS GameCrowdAgentSM

    DECLARE_ABSTRACT_CLASS(AGameCrowdAgentSM,AGameCrowdAgent,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(AGameCrowdAgentSM)
};

class UGameCrowdBehavior_PlayAnimation : public UGameCrowdAgentBehavior
{
public:
    //## BEGIN PROPS GameCrowdBehavior_PlayAnimation
    TArrayNoInit<FName> AnimationList;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    BITFIELD bUseRootMotion:1;
    BITFIELD bLookAtPlayer:1;
    BITFIELD bLooping:1;
    BITFIELD bBlendBetweenAnims:1;
    class AActor* CustomActionTarget;
    INT LoopIndex;
    FLOAT LoopTime;
    class USeqAct_PlayAgentAnimation* AnimSequence;
    INT AnimationIndex;
    //## END PROPS GameCrowdBehavior_PlayAnimation

    virtual void SetSequenceOutput();
    DECLARE_FUNCTION(execSetSequenceOutput)
    {
        P_FINISH;
        this->SetSequenceOutput();
    }
    DECLARE_CLASS(UGameCrowdBehavior_PlayAnimation,UGameCrowdAgentBehavior,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UGameCrowdBehavior_PlayAnimation)
};

class UGameCrowdBehavior_RunFromPanic : public UGameCrowdAgentBehavior
{
public:
    //## BEGIN PROPS GameCrowdBehavior_RunFromPanic
    class AActor* PanicFocus;
    //## END PROPS GameCrowdBehavior_RunFromPanic

    DECLARE_CLASS(UGameCrowdBehavior_RunFromPanic,UGameCrowdAgentBehavior,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UGameCrowdBehavior_RunFromPanic)
};

class UGameCrowdBehavior_WaitForGroup : public UGameCrowdAgentBehavior
{
public:
    //## BEGIN PROPS GameCrowdBehavior_WaitForGroup
    //## END PROPS GameCrowdBehavior_WaitForGroup

    virtual UBOOL ShouldEndIdle();
    DECLARE_CLASS(UGameCrowdBehavior_WaitForGroup,UGameCrowdAgentBehavior,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UGameCrowdBehavior_WaitForGroup)
};

class UGameCrowdBehavior_WaitInQueue : public UGameCrowdAgentBehavior
{
public:
    //## BEGIN PROPS GameCrowdBehavior_WaitInQueue
    BITFIELD bStoppingBehavior:1;
    class AGameCrowdDestinationQueuePoint* QueuePosition;
    //## END PROPS GameCrowdBehavior_WaitInQueue

    virtual UBOOL HandleMovement();
    virtual UBOOL ShouldEndIdle();
    DECLARE_CLASS(UGameCrowdBehavior_WaitInQueue,UGameCrowdAgentBehavior,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UGameCrowdBehavior_WaitInQueue)
};

class UGameCrowdGroup : public UObject
{
public:
    //## BEGIN PROPS GameCrowdGroup
    TArrayNoInit<class AGameCrowdAgent*> Members;
    //## END PROPS GameCrowdGroup

    DECLARE_CLASS(UGameCrowdGroup,UObject,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UGameCrowdGroup)
};

class AGameCrowdInfoVolume : public AVolume
{
public:
    //## BEGIN PROPS GameCrowdInfoVolume
    TArrayNoInit<class AGameCrowdDestination*> PotentialSpawnPoints;
    //## END PROPS GameCrowdInfoVolume

    DECLARE_CLASS(AGameCrowdInfoVolume,AVolume,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(AGameCrowdInfoVolume)
};

class AGameCrowdInteractionPoint : public AActor
{
public:
    //## BEGIN PROPS GameCrowdInteractionPoint
    BITFIELD bIsEnabled:1;
    class UCylinderComponent* CylinderComponent;
    //## END PROPS GameCrowdInteractionPoint

    DECLARE_ABSTRACT_CLASS(AGameCrowdInteractionPoint,AActor,0,GameFramework)
#if WITH_EDITOR
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
#endif
};

class AGameCrowdBehaviorPoint : public AGameCrowdInteractionPoint
{
public:
    //## BEGIN PROPS GameCrowdBehaviorPoint
    FLOAT RadiusOfBehaviorEvent;
    FLOAT DurationOfBehaviorEvent;
    BYTE EventType;
    SCRIPT_ALIGN;
    BITFIELD bRequireLOS:1;
    class AActor* Initiator;
    //## END PROPS GameCrowdBehaviorPoint

    DECLARE_CLASS(AGameCrowdBehaviorPoint,AGameCrowdInteractionPoint,0|CLASS_Config,GameFramework)
    static const TCHAR* StaticConfigName() {return TEXT("Crowd");}

	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual UBOOL IsOverlapping( AActor *Other, FCheckResult* Hit=NULL, UPrimitiveComponent* OtherPrimitiveComponent=NULL, UPrimitiveComponent* MyPrimitiveComponent=NULL );
};

struct GameCrowdDestination_eventAllowableDestinationFor_Parms
{
    class AGameCrowdAgent* Agent;
    UBOOL ReturnValue;
    GameCrowdDestination_eventAllowableDestinationFor_Parms(EEventParm)
    {
    }
};
struct GameCrowdDestination_eventIncrementCustomerCount_Parms
{
    class AGameCrowdAgent* ArrivingAgent;
    GameCrowdDestination_eventIncrementCustomerCount_Parms(EEventParm)
    {
    }
};
struct GameCrowdDestination_eventDecrementCustomerCount_Parms
{
    class AGameCrowdAgent* DepartingAgent;
    GameCrowdDestination_eventDecrementCustomerCount_Parms(EEventParm)
    {
    }
};
struct GameCrowdDestination_eventReachedDestination_Parms
{
    class AGameCrowdAgent* Agent;
    GameCrowdDestination_eventReachedDestination_Parms(EEventParm)
    {
    }
};
class AGameCrowdDestination : public AGameCrowdInteractionPoint, public IEditorLinkSelectionInterface
{
public:
    //## BEGIN PROPS GameCrowdDestination
    BITFIELD bKillWhenReached:1;
    BITFIELD bAllowAsPreviousDestination:1;
    BITFIELD bAvoidWhenPanicked:1;
    BITFIELD bSkipBehaviorIfPanicked:1;
    BITFIELD bFleeDestination:1;
    BITFIELD bMustReachExactly:1;
    BITFIELD bHasRestrictions:1;
    BITFIELD bAllowsSpawning:1;
    BITFIELD bAllowCloudSpawning:1;
    BITFIELD bAllowVisibleSpawning:1;
    BITFIELD bLineSpawner:1;
    BITFIELD bSpawnAtEdge:1;
    BITFIELD bSoftPerimeter:1;
    BITFIELD bIsVisible:1;
    BITFIELD bWillBeVisible:1;
    BITFIELD bCanSpawnHereNow:1;
    BITFIELD bIsBeyondSpawnDistance:1;
    BITFIELD bAdjacentToVisibleNode:1;
    BITFIELD bHasNavigationMesh:1;
    TArrayNoInit<class AGameCrowdDestination*> NextDestinations;
    class AGameCrowdDestinationQueuePoint* QueueHead;
    INT Capacity;
    FLOAT Frequency;
    INT CustomerCount;
    TArrayNoInit<class UClass*> SupportedAgentClasses;
    TArrayNoInit<class UObject*> SupportedArchetypes;
    TArrayNoInit<class UClass*> RestrictedAgentClasses;
    TArrayNoInit<class UObject*> RestrictedArchetypes;
    FLOAT ExactReachTolerance;
    FName InteractionTag;
    FLOAT InteractionDelay;
    TArrayNoInit<struct FBehaviorEntry> ReachedBehaviors;
    class AGameCrowdAgent* AgentEnRoute;
    FLOAT Priority;
    FLOAT LastSpawnTime;
    class AGameCrowdPopulationManager* MyPopMgr;
    //## END PROPS GameCrowdDestination

    virtual UBOOL ReachedByAgent(class AGameCrowdAgent* Agent,FVector TestPosition,UBOOL bTestExactly);
    DECLARE_FUNCTION(execReachedByAgent)
    {
        P_GET_OBJECT(AGameCrowdAgent,Agent);
        P_GET_STRUCT(FVector,TestPosition);
        P_GET_UBOOL(bTestExactly);
        P_FINISH;
        *(UBOOL*)Result=this->ReachedByAgent(Agent,TestPosition,bTestExactly);
    }
    UBOOL eventAllowableDestinationFor(class AGameCrowdAgent* Agent)
    {
        GameCrowdDestination_eventAllowableDestinationFor_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Agent=Agent;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_AllowableDestinationFor),&Parms);
        return Parms.ReturnValue;
    }
    void eventIncrementCustomerCount(class AGameCrowdAgent* ArrivingAgent)
    {
        GameCrowdDestination_eventIncrementCustomerCount_Parms Parms(EC_EventParm);
        Parms.ArrivingAgent=ArrivingAgent;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_IncrementCustomerCount),&Parms);
    }
    void eventDecrementCustomerCount(class AGameCrowdAgent* DepartingAgent)
    {
        GameCrowdDestination_eventDecrementCustomerCount_Parms Parms(EC_EventParm);
        Parms.DepartingAgent=DepartingAgent;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_DecrementCustomerCount),&Parms);
    }
    void eventReachedDestination(class AGameCrowdAgent* Agent)
    {
        GameCrowdDestination_eventReachedDestination_Parms Parms(EC_EventParm);
        Parms.Agent=Agent;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_ReachedDestination),&Parms);
    }
    DECLARE_CLASS(AGameCrowdDestination,AGameCrowdInteractionPoint,0,GameFramework)
    virtual UObject* GetUObjectInterfaceEditorLinkSelectionInterface(){return this;}
	/** EditorLinkSelectionInterface */
	virtual void LinkSelection(USelection* SelectedActors);
	virtual void UnLinkSelection(USelection* SelectedActors);
	
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

struct GameCrowdDestinationQueuePoint_eventReachedDestination_Parms
{
    class AGameCrowdAgent* Agent;
    GameCrowdDestinationQueuePoint_eventReachedDestination_Parms(EEventParm)
    {
    }
};
class AGameCrowdDestinationQueuePoint : public AGameCrowdInteractionPoint
{
public:
    //## BEGIN PROPS GameCrowdDestinationQueuePoint
    class AGameCrowdDestinationQueuePoint* NextQueuePosition;
    class AGameCrowdInteractionPoint* PreviousQueuePosition;
    class AGameCrowdAgent* QueuedAgent;
    class AGameCrowdDestination* QueueDestination;
    BITFIELD bClearingQueue:1;
    BITFIELD bPendingAdvance:1;
    FLOAT AverageReactionTime;
    class UClass* QueueBehaviorClass;
    //## END PROPS GameCrowdDestinationQueuePoint

    virtual UBOOL QueueReachedBy(class AGameCrowdAgent* Agent,FVector TestPosition);
    DECLARE_FUNCTION(execQueueReachedBy)
    {
        P_GET_OBJECT(AGameCrowdAgent,Agent);
        P_GET_STRUCT(FVector,TestPosition);
        P_FINISH;
        *(UBOOL*)Result=this->QueueReachedBy(Agent,TestPosition);
    }
    void eventReachedDestination(class AGameCrowdAgent* Agent)
    {
        GameCrowdDestinationQueuePoint_eventReachedDestination_Parms Parms(EC_EventParm);
        Parms.Agent=Agent;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_ReachedDestination),&Parms);
    }
    DECLARE_CLASS(AGameCrowdDestinationQueuePoint,AGameCrowdInteractionPoint,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(AGameCrowdDestinationQueuePoint)
};

struct SeqAct_GameCrowdPopulationManagerToggle_eventFillCrowdSpawnInfoItem_Parms
{
    struct FCrowdSpawnInfoItem out_Item;
    class AGameCrowdPopulationManager* PopMgr;
    SeqAct_GameCrowdPopulationManagerToggle_eventFillCrowdSpawnInfoItem_Parms(EEventParm)
    : out_Item(EC_EventParm)
    {
    }
};
class USeqAct_GameCrowdPopulationManagerToggle : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GameCrowdPopulationManagerToggle
    FLOAT WarmupPopulationPct;
    class UGameCrowd_ListOfAgents* CrowdAgentList;
    BITFIELD bClearOldArchetypes:1;
    BITFIELD bEnableCrowdLightEnvironment:1;
    BITFIELD bCastShadows:1;
    BITFIELD bFillPotentialSpawnPoints:1;
    BITFIELD bForceObstacleChecking:1;
    BITFIELD bForceNavMeshPathing:1;
    BITFIELD bIndividualSpawner:1;
    INT MaxAgents;
    FLOAT SpawnRate;
    FLightingChannelContainer AgentLightingChannel;
    FLOAT MaxSpawnDist;
    FLOAT MinBehindSpawnDist;
    TArrayNoInit<class AGameCrowdDestination*> PotentialSpawnPoints;
    FLOAT AgentWarmupTime;
    INT NumAgentsToTickPerFrame;
    TArrayNoInit<class AGameCrowdAgent*> LastSpawnedList;
    //## END PROPS SeqAct_GameCrowdPopulationManagerToggle

    void eventFillCrowdSpawnInfoItem(struct FCrowdSpawnInfoItem& out_Item,class AGameCrowdPopulationManager* PopMgr)
    {
        SeqAct_GameCrowdPopulationManagerToggle_eventFillCrowdSpawnInfoItem_Parms Parms(EC_EventParm);
        Parms.out_Item=out_Item;
        Parms.PopMgr=PopMgr;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_FillCrowdSpawnInfoItem),&Parms);
        out_Item=Parms.out_Item;
    }
    DECLARE_CLASS(USeqAct_GameCrowdPopulationManagerToggle,USequenceAction,0,GameFramework)
	virtual void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_GameCrowdSpawner : public USeqAct_GameCrowdPopulationManagerToggle
{
public:
    //## BEGIN PROPS SeqAct_GameCrowdSpawner
    //## END PROPS SeqAct_GameCrowdSpawner

    DECLARE_ABSTRACT_CLASS(USeqAct_GameCrowdSpawner,USeqAct_GameCrowdPopulationManagerToggle,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_GameCrowdSpawner)
};

struct GameCrowdPopulationManager_eventCreateNewAgent_Parms
{
    struct FCrowdSpawnInfoItem Item;
    class AGameCrowdDestination* SpawnLoc;
    class AGameCrowdAgent* AgentTemplate;
    class UGameCrowdGroup* NewGroup;
    class AGameCrowdAgent* ReturnValue;
    GameCrowdPopulationManager_eventCreateNewAgent_Parms(EEventParm)
    : Item(EC_EventParm)
    {
    }
};
struct GameCrowdPopulationManager_eventPrioritizeSpawnPoints_Parms
{
    struct FCrowdSpawnInfoItem Item;
    FLOAT DeltaTime;
    GameCrowdPopulationManager_eventPrioritizeSpawnPoints_Parms(EEventParm)
    : Item(EC_EventParm)
    {
    }
};
struct GameCrowdPopulationManager_eventPickSpawnPoint_Parms
{
    struct FCrowdSpawnInfoItem Item;
    class AGameCrowdDestination* ReturnValue;
    GameCrowdPopulationManager_eventPickSpawnPoint_Parms(EEventParm)
    : Item(EC_EventParm)
    {
    }
};
struct GameCrowdPopulationManager_eventUpdateSpawner_Parms
{
    struct FCrowdSpawnInfoItem Item;
    FLOAT DeltaTime;
    UBOOL ReturnValue;
    GameCrowdPopulationManager_eventUpdateSpawner_Parms(EEventParm)
    : Item(EC_EventParm)
    {
    }
};
struct GameCrowdPopulationManager_eventFlushAllAgents_Parms
{
    GameCrowdPopulationManager_eventFlushAllAgents_Parms(EEventParm)
    {
    }
};
struct GameCrowdPopulationManager_eventFlushAgents_Parms
{
    struct FCrowdSpawnInfoItem Item;
    GameCrowdPopulationManager_eventFlushAgents_Parms(EEventParm)
    : Item(EC_EventParm)
    {
    }
};
struct GameCrowdPopulationManager_eventCreateSpawner_Parms
{
    class USeqAct_GameCrowdPopulationManagerToggle* inAction;
    INT ReturnValue;
    GameCrowdPopulationManager_eventCreateSpawner_Parms(EEventParm)
    {
    }
};
struct GameCrowdPopulationManager_eventNotifyPathChanged_Parms
{
    GameCrowdPopulationManager_eventNotifyPathChanged_Parms(EEventParm)
    {
    }
};
class AGameCrowdPopulationManager : public ACrowdPopulationManagerBase, public IInterface_NavigationHandle
{
public:
    //## BEGIN PROPS GameCrowdPopulationManager
    struct FCrowdSpawnInfoItem CloudSpawnInfo;
    TArrayNoInit<struct FCrowdSpawnInfoItem> ScriptedSpawnInfo;
    class AGameCrowdInfoVolume* ActiveCrowdInfoVolume;
    TArrayNoInit<class AGameCrowdDestination*> GlobalPotentialSpawnPoints;
    FLOAT SplitScreenNumReduction;
    FLOAT PlayerPositionPredictionTime;
    FLOAT HeadVisibilityOffset;
    class UClass* NavigationHandleClass;
    class UNavigationHandle* NavigationHandle;
    class AGameCrowdAgent* QueryingAgent;
    TArrayNoInit<struct FCrowdSpawnerPlayerInfo> PlayerInfo;
    FLOAT LastPlayerInfoUpdateTime;
    BITFIELD bDebugSpawns:1;
    BITFIELD bPauseCrowd:1;
    SCRIPT_ALIGN;
    //## END PROPS GameCrowdPopulationManager

    virtual void UpdateAllSpawners(FLOAT DeltaTime);
    virtual UBOOL GetPlayerInfo();
    UBOOL StaticGetPlayerInfo(TArray<struct FCrowdSpawnerPlayerInfo>& out_PlayerInfo);
    virtual class AGameCrowdAgent* SpawnAgentByIdx(INT SpawnerIdx,class AGameCrowdDestination* SpawnLoc);
    virtual class AGameCrowdAgent* SpawnAgent(struct FCrowdSpawnInfoItem& Item,class AGameCrowdDestination* SpawnLoc);
    virtual UBOOL Warmup(struct FCrowdSpawnInfoItem& Item,INT WarmupNum);
    DECLARE_FUNCTION(execUpdateAllSpawners)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        this->UpdateAllSpawners(DeltaTime);
    }
    DECLARE_FUNCTION(execGetPlayerInfo)
    {
        P_FINISH;
        *(UBOOL*)Result=this->GetPlayerInfo();
    }
    DECLARE_FUNCTION(execStaticGetPlayerInfo)
    {
        P_GET_TARRAY_REF(struct FCrowdSpawnerPlayerInfo,out_PlayerInfo);
        P_FINISH;
        *(UBOOL*)Result=this->StaticGetPlayerInfo(out_PlayerInfo);
    }
    DECLARE_FUNCTION(execSpawnAgentByIdx)
    {
        P_GET_INT(SpawnerIdx);
        P_GET_OBJECT(AGameCrowdDestination,SpawnLoc);
        P_FINISH;
        *(class AGameCrowdAgent**)Result=this->SpawnAgentByIdx(SpawnerIdx,SpawnLoc);
    }
    DECLARE_FUNCTION(execSpawnAgent)
    {
        P_GET_STRUCT_INIT_REF(struct FCrowdSpawnInfoItem,Item);
        P_GET_OBJECT(AGameCrowdDestination,SpawnLoc);
        P_FINISH;
        *(class AGameCrowdAgent**)Result=this->SpawnAgent(Item,SpawnLoc);
    }
    DECLARE_FUNCTION(execWarmup)
    {
        P_GET_STRUCT_INIT_REF(struct FCrowdSpawnInfoItem,Item);
        P_GET_INT(WarmupNum);
        P_FINISH;
        *(UBOOL*)Result=this->Warmup(Item,WarmupNum);
    }
    class AGameCrowdAgent* eventCreateNewAgent(struct FCrowdSpawnInfoItem& Item,class AGameCrowdDestination* SpawnLoc,class AGameCrowdAgent* AgentTemplate,class UGameCrowdGroup* NewGroup)
    {
        GameCrowdPopulationManager_eventCreateNewAgent_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.Item=Item;
        Parms.SpawnLoc=SpawnLoc;
        Parms.AgentTemplate=AgentTemplate;
        Parms.NewGroup=NewGroup;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_CreateNewAgent),&Parms);
        Item=Parms.Item;
        return Parms.ReturnValue;
    }
    void eventPrioritizeSpawnPoints(struct FCrowdSpawnInfoItem& Item,FLOAT DeltaTime)
    {
        GameCrowdPopulationManager_eventPrioritizeSpawnPoints_Parms Parms(EC_EventParm);
        Parms.Item=Item;
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_PrioritizeSpawnPoints),&Parms);
        Item=Parms.Item;
    }
    class AGameCrowdDestination* eventPickSpawnPoint(struct FCrowdSpawnInfoItem& Item)
    {
        GameCrowdPopulationManager_eventPickSpawnPoint_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.Item=Item;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_PickSpawnPoint),&Parms);
        Item=Parms.Item;
        return Parms.ReturnValue;
    }
    UBOOL eventUpdateSpawner(struct FCrowdSpawnInfoItem& Item,FLOAT DeltaTime)
    {
        GameCrowdPopulationManager_eventUpdateSpawner_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Item=Item;
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_UpdateSpawner),&Parms);
        Item=Parms.Item;
        return Parms.ReturnValue;
    }
    void eventFlushAllAgents()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_FlushAllAgents),NULL);
    }
    void eventFlushAgents(struct FCrowdSpawnInfoItem Item)
    {
        GameCrowdPopulationManager_eventFlushAgents_Parms Parms(EC_EventParm);
        Parms.Item=Item;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_FlushAgents),&Parms);
    }
    INT eventCreateSpawner(class USeqAct_GameCrowdPopulationManagerToggle* inAction)
    {
        GameCrowdPopulationManager_eventCreateSpawner_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.inAction=inAction;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_CreateSpawner),&Parms);
        return Parms.ReturnValue;
    }
    void eventNotifyPathChanged()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_NotifyPathChanged),NULL);
    }
    DECLARE_CLASS(AGameCrowdPopulationManager,ACrowdPopulationManagerBase,0,GameFramework)
    virtual UObject* GetUObjectInterfaceInterface_NavigationHandle(){return this;}
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	virtual void TickSpawnInfo( FCrowdSpawnInfoItem& Item, FLOAT DeltaTime );

	virtual void GetAlwaysRelevantDynamics( AGameCrowdAgent* Agent );

	/** Interface_NavigationHandle implementation to grab search params */
	virtual void SetupPathfindingParams( FNavMeshPathParams& out_ParamCache );
	virtual void InitForPathfinding() {}
	virtual INT ExtraEdgeCostToAddWhenActive(FNavMeshEdgeBase* Edge) { return 0; }
	virtual FVector GetEdgeZAdjust(FNavMeshEdgeBase* Edge);

	UBOOL GetSpawnInfoItem( USeqAct_GameCrowdPopulationManagerToggle* inAction, FCrowdSpawnInfoItem*& out_Spawner, UBOOL bCreateIfNotFound = 0 );
};

class AGameCrowdReplicationActor : public AActor
{
public:
    //## BEGIN PROPS GameCrowdReplicationActor
    class USeqAct_GameCrowdSpawner* Spawner;
    BITFIELD bSpawningActive:1;
    INT DestroyAllCount;
    //## END PROPS GameCrowdReplicationActor

    DECLARE_CLASS(AGameCrowdReplicationActor,AActor,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(AGameCrowdReplicationActor)
};

class AGameCrowdSpawnRelativeActor : public AActor
{
public:
    //## BEGIN PROPS GameCrowdSpawnRelativeActor
    //## END PROPS GameCrowdSpawnRelativeActor

    DECLARE_CLASS(AGameCrowdSpawnRelativeActor,AActor,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(AGameCrowdSpawnRelativeActor)
};

class UGameDestinationConnRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS GameDestinationConnRenderingComponent
    //## END PROPS GameDestinationConnRenderingComponent

    DECLARE_CLASS(UGameDestinationConnRenderingComponent,UPrimitiveComponent,0,GameFramework)
	/**
	 * Creates a new scene proxy for the path rendering component.
	 * @return	Pointer to the FConnectionRenderingSceneProxy
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	virtual void UpdateBounds();
};

class UGameExplosion : public UObject
{
public:
    //## BEGIN PROPS GameExplosion
    BITFIELD bDirectionalExplosion:1;
    BITFIELD bIgnoreInstigator:1;
    BITFIELD bAllowTeammateCringes:1;
    BITFIELD bFullDamageToAttachee:1;
    BITFIELD bAttachExplosionEmitterToAttachee:1;
    BITFIELD bPerformRadialBlurRelevanceCheck:1;
    BITFIELD bCausesFracture:1;
    BITFIELD bAllowPerMaterialFX:1;
    BITFIELD bParticleSystemIsBeingOverriddenDontUsePhysMatVersion:1;
    BITFIELD bSkipDefaultPhysMatParticleSystem:1;
    BITFIELD bUseMapSpecificValues:1;
    BITFIELD bUseOverlapCheck:1;
    BITFIELD bOrientCameraShakeTowardsEpicenter:1;
    BITFIELD bAutoControllerVibration:1;
    FLOAT DirectionalExplosionAngleDeg;
    FLOAT DamageDelay;
    FLOAT Damage;
    FLOAT DamageRadius;
    FLOAT DamageFalloffExponent;
    class AActor* ActorToIgnoreForDamage;
    class UClass* ActorClassToIgnoreForDamage;
    class UClass* ActorClassToIgnoreForKnockdownsAndCringes;
    class UClass* MyDamageType;
    FLOAT KnockDownRadius;
    FLOAT KnockDownStrength;
    FLOAT CringeRadius;
    FVector2D CringeDuration;
    FLOAT MomentumTransferScale;
    class UParticleSystem* ParticleEmitterTemplate;
    FLOAT ExplosionEmitterScale;
    class AActor* HitActor;
    FVector HitLocation;
    FVector HitNormal;
    class USoundCue* ExplosionSound;
    class USoundCue* ExplosionSoundHurtSomeone;
    class UPointLightComponent* ExploLight;
    FLOAT ExploLightFadeOutTime;
    class URadialBlurComponent* ExploRadialBlur;
    FLOAT ExploRadialBlurFadeOutTime;
    FLOAT ExploRadialBlurMaxBlur;
    FLOAT FractureMeshRadius;
    FLOAT FracturePartVel;
    class UCameraShake* CamShake;
    class UCameraShake* CamShake_Left;
    class UCameraShake* CamShake_Right;
    class UCameraShake* CamShake_Rear;
    FLOAT CamShakeInnerRadius;
    FLOAT CamShakeOuterRadius;
    FLOAT CamShakeFalloff;
    class UClass* CameraLensEffect;
    FLOAT CameraLensEffectRadius;
    //## END PROPS GameExplosion

    DECLARE_CLASS(UGameExplosion,UObject,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UGameExplosion)
};

class AGameExplosionActor : public AActor
{
public:
    //## BEGIN PROPS GameExplosionActor
    BITFIELD bHasExploded:1;
    BITFIELD bExplodeMoreThanOnce:1;
    BITFIELD bTrackExplosionParticleSystemLifespan:1;
    BITFIELD bDrawDebug:1;
    class UPointLightComponent* ExplosionLight;
    class URadialBlurComponent* ExplosionRadialBlur;
    FLOAT LightFadeTime;
    FLOAT LightFadeTimeRemaining;
    FLOAT LightInitialBrightness;
    FLOAT RadialBlurFadeTime;
    FLOAT RadialBlurFadeTimeRemaining;
    FLOAT RadialBlurMaxBlurAmount;
    class UGameExplosion* ExplosionTemplate;
    class URB_RadialImpulseComponent* RadialImpulseComponent;
    class AController* InstigatorController;
    class AActor* HitActorFromPhysMaterialTrace;
    FVector HitLocationFromPhysMaterialTrace;
    class AActor* Attachee;
    class AController* AttacheeController;
    FLOAT DirectionalExplosionMinDot;
    FVector ExplosionDirection;
    //## END PROPS GameExplosionActor

    FLOAT BoxDistanceToPoint(FVector Start,FBox BBox);
    DECLARE_FUNCTION(execBoxDistanceToPoint)
    {
        P_GET_STRUCT(FVector,Start);
        P_GET_STRUCT(FBox,BBox);
        P_FINISH;
        *(FLOAT*)Result=this->BoxDistanceToPoint(Start,BBox);
    }
    DECLARE_ABSTRACT_CLASS(AGameExplosionActor,AActor,0,GameFramework)
    static const TCHAR* StaticConfigName() {return TEXT("Weapon");}

	virtual void TickSpecial(FLOAT DeltaSeconds);
};

struct GamePawn_eventUpdateShadowSettings_Parms
{
    UBOOL bInWantShadow;
    GamePawn_eventUpdateShadowSettings_Parms(EEventParm)
    {
    }
};
class AGamePawn : public APawn
{
public:
    //## BEGIN PROPS GamePawn
    BITFIELD bLastHitWasHeadShot:1;
    BITFIELD bRespondToExplosions:1;
    SCRIPT_ALIGN;
    //## END PROPS GamePawn

    void eventUpdateShadowSettings(UBOOL bInWantShadow)
    {
        GamePawn_eventUpdateShadowSettings_Parms Parms(EC_EventParm);
        Parms.bInWantShadow=bInWantShadow ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_UpdateShadowSettings),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AGamePawn,APawn,0|CLASS_Config|CLASS_NativeReplication,GameFramework)
		// Networking
	INT* GetOptimizedRepList( BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

struct GamePlayerController_eventWarmupPause_Parms
{
    UBOOL bDesiredPauseState;
    GamePlayerController_eventWarmupPause_Parms(EEventParm)
    {
    }
};
struct GamePlayerController_eventClientStopMovie_Parms
{
    FLOAT DelayInSeconds;
    UBOOL bAllowMovieToFinish;
    UBOOL bForceStopNonSkippable;
    UBOOL bForceStopLoadingMovie;
    GamePlayerController_eventClientStopMovie_Parms(EEventParm)
    {
    }
};
struct GamePlayerController_eventClientPlayMovie_Parms
{
    FString MovieName;
    INT InStartOfRenderingMovieFrame;
    INT InEndOfRenderingMovieFrame;
    UBOOL bRestrictPausing;
    UBOOL bPlayOnceFromStream;
    UBOOL bOnlyBackButtonSkipsMovie;
    GamePlayerController_eventClientPlayMovie_Parms(EEventParm)
    {
    }
};
struct GamePlayerController_eventNotifyCrowdAgentInRadius_Parms
{
    class AGameCrowdAgent* Agent;
    GamePlayerController_eventNotifyCrowdAgentInRadius_Parms(EEventParm)
    {
    }
};
struct GamePlayerController_eventNotifyCrowdAgentRefresh_Parms
{
    GamePlayerController_eventNotifyCrowdAgentRefresh_Parms(EEventParm)
    {
    }
};
class AGamePlayerController : public APlayerController
{
public:
    //## BEGIN PROPS GamePlayerController
    BITFIELD bWarnCrowdMembers:1;
    BITFIELD bDebugCrowdAwareness:1;
    BITFIELD bIsWarmupPaused:1;
    FLOAT AgentAwareRadius;
    FName CurrentSoundMode;
    //## END PROPS GamePlayerController

    virtual INT GetUIPlayerIndex();
    void ShowLoadingMovie(UBOOL bShowMovie,UBOOL bPauseAfterHide=FALSE,FLOAT PauseDuration=0,FLOAT KeepPlayingDuration=0,UBOOL bOverridePreviousDelays=FALSE);
    void KeepPlayingLoadingMovie();
    void ClientPlayMovie(const FString& MovieName,INT InStartOfRenderingMovieFrame,INT InEndOfRenderingMovieFrame,UBOOL bRestrictPausing,UBOOL bPlayOnceFromStream,UBOOL bOnlyBackButtonSkipsMovie);
    void ClientStopMovie(FLOAT DelayInSeconds,UBOOL bAllowMovieToFinish,UBOOL bForceStopNonSkippable,UBOOL bForceStopLoadingMovie);
    void GetCurrentMovie(FString& MovieName);
    DECLARE_FUNCTION(execGetUIPlayerIndex)
    {
        P_FINISH;
        *(INT*)Result=this->GetUIPlayerIndex();
    }
    DECLARE_FUNCTION(execShowLoadingMovie)
    {
        P_GET_UBOOL(bShowMovie);
        P_GET_UBOOL_OPTX(bPauseAfterHide,FALSE);
        P_GET_FLOAT_OPTX(PauseDuration,0);
        P_GET_FLOAT_OPTX(KeepPlayingDuration,0);
        P_GET_UBOOL_OPTX(bOverridePreviousDelays,FALSE);
        P_FINISH;
        this->ShowLoadingMovie(bShowMovie,bPauseAfterHide,PauseDuration,KeepPlayingDuration,bOverridePreviousDelays);
    }
    DECLARE_FUNCTION(execKeepPlayingLoadingMovie)
    {
        P_FINISH;
        this->KeepPlayingLoadingMovie();
    }
    DECLARE_FUNCTION(execClientPlayMovie)
    {
        P_GET_STR(MovieName);
        P_GET_INT(InStartOfRenderingMovieFrame);
        P_GET_INT(InEndOfRenderingMovieFrame);
        P_GET_UBOOL(bRestrictPausing);
        P_GET_UBOOL(bPlayOnceFromStream);
        P_GET_UBOOL(bOnlyBackButtonSkipsMovie);
        P_FINISH;
        this->ClientPlayMovie(MovieName,InStartOfRenderingMovieFrame,InEndOfRenderingMovieFrame,bRestrictPausing,bPlayOnceFromStream,bOnlyBackButtonSkipsMovie);
    }
    DECLARE_FUNCTION(execClientStopMovie)
    {
        P_GET_FLOAT(DelayInSeconds);
        P_GET_UBOOL(bAllowMovieToFinish);
        P_GET_UBOOL(bForceStopNonSkippable);
        P_GET_UBOOL(bForceStopLoadingMovie);
        P_FINISH;
        this->ClientStopMovie(DelayInSeconds,bAllowMovieToFinish,bForceStopNonSkippable,bForceStopLoadingMovie);
    }
    DECLARE_FUNCTION(execGetCurrentMovie)
    {
        P_GET_STR_REF(MovieName);
        P_FINISH;
        this->GetCurrentMovie(MovieName);
    }
    void eventWarmupPause(UBOOL bDesiredPauseState)
    {
        GamePlayerController_eventWarmupPause_Parms Parms(EC_EventParm);
        Parms.bDesiredPauseState=bDesiredPauseState ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_WarmupPause),&Parms);
    }
    void eventClientStopMovie(FLOAT DelayInSeconds,UBOOL bAllowMovieToFinish,UBOOL bForceStopNonSkippable,UBOOL bForceStopLoadingMovie)
    {
        GamePlayerController_eventClientStopMovie_Parms Parms(EC_EventParm);
        Parms.DelayInSeconds=DelayInSeconds;
        Parms.bAllowMovieToFinish=bAllowMovieToFinish ? FIRST_BITFIELD : FALSE;
        Parms.bForceStopNonSkippable=bForceStopNonSkippable ? FIRST_BITFIELD : FALSE;
        Parms.bForceStopLoadingMovie=bForceStopLoadingMovie ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_ClientStopMovie),&Parms);
    }
    void eventClientPlayMovie(const FString& MovieName,INT InStartOfRenderingMovieFrame,INT InEndOfRenderingMovieFrame,UBOOL bRestrictPausing,UBOOL bPlayOnceFromStream,UBOOL bOnlyBackButtonSkipsMovie)
    {
        GamePlayerController_eventClientPlayMovie_Parms Parms(EC_EventParm);
        Parms.MovieName=MovieName;
        Parms.InStartOfRenderingMovieFrame=InStartOfRenderingMovieFrame;
        Parms.InEndOfRenderingMovieFrame=InEndOfRenderingMovieFrame;
        Parms.bRestrictPausing=bRestrictPausing ? FIRST_BITFIELD : FALSE;
        Parms.bPlayOnceFromStream=bPlayOnceFromStream ? FIRST_BITFIELD : FALSE;
        Parms.bOnlyBackButtonSkipsMovie=bOnlyBackButtonSkipsMovie ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_ClientPlayMovie),&Parms);
    }
    void eventNotifyCrowdAgentInRadius(class AGameCrowdAgent* Agent)
    {
        GamePlayerController_eventNotifyCrowdAgentInRadius_Parms Parms(EC_EventParm);
        Parms.Agent=Agent;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_NotifyCrowdAgentInRadius),&Parms);
    }
    void eventNotifyCrowdAgentRefresh()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_NotifyCrowdAgentRefresh),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AGamePlayerController,APlayerController,0|CLASS_Config,GameFramework)
	virtual void TickSpecial( FLOAT DeltaSeconds );
};

class ADebugCameraController : public AGamePlayerController
{
public:
    //## BEGIN PROPS DebugCameraController
    FName PrimaryKey;
    FName SecondaryKey;
    FName UnselectKey;
    BITFIELD bShowSelectedInfo:1;
    BITFIELD bDrawDebugText:1;
    BITFIELD bIsFrozenRendering:1;
    class UClass* HUDClass;
    class APlayerController* OriginalControllerRef;
    class UPlayer* OriginalPlayer;
    class UDrawFrustumComponent* DrawFrustum;
    class AActor* SelectedActor;
    class UPrimitiveComponent* SelectedComponent;
    //## END PROPS DebugCameraController

    virtual void PrimarySelect(FVector HitLoc,FVector HitNormal,struct FTraceHitInfo HitInfo);
    virtual void SecondarySelect(FVector HitLoc,FVector HitNormal,struct FTraceHitInfo HitInfo);
    virtual void Unselect();
    virtual FString ConsoleCommand(const FString& Command,UBOOL bWriteToLog=TRUE);
    DECLARE_FUNCTION(execPrimarySelect)
    {
        P_GET_STRUCT(FVector,HitLoc);
        P_GET_STRUCT(FVector,HitNormal);
        P_GET_STRUCT(struct FTraceHitInfo,HitInfo);
        P_FINISH;
        this->PrimarySelect(HitLoc,HitNormal,HitInfo);
    }
    DECLARE_FUNCTION(execSecondarySelect)
    {
        P_GET_STRUCT(FVector,HitLoc);
        P_GET_STRUCT(FVector,HitNormal);
        P_GET_STRUCT(struct FTraceHitInfo,HitInfo);
        P_FINISH;
        this->SecondarySelect(HitLoc,HitNormal,HitInfo);
    }
    DECLARE_FUNCTION(execUnselect)
    {
        P_FINISH;
        this->Unselect();
    }
    DECLARE_CLASS(ADebugCameraController,AGamePlayerController,0|CLASS_Config,GameFramework)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	/**
	 * Builds a list of components that are hidden based upon gameplay
	 *
	 * @param ViewLocation the view point to hide/unhide from
	 * @param HiddenComponents the list to add to/remove from
	 */
	virtual void UpdateHiddenComponents(const FVector& ViewLocation,TSet<UPrimitiveComponent*>& HiddenComponents);
};

struct FTextureUVs
{
    FLOAT U;
    FLOAT V;
    FLOAT UL;
    FLOAT VL;

    /** Constructors */
    FTextureUVs() {}
    FTextureUVs(EEventParm)
    {
        appMemzero(this, sizeof(FTextureUVs));
    }
};

struct MobileInputZone_eventOnPostDrawZone_Parms
{
    class UMobileInputZone* Zone;
    class UCanvas* Canvas;
    MobileInputZone_eventOnPostDrawZone_Parms(EEventParm)
    {
    }
};
struct MobileInputZone_eventOnPreDrawZone_Parms
{
    class UMobileInputZone* Zone;
    class UCanvas* Canvas;
    UBOOL ReturnValue;
    MobileInputZone_eventOnPreDrawZone_Parms(EEventParm)
    {
    }
};
struct MobileInputZone_eventOnProcessSlide_Parms
{
    class UMobileInputZone* Zone;
    BYTE EventType;
    INT SlideValue;
    FVector2D ViewportSize;
    UBOOL ReturnValue;
    MobileInputZone_eventOnProcessSlide_Parms(EEventParm)
    {
    }
};
struct MobileInputZone_eventOnDoubleTapDelegate_Parms
{
    class UMobileInputZone* Zone;
    BYTE EventType;
    FVector2D TouchLocation;
    UBOOL ReturnValue;
    MobileInputZone_eventOnDoubleTapDelegate_Parms(EEventParm)
    {
    }
};
struct MobileInputZone_eventOnTapDelegate_Parms
{
    class UMobileInputZone* Zone;
    BYTE EventType;
    FVector2D TouchLocation;
    UBOOL ReturnValue;
    MobileInputZone_eventOnTapDelegate_Parms(EEventParm)
    {
    }
};
struct MobileInputZone_eventOnProcessInputDelegate_Parms
{
    class UMobileInputZone* Zone;
    FLOAT DeltaTime;
    INT Handle;
    BYTE EventType;
    FVector2D TouchLocation;
    UBOOL ReturnValue;
    MobileInputZone_eventOnProcessInputDelegate_Parms(EEventParm)
    {
    }
};
class UMobileInputZone : public UObject
{
public:
    //## BEGIN PROPS MobileInputZone
    BYTE Type;
    BYTE TouchpadIndex;
    BYTE State;
    BYTE SlideType;
    FStringNoInit Caption;
    FName InputKey;
    FName HorizontalInputKey;
    FName TapInputKey;
    FName DoubleTapInputKey;
    FLOAT VertMultiplier;
    FLOAT HorizMultiplier;
    FLOAT Acceleration;
    FLOAT Smoothing;
    FLOAT EscapeVelocityStrength;
    BITFIELD bScalePawnMovement:1;
    BITFIELD bRelativeX:1;
    BITFIELD bRelativeY:1;
    BITFIELD bRelativeSizeX:1;
    BITFIELD bRelativeSizeY:1;
    BITFIELD bActiveSizeYFromX:1;
    BITFIELD bSizeYFromSizeX:1;
    BITFIELD bApplyGlobalScaleToActiveSizes:1;
    BITFIELD bCenterX:1;
    BITFIELD bCenterY:1;
    BITFIELD bIsInvisible:1;
    BITFIELD bQuickDoubleTap:1;
    BITFIELD bCenterOnEvent:1;
    BITFIELD bSliderHasTrack:1;
    BITFIELD bFloatingTiltZone:1;
    BITFIELD bUseGentleTransitions:1;
    BITFIELD bAllowFirstDeltaForTrackballZone:1;
    BITFIELD bRenderGuides:1;
    BITFIELD bIsDoubleTapAndHold:1;
    FLOAT X;
    FLOAT Y;
    FLOAT SizeX;
    FLOAT SizeY;
    FLOAT ActiveSizeX;
    FLOAT ActiveSizeY;
    FLOAT InitialX;
    FLOAT InitialY;
    FLOAT InitialSizeX;
    FLOAT InitialSizeY;
    FLOAT InitialActiveSizeX;
    FLOAT InitialActiveSizeY;
    FLOAT AuthoredGlobalScale;
    FLOAT Border;
    FLOAT ResetCenterAfterInactivityTime;
    FLOAT TapDistanceConstraint;
    FLOAT ActivateTime;
    FLOAT DeactivateTime;
    FColor RenderColor;
    FLOAT InactiveAlpha;
    FLOAT CaptionXAdjustment;
    FLOAT CaptionYAdjustment;
    class UTexture2D* OverrideTexture1;
    FStringNoInit OverrideTexture1Name;
    struct FTextureUVs OverrideUVs1;
    class UTexture2D* OverrideTexture2;
    FStringNoInit OverrideTexture2Name;
    struct FTextureUVs OverrideUVs2;
    FVector2D InitialLocation;
    FVector2D CurrentLocation;
    FVector2D CurrentCenter;
    FVector2D InitialCenter;
    FVector2D PreviousLocations[6];
    FLOAT PreviousMoveDeltaTimes[6];
    INT PreviousLocationCount;
    FLOAT LastTouchTime;
    FLOAT TimeSinceLastTapRepeat;
    FLOAT AnimatingFadeOpacity;
    class UMobilePlayerInput* InputOwner;
    FLOAT TransitionTime;
    FVector2D EscapeVelocity;
    TArrayNoInit<class USeqEvent_MobileZoneBase*> MobileSeqEventHandlers;
    FVector2D LastAxisValues;
    FLOAT TotalActiveTime;
    FLOAT LastWentActiveTime;
    FScriptDelegate __OnProcessInputDelegate__Delegate;
    FScriptDelegate __OnTapDelegate__Delegate;
    FScriptDelegate __OnDoubleTapDelegate__Delegate;
    FScriptDelegate __OnProcessSlide__Delegate;
    FScriptDelegate __OnPreDrawZone__Delegate;
    FScriptDelegate __OnPostDrawZone__Delegate;
    //## END PROPS MobileInputZone

    virtual void ActivateZone();
    virtual void DeactivateZone();
    DECLARE_FUNCTION(execActivateZone)
    {
        P_FINISH;
        this->ActivateZone();
    }
    DECLARE_FUNCTION(execDeactivateZone)
    {
        P_FINISH;
        this->DeactivateZone();
    }
    void delegateOnPostDrawZone(class UMobileInputZone* Zone,class UCanvas* Canvas)
    {
        MobileInputZone_eventOnPostDrawZone_Parms Parms(EC_EventParm);
        Parms.Zone=Zone;
        Parms.Canvas=Canvas;
        ProcessDelegate(GAMEFRAMEWORK_OnPostDrawZone,&__OnPostDrawZone__Delegate,&Parms);
    }
    UBOOL delegateOnPreDrawZone(class UMobileInputZone* Zone,class UCanvas* Canvas)
    {
        MobileInputZone_eventOnPreDrawZone_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Zone=Zone;
        Parms.Canvas=Canvas;
        ProcessDelegate(GAMEFRAMEWORK_OnPreDrawZone,&__OnPreDrawZone__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnProcessSlide(class UMobileInputZone* Zone,BYTE EventType,INT SlideValue,FVector2D ViewportSize)
    {
        MobileInputZone_eventOnProcessSlide_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Zone=Zone;
        Parms.EventType=EventType;
        Parms.SlideValue=SlideValue;
        Parms.ViewportSize=ViewportSize;
        ProcessDelegate(GAMEFRAMEWORK_OnProcessSlide,&__OnProcessSlide__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnDoubleTapDelegate(class UMobileInputZone* Zone,BYTE EventType,FVector2D TouchLocation)
    {
        MobileInputZone_eventOnDoubleTapDelegate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Zone=Zone;
        Parms.EventType=EventType;
        Parms.TouchLocation=TouchLocation;
        ProcessDelegate(GAMEFRAMEWORK_OnDoubleTapDelegate,&__OnDoubleTapDelegate__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnTapDelegate(class UMobileInputZone* Zone,BYTE EventType,FVector2D TouchLocation)
    {
        MobileInputZone_eventOnTapDelegate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Zone=Zone;
        Parms.EventType=EventType;
        Parms.TouchLocation=TouchLocation;
        ProcessDelegate(GAMEFRAMEWORK_OnTapDelegate,&__OnTapDelegate__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnProcessInputDelegate(class UMobileInputZone* Zone,FLOAT DeltaTime,INT Handle,BYTE EventType,FVector2D TouchLocation)
    {
        MobileInputZone_eventOnProcessInputDelegate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Zone=Zone;
        Parms.DeltaTime=DeltaTime;
        Parms.Handle=Handle;
        Parms.EventType=EventType;
        Parms.TouchLocation=TouchLocation;
        ProcessDelegate(GAMEFRAMEWORK_OnProcessInputDelegate,&__OnProcessInputDelegate__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UMobileInputZone,UObject,0|CLASS_Config,GameFramework)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/**
	 * Processes a touch event
	 *
	 * @param DeltaTime		Much time has elapsed since the last processing
	 * @param Handle		The unique ID of this touch
	 * @param EventType		The type of event that occurred
	 * @param TouchLocation	Where on the device has the touch occurred.
	 * @param TouchDuration	How long since the touch started
	 * @param MoveDeltaTime	Time delta between the movement events the last time this touch moved
 	 */
	void virtual ProcessTouch(FLOAT DeltaTime, UINT Handle, ETouchType EventType, FVector2D TouchLocation, FLOAT TouchTotalMoveDistance, FLOAT TouchDuration, FLOAT MoveDeltaTime);

	/**
	 * All zones that are in the active group get 'Ticked' at the end of MobilePlayerInput::Tick
	 *
	 * @param DeltaTime		Much time has elapsed since the last processing
	 */
	void virtual TickZone(FLOAT DeltaTime);

 	/**
	 * Applies any remaining escape velocity for this zone
	 *
	 * @param DeltaTime		Much time has elapsed since the last processing
	 */
	void ApplyEscapeVelocity( FLOAT DeltaTime );

	/**
	 * This function will iterate over the MobileSeqEventHandles array and cause them to be updated.  It get's called once per frame that the zone is active
	 */
	void UpdateListeners();

protected:
	/**
	 * Computes average location and movement time for the zone's active touch 
	 *
	 * @param	InTimeToAverageOver			How long a duration to average over (max)
	 * @param	OutSmoothedLocation			(Out) Average location
	 * @param	OutSmoothedMoveDeltaTime	(Out) Average movement delta time
	 */
	void ComputeSmoothedMovement( const FLOAT InTimeToAverageOver, FVector2D& OutSmoothedLocation, FLOAT& OutSmoothedMoveDeltaTime ) const;
};

#define UCONST_NumTouchDataEntries 5

struct FTouchDataEvent
{
    BYTE EventType;
    BYTE TouchpadIndex;
    SCRIPT_ALIGN;
    FVector2D Location;
    DOUBLE DeviceTime;

    /** Constructors */
    FTouchDataEvent() {}
    FTouchDataEvent(EEventParm)
    {
        appMemzero(this, sizeof(FTouchDataEvent));
    }
};

struct FTouchData
{
    INT Handle;
    BYTE TouchpadIndex;
    SCRIPT_ALIGN;
    FVector2D Location;
    FLOAT TotalMoveDistance;
    DOUBLE InitialDeviceTime;
    FLOAT TouchDuration;
    DOUBLE MoveEventDeviceTime;
    FLOAT MoveDeltaTime;
    BITFIELD bInUse:1;
    class UMobileInputZone* Zone;
    BYTE State;
    TArrayNoInit<struct FTouchDataEvent> Events;
    FLOAT LastActiveTime;

    /** Constructors */
    FTouchData() {}
    FTouchData(EEventParm)
    {
        appMemzero(this, sizeof(FTouchData));
    }
};

struct FMobileInputGroup
{
    FStringNoInit GroupName;
    TArrayNoInit<class UMobileInputZone*> AssociatedZones;

    /** Constructors */
    FMobileInputGroup() {}
    FMobileInputGroup(EEventParm)
    {
        appMemzero(this, sizeof(FMobileInputGroup));
    }
};

struct FMobileInputZoneClassMap
{
    FStringNoInit Name;
    class UClass* ClassType;

    /** Constructors */
    FMobileInputZoneClassMap() {}
    FMobileInputZoneClassMap(EEventParm)
    {
        appMemzero(this, sizeof(FMobileInputZoneClassMap));
    }
};

struct MobilePlayerInput_eventRenderMenus_Parms
{
    class UCanvas* Canvas;
    FLOAT RenderDelta;
    MobilePlayerInput_eventRenderMenus_Parms(EEventParm)
    {
    }
};
struct MobilePlayerInput_eventCloseAllMenus_Parms
{
    MobilePlayerInput_eventCloseAllMenus_Parms(EEventParm)
    {
    }
};
struct MobilePlayerInput_eventCloseMenuScene_Parms
{
    class UMobileMenuScene* SceneToClose;
    MobilePlayerInput_eventCloseMenuScene_Parms(EEventParm)
    {
    }
};
struct MobilePlayerInput_eventOpenMenuScene_Parms
{
    class UClass* SceneClass;
    FString Mode;
    class UMobileMenuScene* ReturnValue;
    MobilePlayerInput_eventOpenMenuScene_Parms(EEventParm)
    {
    }
};
struct MobilePlayerInput_eventRefreshKismetLinks_Parms
{
    MobilePlayerInput_eventRefreshKismetLinks_Parms(EEventParm)
    {
    }
};
struct MobilePlayerInput_eventOnInputTouch_Parms
{
    INT Handle;
    BYTE Type;
    FVector2D TouchLocation;
    FLOAT DeviceTimestamp;
    INT TouchpadIndex;
    MobilePlayerInput_eventOnInputTouch_Parms(EEventParm)
    {
    }
};
struct MobilePlayerInput_eventOnPreviewTouch_Parms
{
    FLOAT X;
    FLOAT Y;
    INT TouchpadIndex;
    UBOOL ReturnValue;
    MobilePlayerInput_eventOnPreviewTouch_Parms(EEventParm)
    {
    }
};
struct MobilePlayerInput_eventOnTouchNotHandledInMenu_Parms
{
    MobilePlayerInput_eventOnTouchNotHandledInMenu_Parms(EEventParm)
    {
    }
};
class UMobilePlayerInput : public UPlayerInput
{
public:
    //## BEGIN PROPS MobilePlayerInput
    struct FTouchData Touches[5];
    class UMobileMenuObject* InteractiveObject;
    DOUBLE InteractiveObjectLastTime;
    TArrayNoInit<struct FMobileInputGroup> MobileInputGroups;
    INT CurrentMobileGroup;
    TArrayNoInit<class UMobileInputZone*> MobileInputZones;
    TArrayNoInit<struct FMobileInputZoneClassMap> MobileInputZoneClasses;
    FLOAT MobilePitch;
    FLOAT MobilePitchCenter;
    FLOAT MobilePitchMultiplier;
    FLOAT MobileYaw;
    FLOAT MobileYawCenter;
    FLOAT MobileYawMultiplier;
    FLOAT MobilePitchDeadzoneSize;
    FLOAT MobileYawDeadzoneSize;
    FLOAT MobileDoubleTapTime;
    FLOAT MobileMinHoldForTap;
    FLOAT MobileTapRepeatTime;
    BITFIELD bAllowTouchesInCinematic:1;
    BITFIELD bDisableTouchInput:1;
    BITFIELD bAbsoluteTouchLocations:1;
    BITFIELD bCollapseTouchInput:1;
    BITFIELD bFakeMobileTouches:1;
    BITFIELD bDisableSceneRender:1;
    FLOAT ZoneTimeout;
    TArrayNoInit<class UMobileMenuScene*> MobileMenuStack;
    FStringNoInit NativeDebugString;
    FLOAT MobileInactiveTime;
    TArrayNoInit<class USeqEvent_MobileBase*> MobileSeqEventHandlers;
    TArrayNoInit<class USeqEvent_MobileRawInput*> MobileRawInputSeqEventHandlers;
    FVector2D MobileViewportOffset;
    FVector2D MobileViewportSize;
    FScriptDelegate __OnTouchNotHandledInMenu__Delegate;
    FScriptDelegate __OnPreviewTouch__Delegate;
    FScriptDelegate __OnInputTouch__Delegate;
    //## END PROPS MobilePlayerInput

    virtual void ProcessMobileInput(FLOAT DeltaTime);
    virtual void CancelMobileInput();
    virtual void NativeInitializeInputSystem();
    virtual void NativeInitializeInputZones(UBOOL bIsFirstInitialize);
    virtual void ConditionalUpdateInputZones(INT NewViewportX,INT NewViewportY,INT NewViewportSizeX,INT NewViewportSizeY);
    virtual void SendInputKey(FName Key,BYTE Event,FLOAT AmountDepressed);
    virtual void SendInputAxis(FName Key,FLOAT Delta,FLOAT DeltaTime);
    virtual UBOOL ProcessWorldTouch(class UMobileInputZone* Zone,BYTE EventType,FVector2D TouchLocation);
    DECLARE_FUNCTION(execProcessMobileInput)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        this->ProcessMobileInput(DeltaTime);
    }
    DECLARE_FUNCTION(execNativeInitializeInputSystem)
    {
        P_FINISH;
        this->NativeInitializeInputSystem();
    }
    DECLARE_FUNCTION(execNativeInitializeInputZones)
    {
        P_GET_UBOOL(bIsFirstInitialize);
        P_FINISH;
        this->NativeInitializeInputZones(bIsFirstInitialize);
    }
    DECLARE_FUNCTION(execConditionalUpdateInputZones)
    {
        P_GET_INT(NewViewportX);
        P_GET_INT(NewViewportY);
        P_GET_INT(NewViewportSizeX);
        P_GET_INT(NewViewportSizeY);
        P_FINISH;
        this->ConditionalUpdateInputZones(NewViewportX,NewViewportY,NewViewportSizeX,NewViewportSizeY);
    }
    DECLARE_FUNCTION(execSendInputKey)
    {
        P_GET_NAME(Key);
        P_GET_BYTE(Event);
        P_GET_FLOAT(AmountDepressed);
        P_FINISH;
        this->SendInputKey(Key,Event,AmountDepressed);
    }
    DECLARE_FUNCTION(execSendInputAxis)
    {
        P_GET_NAME(Key);
        P_GET_FLOAT(Delta);
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        this->SendInputAxis(Key,Delta,DeltaTime);
    }
    DECLARE_FUNCTION(execProcessWorldTouch)
    {
        P_GET_OBJECT(UMobileInputZone,Zone);
        P_GET_BYTE(EventType);
        P_GET_STRUCT(FVector2D,TouchLocation);
        P_FINISH;
        *(UBOOL*)Result=this->ProcessWorldTouch(Zone,EventType,TouchLocation);
    }
    void eventRenderMenus(class UCanvas* Canvas,FLOAT RenderDelta)
    {
        MobilePlayerInput_eventRenderMenus_Parms Parms(EC_EventParm);
        Parms.Canvas=Canvas;
        Parms.RenderDelta=RenderDelta;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_RenderMenus),&Parms);
    }
    void eventCloseAllMenus()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_CloseAllMenus),NULL);
    }
    void eventCloseMenuScene(class UMobileMenuScene* SceneToClose)
    {
        MobilePlayerInput_eventCloseMenuScene_Parms Parms(EC_EventParm);
        Parms.SceneToClose=SceneToClose;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_CloseMenuScene),&Parms);
    }
    class UMobileMenuScene* eventOpenMenuScene(class UClass* SceneClass,const FString& Mode=TEXT(""))
    {
        MobilePlayerInput_eventOpenMenuScene_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.SceneClass=SceneClass;
        Parms.Mode=Mode;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_OpenMenuScene),&Parms);
        return Parms.ReturnValue;
    }
    void eventRefreshKismetLinks()
    {
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_RefreshKismetLinks),NULL);
    }
    void delegateOnInputTouch(INT Handle,BYTE Type,FVector2D TouchLocation,FLOAT DeviceTimestamp,INT TouchpadIndex)
    {
        MobilePlayerInput_eventOnInputTouch_Parms Parms(EC_EventParm);
        Parms.Handle=Handle;
        Parms.Type=Type;
        Parms.TouchLocation=TouchLocation;
        Parms.DeviceTimestamp=DeviceTimestamp;
        Parms.TouchpadIndex=TouchpadIndex;
        ProcessDelegate(GAMEFRAMEWORK_OnInputTouch,&__OnInputTouch__Delegate,&Parms);
    }
    UBOOL delegateOnPreviewTouch(FLOAT X,FLOAT Y,INT TouchpadIndex)
    {
        MobilePlayerInput_eventOnPreviewTouch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.X=X;
        Parms.Y=Y;
        Parms.TouchpadIndex=TouchpadIndex;
        ProcessDelegate(GAMEFRAMEWORK_OnPreviewTouch,&__OnPreviewTouch__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void delegateOnTouchNotHandledInMenu()
    {
        ProcessDelegate(GAMEFRAMEWORK_OnTouchNotHandledInMenu,&__OnTouchNotHandledInMenu__Delegate,NULL);
    }
    DECLARE_CLASS(UMobilePlayerInput,UPlayerInput,0|CLASS_Transient|CLASS_Config,GameFramework)
    DECLARE_WITHIN(AGamePlayerController)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/**
	 * Takes a touch and looks up the InputZone that would handle it.
	 *
	 * @param TouchLocation		 Where the touch occurred
	 * @param TouchpadIndex		The index of the touchpad this touch came from
	 * @returns the zone that will be managing this touch
	 */
	UMobileInputZone* HitTest(FVector2D TouchLocation, UINT TouchpadIndex);

	/**
	 * Process an input key event received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	gamepad/controller that generated this input event
	 * @param	Key				the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)
	 * @param	EventType		the type of event which occured (pressed, released, etc.)
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
		* Process an input axis (joystick, thumbstick, or mouse) event received from the viewport.
		*
		* @param	Viewport		the viewport the input event was received from
		* @param	ControllerId	the controller that generated this input axis event
		* @param	Key				the name of the axis that moved  (KEY_MouseX, KEY_XboxTypeS_LeftX, etc.)
		* @param	Delta			the movement delta for the axis
		* @param	DeltaTime		the time (in seconds) since the last axis update.
		*
		* @return	TRUE to consume the axis event, FALSE to pass it on.
		*/
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Handle a touch event coming from the device.
	 *
	 * NOTE: no processing of the touch happens here.  This just tracks the touch in the Touches stack.  Processing
	 * happens each tick
	 *
	 * @param Handle			the id of the touch
	 * @param Type				What type of event is this
	 * @param TouchLocation		Where the touch occurred
	 * @param DeviceTimestamp	Input event timestamp from the device
	 * @param TouchpadIndex		The index of the touchpad this touch came from
	 */
	virtual UBOOL InputTouch(INT ControllerId, UINT Handle, ETouchType Type, FVector2D TouchLocation, DOUBLE DeviceTimestamp, UINT TouchpadIndex=0);

	/**
	 * Update active touches, etc
	 *
	 * @param DeltaTime		Much time has elapsed since the last processing
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * When input comes in to the player input, the first thing we need to do is process it for
	 * the menus.
	 *
	 * @param TouchHandle       A unique id for the touch
	 * @param TouchpadIndex		The index of the touchpad this touch came from
	 * @param EventType         What type of event is this
	 * @param TouchLocation     Where the touch occurred
	 * @param DeviceTimestamp	Time this event happened.
	 *
	 * @returns true if the menu system swallowed the input
	 */
	UBOOL ProcessMenuInput(UINT TouchHandle, UINT TouchpadIndex, ETouchType EventType, FVector2D TouchLocation, DOUBLE DeviceTimestamp);


	/**
	 * This function will iterate over the MobileSeqEventHandles array and cause them to be updated.
	 * It get's called once per frame.
	 */
	void UpdateListeners();

	/**
	 * Returns the Global Scaling values
	 *
	 * @return a FVector2 containing the global scale values
	 */
	FVector2D GetGlobalScale();


	/**
	 * Swap around components of a vector (with rotational values) based on an orientation.
	 * This will swap pitch and roll when a mobile device is rotated 90 degrees, etc
	 *
	 * @param Vec [in/out] Vector to modify
	 * @param Orientation Orientation for which the values were generated in
	 * @param bIsRotation TRUE if the vector represents rotation, not a directional vector
	 */
	static void ModifyVectorByOrientation(FVector& Vec, EUIOrientation Orientation, UBOOL bIsRotation)
	{
		switch (Orientation)
		{
			case UI_Portait:
				// this is the base orientation, so nothing to do
				break;

			case UI_PortaitUpsideDown:
				if (bIsRotation)
				{
					// negate roll and pitch
					Vec.X = -Vec.X;
					Vec.Z = -Vec.Z;
				}
				else
				{
					// negate x/y
					Vec.X = -Vec.X;
					Vec.Y = -Vec.Y;
				}
				break;

			case UI_LandscapeRight:
				if (bIsRotation)
				{
					// swap and negate (as needed) roll and pitch
					FLOAT Temp = Vec.X;
					Vec.X = -Vec.Z;
					Vec.Z = Temp;
				}
				else
				{
					// swap and negate (as needed) x and y
					FLOAT Temp = Vec.X;
					Vec.X = -Vec.Y;
					Vec.Y = Temp;
				}
				break;

			case UI_LandscapeLeft:
				if (bIsRotation)
				{
					// swap and negate (as needed) roll and pitch
					FLOAT Temp = Vec.X;
					Vec.X = Vec.Z;
					Vec.Z = -Temp;
				}
				else
				{
					// swap and negate (as needed) x and y
					FLOAT Temp = Vec.X;
					Vec.X = Vec.Y;
					Vec.Y = -Temp;
				}
				break;
		}
	}

public:
	/**
	 * Determine the size of the current interactive canvas
	 *
	 * @param ViewportSize Size of the canvas
	 */
	void GetInteractiveViewportSize(FVector2D& ViewportSize);

	/**
	 * Initialize, or reinitialize a zone
	 *
	 * @param Zone The Zone to initialize
	 * @param ViewportSize Size of the canvas
	 * @param bIsFirstInitialize TRUE if this is the first time the zone is initialized (use FALSE when canvas was resized)
	 */
	void NativeInitializeZone(UMobileInputZone* Zone, const FVector2D& ViewportSize, UBOOL bIsFirstInitialize);
};

class AMobileHUD : public AHUD
{
public:
    //## BEGIN PROPS MobileHUD
    BITFIELD bShowGameHud:1;
    BITFIELD bShowMobileHud:1;
    BITFIELD bForceMobileHUD:1;
    BITFIELD bShowMobileTilt:1;
    BITFIELD bDebugTouches:1;
    BITFIELD bDebugZones:1;
    BITFIELD bDebugZonePresses:1;
    BITFIELD bShowMotionDebug:1;
    class UTexture2D* JoystickBackground;
    struct FTextureUVs JoystickBackgroundUVs;
    class UTexture2D* JoystickHat;
    struct FTextureUVs JoystickHatUVs;
    class UTexture2D* ButtonImages[2];
    struct FTextureUVs ButtonUVs[2];
    class UFont* ButtonFont;
    FColor ButtonCaptionColor;
    class UTexture2D* TrackballBackground;
    struct FTextureUVs TrackballBackgroundUVs;
    class UTexture2D* TrackballTouchIndicator;
    struct FTextureUVs TrackballTouchIndicatorUVs;
    class UTexture2D* SliderImages[4];
    struct FTextureUVs SliderUVs[4];
    FLOAT MobileTiltX;
    FLOAT MobileTiltY;
    FLOAT MobileTiltSize;
    TArrayNoInit<class USeqEvent_HudRender*> KismetRenderEvents;
    //## END PROPS MobileHUD

    DECLARE_CLASS(AMobileHUD,AHUD,0|CLASS_Transient|CLASS_Config,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(AMobileHUD)
};

struct FUVCoords
{
    BITFIELD bCustomCoords:1;
    FLOAT U;
    FLOAT V;
    FLOAT UL;
    FLOAT VL;

    /** Constructors */
    FUVCoords() {}
    FUVCoords(EEventParm)
    {
        appMemzero(this, sizeof(FUVCoords));
    }
};

struct MobileMenuObject_eventGetRealPosition_Parms
{
    FLOAT PosX;
    FLOAT PosY;
    MobileMenuObject_eventGetRealPosition_Parms(EEventParm)
    {
    }
};
struct MobileMenuObject_eventOnTouch_Parms
{
    BYTE EventType;
    FLOAT TouchX;
    FLOAT TouchY;
    class UMobileMenuObject* ObjectOver;
    FLOAT DeltaTime;
    UBOOL ReturnValue;
    MobileMenuObject_eventOnTouch_Parms(EEventParm)
    {
    }
};
class UMobileMenuObject : public UObject
{
public:
    //## BEGIN PROPS MobileMenuObject
    BITFIELD bHasBeenInitialized:1;
    BITFIELD bRelativeLeft:1;
    BITFIELD bRelativeTop:1;
    BITFIELD bRelativeWidth:1;
    BITFIELD bRelativeHeight:1;
    BITFIELD bApplyGlobalScaleLeft:1;
    BITFIELD bApplyGlobalScaleTop:1;
    BITFIELD bApplyGlobalScaleWidth:1;
    BITFIELD bApplyGlobalScaleHeight:1;
    BITFIELD bHeightRelativeToWidth:1;
    BITFIELD bXOffsetIsActual:1;
    BITFIELD bYOffsetIsActual:1;
    BITFIELD bIsActive:1;
    BITFIELD bIsHidden:1;
    BITFIELD bIsTouched:1;
    BITFIELD bIsHighlighted:1;
    BITFIELD bTellSceneBeforeRendering:1;
    FLOAT Left;
    FLOAT Top;
    FLOAT Width;
    FLOAT Height;
    FLOAT InitialLeft;
    FLOAT InitialTop;
    FLOAT InitialWidth;
    FLOAT InitialHeight;
    FLOAT AuthoredGlobalScale;
    FLOAT TopLeeway;
    FLOAT BottomLeeway;
    FLOAT LeftLeeway;
    FLOAT RightLeeway;
    FLOAT XOffset;
    FLOAT YOffset;
    FStringNoInit Tag;
    class UMobilePlayerInput* InputOwner;
    FLOAT Opacity;
    class UMobileMenuScene* OwnerScene;
    FStringNoInit RelativeToTag;
    class UMobileMenuObject* RelativeTo;
    //## END PROPS MobileMenuObject

    void eventGetRealPosition(FLOAT& PosX,FLOAT& PosY)
    {
        MobileMenuObject_eventGetRealPosition_Parms Parms(EC_EventParm);
        Parms.PosX=PosX;
        Parms.PosY=PosY;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_GetRealPosition),&Parms);
        PosX=Parms.PosX;
        PosY=Parms.PosY;
    }
    UBOOL eventOnTouch(BYTE EventType,FLOAT TouchX,FLOAT TouchY,class UMobileMenuObject* ObjectOver,FLOAT DeltaTime)
    {
        MobileMenuObject_eventOnTouch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EventType=EventType;
        Parms.TouchX=TouchX;
        Parms.TouchY=TouchY;
        Parms.ObjectOver=ObjectOver;
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_OnTouch),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UMobileMenuObject,UObject,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UMobileMenuObject)
};

class UMobileMenuImage : public UMobileMenuObject
{
public:
    //## BEGIN PROPS MobileMenuImage
    class UTexture2D* Image;
    BYTE ImageDrawStyle;
    SCRIPT_ALIGN;
    struct FUVCoords ImageUVs;
    FLinearColor ImageColor;
    //## END PROPS MobileMenuImage

    DECLARE_CLASS(UMobileMenuImage,UMobileMenuObject,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(UMobileMenuImage)
};

struct MobileMenuScene_eventOnSceneTouch_Parms
{
    BYTE EventType;
    FLOAT TouchX;
    FLOAT TouchY;
    UBOOL bInside;
    UBOOL ReturnValue;
    MobileMenuScene_eventOnSceneTouch_Parms(EEventParm)
    {
    }
};
struct MobileMenuScene_eventOnTouch_Parms
{
    class UMobileMenuObject* Sender;
    BYTE EventType;
    FLOAT TouchX;
    FLOAT TouchY;
    MobileMenuScene_eventOnTouch_Parms(EEventParm)
    {
    }
};
struct MobileMenuScene_eventInitMenuScene_Parms
{
    class UMobilePlayerInput* PlayerInput;
    INT ScreenWidth;
    INT ScreenHeight;
    UBOOL bIsFirstInitialization;
    MobileMenuScene_eventInitMenuScene_Parms(EEventParm)
    {
    }
};
class UMobileMenuScene : public UObject
{
public:
    //## BEGIN PROPS MobileMenuScene
    FStringNoInit MenuName;
    TArrayNoInit<class UMobileMenuObject*> MenuObjects;
    class UFont* SceneCaptionFont;
    class UMobilePlayerInput* InputOwner;
    BITFIELD bSceneDoesNotRequireInput:1;
    BITFIELD bRelativeLeft:1;
    BITFIELD bRelativeTop:1;
    BITFIELD bRelativeWidth:1;
    BITFIELD bRelativeHeight:1;
    BITFIELD bApplyGlobalScaleLeft:1;
    BITFIELD bApplyGlobalScaleTop:1;
    BITFIELD bApplyGlobalScaleWidth:1;
    BITFIELD bApplyGlobalScaleHeight:1;
    SCRIPT_ALIGN;
    BYTE TouchpadIndex;
    FLOAT Left;
    FLOAT Top;
    FLOAT Width;
    FLOAT Height;
    FLOAT InitialLeft;
    FLOAT InitialTop;
    FLOAT InitialWidth;
    FLOAT InitialHeight;
    FLOAT AuthoredGlobalScale;
    FLOAT Opacity;
    class USoundCue* UITouchSound;
    class USoundCue* UIUnTouchSound;
    //## END PROPS MobileMenuScene

    FLOAT GetGlobalScaleX();
    FLOAT GetGlobalScaleY();
    virtual void CleanUpScene();
    DECLARE_FUNCTION(execGetGlobalScaleX)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetGlobalScaleX();
    }
    DECLARE_FUNCTION(execGetGlobalScaleY)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetGlobalScaleY();
    }
    DECLARE_FUNCTION(execCleanUpScene)
    {
        P_FINISH;
        this->CleanUpScene();
    }
    UBOOL eventOnSceneTouch(BYTE EventType,FLOAT TouchX,FLOAT TouchY,UBOOL bInside)
    {
        MobileMenuScene_eventOnSceneTouch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EventType=EventType;
        Parms.TouchX=TouchX;
        Parms.TouchY=TouchY;
        Parms.bInside=bInside ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_OnSceneTouch),&Parms);
        return Parms.ReturnValue;
    }
    void eventOnTouch(class UMobileMenuObject* Sender,BYTE EventType,FLOAT TouchX,FLOAT TouchY)
    {
        MobileMenuScene_eventOnTouch_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.EventType=EventType;
        Parms.TouchX=TouchX;
        Parms.TouchY=TouchY;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_OnTouch),&Parms);
    }
    void eventInitMenuScene(class UMobilePlayerInput* PlayerInput,INT ScreenWidth,INT ScreenHeight,UBOOL bIsFirstInitialization)
    {
        MobileMenuScene_eventInitMenuScene_Parms Parms(EC_EventParm);
        Parms.PlayerInput=PlayerInput;
        Parms.ScreenWidth=ScreenWidth;
        Parms.ScreenHeight=ScreenHeight;
        Parms.bIsFirstInitialization=bIsFirstInitialization ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_InitMenuScene),&Parms);
    }
    DECLARE_CLASS(UMobileMenuScene,UObject,0,GameFramework)

	/**
	 * Performs a hit test against all of the objects in the object stack.  
	 *
	 * @param TouchX - The X location of the touch event
	 * @param TouchY - The Y location of the touch event
	 * @param Returns the object that hits.                                                                     
	 */
	virtual UMobileMenuObject* HitTest(FLOAT TouchX, FLOAT TouchY);
};

class UNavMeshGoal_OutOfViewFrom : public UNavMeshPathGoalEvaluator
{
public:
    //## BEGIN PROPS NavMeshGoal_OutOfViewFrom
    FNavMeshPolyBase* GoalPoly;
    FVector OutOfViewLocation;
    BITFIELD bShowDebug:1;
    SCRIPT_ALIGN;
    //## END PROPS NavMeshGoal_OutOfViewFrom

    virtual void RecycleNative();
    DECLARE_FUNCTION(execRecycleNative)
    {
        P_FINISH;
        this->RecycleNative();
    }
    DECLARE_CLASS(UNavMeshGoal_OutOfViewFrom,UNavMeshPathGoalEvaluator,0,GameFramework)
	// Interface
	virtual UBOOL InitializeSearch( UNavigationHandle* Handle, const FNavMeshPathParams& PathParams);
	virtual UBOOL EvaluateGoal( PathCardinalType PossibleGoal, const FNavMeshPathParams& PathParams, PathCardinalType& out_GenGoal );
	virtual void  NotifyExceededMaxPathVisits( PathCardinalType BestGuess, PathCardinalType& out_GenGoal );
};

class UNavMeshPath_BiasAgainstPolysWithinDistanceOfLocations : public UNavMeshPathConstraint
{
public:
    //## BEGIN PROPS NavMeshPath_BiasAgainstPolysWithinDistanceOfLocations
    FVector Location;
    FVector Rotation;
    FLOAT DistanceToCheck;
    TArrayNoInit<FVector> LocationsToCheck;
    //## END PROPS NavMeshPath_BiasAgainstPolysWithinDistanceOfLocations

    DECLARE_CLASS(UNavMeshPath_BiasAgainstPolysWithinDistanceOfLocations,UNavMeshPathConstraint,0,GameFramework)
	// Interface
	virtual UBOOL EvaluatePath( FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge, FNavMeshPolyBase* SrcPoly, FNavMeshPolyBase* DestPoly, const FNavMeshPathParams& PathParams, INT& out_PathCost, INT& out_HeuristicCost, const FVector& EdgePoint );
};

struct SecondaryViewportClient_eventPostRender_Parms
{
    class UCanvas* Canvas;
    SecondaryViewportClient_eventPostRender_Parms(EEventParm)
    {
    }
};
class USecondaryViewportClient : public UScriptViewportClient
{
public:
    //## BEGIN PROPS SecondaryViewportClient
    //## END PROPS SecondaryViewportClient

    void eventPostRender(class UCanvas* Canvas)
    {
        SecondaryViewportClient_eventPostRender_Parms Parms(EC_EventParm);
        Parms.Canvas=Canvas;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_PostRender),&Parms);
    }
    DECLARE_CLASS(USecondaryViewportClient,UScriptViewportClient,0|CLASS_Transient,GameFramework)
	virtual void Draw(FViewport* Viewport,FCanvas* Canvas);
	virtual UBOOL RequiresHitProxyStorage() { return 0; }

protected:
	
	virtual UCanvas* InitCanvas(FViewport* Viewport, FCanvas* Canvas);
	virtual void DrawSecondaryHUD(UCanvas* CanvasObject);
};

class UMobileSecondaryViewportClient : public USecondaryViewportClient
{
public:
    //## BEGIN PROPS MobileSecondaryViewportClient
    //## END PROPS MobileSecondaryViewportClient

    DECLARE_CLASS(UMobileSecondaryViewportClient,USecondaryViewportClient,0|CLASS_Transient,GameFramework)
	virtual void Draw(FViewport* Viewport,FCanvas* Canvas)
	{
		Super::Draw(Viewport, Canvas);
	}
	virtual UBOOL RequiresHitProxyStorage() { return 0; }

protected:
	
	virtual void DrawSecondaryHUD(UCanvas* CanvasObject) { }
};

class USeqAct_ControlGameMovie : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_ControlGameMovie
    FStringNoInit MovieName;
    INT StartOfRenderingMovieFrame;
    INT EndOfRenderingMovieFrame;
    //## END PROPS SeqAct_ControlGameMovie

    DECLARE_CLASS(USeqAct_ControlGameMovie,USeqAct_Latent,0,GameFramework)
	/**
	 * Executes the action when it is triggered 
	 */
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
};

class USeqAct_Deproject : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Deproject
    FLOAT ScreenX;
    FLOAT ScreenY;
    FLOAT TraceDistance;
    class UObject* HitObject;
    FVector HitLocation;
    FVector HitNormal;
    //## END PROPS SeqAct_Deproject

    DECLARE_CLASS(USeqAct_Deproject,USequenceAction,0,GameFramework)
	void Activated();
};

class USeqAct_MobileAddInputZones : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_MobileAddInputZones
    FName ZoneName;
    class UMobileInputZone* NewZone;
    //## END PROPS SeqAct_MobileAddInputZones

    DECLARE_CLASS(USeqAct_MobileAddInputZones,USequenceAction,0,GameFramework)
	void Activated();
};

class USeqAct_MobileClearInputZones : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_MobileClearInputZones
    //## END PROPS SeqAct_MobileClearInputZones

    DECLARE_CLASS(USeqAct_MobileClearInputZones,USequenceAction,0,GameFramework)
	void Activated();
};

class USeqAct_MobileRemoveInputZone : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_MobileRemoveInputZone
    FStringNoInit ZoneName;
    //## END PROPS SeqAct_MobileRemoveInputZone

    DECLARE_CLASS(USeqAct_MobileRemoveInputZone,USequenceAction,0,GameFramework)
	void Activated();
};

class USeqAct_MobileSaveLoadValue : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_MobileSaveLoadValue
    //## END PROPS SeqAct_MobileSaveLoadValue

    DECLARE_CLASS(USeqAct_MobileSaveLoadValue,USequenceAction,0,GameFramework)
	void Activated();
	void DeActivated();
};

struct FPropertyInfo
{
    FName PropertyName;
    BITFIELD bModifyProperty:1;
    FStringNoInit PropertyValue;

    /** Constructors */
    FPropertyInfo() {}
    FPropertyInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPropertyInfo));
    }
};

class USeqAct_ModifyProperty : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ModifyProperty
    TArrayNoInit<struct FPropertyInfo> Properties;
    //## END PROPS SeqAct_ModifyProperty

    DECLARE_CLASS(USeqAct_ModifyProperty,USequenceAction,0,GameFramework)
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
	virtual void Activated();
};

class USeqAct_PlayAgentAnimation : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_PlayAgentAnimation
    TArrayNoInit<FName> AnimationList;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    BITFIELD bUseRootMotion:1;
    BITFIELD bFaceActionTargetFirst:1;
    BITFIELD bLooping:1;
    BITFIELD bBlendBetweenAnims:1;
    INT LoopIndex;
    FLOAT LoopTime;
    class AActor* ActionTarget;
    //## END PROPS SeqAct_PlayAgentAnimation

    DECLARE_CLASS(USeqAct_PlayAgentAnimation,USeqAct_Latent,0,GameFramework)
	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqEvent_CrowdAgentReachedDestination : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_CrowdAgentReachedDestination
    //## END PROPS SeqEvent_CrowdAgentReachedDestination

    DECLARE_CLASS(USeqEvent_CrowdAgentReachedDestination,USequenceEvent,0,GameFramework)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_HudRender : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_HudRender
    TArrayNoInit<class UObject*> Targets;
    BITFIELD bIsActive:1;
    FLOAT AuthoredGlobalScale;
    //## END PROPS SeqEvent_HudRender

    DECLARE_ABSTRACT_CLASS(USeqEvent_HudRender,USequenceEvent,0,GameFramework)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_HudRender)
};

struct SeqEvent_MobileBase_eventAddToMobileInput_Parms
{
    class UMobilePlayerInput* MPI;
    SeqEvent_MobileBase_eventAddToMobileInput_Parms(EEventParm)
    {
    }
};
class USeqEvent_MobileBase : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_MobileBase
    //## END PROPS SeqEvent_MobileBase

    void eventAddToMobileInput(class UMobilePlayerInput* MPI)
    {
        SeqEvent_MobileBase_eventAddToMobileInput_Parms Parms(EC_EventParm);
        Parms.MPI=MPI;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_AddToMobileInput),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(USeqEvent_MobileBase,USequenceEvent,0,GameFramework)
	/**
	 * Called each frame.  
	 * @param Originator is a reference to the PC that caused the input
	 * @param OriginatorInput is a reference to the mobile player input assoicated with this object
	 */
	virtual void Update(APlayerController* Originator, UMobilePlayerInput* OriginatorInput);
};

class USeqEvent_MobileMotion : public USeqEvent_MobileBase
{
public:
    //## BEGIN PROPS SeqEvent_MobileMotion
    FLOAT Roll;
    FLOAT Pitch;
    FLOAT Yaw;
    FLOAT DeltaRoll;
    FLOAT DeltaPitch;
    FLOAT DeltaYaw;
    //## END PROPS SeqEvent_MobileMotion

    DECLARE_CLASS(USeqEvent_MobileMotion,USeqEvent_MobileBase,0,GameFramework)
	/**
	 * Called each frame.  
	 * @param Originator is a reference to the PC that caused the input
	 * @param OriginatorInput is a reference to the mobile player input assoicated with this object
	 */
	void Update(APlayerController* Originator, UMobilePlayerInput* OriginatorInput);
};

class USeqEvent_MobileZoneBase : public USeqEvent_MobileBase
{
public:
    //## BEGIN PROPS SeqEvent_MobileZoneBase
    FStringNoInit TargetZoneName;
    //## END PROPS SeqEvent_MobileZoneBase

    DECLARE_ABSTRACT_CLASS(USeqEvent_MobileZoneBase,USeqEvent_MobileBase,0,GameFramework)
	/**
	 * Called each frame.  
	 * @param Originator is a reference to the PC that caused the input
	 * @param OriginatorInput is a reference to the mobile player input assoicated with this object
	 * @param OriginatorZone is a reference to the zone that caused this update
	 */
	virtual void UpdateZone(APlayerController* Originator, UMobilePlayerInput* OriginatorInput, UMobileInputZone* OriginatorZone);
};

class USeqEvent_MobileButton : public USeqEvent_MobileZoneBase
{
public:
    //## BEGIN PROPS SeqEvent_MobileButton
    BITFIELD bWasActiveLastFrame:1;
    BITFIELD bSendPressedOnlyOnTouchDown:1;
    BITFIELD bSendPressedOnlyOnTouchUp:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqEvent_MobileButton

    DECLARE_CLASS(USeqEvent_MobileButton,USeqEvent_MobileZoneBase,0,GameFramework)
	/**
	 * Called each frame.  
	 * @param Originator is a reference to the PC that caused the input
	 * @param OriginatorInput is a reference to the mobile player input assoicated with this object
	 * @param OriginatorZone is a reference to the zone that caused this update
	 */
	void UpdateZone(APlayerController* Originator, UMobilePlayerInput* OriginatorInput, UMobileInputZone* OriginatorZone);
};

class USeqEvent_MobileInput : public USeqEvent_MobileZoneBase
{
public:
    //## BEGIN PROPS SeqEvent_MobileInput
    FLOAT XAxisValue;
    FLOAT YAxisValue;
    FLOAT CenterX;
    FLOAT CenterY;
    FLOAT CurrentX;
    FLOAT CurrentY;
    //## END PROPS SeqEvent_MobileInput

    DECLARE_CLASS(USeqEvent_MobileInput,USeqEvent_MobileZoneBase,0,GameFramework)
	/**
	 * Called each frame.  
	 * @param Originator is a reference to the PC that caused the input
	 * @param OriginatorInput is a reference to the mobile player input assoicated with this object
	 * @param OriginatorZone is a reference to the zone that caused this update
	 */
	void UpdateZone(APlayerController* Originator, UMobilePlayerInput* OriginatorInput, UMobileInputZone* OriginatorZone);
};

class USeqEvent_MobileLook : public USeqEvent_MobileZoneBase
{
public:
    //## BEGIN PROPS SeqEvent_MobileLook
    FLOAT Yaw;
    FLOAT StickStrength;
    FVector RotationVector;
    //## END PROPS SeqEvent_MobileLook

    DECLARE_CLASS(USeqEvent_MobileLook,USeqEvent_MobileZoneBase,0,GameFramework)
	/**
	 * Called each frame.  
	 * @param Originator is a reference to the PC that caused the input
	 * @param OriginatorInput is a reference to the mobile player input assoicated with this object
	 * @param OriginatorZone is a reference to the zone that caused this update
	 */
	void UpdateZone(APlayerController* Originator, UMobilePlayerInput* OriginatorInput, UMobileInputZone* OriginatorZone);
};

class USeqEvent_MobileRawInput : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_MobileRawInput
    INT TouchIndex;
    INT TouchpadIndex;
    FLOAT TouchLocationX;
    FLOAT TouchLocationY;
    FLOAT TimeStamp;
    //## END PROPS SeqEvent_MobileRawInput

    DECLARE_CLASS(USeqEvent_MobileRawInput,USequenceEvent,0,GameFramework)
	/**
	 * Handle a touch event coming from the device. 
	 *
	 * @param Originator		is a reference to the PC that caused the input
	 * @param Handle			the id of the touch
	 * @param Type				What type of event is this
	 * @param TouchpadIndex		The touchpad this touch came from
	 * @param TouchLocation		Where the touch occurred
	 * @param DeviceTimestamp	Input event timestamp from the device
	 */
	virtual void InputTouch(APlayerController* Originator, UINT Handle, UINT TouchpadIndex, BYTE Type, FVector2D TouchLocation, DOUBLE DeviceTimestamp);
};

class USeqEvent_MobileObjectPicker : public USeqEvent_MobileRawInput
{
public:
    //## BEGIN PROPS SeqEvent_MobileObjectPicker
    FLOAT TraceDistance;
    BITFIELD bCheckonTouch:1;
    SCRIPT_ALIGN;
    FVector FinalTouchLocation;
    FVector FinalTouchNormal;
    class UObject* FinalTouchObject;
    TArrayNoInit<class UObject*> Targets;
    //## END PROPS SeqEvent_MobileObjectPicker

    DECLARE_CLASS(USeqEvent_MobileObjectPicker,USeqEvent_MobileRawInput,0,GameFramework)
	/**
	 * Handle a touch event coming from the device. 
	 *
	 * @param Originator		is a reference to the PC that caused the input
	 * @param Handle			the id of the touch
	 * @param Type				What type of event is this
	 * @param TouchpadIndex		The touchpad this touch came from
	 * @param TouchLocation		Where the touch occurred
	 * @param DeviceTimestamp	Input event timestamp from the device
	 */
	void InputTouch(APlayerController* Originator, UINT Handle, UINT TouchpadIndex, BYTE Type, FVector2D TouchLocation, DOUBLE DeviceTimestamp);
};

class USeqEvent_MobileSwipe : public USeqEvent_MobileRawInput
{
public:
    //## BEGIN PROPS SeqEvent_MobileSwipe
    FLOAT Tolerance;
    FLOAT MinDistance;
    FVector2D InitialTouch;
    TArrayNoInit<class AActor*> TouchedActors;
    FLOAT TraceDistance;
    //## END PROPS SeqEvent_MobileSwipe

    DECLARE_CLASS(USeqEvent_MobileSwipe,USeqEvent_MobileRawInput,0,GameFramework)
	/**
	 * Handle a touch event coming from the device. 
	 *
	 * @param Originator		is a reference to the PC that caused the input
	 * @param Handle			the id of the touch
	 * @param Type				What type of event is this
	 * @param TouchpadIndex		The touchpad this touch came from
	 * @param TouchLocation		Where the touch occurred
	 * @param DeviceTimestamp	Input event timestamp from the device
	 */
	void InputTouch(APlayerController* Originator, UINT Handle, UINT TouchpadIndex, BYTE Type, FVector2D TouchLocation, DOUBLE DeviceTimestamp);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_GAMEFRAMEWORK_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UGameAICommand,-1,execShouldIgnoreNotifies);
AUTOGENERATE_FUNCTION(AGameAIController,-1,execGetAICommandInStack);
AUTOGENERATE_FUNCTION(AGameAIController,-1,execFindCommandOfClass);
AUTOGENERATE_FUNCTION(AGameAIController,-1,execDumpCommandStack);
AUTOGENERATE_FUNCTION(AGameAIController,-1,execCheckCommandCount);
AUTOGENERATE_FUNCTION(AGameAIController,-1,execGetActiveCommand);
AUTOGENERATE_FUNCTION(AGameAIController,-1,execAbortCommand);
AUTOGENERATE_FUNCTION(AGameAIController,-1,execPopCommand);
AUTOGENERATE_FUNCTION(AGameAIController,-1,execPushCommand);
AUTOGENERATE_FUNCTION(AGameAIController,-1,execAllCommands);
AUTOGENERATE_FUNCTION(AGameCrowdAgent,-1,execNativePostRenderFor);
AUTOGENERATE_FUNCTION(AGameCrowdAgent,-1,execPlayDeath);
AUTOGENERATE_FUNCTION(AGameCrowdAgent,-1,execIsIdle);
AUTOGENERATE_FUNCTION(AGameCrowdAgent,-1,execSetCurrentBehavior);
AUTOGENERATE_FUNCTION(AGameCrowdAgent,-1,execIsPanicked);
AUTOGENERATE_FUNCTION(AGameCrowdAgent,-1,execGetCollisionExtent);
AUTOGENERATE_FUNCTION(AGameCrowdAgentSkeletal,-1,execSetRootMotion);
AUTOGENERATE_FUNCTION(AGameCrowdAgentSkeletal,-1,execPlayDeath);
AUTOGENERATE_FUNCTION(UGameCrowdAgentBehavior,-1,execHandleMovement);
AUTOGENERATE_FUNCTION(UGameCrowdAgentBehavior,-1,execTick);
AUTOGENERATE_FUNCTION(UGameCrowdAgentBehavior,-1,execShouldEndIdle);
AUTOGENERATE_FUNCTION(UGameCrowdAgentBehavior,-1,execTriggerCrowdBehavior);
AUTOGENERATE_FUNCTION(UGameCrowdBehavior_PlayAnimation,-1,execSetSequenceOutput);
AUTOGENERATE_FUNCTION(UGameCrowdBehavior_WaitForGroup,-1,execShouldEndIdle);
AUTOGENERATE_FUNCTION(UGameCrowdBehavior_WaitInQueue,-1,execShouldEndIdle);
AUTOGENERATE_FUNCTION(UGameCrowdBehavior_WaitInQueue,-1,execHandleMovement);
AUTOGENERATE_FUNCTION(AGameCrowdDestination,-1,execReachedByAgent);
AUTOGENERATE_FUNCTION(AGameCrowdDestinationQueuePoint,-1,execQueueReachedBy);
AUTOGENERATE_FUNCTION(AGameCrowdPopulationManager,-1,execWarmup);
AUTOGENERATE_FUNCTION(AGameCrowdPopulationManager,-1,execSpawnAgent);
AUTOGENERATE_FUNCTION(AGameCrowdPopulationManager,-1,execSpawnAgentByIdx);
AUTOGENERATE_FUNCTION(AGameCrowdPopulationManager,-1,execStaticGetPlayerInfo);
AUTOGENERATE_FUNCTION(AGameCrowdPopulationManager,-1,execGetPlayerInfo);
AUTOGENERATE_FUNCTION(AGameCrowdPopulationManager,-1,execUpdateAllSpawners);
AUTOGENERATE_FUNCTION(AGameExplosionActor,-1,execBoxDistanceToPoint);
AUTOGENERATE_FUNCTION(AGamePlayerController,-1,execGetCurrentMovie);
AUTOGENERATE_FUNCTION(AGamePlayerController,-1,execClientStopMovie);
AUTOGENERATE_FUNCTION(AGamePlayerController,-1,execClientPlayMovie);
AUTOGENERATE_FUNCTION(AGamePlayerController,-1,execKeepPlayingLoadingMovie);
AUTOGENERATE_FUNCTION(AGamePlayerController,-1,execShowLoadingMovie);
AUTOGENERATE_FUNCTION(AGamePlayerController,-1,execGetUIPlayerIndex);
AUTOGENERATE_FUNCTION(ADebugCameraController,-1,execConsoleCommand);
AUTOGENERATE_FUNCTION(ADebugCameraController,-1,execUnselect);
AUTOGENERATE_FUNCTION(ADebugCameraController,-1,execSecondarySelect);
AUTOGENERATE_FUNCTION(ADebugCameraController,-1,execPrimarySelect);
AUTOGENERATE_FUNCTION(UMobileInputZone,-1,execDeactivateZone);
AUTOGENERATE_FUNCTION(UMobileInputZone,-1,execActivateZone);
AUTOGENERATE_FUNCTION(UMobileMenuScene,-1,execCleanUpScene);
AUTOGENERATE_FUNCTION(UMobileMenuScene,-1,execGetGlobalScaleY);
AUTOGENERATE_FUNCTION(UMobileMenuScene,-1,execGetGlobalScaleX);
AUTOGENERATE_FUNCTION(UMobilePlayerInput,-1,execProcessWorldTouch);
AUTOGENERATE_FUNCTION(UMobilePlayerInput,-1,execSendInputAxis);
AUTOGENERATE_FUNCTION(UMobilePlayerInput,-1,execSendInputKey);
AUTOGENERATE_FUNCTION(UMobilePlayerInput,-1,execConditionalUpdateInputZones);
AUTOGENERATE_FUNCTION(UMobilePlayerInput,-1,execNativeInitializeInputZones);
AUTOGENERATE_FUNCTION(UMobilePlayerInput,-1,execNativeInitializeInputSystem);
AUTOGENERATE_FUNCTION(UMobilePlayerInput,-1,execCancelMobileInput);
AUTOGENERATE_FUNCTION(UMobilePlayerInput,-1,execProcessMobileInput);
AUTOGENERATE_FUNCTION(UNavMeshGoal_OutOfViewFrom,-1,execRecycleNative);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef GAMEFRAMEWORK_NATIVE_DEFS
#define GAMEFRAMEWORK_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_GAMEFRAMEWORK \
	UDynamicSpriteComponent::StaticClass(); \
	AFrameworkGame::StaticClass(); \
	UGameAICommand::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameAICommand"), GGameFrameworkUGameAICommandNatives); \
	AGameAIController::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameAIController"), GGameFrameworkAGameAIControllerNatives); \
	AGameCameraBlockingVolume::StaticClass(); \
	UGameCheatManager::StaticClass(); \
	AGameCrowdAgent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameCrowdAgent"), GGameFrameworkAGameCrowdAgentNatives); \
	AGameCrowdAgentSkeletal::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameCrowdAgentSkeletal"), GGameFrameworkAGameCrowdAgentSkeletalNatives); \
	AGameCrowdAgentSM::StaticClass(); \
	UGameCrowdAgentBehavior::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameCrowdAgentBehavior"), GGameFrameworkUGameCrowdAgentBehaviorNatives); \
	UGameCrowdBehavior_PlayAnimation::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameCrowdBehavior_PlayAnimation"), GGameFrameworkUGameCrowdBehavior_PlayAnimationNatives); \
	UGameCrowdBehavior_RunFromPanic::StaticClass(); \
	UGameCrowdBehavior_WaitForGroup::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameCrowdBehavior_WaitForGroup"), GGameFrameworkUGameCrowdBehavior_WaitForGroupNatives); \
	UGameCrowdBehavior_WaitInQueue::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameCrowdBehavior_WaitInQueue"), GGameFrameworkUGameCrowdBehavior_WaitInQueueNatives); \
	UGameCrowdGroup::StaticClass(); \
	AGameCrowdInfoVolume::StaticClass(); \
	AGameCrowdInteractionPoint::StaticClass(); \
	AGameCrowdBehaviorPoint::StaticClass(); \
	AGameCrowdDestination::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameCrowdDestination"), GGameFrameworkAGameCrowdDestinationNatives); \
	AGameCrowdDestinationQueuePoint::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameCrowdDestinationQueuePoint"), GGameFrameworkAGameCrowdDestinationQueuePointNatives); \
	AGameCrowdPopulationManager::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameCrowdPopulationManager"), GGameFrameworkAGameCrowdPopulationManagerNatives); \
	AGameCrowdReplicationActor::StaticClass(); \
	AGameCrowdSpawnRelativeActor::StaticClass(); \
	UGameDestinationConnRenderingComponent::StaticClass(); \
	UGameExplosion::StaticClass(); \
	AGameExplosionActor::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameExplosionActor"), GGameFrameworkAGameExplosionActorNatives); \
	AGamePawn::StaticClass(); \
	AGamePlayerController::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GamePlayerController"), GGameFrameworkAGamePlayerControllerNatives); \
	ADebugCameraController::StaticClass(); \
	GNativeLookupFuncs.Set(FName("DebugCameraController"), GGameFrameworkADebugCameraControllerNatives); \
	UGameTypes::StaticClass(); \
	AMobileHUD::StaticClass(); \
	UMobileInputZone::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MobileInputZone"), GGameFrameworkUMobileInputZoneNatives); \
	UMobileMenuObject::StaticClass(); \
	UMobileMenuImage::StaticClass(); \
	UMobileMenuScene::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MobileMenuScene"), GGameFrameworkUMobileMenuSceneNatives); \
	UMobilePlayerInput::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MobilePlayerInput"), GGameFrameworkUMobilePlayerInputNatives); \
	UNavMeshGoal_OutOfViewFrom::StaticClass(); \
	GNativeLookupFuncs.Set(FName("NavMeshGoal_OutOfViewFrom"), GGameFrameworkUNavMeshGoal_OutOfViewFromNatives); \
	UNavMeshPath_BiasAgainstPolysWithinDistanceOfLocations::StaticClass(); \
	USecondaryViewportClient::StaticClass(); \
	UMobileSecondaryViewportClient::StaticClass(); \
	USeqAct_ControlGameMovie::StaticClass(); \
	USeqAct_Deproject::StaticClass(); \
	USeqAct_GameCrowdPopulationManagerToggle::StaticClass(); \
	USeqAct_GameCrowdSpawner::StaticClass(); \
	USeqAct_MobileAddInputZones::StaticClass(); \
	USeqAct_MobileClearInputZones::StaticClass(); \
	USeqAct_MobileRemoveInputZone::StaticClass(); \
	USeqAct_MobileSaveLoadValue::StaticClass(); \
	USeqAct_ModifyProperty::StaticClass(); \
	USeqAct_PlayAgentAnimation::StaticClass(); \
	USeqEvent_CrowdAgentReachedDestination::StaticClass(); \
	USeqEvent_HudRender::StaticClass(); \
	USeqEvent_MobileBase::StaticClass(); \
	USeqEvent_MobileMotion::StaticClass(); \
	USeqEvent_MobileZoneBase::StaticClass(); \
	USeqEvent_MobileButton::StaticClass(); \
	USeqEvent_MobileInput::StaticClass(); \
	USeqEvent_MobileLook::StaticClass(); \
	USeqEvent_MobileRawInput::StaticClass(); \
	USeqEvent_MobileObjectPicker::StaticClass(); \
	USeqEvent_MobileSwipe::StaticClass(); \

#endif // GAMEFRAMEWORK_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GGameFrameworkUGameAICommandNatives[] = 
{ 
	MAP_NATIVE(UGameAICommand, execShouldIgnoreNotifies)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkAGameAIControllerNatives[] = 
{ 
	MAP_NATIVE(AGameAIController, execGetAICommandInStack)
	MAP_NATIVE(AGameAIController, execFindCommandOfClass)
	MAP_NATIVE(AGameAIController, execDumpCommandStack)
	MAP_NATIVE(AGameAIController, execCheckCommandCount)
	MAP_NATIVE(AGameAIController, execGetActiveCommand)
	MAP_NATIVE(AGameAIController, execAbortCommand)
	MAP_NATIVE(AGameAIController, execPopCommand)
	MAP_NATIVE(AGameAIController, execPushCommand)
	MAP_NATIVE(AGameAIController, execAllCommands)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkAGameCrowdAgentNatives[] = 
{ 
	MAP_NATIVE(AGameCrowdAgent, execNativePostRenderFor)
	MAP_NATIVE(AGameCrowdAgent, execPlayDeath)
	MAP_NATIVE(AGameCrowdAgent, execIsIdle)
	MAP_NATIVE(AGameCrowdAgent, execSetCurrentBehavior)
	MAP_NATIVE(AGameCrowdAgent, execIsPanicked)
	MAP_NATIVE(AGameCrowdAgent, execGetCollisionExtent)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkAGameCrowdAgentSkeletalNatives[] = 
{ 
	MAP_NATIVE(AGameCrowdAgentSkeletal, execSetRootMotion)
	MAP_NATIVE(AGameCrowdAgentSkeletal, execPlayDeath)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkUGameCrowdAgentBehaviorNatives[] = 
{ 
	MAP_NATIVE(UGameCrowdAgentBehavior, execHandleMovement)
	MAP_NATIVE(UGameCrowdAgentBehavior, execTick)
	MAP_NATIVE(UGameCrowdAgentBehavior, execShouldEndIdle)
	MAP_NATIVE(UGameCrowdAgentBehavior, execTriggerCrowdBehavior)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkUGameCrowdBehavior_PlayAnimationNatives[] = 
{ 
	MAP_NATIVE(UGameCrowdBehavior_PlayAnimation, execSetSequenceOutput)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkUGameCrowdBehavior_WaitForGroupNatives[] = 
{ 
	MAP_NATIVE(UGameCrowdBehavior_WaitForGroup, execShouldEndIdle)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkUGameCrowdBehavior_WaitInQueueNatives[] = 
{ 
	MAP_NATIVE(UGameCrowdBehavior_WaitInQueue, execShouldEndIdle)
	MAP_NATIVE(UGameCrowdBehavior_WaitInQueue, execHandleMovement)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkAGameCrowdDestinationNatives[] = 
{ 
	MAP_NATIVE(AGameCrowdDestination, execReachedByAgent)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkAGameCrowdDestinationQueuePointNatives[] = 
{ 
	MAP_NATIVE(AGameCrowdDestinationQueuePoint, execQueueReachedBy)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkAGameCrowdPopulationManagerNatives[] = 
{ 
	MAP_NATIVE(AGameCrowdPopulationManager, execWarmup)
	MAP_NATIVE(AGameCrowdPopulationManager, execSpawnAgent)
	MAP_NATIVE(AGameCrowdPopulationManager, execSpawnAgentByIdx)
	MAP_NATIVE(AGameCrowdPopulationManager, execStaticGetPlayerInfo)
	MAP_NATIVE(AGameCrowdPopulationManager, execGetPlayerInfo)
	MAP_NATIVE(AGameCrowdPopulationManager, execUpdateAllSpawners)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkAGameExplosionActorNatives[] = 
{ 
	MAP_NATIVE(AGameExplosionActor, execBoxDistanceToPoint)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkAGamePlayerControllerNatives[] = 
{ 
	MAP_NATIVE(AGamePlayerController, execGetCurrentMovie)
	MAP_NATIVE(AGamePlayerController, execClientStopMovie)
	MAP_NATIVE(AGamePlayerController, execClientPlayMovie)
	MAP_NATIVE(AGamePlayerController, execKeepPlayingLoadingMovie)
	MAP_NATIVE(AGamePlayerController, execShowLoadingMovie)
	MAP_NATIVE(AGamePlayerController, execGetUIPlayerIndex)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkADebugCameraControllerNatives[] = 
{ 
	MAP_NATIVE(ADebugCameraController, execConsoleCommand)
	MAP_NATIVE(ADebugCameraController, execUnselect)
	MAP_NATIVE(ADebugCameraController, execSecondarySelect)
	MAP_NATIVE(ADebugCameraController, execPrimarySelect)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkUMobileInputZoneNatives[] = 
{ 
	MAP_NATIVE(UMobileInputZone, execDeactivateZone)
	MAP_NATIVE(UMobileInputZone, execActivateZone)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkUMobileMenuSceneNatives[] = 
{ 
	MAP_NATIVE(UMobileMenuScene, execCleanUpScene)
	MAP_NATIVE(UMobileMenuScene, execGetGlobalScaleY)
	MAP_NATIVE(UMobileMenuScene, execGetGlobalScaleX)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkUMobilePlayerInputNatives[] = 
{ 
	MAP_NATIVE(UMobilePlayerInput, execProcessWorldTouch)
	MAP_NATIVE(UMobilePlayerInput, execSendInputAxis)
	MAP_NATIVE(UMobilePlayerInput, execSendInputKey)
	MAP_NATIVE(UMobilePlayerInput, execConditionalUpdateInputZones)
	MAP_NATIVE(UMobilePlayerInput, execNativeInitializeInputZones)
	MAP_NATIVE(UMobilePlayerInput, execNativeInitializeInputSystem)
	MAP_NATIVE(UMobilePlayerInput, execCancelMobileInput)
	MAP_NATIVE(UMobilePlayerInput, execProcessMobileInput)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkUNavMeshGoal_OutOfViewFromNatives[] = 
{ 
	MAP_NATIVE(UNavMeshGoal_OutOfViewFrom, execRecycleNative)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UDynamicSpriteComponent,DynamicSpriteComponent,AnimatedScale)
VERIFY_CLASS_OFFSET_NODIE(UDynamicSpriteComponent,DynamicSpriteComponent,LoopCount)
VERIFY_CLASS_SIZE_NODIE(UDynamicSpriteComponent)
VERIFY_CLASS_OFFSET_NODIE(AFrameworkGame,FrameworkGame,RequiredMobileInputConfigs)
VERIFY_CLASS_SIZE_NODIE(AFrameworkGame)
VERIFY_CLASS_OFFSET_NODIE(UGameAICommand,GameAICommand,ChildCommand)
VERIFY_CLASS_OFFSET_NODIE(UGameAICommand,GameAICommand,Status)
VERIFY_CLASS_SIZE_NODIE(UGameAICommand)
VERIFY_CLASS_OFFSET_NODIE(AGameAIController,GameAIController,CommandList)
VERIFY_CLASS_OFFSET_NODIE(AGameAIController,GameAIController,DemoActionString)
VERIFY_CLASS_SIZE_NODIE(AGameAIController)
VERIFY_CLASS_SIZE_NODIE(AGameCameraBlockingVolume)
VERIFY_CLASS_OFFSET_NODIE(UGameCheatManager,GameCheatManager,DebugCameraControllerRef)
VERIFY_CLASS_OFFSET_NODIE(UGameCheatManager,GameCheatManager,DebugCameraControllerClassName)
VERIFY_CLASS_SIZE_NODIE(UGameCheatManager)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdAgent,GameCrowdAgent,MyGroup)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdAgent,GameCrowdAgent,DebugSpawnDest)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdAgent)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdAgentSkeletal,GameCrowdAgentSkeletal,SkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdAgentSkeletal,GameCrowdAgentSkeletal,MaxAnimationDistanceSq)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdAgentSkeletal)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdAgentSM,GameCrowdAgentSM,Mesh)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdAgentSM,GameCrowdAgentSM,MeshColor)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdAgentSM)
VERIFY_CLASS_OFFSET_NODIE(UGameCrowdAgentBehavior,GameCrowdAgentBehavior,MyEventType)
VERIFY_CLASS_OFFSET_NODIE(UGameCrowdAgentBehavior,GameCrowdAgentBehavior,DebugBehaviorColor)
VERIFY_CLASS_SIZE_NODIE(UGameCrowdAgentBehavior)
VERIFY_CLASS_OFFSET_NODIE(UGameCrowdBehavior_PlayAnimation,GameCrowdBehavior_PlayAnimation,AnimationList)
VERIFY_CLASS_OFFSET_NODIE(UGameCrowdBehavior_PlayAnimation,GameCrowdBehavior_PlayAnimation,AnimationIndex)
VERIFY_CLASS_SIZE_NODIE(UGameCrowdBehavior_PlayAnimation)
VERIFY_CLASS_OFFSET_NODIE(UGameCrowdBehavior_RunFromPanic,GameCrowdBehavior_RunFromPanic,PanicFocus)
VERIFY_CLASS_SIZE_NODIE(UGameCrowdBehavior_RunFromPanic)
VERIFY_CLASS_SIZE_NODIE(UGameCrowdBehavior_WaitForGroup)
VERIFY_CLASS_OFFSET_NODIE(UGameCrowdBehavior_WaitInQueue,GameCrowdBehavior_WaitInQueue,QueuePosition)
VERIFY_CLASS_SIZE_NODIE(UGameCrowdBehavior_WaitInQueue)
VERIFY_CLASS_OFFSET_NODIE(UGameCrowdGroup,GameCrowdGroup,Members)
VERIFY_CLASS_SIZE_NODIE(UGameCrowdGroup)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdInfoVolume,GameCrowdInfoVolume,PotentialSpawnPoints)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdInfoVolume)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdInteractionPoint,GameCrowdInteractionPoint,CylinderComponent)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdInteractionPoint)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdBehaviorPoint,GameCrowdBehaviorPoint,RadiusOfBehaviorEvent)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdBehaviorPoint,GameCrowdBehaviorPoint,Initiator)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdBehaviorPoint)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdDestination,GameCrowdDestination,NextDestinations)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdDestination,GameCrowdDestination,MyPopMgr)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdDestination)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdDestinationQueuePoint,GameCrowdDestinationQueuePoint,NextQueuePosition)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdDestinationQueuePoint,GameCrowdDestinationQueuePoint,QueueBehaviorClass)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdDestinationQueuePoint)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdPopulationManager,GameCrowdPopulationManager,CloudSpawnInfo)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdPopulationManager,GameCrowdPopulationManager,LastPlayerInfoUpdateTime)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdPopulationManager)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdReplicationActor,GameCrowdReplicationActor,Spawner)
VERIFY_CLASS_OFFSET_NODIE(AGameCrowdReplicationActor,GameCrowdReplicationActor,DestroyAllCount)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdReplicationActor)
VERIFY_CLASS_SIZE_NODIE(AGameCrowdSpawnRelativeActor)
VERIFY_CLASS_SIZE_NODIE(UGameDestinationConnRenderingComponent)
VERIFY_CLASS_OFFSET_NODIE(UGameExplosion,GameExplosion,DirectionalExplosionAngleDeg)
VERIFY_CLASS_OFFSET_NODIE(UGameExplosion,GameExplosion,CameraLensEffectRadius)
VERIFY_CLASS_SIZE_NODIE(UGameExplosion)
VERIFY_CLASS_OFFSET_NODIE(AGameExplosionActor,GameExplosionActor,ExplosionLight)
VERIFY_CLASS_OFFSET_NODIE(AGameExplosionActor,GameExplosionActor,ExplosionDirection)
VERIFY_CLASS_SIZE_NODIE(AGameExplosionActor)
VERIFY_CLASS_SIZE_NODIE(AGamePawn)
VERIFY_CLASS_OFFSET_NODIE(AGamePlayerController,GamePlayerController,AgentAwareRadius)
VERIFY_CLASS_OFFSET_NODIE(AGamePlayerController,GamePlayerController,CurrentSoundMode)
VERIFY_CLASS_SIZE_NODIE(AGamePlayerController)
VERIFY_CLASS_OFFSET_NODIE(ADebugCameraController,DebugCameraController,PrimaryKey)
VERIFY_CLASS_OFFSET_NODIE(ADebugCameraController,DebugCameraController,SelectedComponent)
VERIFY_CLASS_SIZE_NODIE(ADebugCameraController)
VERIFY_CLASS_SIZE_NODIE(UGameTypes)
VERIFY_CLASS_OFFSET_NODIE(AMobileHUD,MobileHUD,JoystickBackground)
VERIFY_CLASS_OFFSET_NODIE(AMobileHUD,MobileHUD,KismetRenderEvents)
VERIFY_CLASS_SIZE_NODIE(AMobileHUD)
VERIFY_CLASS_OFFSET_NODIE(UMobileInputZone,MobileInputZone,Type)
VERIFY_CLASS_OFFSET_NODIE(UMobileInputZone,MobileInputZone,__OnPostDrawZone__Delegate)
VERIFY_CLASS_SIZE_NODIE(UMobileInputZone)
VERIFY_CLASS_OFFSET_NODIE(UMobileMenuObject,MobileMenuObject,Left)
VERIFY_CLASS_OFFSET_NODIE(UMobileMenuObject,MobileMenuObject,RelativeTo)
VERIFY_CLASS_SIZE_NODIE(UMobileMenuObject)
VERIFY_CLASS_OFFSET_NODIE(UMobileMenuImage,MobileMenuImage,Image)
VERIFY_CLASS_OFFSET_NODIE(UMobileMenuImage,MobileMenuImage,ImageColor)
VERIFY_CLASS_SIZE_NODIE(UMobileMenuImage)
VERIFY_CLASS_OFFSET_NODIE(UMobileMenuScene,MobileMenuScene,MenuName)
VERIFY_CLASS_OFFSET_NODIE(UMobileMenuScene,MobileMenuScene,UIUnTouchSound)
VERIFY_CLASS_SIZE_NODIE(UMobileMenuScene)
VERIFY_CLASS_OFFSET_NODIE(UMobilePlayerInput,MobilePlayerInput,Touches)
VERIFY_CLASS_OFFSET_NODIE(UMobilePlayerInput,MobilePlayerInput,__OnInputTouch__Delegate)
VERIFY_CLASS_SIZE_NODIE(UMobilePlayerInput)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_OutOfViewFrom,NavMeshGoal_OutOfViewFrom,GoalPoly)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_OutOfViewFrom,NavMeshGoal_OutOfViewFrom,OutOfViewLocation)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoal_OutOfViewFrom)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_BiasAgainstPolysWithinDistanceOfLocations,NavMeshPath_BiasAgainstPolysWithinDistanceOfLocations,Location)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_BiasAgainstPolysWithinDistanceOfLocations,NavMeshPath_BiasAgainstPolysWithinDistanceOfLocations,LocationsToCheck)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPath_BiasAgainstPolysWithinDistanceOfLocations)
VERIFY_CLASS_SIZE_NODIE(USecondaryViewportClient)
VERIFY_CLASS_SIZE_NODIE(UMobileSecondaryViewportClient)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ControlGameMovie,SeqAct_ControlGameMovie,MovieName)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ControlGameMovie,SeqAct_ControlGameMovie,EndOfRenderingMovieFrame)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ControlGameMovie)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Deproject,SeqAct_Deproject,ScreenX)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Deproject,SeqAct_Deproject,HitNormal)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Deproject)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GameCrowdPopulationManagerToggle,SeqAct_GameCrowdPopulationManagerToggle,WarmupPopulationPct)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GameCrowdPopulationManagerToggle,SeqAct_GameCrowdPopulationManagerToggle,LastSpawnedList)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GameCrowdPopulationManagerToggle)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GameCrowdSpawner)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_MobileAddInputZones,SeqAct_MobileAddInputZones,ZoneName)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_MobileAddInputZones,SeqAct_MobileAddInputZones,NewZone)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MobileAddInputZones)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MobileClearInputZones)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_MobileRemoveInputZone,SeqAct_MobileRemoveInputZone,ZoneName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MobileRemoveInputZone)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MobileSaveLoadValue)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ModifyProperty,SeqAct_ModifyProperty,Properties)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ModifyProperty)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PlayAgentAnimation,SeqAct_PlayAgentAnimation,AnimationList)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PlayAgentAnimation,SeqAct_PlayAgentAnimation,ActionTarget)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlayAgentAnimation)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_CrowdAgentReachedDestination)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_HudRender,SeqEvent_HudRender,Targets)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_HudRender,SeqEvent_HudRender,AuthoredGlobalScale)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_HudRender)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_MobileBase)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileMotion,SeqEvent_MobileMotion,Roll)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileMotion,SeqEvent_MobileMotion,DeltaYaw)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_MobileMotion)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileZoneBase,SeqEvent_MobileZoneBase,TargetZoneName)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_MobileZoneBase)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_MobileButton)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileInput,SeqEvent_MobileInput,XAxisValue)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileInput,SeqEvent_MobileInput,CurrentY)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_MobileInput)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileLook,SeqEvent_MobileLook,Yaw)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileLook,SeqEvent_MobileLook,RotationVector)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_MobileLook)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileRawInput,SeqEvent_MobileRawInput,TouchIndex)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileRawInput,SeqEvent_MobileRawInput,TimeStamp)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_MobileRawInput)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileObjectPicker,SeqEvent_MobileObjectPicker,TraceDistance)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileObjectPicker,SeqEvent_MobileObjectPicker,Targets)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_MobileObjectPicker)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileSwipe,SeqEvent_MobileSwipe,Tolerance)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_MobileSwipe,SeqEvent_MobileSwipe,TraceDistance)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_MobileSwipe)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
