/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "GameFrameworkNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_GAMEFRAMEWORK_CAMERA_ENUMS
#define INCLUDED_GAMEFRAMEWORK_CAMERA_ENUMS 1

enum ECameraViewportTypes
{
    CVT_16to9_Full          =0,
    CVT_16to9_VertSplit     =1,
    CVT_16to9_HorizSplit    =2,
    CVT_4to3_Full           =3,
    CVT_4to3_HorizSplit     =4,
    CVT_4to3_VertSplit      =5,
    CVT_MAX                 =6,
};
#define FOREACH_ENUM_ECAMERAVIEWPORTTYPES(op) \
    op(CVT_16to9_Full) \
    op(CVT_16to9_VertSplit) \
    op(CVT_16to9_HorizSplit) \
    op(CVT_4to3_Full) \
    op(CVT_4to3_HorizSplit) \
    op(CVT_4to3_VertSplit) 

#endif // !INCLUDED_GAMEFRAMEWORK_CAMERA_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_GAMEFRAMEWORK_CAMERA_CLASSES
#define INCLUDED_GAMEFRAMEWORK_CAMERA_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct GameCameraBase_eventModifyPostProcessSettings_Parms
{
    struct FPostProcessSettings PP;
    GameCameraBase_eventModifyPostProcessSettings_Parms(EEventParm)
    : PP(EC_EventParm)
    {
    }
};
class UGameCameraBase : public UObject
{
public:
    //## BEGIN PROPS GameCameraBase
    class AGamePlayerCamera* PlayerCamera;
    BITFIELD bResetCameraInterpolation:1;
    SCRIPT_ALIGN;
    //## END PROPS GameCameraBase

    void eventModifyPostProcessSettings(struct FPostProcessSettings& PP)
    {
        GameCameraBase_eventModifyPostProcessSettings_Parms Parms(EC_EventParm);
        Parms.PP=PP;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_ModifyPostProcessSettings),&Parms);
        PP=Parms.PP;
    }
    DECLARE_ABSTRACT_CLASS(UGameCameraBase,UObject,0,GameFramework)
    static const TCHAR* StaticConfigName() {return TEXT("Camera");}

    NO_DEFAULT_CONSTRUCTOR(UGameCameraBase)
};

struct FCamFocusPointParams
{
    class AActor* FocusActor;
    FName FocusBoneName;
    FVector FocusWorldLoc;
    FLOAT CameraFOV;
    FVector2D InterpSpeedRange;
    FVector2D InFocusFOV;
    BITFIELD bAlwaysFocus:1;
    BITFIELD bAdjustCamera:1;
    BITFIELD bIgnoreTrace:1;
    FLOAT FocusPitchOffsetDeg;

    /** Constructors */
    FCamFocusPointParams() {}
    FCamFocusPointParams(EEventParm)
    {
        appMemzero(this, sizeof(FCamFocusPointParams));
    }
};

struct FPenetrationAvoidanceFeeler
{
    FRotator AdjustmentRot;
    FLOAT WorldWeight;
    FLOAT PawnWeight;
    FVector Extent;
    INT TraceInterval;
    INT FramesUntilNextTrace;

    /** Constructors */
    FPenetrationAvoidanceFeeler() {}
    FPenetrationAvoidanceFeeler(EEventParm)
    {
        appMemzero(this, sizeof(FPenetrationAvoidanceFeeler));
    }
};

struct GameThirdPersonCamera_eventUpdateFocusPoint_Parms
{
    class APawn* P;
    GameThirdPersonCamera_eventUpdateFocusPoint_Parms(EEventParm)
    {
    }
};
struct GameThirdPersonCamera_eventGetDesiredFOV_Parms
{
    class APawn* ViewedPawn;
    FLOAT ReturnValue;
    GameThirdPersonCamera_eventGetDesiredFOV_Parms(EEventParm)
    {
    }
};
class UGameThirdPersonCamera : public UGameCameraBase
{
public:
    //## BEGIN PROPS GameThirdPersonCamera
    FLOAT WorstLocBlockedPct;
    FLOAT WorstLocPenetrationExtentScale;
    FLOAT PenetrationBlendOutTime;
    FLOAT PenetrationBlendInTime;
    FLOAT PenetrationBlockedPct;
    FLOAT PenetrationExtentScale;
    FVector LastActualOriginOffset;
    FVector LastActualCameraOrigin;
    FRotator LastActualCameraOriginRot;
    FLOAT OriginOffsetInterpSpeed;
    FVector LastViewOffset;
    FLOAT LastCamFOV;
    FVector LastIdealCameraOrigin;
    FRotator LastIdealCameraOriginRot;
    class UGameThirdPersonCameraMode* ThirdPersonCamDefault;
    class UClass* ThirdPersonCamDefaultClass;
    class UGameThirdPersonCameraMode* CurrentCamMode;
    FLOAT LastHeightAdjustment;
    FLOAT LastPitchAdjustment;
    FLOAT LastYawAdjustment;
    FLOAT LeftoverPitchAdjustment;
    FLOAT Focus_BackOffStrength;
    FLOAT Focus_StepHeightAdjustment;
    INT Focus_MaxTries;
    FLOAT Focus_FastAdjustKickInTime;
    FLOAT LastFocusChangeTime;
    FVector ActualFocusPointWorldLoc;
    FVector LastFocusPointLoc;
    struct FCamFocusPointParams FocusPoint;
    BITFIELD bFocusPointSet:1;
    BITFIELD bFocusPointSuccessful:1;
    BITFIELD bDoingACameraTurn:1;
    BITFIELD bTurnAlignTargetWhenFinished:1;
    BITFIELD bDrawDebug:1;
    BITFIELD bDoingDirectLook:1;
    BITFIELD bDebugChangedCameraMode:1;
    BITFIELD bDoSeamlessPivotTransition:1;
    FLOAT TurnCurTime;
    INT TurnStartAngle;
    INT TurnEndAngle;
    FLOAT TurnTotalTime;
    FLOAT TurnDelay;
    INT LastPostCamTurnYaw;
    INT DirectLookYaw;
    FLOAT DirectLookInterpSpeed;
    FLOAT WorstLocInterpSpeed;
    FVector LastWorstLocationLocal;
    FVector LastWorstLocation;
    FVector LastPreModifierCameraLoc;
    FRotator LastPreModifierCameraRot;
    TArrayNoInit<struct FPenetrationAvoidanceFeeler> PenetrationAvoidanceFeelers;
    FVector LastOffsetAdjustment;
    //## END PROPS GameThirdPersonCamera

    virtual void PlayerUpdateCamera(class APawn* P,class AGamePlayerCamera* CameraActor,FLOAT DeltaTime,struct FTViewTarget& OutVT);
    virtual void EndTurn();
    DECLARE_FUNCTION(execPlayerUpdateCamera)
    {
        P_GET_OBJECT(APawn,P);
        P_GET_OBJECT(AGamePlayerCamera,CameraActor);
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(struct FTViewTarget,OutVT);
        P_FINISH;
        this->PlayerUpdateCamera(P,CameraActor,DeltaTime,OutVT);
    }
    DECLARE_FUNCTION(execEndTurn)
    {
        P_FINISH;
        this->EndTurn();
    }
    void eventUpdateFocusPoint(class APawn* P)
    {
        GameThirdPersonCamera_eventUpdateFocusPoint_Parms Parms(EC_EventParm);
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_UpdateFocusPoint),&Parms);
    }
    FLOAT eventGetDesiredFOV(class APawn* ViewedPawn)
    {
        GameThirdPersonCamera_eventGetDesiredFOV_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ViewedPawn=ViewedPawn;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_GetDesiredFOV),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UGameThirdPersonCamera,UGameCameraBase,0,GameFramework)
protected:
	/**
	 * Interpolates from previous location/rotation toward desired location/rotation
	 */
	virtual void InterpolateCameraOrigin( class APawn* TargetPawn, FLOAT DeltaTime, FVector& out_ActualCameraOrigin, FVector const& IdealCameraOrigin, FRotator& out_ActualCameraOriginRot, FRotator const& IdealCameraOriginRot );

	/** Returns the focus location, adjusted to compensate for the third-person camera offset. */
	FVector GetEffectiveFocusLoc(const FVector& CamLoc, const FVector& FocusLoc, const FVector& ViewOffset);
	void AdjustToFocusPointKeepingTargetInView(class APawn* P, FLOAT DeltaTime, FVector& CamLoc, FRotator& CamRot, const FVector& ViewOffset);
	void AdjustToFocusPoint(class APawn* P, FLOAT DeltaTime, FVector& CamLoc, FRotator& CamRot);
	void PreventCameraPenetration(class APawn* P, class AGamePlayerCamera* CameraActor, const FVector& WorstLocation, FVector& DesiredLocation, FLOAT DeltaTime, FLOAT& DistBlockedPct, FLOAT CameraExtentScale, UBOOL bSingleRayOnly=FALSE);
	void UpdateForMovingBase(class AActor* BaseActor);

	/** Returns desired camera origin offset that should be applied AFTER the interpolation, if any. */
	virtual FVector  GetPostInterpCameraOriginLocationOffset(APawn* TargetPawn) const { return FVector::ZeroVector; }
	virtual FRotator GetPostInterpCameraOriginRotationOffset(APawn* TargetPawn) const { return FRotator::ZeroRotator; }

	virtual FMatrix GetWorstCaseLocTransform(APawn* P) const;

	virtual UBOOL ShouldIgnorePenetrationHit(FCheckResult const* Hit, APawn* TargetPawn) const;
	virtual UBOOL ShouldDoPerPolyPenetrationTests(APawn* TargetPawn) const { return FALSE; };
	virtual UBOOL ShouldDoPredictavePenetrationAvoidance(APawn* TargetPawn) const;
	virtual void HandlePawnPenetration(FTViewTarget& OutVT);
	
	virtual UBOOL HandleCameraSafeZone( FVector& CameraOrigin, FRotator& CameraRotation, FLOAT DeltaTime ) { return FALSE; }
public:

};

class AGamePlayerCamera : public ACamera
{
public:
    //## BEGIN PROPS GamePlayerCamera
    class UGameCameraBase* ThirdPersonCam;
    class UClass* ThirdPersonCameraClass;
    class UGameCameraBase* FixedCam;
    class UClass* FixedCameraClass;
    class UGameCameraBase* CurrentCamera;
    BITFIELD bUseForcedCamFOV:1;
    BITFIELD bInterpolateCamChanges:1;
    BITFIELD bResetInterp:1;
    FLOAT ForcedCamFOV;
    class AActor* LastViewTarget;
    FLOAT SplitScreenShakeScale;
    class AActor* LastTargetBase;
    FMatrix LastTargetBaseTM;
    //## END PROPS GamePlayerCamera

    virtual void CacheLastTargetBaseInfo(class AActor* TargetBase);
    FLOAT AdjustFOVForViewport(FLOAT inHorizFOV,class APawn* CameraTargetPawn) const;
    DECLARE_FUNCTION(execCacheLastTargetBaseInfo)
    {
        P_GET_OBJECT(AActor,TargetBase);
        P_FINISH;
        this->CacheLastTargetBaseInfo(TargetBase);
    }
    DECLARE_FUNCTION(execAdjustFOVForViewport)
    {
        P_GET_FLOAT(inHorizFOV);
        P_GET_OBJECT(APawn,CameraTargetPawn);
        P_FINISH;
        *(FLOAT*)Result=this->AdjustFOVForViewport(inHorizFOV,CameraTargetPawn);
    }
    DECLARE_CLASS(AGamePlayerCamera,ACamera,0|CLASS_Transient,GameFramework)
    static const TCHAR* StaticConfigName() {return TEXT("Camera");}

	virtual void AddPawnToHiddenActorsArray( APawn *PawnToHide );
	virtual void RemovePawnFromHiddenActorsArray( APawn *PawnToHide );
	virtual void ModifyPostProcessSettings(FPostProcessSettings& PPSettings) const;
};

struct FViewOffsetData
{
    FVector OffsetHigh;
    FVector OffsetMid;
    FVector OffsetLow;

    /** Constructors */
    FViewOffsetData() {}
    FViewOffsetData(EEventParm)
    {
        appMemzero(this, sizeof(FViewOffsetData));
    }
};

struct GameThirdPersonCameraMode_eventGetCameraWorstCaseLoc_Parms
{
    class APawn* TargetPawn;
    struct FTViewTarget CurrentViewTarget;
    FVector ReturnValue;
    GameThirdPersonCameraMode_eventGetCameraWorstCaseLoc_Parms(EEventParm)
    {
    }
};
struct GameThirdPersonCameraMode_eventAdjustViewOffset_Parms
{
    class APawn* P;
    FVector Offset;
    FVector ReturnValue;
    GameThirdPersonCameraMode_eventAdjustViewOffset_Parms(EEventParm)
    {
    }
};
class UGameThirdPersonCameraMode : public UObject
{
public:
    //## BEGIN PROPS GameThirdPersonCameraMode
    class UGameThirdPersonCamera* ThirdPersonCam;
    FLOAT FOVAngle;
    FLOAT BlendTime;
    BITFIELD bLockedToViewTarget:1;
    BITFIELD bDirectLook:1;
    BITFIELD bFollowTarget:1;
    BITFIELD bInterpLocation:1;
    BITFIELD bUsePerAxisOriginLocInterp:1;
    BITFIELD bInterpRotation:1;
    BITFIELD bRotInterpSpeedConstant:1;
    BITFIELD bDoPredictiveAvoidance:1;
    BITFIELD bValidateWorstLoc:1;
    BITFIELD bSkipCameraCollision:1;
    BITFIELD bSmoothViewOffsetPitchChanges:1;
    BITFIELD bApplyDeltaViewOffset:1;
    BITFIELD bAdjustDOF:1;
    BITFIELD bDOFUpdated:1;
    BITFIELD bNoFOVPostProcess:1;
    BITFIELD bInterpViewOffsetOnlyForCamTransition:1;
    FLOAT FollowingInterpSpeed_Pitch;
    FLOAT FollowingInterpSpeed_Yaw;
    FLOAT FollowingInterpSpeed_Roll;
    FLOAT FollowingCameraVelThreshold;
    FLOAT OriginLocInterpSpeed;
    FVector PerAxisOriginLocInterpSpeed;
    FLOAT OriginRotInterpSpeed;
    FVector StrafeLeftAdjustment;
    FVector StrafeRightAdjustment;
    FLOAT StrafeOffsetScalingThreshold;
    FLOAT StrafeOffsetInterpSpeedIn;
    FLOAT StrafeOffsetInterpSpeedOut;
    FVector LastStrafeOffset;
    FVector RunFwdAdjustment;
    FVector RunBackAdjustment;
    FLOAT RunOffsetScalingThreshold;
    FLOAT RunOffsetInterpSpeedIn;
    FLOAT RunOffsetInterpSpeedOut;
    FVector LastRunOffset;
    FVector WorstLocOffset;
    FVector TargetRelativeCameraOriginOffset;
    struct FViewOffsetData ViewOffset;
    struct FViewOffsetData ViewOffset_ViewportAdjustments[6];
    FLOAT DOF_FalloffExponent;
    FLOAT DOF_BlurKernelSize;
    FLOAT DOF_FocusInnerRadius;
    FLOAT DOF_MaxNearBlurAmount;
    FLOAT DOF_MaxFarBlurAmount;
    FLOAT LastDOFRadius;
    FLOAT LastDOFDistance;
    FLOAT DOFDistanceInterpSpeed;
    FVector DOFTraceExtent;
    FLOAT DOF_RadiusFalloff;
    FVector2D DOF_RadiusRange;
    FVector2D DOF_RadiusDistRange;
    FLOAT ViewOffsetInterp;
    FLOAT OffsetAdjustmentInterpSpeed;
    BYTE CurrentViewportType;
    SCRIPT_ALIGN;
    //## END PROPS GameThirdPersonCameraMode

    void SetViewOffset(const struct FViewOffsetData& NewViewOffset);
    DECLARE_FUNCTION(execSetViewOffset)
    {
        P_GET_STRUCT_REF(struct FViewOffsetData,NewViewOffset);
        P_FINISH;
        this->SetViewOffset(NewViewOffset);
    }
    FVector eventGetCameraWorstCaseLoc(class APawn* TargetPawn,struct FTViewTarget CurrentViewTarget)
    {
        GameThirdPersonCameraMode_eventGetCameraWorstCaseLoc_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.TargetPawn=TargetPawn;
        Parms.CurrentViewTarget=CurrentViewTarget;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_GetCameraWorstCaseLoc),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventAdjustViewOffset(class APawn* P,FVector Offset)
    {
        GameThirdPersonCameraMode_eventAdjustViewOffset_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.P=P;
        Parms.Offset=Offset;
        ProcessEvent(FindFunctionChecked(GAMEFRAMEWORK_AdjustViewOffset),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UGameThirdPersonCameraMode,UObject,0|CLASS_Config,GameFramework)
    static const TCHAR* StaticConfigName() {return TEXT("Camera");}

	// GearThirdPersonCameraMode interface

	/**
	 * Calculates and returns the ideal view offset for the specified camera mode.
	 * The offset is relative to the Camera's pos/rot and calculated by interpolating
	 * 2 ideal view points based on the player view pitch.
	 *
	 * @param	ViewedPawn			Camera target pawn
	 * @param	DeltaTime			Delta time since last frame.
	 * @param	ViewRotation		Rot of the camera
	 */
	virtual FVector GetViewOffset(class APawn* ViewedPawn, FLOAT DeltaTime, const FVector& ViewOrigin, const FRotator& ViewRotation);
	FLOAT GetViewOffsetInterpSpeed(class APawn* ViewedPawn, FLOAT DeltaTime);
	virtual FRotator GetViewOffsetRotBase( class APawn* ViewedPawn, const FTViewTarget& VT );

	/** Returns View relative offsets */
	virtual void GetBaseViewOffsets(class APawn* ViewedPawn, BYTE ViewportConfig, FLOAT DeltaTime, FVector& out_Low, FVector& out_Mid, FVector& out_High);

	/** Returns true if mode should be using direct-look mode, false otherwise */
	virtual UBOOL UseDirectLookMode(class APawn* CameraTarget);

	/** Returns true if mode should lock camera to view target, false otherwise */
	virtual UBOOL LockedToViewTarget(class APawn* CameraTarget);

	/**
	 * Returns true if this mode should do target following.  If true is returned, interp speeds are filled in.
	 * If false is returned, interp speeds are not altered.
	 */
	virtual UBOOL ShouldFollowTarget(class APawn* CameraTarget, FLOAT& PitchInterpSpeed, FLOAT& YawInterpSpeed, FLOAT& RollInterpSpeed);

	/** Returns an offset, in pawn-local space, to be applied to the camera origin. */
	virtual FVector GetTargetRelativeOriginOffset(class APawn* TargetPawn);

	/**
	 * Returns location and rotation, in world space, of the camera's basis point.  The camera will rotate
	 * around this point, offsets are applied from here, etc.
	 */
	virtual void GetCameraOrigin(class APawn* TargetPawn, FVector& OriginLoc, FRotator& OriginRot);

	/**
	 * Interpolates from previous location/rotation toward desired location/rotation
	 */
	virtual void InterpolateCameraOrigin( class APawn* TargetPawn, FLOAT DeltaTime, FVector& out_ActualCameraOrigin, FVector const& IdealCameraOrigin, FRotator& out_ActualCameraOriginRot, FRotator const& IdealCameraOriginRot );

	/** Returns time to interpolate location/rotation changes. */
	virtual FLOAT GetBlendTime(class APawn* Pawn);

	/** Returns time to interpolate FOV changes. */
	virtual FLOAT GetFOVBlendTime(class APawn* Pawn);

	/*
	 *   Interpolates a camera's origin from the last location to a new ideal location
	 *   @CameraTargetRot - Rotation of the camera target, used to create a reference frame for interpolation
	 *   @LastLoc - Last location of the camera
	 *   @IdealLoc - Ideal location for the camera this frame
	 *   @DeltaTime - time step
	 *   @return if bInterpLocation is false, returns IdealLoc, otherwise if bUsePerAxisOriginLocInterp is TRUE it interpolates relative to the target axis via PerAxisOriginLocInterpSpeed, else via constant OriginLocInterpSpeed
	 */
	virtual FVector InterpolateCameraOriginLoc(class APawn* TargetPawn, FRotator const& CameraTargetRot, FVector const& LastLoc, FVector const& IdealLoc, FLOAT DeltaTime);
	virtual FRotator InterpolateCameraOriginRot(class APawn* TargetPawn, FRotator const& LastRot, FRotator const& IdealRot, FLOAT DeltaTime);

	virtual FVector	ApplyViewOffset( class APawn* ViewedPawn, const FVector& CameraOrigin, const FVector& ActualViewOffset, const FVector& DeltaViewOffset, const FTViewTarget& OutVT );

protected:
	virtual FLOAT GetViewPitch(APawn* TargetPawn, FRotator const& ViewRotation) const;
public:
};

class UGameThirdPersonCameraMode_Default : public UGameThirdPersonCameraMode
{
public:
    //## BEGIN PROPS GameThirdPersonCameraMode_Default
    FLOAT WorstLocAimingZOffset;
    BITFIELD bTemporaryOriginRotInterp:1;
    FLOAT TemporaryOriginRotInterpSpeed;
    //## END PROPS GameThirdPersonCameraMode_Default

    DECLARE_CLASS(UGameThirdPersonCameraMode_Default,UGameThirdPersonCameraMode,0|CLASS_Config,GameFramework)
	/**
	 * Returns location and rotation, in world space, of the camera's basis point.  The camera will rotate
	 * around this point, offsets are applied from here, etc.
	 */
	virtual void GetCameraOrigin(class APawn* TargetPawn, FVector& OriginLoc, FRotator& OriginRot);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_GAMEFRAMEWORK_CAMERA_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UGameThirdPersonCamera,-1,execEndTurn);
AUTOGENERATE_FUNCTION(UGameThirdPersonCamera,-1,execPlayerUpdateCamera);
AUTOGENERATE_FUNCTION(AGamePlayerCamera,-1,execAdjustFOVForViewport);
AUTOGENERATE_FUNCTION(AGamePlayerCamera,-1,execCacheLastTargetBaseInfo);
AUTOGENERATE_FUNCTION(UGameThirdPersonCameraMode,-1,execSetViewOffset);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef GAMEFRAMEWORK_CAMERA_NATIVE_DEFS
#define GAMEFRAMEWORK_CAMERA_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_GAMEFRAMEWORK_CAMERA \
	UGameCameraBase::StaticClass(); \
	UGameThirdPersonCamera::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameThirdPersonCamera"), GGameFrameworkUGameThirdPersonCameraNatives); \
	AGamePlayerCamera::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GamePlayerCamera"), GGameFrameworkAGamePlayerCameraNatives); \
	UGameThirdPersonCameraMode::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameThirdPersonCameraMode"), GGameFrameworkUGameThirdPersonCameraModeNatives); \
	UGameThirdPersonCameraMode_Default::StaticClass(); \

#endif // GAMEFRAMEWORK_CAMERA_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GGameFrameworkUGameThirdPersonCameraNatives[] = 
{ 
	MAP_NATIVE(UGameThirdPersonCamera, execEndTurn)
	MAP_NATIVE(UGameThirdPersonCamera, execPlayerUpdateCamera)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkAGamePlayerCameraNatives[] = 
{ 
	MAP_NATIVE(AGamePlayerCamera, execAdjustFOVForViewport)
	MAP_NATIVE(AGamePlayerCamera, execCacheLastTargetBaseInfo)
	{NULL, NULL}
};

FNativeFunctionLookup GGameFrameworkUGameThirdPersonCameraModeNatives[] = 
{ 
	MAP_NATIVE(UGameThirdPersonCameraMode, execSetViewOffset)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UGameCameraBase,GameCameraBase,PlayerCamera)
VERIFY_CLASS_SIZE_NODIE(UGameCameraBase)
VERIFY_CLASS_OFFSET_NODIE(UGameThirdPersonCamera,GameThirdPersonCamera,WorstLocBlockedPct)
VERIFY_CLASS_OFFSET_NODIE(UGameThirdPersonCamera,GameThirdPersonCamera,LastOffsetAdjustment)
VERIFY_CLASS_SIZE_NODIE(UGameThirdPersonCamera)
VERIFY_CLASS_OFFSET_NODIE(AGamePlayerCamera,GamePlayerCamera,ThirdPersonCam)
VERIFY_CLASS_OFFSET_NODIE(AGamePlayerCamera,GamePlayerCamera,LastTargetBaseTM)
VERIFY_CLASS_SIZE_NODIE(AGamePlayerCamera)
VERIFY_CLASS_OFFSET_NODIE(UGameThirdPersonCameraMode,GameThirdPersonCameraMode,ThirdPersonCam)
VERIFY_CLASS_OFFSET_NODIE(UGameThirdPersonCameraMode,GameThirdPersonCameraMode,CurrentViewportType)
VERIFY_CLASS_SIZE_NODIE(UGameThirdPersonCameraMode)
VERIFY_CLASS_OFFSET_NODIE(UGameThirdPersonCameraMode_Default,GameThirdPersonCameraMode_Default,WorstLocAimingZOffset)
VERIFY_CLASS_OFFSET_NODIE(UGameThirdPersonCameraMode_Default,GameThirdPersonCameraMode_Default,TemporaryOriginRotInterpSpeed)
VERIFY_CLASS_SIZE_NODIE(UGameThirdPersonCameraMode_Default)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
