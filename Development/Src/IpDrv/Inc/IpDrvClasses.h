/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "IpDrvNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_IPDRV_ENUMS
#define INCLUDED_IPDRV_ENUMS 1

enum EReceiveMode
{
    RMODE_Manual            =0,
    RMODE_Event             =1,
    RMODE_MAX               =2,
};
#define FOREACH_ENUM_ERECEIVEMODE(op) \
    op(RMODE_Manual) \
    op(RMODE_Event) 
enum ELineMode
{
    LMODE_auto              =0,
    LMODE_DOS               =1,
    LMODE_UNIX              =2,
    LMODE_MAC               =3,
    LMODE_MAX               =4,
};
#define FOREACH_ENUM_ELINEMODE(op) \
    op(LMODE_auto) \
    op(LMODE_DOS) \
    op(LMODE_UNIX) \
    op(LMODE_MAC) 
enum ELinkMode
{
    MODE_Text               =0,
    MODE_Line               =1,
    MODE_Binary             =2,
    MODE_MAX                =3,
};
#define FOREACH_ENUM_ELINKMODE(op) \
    op(MODE_Text) \
    op(MODE_Line) \
    op(MODE_Binary) 
enum ELinkState
{
    STATE_Initialized       =0,
    STATE_Ready             =1,
    STATE_Listening         =2,
    STATE_Connecting        =3,
    STATE_Connected         =4,
    STATE_ListenClosePending=5,
    STATE_ConnectClosePending=6,
    STATE_ListenClosing     =7,
    STATE_ConnectClosing    =8,
    STATE_MAX               =9,
};
#define FOREACH_ENUM_ELINKSTATE(op) \
    op(STATE_Initialized) \
    op(STATE_Ready) \
    op(STATE_Listening) \
    op(STATE_Connecting) \
    op(STATE_Connected) \
    op(STATE_ListenClosePending) \
    op(STATE_ConnectClosePending) \
    op(STATE_ListenClosing) \
    op(STATE_ConnectClosing) 
enum EEventUploadType
{
    EUT_GenericStats        =0,
    EUT_ProfileData         =1,
    EUT_MatchmakingData     =2,
    EUT_PlaylistPopulation  =3,
    EUT_MAX                 =4,
};
#define FOREACH_ENUM_EEVENTUPLOADTYPE(op) \
    op(EUT_GenericStats) \
    op(EUT_ProfileData) \
    op(EUT_MatchmakingData) \
    op(EUT_PlaylistPopulation) 
enum EMcpFileCompressionType
{
    MFCT_NONE               =0,
    MFCT_ZLIB               =1,
    MFCT_MAX                =2,
};
#define FOREACH_ENUM_EMCPFILECOMPRESSIONTYPE(op) \
    op(MFCT_NONE) \
    op(MFCT_ZLIB) 
enum ETitleFileFileOp
{
    TitleFile_None          =0,
    TitleFile_Save          =1,
    TitleFile_Load          =2,
    TitleFile_MAX           =3,
};
#define FOREACH_ENUM_ETITLEFILEFILEOP(op) \
    op(TitleFile_None) \
    op(TitleFile_Save) \
    op(TitleFile_Load) 
enum EMcpMessageCompressionType
{
    MMCT_NONE               =0,
    MMCT_LZO                =1,
    MMCT_ZLIB               =2,
    MMCT_MAX                =3,
};
#define FOREACH_ENUM_EMCPMESSAGECOMPRESSIONTYPE(op) \
    op(MMCT_NONE) \
    op(MMCT_LZO) \
    op(MMCT_ZLIB) 
enum EMeshBeaconBandwidthTestType
{
    MB_BandwidthTestType_Upstream=0,
    MB_BandwidthTestType_Downstream=1,
    MB_BandwidthTestType_RoundtripLatency=2,
    MB_BandwidthTestType_MAX=3,
};
#define FOREACH_ENUM_EMESHBEACONBANDWIDTHTESTTYPE(op) \
    op(MB_BandwidthTestType_Upstream) \
    op(MB_BandwidthTestType_Downstream) \
    op(MB_BandwidthTestType_RoundtripLatency) 
enum EMeshBeaconBandwidthTestResult
{
    MB_BandwidthTestResult_Succeeded=0,
    MB_BandwidthTestResult_Timeout=1,
    MB_BandwidthTestResult_Error=2,
    MB_BandwidthTestResult_MAX=3,
};
#define FOREACH_ENUM_EMESHBEACONBANDWIDTHTESTRESULT(op) \
    op(MB_BandwidthTestResult_Succeeded) \
    op(MB_BandwidthTestResult_Timeout) \
    op(MB_BandwidthTestResult_Error) 
enum EMeshBeaconBandwidthTestState
{
    MB_BandwidthTestState_NotStarted=0,
    MB_BandwidthTestState_RequestPending=1,
    MB_BandwidthTestState_StartPending=2,
    MB_BandwidthTestState_InProgress=3,
    MB_BandwidthTestState_Completed=4,
    MB_BandwidthTestState_Incomplete=5,
    MB_BandwidthTestState_Timeout=6,
    MB_BandwidthTestState_Error=7,
    MB_BandwidthTestState_MAX=8,
};
#define FOREACH_ENUM_EMESHBEACONBANDWIDTHTESTSTATE(op) \
    op(MB_BandwidthTestState_NotStarted) \
    op(MB_BandwidthTestState_RequestPending) \
    op(MB_BandwidthTestState_StartPending) \
    op(MB_BandwidthTestState_InProgress) \
    op(MB_BandwidthTestState_Completed) \
    op(MB_BandwidthTestState_Incomplete) \
    op(MB_BandwidthTestState_Timeout) \
    op(MB_BandwidthTestState_Error) 
enum EMeshBeaconConnectionResult
{
    MB_ConnectionResult_Succeeded=0,
    MB_ConnectionResult_Duplicate=1,
    MB_ConnectionResult_Timeout=2,
    MB_ConnectionResult_Error=3,
    MB_ConnectionResult_MAX =4,
};
#define FOREACH_ENUM_EMESHBEACONCONNECTIONRESULT(op) \
    op(MB_ConnectionResult_Succeeded) \
    op(MB_ConnectionResult_Duplicate) \
    op(MB_ConnectionResult_Timeout) \
    op(MB_ConnectionResult_Error) 
enum EMeshBeaconPacketType
{
    MB_Packet_UnknownType   =0,
    MB_Packet_ClientNewConnectionRequest=1,
    MB_Packet_ClientBeginBandwidthTest=2,
    MB_Packet_ClientCreateNewSessionResponse=3,
    MB_Packet_HostNewConnectionResponse=4,
    MB_Packet_HostBandwidthTestRequest=5,
    MB_Packet_HostCompletedBandwidthTest=6,
    MB_Packet_HostTravelRequest=7,
    MB_Packet_HostCreateNewSessionRequest=8,
    MB_Packet_DummyData     =9,
    MB_Packet_Heartbeat     =10,
    MB_Packet_MAX           =11,
};
#define FOREACH_ENUM_EMESHBEACONPACKETTYPE(op) \
    op(MB_Packet_UnknownType) \
    op(MB_Packet_ClientNewConnectionRequest) \
    op(MB_Packet_ClientBeginBandwidthTest) \
    op(MB_Packet_ClientCreateNewSessionResponse) \
    op(MB_Packet_HostNewConnectionResponse) \
    op(MB_Packet_HostBandwidthTestRequest) \
    op(MB_Packet_HostCompletedBandwidthTest) \
    op(MB_Packet_HostTravelRequest) \
    op(MB_Packet_HostCreateNewSessionRequest) \
    op(MB_Packet_DummyData) \
    op(MB_Packet_Heartbeat) 
enum EMeshBeaconClientState
{
    MBCS_None               =0,
    MBCS_Connecting         =1,
    MBCS_Connected          =2,
    MBCS_ConnectionFailed   =3,
    MBCS_AwaitingResponse   =4,
    MBCS_Closed             =5,
    MBCS_MAX                =6,
};
#define FOREACH_ENUM_EMESHBEACONCLIENTSTATE(op) \
    op(MBCS_None) \
    op(MBCS_Connecting) \
    op(MBCS_Connected) \
    op(MBCS_ConnectionFailed) \
    op(MBCS_AwaitingResponse) \
    op(MBCS_Closed) 
enum EPartyReservationResult
{
    PRR_GeneralError        =0,
    PRR_PartyLimitReached   =1,
    PRR_IncorrectPlayerCount=2,
    PRR_RequestTimedOut     =3,
    PRR_ReservationDuplicate=4,
    PRR_ReservationNotFound =5,
    PRR_ReservationAccepted =6,
    PRR_ReservationDenied   =7,
    PRR_MAX                 =8,
};
#define FOREACH_ENUM_EPARTYRESERVATIONRESULT(op) \
    op(PRR_GeneralError) \
    op(PRR_PartyLimitReached) \
    op(PRR_IncorrectPlayerCount) \
    op(PRR_RequestTimedOut) \
    op(PRR_ReservationDuplicate) \
    op(PRR_ReservationNotFound) \
    op(PRR_ReservationAccepted) \
    op(PRR_ReservationDenied) 
enum EReservationPacketType
{
    RPT_UnknownPacketType   =0,
    RPT_ClientReservationRequest=1,
    RPT_ClientReservationUpdateRequest=2,
    RPT_ClientCancellationRequest=3,
    RPT_HostReservationResponse=4,
    RPT_HostReservationCountUpdate=5,
    RPT_HostTravelRequest   =6,
    RPT_HostIsReady         =7,
    RPT_HostHasCancelled    =8,
    RPT_Heartbeat           =9,
    RPT_MAX                 =10,
};
#define FOREACH_ENUM_ERESERVATIONPACKETTYPE(op) \
    op(RPT_UnknownPacketType) \
    op(RPT_ClientReservationRequest) \
    op(RPT_ClientReservationUpdateRequest) \
    op(RPT_ClientCancellationRequest) \
    op(RPT_HostReservationResponse) \
    op(RPT_HostReservationCountUpdate) \
    op(RPT_HostTravelRequest) \
    op(RPT_HostIsReady) \
    op(RPT_HostHasCancelled) \
    op(RPT_Heartbeat) 
enum EPartyBeaconClientRequest
{
    PBClientRequest_NewReservation=0,
    PBClientRequest_UpdateReservation=1,
    PBClientRequest_MAX     =2,
};
#define FOREACH_ENUM_EPARTYBEACONCLIENTREQUEST(op) \
    op(PBClientRequest_NewReservation) \
    op(PBClientRequest_UpdateReservation) 
enum EPartyBeaconClientState
{
    PBCS_None               =0,
    PBCS_Connecting         =1,
    PBCS_Connected          =2,
    PBCS_ConnectionFailed   =3,
    PBCS_AwaitingResponse   =4,
    PBCS_Closed             =5,
    PBCS_MAX                =6,
};
#define FOREACH_ENUM_EPARTYBEACONCLIENTSTATE(op) \
    op(PBCS_None) \
    op(PBCS_Connecting) \
    op(PBCS_Connected) \
    op(PBCS_ConnectionFailed) \
    op(PBCS_AwaitingResponse) \
    op(PBCS_Closed) 
enum EPartyBeaconHostState
{
    PBHS_AllowReservations  =0,
    PBHS_DenyReservations   =1,
    PBHS_MAX                =2,
};
#define FOREACH_ENUM_EPARTYBEACONHOSTSTATE(op) \
    op(PBHS_AllowReservations) \
    op(PBHS_DenyReservations) 
enum ERequestType
{
    Request_GET             =0,
    Request_POST            =1,
    Request_MAX             =2,
};
#define FOREACH_ENUM_EREQUESTTYPE(op) \
    op(Request_GET) \
    op(Request_POST) 

#endif // !INCLUDED_IPDRV_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_IPDRV_CLASSES
#define INCLUDED_IPDRV_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UClientBeaconAddressResolver : public UObject
{
public:
    //## BEGIN PROPS ClientBeaconAddressResolver
    INT BeaconPort;
    FName BeaconName;
    //## END PROPS ClientBeaconAddressResolver

    DECLARE_CLASS(UClientBeaconAddressResolver,UObject,0,IpDrv)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/**
	 * Performs platform specific resolution of the address
	 *
	 * @param DesiredHost the host to resolve the IP address for
	 * @param Addr out param having it's address set
	 *
	 * @return true if the address could be resolved, false otherwise
	 */
	virtual UBOOL ResolveAddress(const FOnlineGameSearchResult& DesiredHost,FInternetIpAddr& Addr);

	/**
	 * Allows for per platform registration of secure keys, so that a secure connection
	 * can be opened and used for sending/receiving data.
	 *
	 * @param DesiredHost the host that is being registered
	 */
	virtual UBOOL RegisterAddress(const FOnlineGameSearchResult& DesiredHost)
	{
		return TRUE;
	}

	/**
	 * Allows for per platform unregistration of secure keys, which breaks the link between
	 * a client and server. This also releases any memory associated with the keys.
	 *
	 * @param DesiredHost the host that is being registered
	 */
	virtual UBOOL UnregisterAddress(const FOnlineGameSearchResult& DesiredHost)
	{
		return TRUE;
	}
};

struct InternetLink_eventResolveFailed_Parms
{
    InternetLink_eventResolveFailed_Parms(EEventParm)
    {
    }
};
struct InternetLink_eventResolved_Parms
{
    FIpAddr Addr;
    InternetLink_eventResolved_Parms(EEventParm)
    {
    }
};
class AInternetLink : public AInfo
{
public:
    //## BEGIN PROPS InternetLink
    BYTE LinkMode;
    BYTE InLineMode;
    BYTE OutLineMode;
    BYTE ReceiveMode;
    SCRIPT_ALIGN;
    FSocket* Socket;
    INT Port;
    FSocket* RemoteSocket;
    FPointer PrivateResolveInfo;
    INT DataPending;
    //## END PROPS InternetLink

    virtual UBOOL IsDataPending();
    virtual UBOOL ParseURL(const FString& URL,FString& Addr,INT& PortNum,FString& LevelName,FString& EntryName);
    virtual void Resolve(const FString& Domain);
    virtual INT GetLastError();
    virtual FString IpAddrToString(FIpAddr Arg);
    virtual UBOOL StringToIpAddr(const FString& Str,FIpAddr& Addr);
    virtual void GetLocalIP(FIpAddr& Arg);
    DECLARE_FUNCTION(execIsDataPending)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsDataPending();
    }
    DECLARE_FUNCTION(execParseURL)
    {
        P_GET_STR(URL);
        P_GET_STR_REF(Addr);
        P_GET_INT_REF(PortNum);
        P_GET_STR_REF(LevelName);
        P_GET_STR_REF(EntryName);
        P_FINISH;
        *(UBOOL*)Result=this->ParseURL(URL,Addr,PortNum,LevelName,EntryName);
    }
    DECLARE_FUNCTION(execResolve)
    {
        P_GET_STR(Domain);
        P_FINISH;
        this->Resolve(Domain);
    }
    DECLARE_FUNCTION(execGetLastError)
    {
        P_FINISH;
        *(INT*)Result=this->GetLastError();
    }
    DECLARE_FUNCTION(execIpAddrToString)
    {
        P_GET_STRUCT(FIpAddr,Arg);
        P_FINISH;
        *(FString*)Result=this->IpAddrToString(Arg);
    }
    DECLARE_FUNCTION(execStringToIpAddr)
    {
        P_GET_STR(Str);
        P_GET_STRUCT_REF(FIpAddr,Addr);
        P_FINISH;
        *(UBOOL*)Result=this->StringToIpAddr(Str,Addr);
    }
    DECLARE_FUNCTION(execGetLocalIP)
    {
        P_GET_STRUCT_REF(FIpAddr,Arg);
        P_FINISH;
        this->GetLocalIP(Arg);
    }
    void eventResolveFailed()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_ResolveFailed),NULL);
    }
    void eventResolved(FIpAddr Addr)
    {
        InternetLink_eventResolved_Parms Parms(EC_EventParm);
        Parms.Addr=Addr;
        ProcessEvent(FindFunctionChecked(IPDRV_Resolved),&Parms);
    }
    DECLARE_CLASS(AInternetLink,AInfo,0|CLASS_Transient,IpDrv)
	AInternetLink();
	void BeginDestroy();
	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );	
	FSocket* GetSocket() 
	{ 
		return Socket;
	}
	FSocket* GetRemoteSocket() 
	{ 
		return RemoteSocket;
	}
	FResolveInfo*& GetResolveInfo()
	{
		return *(FResolveInfo**)&PrivateResolveInfo;
	}
};

struct TcpLink_eventReceivedBinary_Parms
{
    INT Count;
    BYTE B[255];
    TcpLink_eventReceivedBinary_Parms(EEventParm)
    {
    }
};
struct TcpLink_eventReceivedLine_Parms
{
    FString Line;
    TcpLink_eventReceivedLine_Parms(EEventParm)
    {
    }
};
struct TcpLink_eventReceivedText_Parms
{
    FString Text;
    TcpLink_eventReceivedText_Parms(EEventParm)
    {
    }
};
struct TcpLink_eventClosed_Parms
{
    TcpLink_eventClosed_Parms(EEventParm)
    {
    }
};
struct TcpLink_eventOpened_Parms
{
    TcpLink_eventOpened_Parms(EEventParm)
    {
    }
};
struct TcpLink_eventAccepted_Parms
{
    TcpLink_eventAccepted_Parms(EEventParm)
    {
    }
};
class ATcpLink : public AInternetLink
{
public:
    //## BEGIN PROPS TcpLink
    BYTE LinkState;
    SCRIPT_ALIGN;
    FIpAddr RemoteAddr;
    class UClass* AcceptClass;
    TArrayNoInit<BYTE> SendFIFO;
    FStringNoInit RecvBuf;
    //## END PROPS TcpLink

    virtual INT BindPort(INT PortNum=0,UBOOL bUseNextAvailable=FALSE);
    virtual UBOOL Listen();
    virtual UBOOL Open(FIpAddr Addr);
    virtual UBOOL Close();
    virtual UBOOL IsConnected();
    virtual INT SendText(const FString& Str);
    virtual INT SendBinary(INT Count,BYTE* B);
    virtual INT ReadText(FString& Str);
    virtual INT ReadBinary(INT Count,BYTE* B);
    DECLARE_FUNCTION(execBindPort)
    {
        P_GET_INT_OPTX(PortNum,0);
        P_GET_UBOOL_OPTX(bUseNextAvailable,FALSE);
        P_FINISH;
        *(INT*)Result=this->BindPort(PortNum,bUseNextAvailable);
    }
    DECLARE_FUNCTION(execListen)
    {
        P_FINISH;
        *(UBOOL*)Result=this->Listen();
    }
    DECLARE_FUNCTION(execOpen)
    {
        P_GET_STRUCT(FIpAddr,Addr);
        P_FINISH;
        *(UBOOL*)Result=this->Open(Addr);
    }
    DECLARE_FUNCTION(execClose)
    {
        P_FINISH;
        *(UBOOL*)Result=this->Close();
    }
    DECLARE_FUNCTION(execIsConnected)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsConnected();
    }
    DECLARE_FUNCTION(execSendText)
    {
        P_GET_STR(Str);
        P_FINISH;
        *(INT*)Result=this->SendText(Str);
    }
    DECLARE_FUNCTION(execSendBinary)
    {
        P_GET_INT(Count);
        P_GET_ARRAY(BYTE,B);
        P_FINISH;
        *(INT*)Result=this->SendBinary(Count,B);
    }
    DECLARE_FUNCTION(execReadText)
    {
        P_GET_STR_REF(Str);
        P_FINISH;
        *(INT*)Result=this->ReadText(Str);
    }
    DECLARE_FUNCTION(execReadBinary)
    {
        P_GET_INT(Count);
        P_GET_ARRAY_REF(BYTE,B);
        P_FINISH;
        *(INT*)Result=this->ReadBinary(Count,B);
    }
    void eventReceivedBinary(INT Count,BYTE* B)
    {
        TcpLink_eventReceivedBinary_Parms Parms(EC_EventParm);
        Parms.Count=Count;
        appMemcpy(Parms.B,B,sizeof(Parms.B));
        ProcessEvent(FindFunctionChecked(IPDRV_ReceivedBinary),&Parms);
    }
    void eventReceivedLine(const FString& Line)
    {
        TcpLink_eventReceivedLine_Parms Parms(EC_EventParm);
        Parms.Line=Line;
        ProcessEvent(FindFunctionChecked(IPDRV_ReceivedLine),&Parms);
    }
    void eventReceivedText(const FString& Text)
    {
        TcpLink_eventReceivedText_Parms Parms(EC_EventParm);
        Parms.Text=Text;
        ProcessEvent(FindFunctionChecked(IPDRV_ReceivedText),&Parms);
    }
    void eventClosed()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_Closed),NULL);
    }
    void eventOpened()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_Opened),NULL);
    }
    void eventAccepted()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_Accepted),NULL);
    }
    DECLARE_CLASS(ATcpLink,AInternetLink,0|CLASS_Transient,IpDrv)
	ATcpLink();
	void PostScriptDestroyed();
	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );	

	void CheckConnectionAttempt();
	void CheckConnectionQueue();
	void PollConnections();
	UBOOL FlushSendBuffer();
	void ShutdownConnection();
	virtual UBOOL ShouldTickInEntry() { return true; }
	virtual INT NativeReadBinary(INT Count, BYTE*& B);
};

struct McpServiceBase_eventInit_Parms
{
    McpServiceBase_eventInit_Parms(EEventParm)
    {
    }
};
class UMcpServiceBase : public UObject
{
public:
    //## BEGIN PROPS McpServiceBase
    FStringNoInit McpConfigClassName;
    class UMcpServiceConfig* McpConfig;
    //## END PROPS McpServiceBase

    void eventInit()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_Init),NULL);
    }
    DECLARE_CLASS(UMcpServiceBase,UObject,0|CLASS_Config,IpDrv)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    NO_DEFAULT_CONSTRUCTOR(UMcpServiceBase)
};

class UMCPBase : public UMcpServiceBase, public FTickableObject
{
public:
    //## BEGIN PROPS MCPBase
    //## END PROPS MCPBase

    DECLARE_ABSTRACT_CLASS(UMCPBase,UMcpServiceBase,0|CLASS_Config,IpDrv)
// FTickableObject interface

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}

	/**
	 * Used to determine if an object should be ticked when the game is paused.
	 *
	 * @return always TRUE as networking needs to be ticked even when paused
	 */
	virtual UBOOL IsTickableWhenPaused() const
	{
		return TRUE;
	}

	/**
	 * Needs to be overridden by child classes
	 *
	 * @param ignored
	 */
	virtual void Tick(FLOAT)
	{
		check(0 && "Implement this in child classes");
	}
};

struct FEventUploadConfig
{
    BYTE UploadType;
    FStringNoInit UploadUrl;
    FLOAT TimeOut;
    BITFIELD bUseCompression:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FEventUploadConfig() {}
    FEventUploadConfig(EEventParm)
    {
        appMemzero(this, sizeof(FEventUploadConfig));
    }
};

class UOnlineEventsInterfaceMcp : public UMCPBase
{
public:
    //## BEGIN PROPS OnlineEventsInterfaceMcp
    TArrayNoInit<struct FEventUploadConfig> EventUploadConfigs;
    TArrayNoInit<struct FMCPEventPoster*> MCPEventPostObjects;
    TArrayNoInit<BYTE> DisabledUploadTypes;
    BITFIELD bBinaryStats:1;
    SCRIPT_ALIGN;
    //## END PROPS OnlineEventsInterfaceMcp

    virtual UBOOL UploadPlayerData(struct FUniqueNetId UniqueId,const FString& PlayerNick,class UOnlineProfileSettings* ProfileSettings,class UOnlinePlayerStorage* PlayerStorage);
    virtual UBOOL UploadGameplayEventsData(struct FUniqueNetId UniqueId,const TArray<BYTE>& Payload);
    virtual UBOOL UpdatePlaylistPopulation(INT PlaylistId,INT NumPlayers);
    virtual UBOOL UploadMatchmakingStats(struct FUniqueNetId UniqueId,class UOnlineMatchmakingStats* MMStats);
    DECLARE_FUNCTION(execUploadPlayerData)
    {
        P_GET_STRUCT(struct FUniqueNetId,UniqueId);
        P_GET_STR(PlayerNick);
        P_GET_OBJECT(UOnlineProfileSettings,ProfileSettings);
        P_GET_OBJECT(UOnlinePlayerStorage,PlayerStorage);
        P_FINISH;
        *(UBOOL*)Result=this->UploadPlayerData(UniqueId,PlayerNick,ProfileSettings,PlayerStorage);
    }
    DECLARE_FUNCTION(execUploadGameplayEventsData)
    {
        P_GET_STRUCT(struct FUniqueNetId,UniqueId);
        P_GET_TARRAY_REF(BYTE,Payload);
        P_FINISH;
        *(UBOOL*)Result=this->UploadGameplayEventsData(UniqueId,Payload);
    }
    DECLARE_FUNCTION(execUpdatePlaylistPopulation)
    {
        P_GET_INT(PlaylistId);
        P_GET_INT(NumPlayers);
        P_FINISH;
        *(UBOOL*)Result=this->UpdatePlaylistPopulation(PlaylistId,NumPlayers);
    }
    DECLARE_FUNCTION(execUploadMatchmakingStats)
    {
        P_GET_STRUCT(struct FUniqueNetId,UniqueId);
        P_GET_OBJECT(UOnlineMatchmakingStats,MMStats);
        P_FINISH;
        *(UBOOL*)Result=this->UploadMatchmakingStats(UniqueId,MMStats);
    }
    DECLARE_CLASS(UOnlineEventsInterfaceMcp,UMCPBase,0|CLASS_Config,IpDrv)
protected:
// FTickableObject interface
	/**
	 * Ticks any outstanding async tasks that need processing
	 *
	 * @param DeltaTime the amount of time that has passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

// Event upload specific methods
	/**
	 * Finds the upload config for the type
	 *
	 * @param UploadType the type of upload that is being processed
	 *
	 * @return pointer to the config item or NULL if not found
	 */
	inline FEventUploadConfig* FindUploadConfig(BYTE UploadType)
	{
		// Make sure this config wasn't disabled
		INT ItemIndex = DisabledUploadTypes.FindItemIndex(UploadType);
		if (ItemIndex == INDEX_NONE)
		{
			for (INT EventIndex = 0; EventIndex < EventUploadConfigs.Num(); EventIndex++)
			{
				if (EventUploadConfigs(EventIndex).UploadType == UploadType)
				{
					return &EventUploadConfigs(EventIndex);
				}
			}
		}
		return NULL;
	}

	/**
	 * Common method for POST-ing a payload to an URL (determined by upload type)
	 *
	 * @param UploadType the type of upload that is happening
	 * @param Payload the data to send
	 * @param NetId unique id of the player sending the data
	 *
	 * @return TRUE if the send started successfully, FALSE otherwise
	 */
	virtual UBOOL UploadPayload(BYTE UploadType,const FString& Payload,const FUniqueNetId NetId);

	/**
	 * Common method for POST-ing a payload to an URL (determined by upload type)
	 *
	 * @param UploadType the type of upload that is happening
	 * @param Payload the data to send
	 * @param NetId unique id of the player sending the data
	 *
	 * @return TRUE if the send started successfully, FALSE otherwise
	 */
	virtual UBOOL UploadBinaryPayload(BYTE UploadType,const TArray<BYTE>& Payload,const FUniqueNetId NetId);

	/**
	 * Final method for POST-ing a payload to a URL.  At this point it is assumed to be binary data
	 *
	 * @param bWasText will be true if the original post was text data
	 * @param UploadType the type of upload that is happening
	 * @param Payload the data to send
	 * @param NetId unique id of the player sending the data
	 *
	 * @return TRUE if the send started successfully, FALSE otherwise
	 */	
	virtual UBOOL UploadFinalPayload(UBOOL bWasText,BYTE UploadType,const TArray<BYTE>& Payload,const FUniqueNetId NetId);

	/**
	 * Converts the net id to a string
	 *
	 * @param Id the net id to convert
	 *
	 * @return the string form of the id
	 */
	virtual FString FormatAsString(const FUniqueNetId& Id)
	{
		return FString::Printf(TEXT("%I64u"),(QWORD&)Id);
	}

	/**
	 * Filters out escape characters that can't be sent to MCP via XML and
	 * replaces them with the XML allowed sequences
	 *
	 * @param Source the source string to modify
	 *
	 * @return a new string with the data escaped
	 */
	virtual FString EscapeString(const FString& Source);

	/**
	 * Builds the URL of additional parameters used when posting playlist population data
	 *
	 * @param PlaylistId the playlist id being reported
	 * @param NumPlayers the number of players on the host
	 *
	 * @return the URL to use with all of the per platform extras
	 */
	virtual FString BuildPlaylistPopulationURLParameters(INT PlaylistId,INT NumPlayers);

	/**
	 * Builds the URL of additional parameters used when posting data
	 *
	 * @param NetId the unique id of the player sending their data
	 *
	 * @return the URL to use with all of the per platform extras
	 */
	virtual FString BuildGenericURLParameters(const FUniqueNetId NetId);

	/**
	 * Captures hardware information as a string for uploading to MCP
	 */
	virtual FString BuildHardwareXmlData(void)
	{
		return FString(TEXT("<Hardware />\r\n"));
	}

	/**
	 * @return platform specific XML data
	 */
	virtual FString BuildPlatformXmlData(void)
	{
		return TEXT("");
	}
};

struct FNewsCacheEntry
{
    FStringNoInit NewsUrl;
    BYTE ReadState;
    BYTE NewsType;
    FStringNoInit NewsItem;
    FLOAT TimeOut;
    BITFIELD bIsUnicode:1;
    SCRIPT_ALIGN;
    class FHttpDownloadString* HttpDownloader;

    /** Constructors */
    FNewsCacheEntry() {}
    FNewsCacheEntry(EEventParm)
    {
        appMemzero(this, sizeof(FNewsCacheEntry));
    }
};

struct OnlineNewsInterfaceMcp_eventOnReadNewsCompleted_Parms
{
    UBOOL bWasSuccessful;
    BYTE NewsType;
    OnlineNewsInterfaceMcp_eventOnReadNewsCompleted_Parms(EEventParm)
    {
    }
};
class UOnlineNewsInterfaceMcp : public UMCPBase
{
public:
    //## BEGIN PROPS OnlineNewsInterfaceMcp
    TArrayNoInit<struct FNewsCacheEntry> NewsItems;
    TArrayNoInit<FScriptDelegate> ReadNewsDelegates;
    BITFIELD bNeedsTicking:1;
    FScriptDelegate __OnReadNewsCompleted__Delegate;
    //## END PROPS OnlineNewsInterfaceMcp

    virtual UBOOL ReadNews(BYTE LocalUserNum,BYTE NewsType);
    DECLARE_FUNCTION(execReadNews)
    {
        P_GET_BYTE(LocalUserNum);
        P_GET_BYTE(NewsType);
        P_FINISH;
        *(UBOOL*)Result=this->ReadNews(LocalUserNum,NewsType);
    }
    void delegateOnReadNewsCompleted(UBOOL bWasSuccessful,BYTE NewsType)
    {
        OnlineNewsInterfaceMcp_eventOnReadNewsCompleted_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.NewsType=NewsType;
        ProcessDelegate(IPDRV_OnReadNewsCompleted,&__OnReadNewsCompleted__Delegate,&Parms);
    }
    DECLARE_CLASS(UOnlineNewsInterfaceMcp,UMCPBase,0|CLASS_Config,IpDrv)
// FTickableObject interface
	/**
	 * Ticks any outstanding news read requests
	 *
	 * @param DeltaTime the amount of time that has passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

// News specific methods
	/**
	 * Finds the news cache entry for the specified type
	 *
	 * @param NewsType the type of news being read
	 *
	 * @return pointer to the news item or NULL if not found
	 */
	inline FNewsCacheEntry* FindNewsCacheEntry(BYTE NewsType)
	{
		for (INT NewsIndex = 0; NewsIndex < NewsItems.Num(); NewsIndex++)
		{
			if (NewsItems(NewsIndex).NewsType == NewsType)
			{
				return &NewsItems(NewsIndex);
			}
		}
		return NULL;
	}
};

struct FTitleFileWeb : public FTitleFile
{
    FStringNoInit StringData;
    class UHttpRequestInterface* HTTPRequest;
    BYTE FileCompressionType;
    SCRIPT_ALIGN;

    /** Constructors */
    FTitleFileWeb() {}
    FTitleFileWeb(EEventParm)
    {
        appMemzero(this, sizeof(FTitleFileWeb));
    }
};

struct FFileNameToURLMapping
{
    FName Filename;
    FName UrlMapping;

    /** Constructors */
    FFileNameToURLMapping() {}
    FFileNameToURLMapping(EEventParm)
    {
        appMemzero(this, sizeof(FFileNameToURLMapping));
    }
};

struct OnlineTitleFileDownloadBase_eventOnRequestTitleFileListComplete_Parms
{
    UBOOL bWasSuccessful;
    FString ResultStr;
    OnlineTitleFileDownloadBase_eventOnRequestTitleFileListComplete_Parms(EEventParm)
    {
    }
};
struct OnlineTitleFileDownloadBase_eventOnReadTitleFileComplete_Parms
{
    UBOOL bWasSuccessful;
    FString Filename;
    OnlineTitleFileDownloadBase_eventOnReadTitleFileComplete_Parms(EEventParm)
    {
    }
};
class UOnlineTitleFileDownloadBase : public UMCPBase
{
public:
    //## BEGIN PROPS OnlineTitleFileDownloadBase
    TArrayNoInit<FScriptDelegate> ReadTitleFileCompleteDelegates;
    TArrayNoInit<FScriptDelegate> RequestTitleFileListCompleteDelegates;
    FStringNoInit BaseUrl;
    FStringNoInit RequestFileListURL;
    FStringNoInit RequestFileURL;
    FLOAT TimeOut;
    TArrayNoInit<struct FFileNameToURLMapping> FilesToUrls;
    FScriptDelegate __OnReadTitleFileComplete__Delegate;
    FScriptDelegate __OnRequestTitleFileListComplete__Delegate;
    //## END PROPS OnlineTitleFileDownloadBase

    virtual FString GetUrlForFile(const FString& Filename);
    DECLARE_FUNCTION(execGetUrlForFile)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(FString*)Result=this->GetUrlForFile(Filename);
    }
    void delegateOnRequestTitleFileListComplete(UBOOL bWasSuccessful,const FString& ResultStr)
    {
        OnlineTitleFileDownloadBase_eventOnRequestTitleFileListComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.ResultStr=ResultStr;
        ProcessDelegate(IPDRV_OnRequestTitleFileListComplete,&__OnRequestTitleFileListComplete__Delegate,&Parms);
    }
    void delegateOnReadTitleFileComplete(UBOOL bWasSuccessful,const FString& Filename)
    {
        OnlineTitleFileDownloadBase_eventOnReadTitleFileComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Filename=Filename;
        ProcessDelegate(IPDRV_OnReadTitleFileComplete,&__OnReadTitleFileComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UOnlineTitleFileDownloadBase,UMCPBase,0|CLASS_Config,IpDrv)
    NO_DEFAULT_CONSTRUCTOR(UOnlineTitleFileDownloadBase)
};

struct FTitleFileMcp : public FTitleFile
{
    class FHttpDownloadBinary* HttpDownloader;

    /** Constructors */
    FTitleFileMcp() {}
    FTitleFileMcp(EEventParm)
    {
        appMemzero(this, sizeof(FTitleFileMcp));
    }
};

class UOnlineTitleFileDownloadMcp : public UOnlineTitleFileDownloadBase
{
public:
    //## BEGIN PROPS OnlineTitleFileDownloadMcp
    TArrayNoInit<struct FTitleFileMcp> TitleFiles;
    INT DownloadCount;
    //## END PROPS OnlineTitleFileDownloadMcp

    virtual UBOOL ReadTitleFile(const FString& FileToRead);
    virtual UBOOL GetTitleFileContents(const FString& Filename,TArray<BYTE>& FileContents);
    virtual UBOOL ClearDownloadedFiles();
    virtual UBOOL ClearDownloadedFile(const FString& Filename);
    DECLARE_FUNCTION(execReadTitleFile)
    {
        P_GET_STR(FileToRead);
        P_FINISH;
        *(UBOOL*)Result=this->ReadTitleFile(FileToRead);
    }
    DECLARE_FUNCTION(execGetTitleFileContents)
    {
        P_GET_STR(Filename);
        P_GET_TARRAY_REF(BYTE,FileContents);
        P_FINISH;
        *(UBOOL*)Result=this->GetTitleFileContents(Filename,FileContents);
    }
    DECLARE_FUNCTION(execClearDownloadedFiles)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ClearDownloadedFiles();
    }
    DECLARE_FUNCTION(execClearDownloadedFile)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->ClearDownloadedFile(Filename);
    }
    DECLARE_CLASS(UOnlineTitleFileDownloadMcp,UOnlineTitleFileDownloadBase,0|CLASS_Config,IpDrv)
// FTickableObject interface
	/**
	 * Ticks any outstanding async tasks that need processing
	 *
	 * @param DeltaTime the amount of time that has passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

// Helpers

	/**
	 * Searches the list of files for the one that matches the filename
	 *
	 * @param FileName the file to search for
	 *
	 * @return the file details
	 */
	FORCEINLINE FTitleFileMcp* GetTitleFile(const FString& FileName)
	{
		// Search for the specified file
		for (INT Index = 0; Index < TitleFiles.Num(); Index++)
		{
			FTitleFileMcp* TitleFile = &TitleFiles(Index);
			if (TitleFile &&
				TitleFile->Filename == FileName)
			{
				return TitleFile;
			}
		}
		return NULL;
	}

	/**
	 * Fires the delegates so the caller knows the file download is complete
	 *
	 * @param TitleFile the information for the file that was downloaded
	 */
	void TriggerDelegates(const FTitleFile* TitleFile);

	/**
	 * Builds the URL to use when fetching the specified file
	 *
	 * @param FileName the file that is being requested
	 *
	 * @return the URL to use with all of the per platform extras
	 */
	virtual FString BuildURLParameters(const FString& FileName)
	{
		return FString::Printf(TEXT("TitleID=%d&PlatformID=%d&Filename=%s"),
			appGetTitleId(),
			(DWORD)appGetPlatformType(),
			*FileName);
	}
};

class UOnlineTitleFileDownloadWeb : public UOnlineTitleFileDownloadBase
{
public:
    //## BEGIN PROPS OnlineTitleFileDownloadWeb
    TArrayNoInit<struct FTitleFileWeb> TitleFiles;
    //## END PROPS OnlineTitleFileDownloadWeb

    virtual UBOOL UncompressTitleFileContents(BYTE FileCompressionType,const TArray<BYTE>& CompressedFileContents,TArray<BYTE>& UncompressedFileContents);
    virtual void TriggerDelegates(UBOOL bSuccess,const FString& FileRead);
    virtual UBOOL GetTitleFileContents(const FString& Filename,TArray<BYTE>& FileContents);
    virtual UBOOL ClearDownloadedFiles();
    virtual UBOOL ClearDownloadedFile(const FString& Filename);
    DECLARE_FUNCTION(execUncompressTitleFileContents)
    {
        P_GET_BYTE(FileCompressionType);
        P_GET_TARRAY_REF(BYTE,CompressedFileContents);
        P_GET_TARRAY_REF(BYTE,UncompressedFileContents);
        P_FINISH;
        *(UBOOL*)Result=this->UncompressTitleFileContents(FileCompressionType,CompressedFileContents,UncompressedFileContents);
    }
    DECLARE_FUNCTION(execTriggerDelegates)
    {
        P_GET_UBOOL(bSuccess);
        P_GET_STR(FileRead);
        P_FINISH;
        this->TriggerDelegates(bSuccess,FileRead);
    }
    DECLARE_FUNCTION(execGetTitleFileContents)
    {
        P_GET_STR(Filename);
        P_GET_TARRAY_REF(BYTE,FileContents);
        P_FINISH;
        *(UBOOL*)Result=this->GetTitleFileContents(Filename,FileContents);
    }
    DECLARE_FUNCTION(execClearDownloadedFiles)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ClearDownloadedFiles();
    }
    DECLARE_FUNCTION(execClearDownloadedFile)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->ClearDownloadedFile(Filename);
    }
    DECLARE_CLASS(UOnlineTitleFileDownloadWeb,UOnlineTitleFileDownloadBase,0|CLASS_Config,IpDrv)
	/**
	 * Ticks any outstanding async tasks that need processing
	 *
	 * @param DeltaTime the amount of time that has passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Searches the list of files for the one that matches the filename
	 *
	 * @param FileName the file to search for
	 *
	 * @return the file details
	 */
	FTitleFileWeb* GetTitleFile(const FString& FileName);
};

struct FTitleFileCacheEntry : public FTitleFile
{
    FStringNoInit LogicalName;
    FStringNoInit Hash;
    BYTE FileOp;
    SCRIPT_ALIGN;
    class FArchive* Ar;

    /** Constructors */
    FTitleFileCacheEntry() {}
    FTitleFileCacheEntry(EEventParm)
    {
        appMemzero(this, sizeof(FTitleFileCacheEntry));
    }
};

struct TitleFileDownloadCache_eventOnSaveTitleFileComplete_Parms
{
    UBOOL bWasSuccessful;
    FString Filename;
    TitleFileDownloadCache_eventOnSaveTitleFileComplete_Parms(EEventParm)
    {
    }
};
struct TitleFileDownloadCache_eventOnLoadTitleFileComplete_Parms
{
    UBOOL bWasSuccessful;
    FString Filename;
    TitleFileDownloadCache_eventOnLoadTitleFileComplete_Parms(EEventParm)
    {
    }
};
class UTitleFileDownloadCache : public UMCPBase
{
public:
    //## BEGIN PROPS TitleFileDownloadCache
    TArrayNoInit<struct FTitleFileCacheEntry> TitleFiles;
    TArrayNoInit<FScriptDelegate> LoadCompleteDelegates;
    TArrayNoInit<FScriptDelegate> SaveCompleteDelegates;
    FScriptDelegate __OnLoadTitleFileComplete__Delegate;
    FScriptDelegate __OnSaveTitleFileComplete__Delegate;
    //## END PROPS TitleFileDownloadCache

    virtual UBOOL LoadTitleFile(const FString& Filename);
    virtual UBOOL SaveTitleFile(const FString& Filename,const FString& LogicalName,const TArray<BYTE>& FileContents);
    virtual UBOOL GetTitleFileContents(const FString& Filename,TArray<BYTE>& FileContents);
    virtual BYTE GetTitleFileState(const FString& Filename);
    virtual FString GetTitleFileHash(const FString& Filename);
    virtual FString GetTitleFileLogicalName(const FString& Filename);
    virtual UBOOL ClearCachedFiles();
    virtual UBOOL ClearCachedFile(const FString& Filename);
    virtual UBOOL DeleteTitleFiles(FLOAT MaxAgeSeconds);
    virtual UBOOL DeleteTitleFile(const FString& Filename);
    DECLARE_FUNCTION(execLoadTitleFile)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->LoadTitleFile(Filename);
    }
    DECLARE_FUNCTION(execSaveTitleFile)
    {
        P_GET_STR(Filename);
        P_GET_STR(LogicalName);
        P_GET_TARRAY(BYTE,FileContents);
        P_FINISH;
        *(UBOOL*)Result=this->SaveTitleFile(Filename,LogicalName,FileContents);
    }
    DECLARE_FUNCTION(execGetTitleFileContents)
    {
        P_GET_STR(Filename);
        P_GET_TARRAY_REF(BYTE,FileContents);
        P_FINISH;
        *(UBOOL*)Result=this->GetTitleFileContents(Filename,FileContents);
    }
    DECLARE_FUNCTION(execGetTitleFileState)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(BYTE*)Result=this->GetTitleFileState(Filename);
    }
    DECLARE_FUNCTION(execGetTitleFileHash)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(FString*)Result=this->GetTitleFileHash(Filename);
    }
    DECLARE_FUNCTION(execGetTitleFileLogicalName)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(FString*)Result=this->GetTitleFileLogicalName(Filename);
    }
    DECLARE_FUNCTION(execClearCachedFiles)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ClearCachedFiles();
    }
    DECLARE_FUNCTION(execClearCachedFile)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->ClearCachedFile(Filename);
    }
    DECLARE_FUNCTION(execDeleteTitleFiles)
    {
        P_GET_FLOAT(MaxAgeSeconds);
        P_FINISH;
        *(UBOOL*)Result=this->DeleteTitleFiles(MaxAgeSeconds);
    }
    DECLARE_FUNCTION(execDeleteTitleFile)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->DeleteTitleFile(Filename);
    }
    void delegateOnSaveTitleFileComplete(UBOOL bWasSuccessful,const FString& Filename)
    {
        TitleFileDownloadCache_eventOnSaveTitleFileComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Filename=Filename;
        ProcessDelegate(IPDRV_OnSaveTitleFileComplete,&__OnSaveTitleFileComplete__Delegate,&Parms);
    }
    void delegateOnLoadTitleFileComplete(UBOOL bWasSuccessful,const FString& Filename)
    {
        TitleFileDownloadCache_eventOnLoadTitleFileComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Filename=Filename;
        ProcessDelegate(IPDRV_OnLoadTitleFileComplete,&__OnLoadTitleFileComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UTitleFileDownloadCache,UMCPBase,0|CLASS_Config,IpDrv)
	/**
	 * Ticks any outstanding async tasks that need processing
	 *
	 * @param DeltaTime the amount of time that has passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Fires the delegates so the caller knows the file load/save is complete
	 *
	 * @param TitleFile the information for the file that was loaded/saved
	 * @param FileOp read/write opeartion on the file to know which delegates to call
	 */
	void TriggerDelegates(const FTitleFileCacheEntry* TitleFile,ETitleFileFileOp FileOp);

	/**
	 * Searches the list of files for the one that matches the filename
	 *
	 * @param FileName the file to search for
	 *
	 * @return the file details
	 */
	FTitleFileCacheEntry* GetTitleFile(const FString& FileName);

	/**
	 * @return base path to all cached files
	 */
	FString GetCachePath() const;
};

struct FMcpMessage
{
    FStringNoInit MessageId;
    FStringNoInit ToUniqueUserId;
    FStringNoInit FromUniqueUserId;
    FStringNoInit FromFriendlyName;
    FStringNoInit MessageType;
    FStringNoInit ValidUntil;
    BYTE MessageCompressionType;
    SCRIPT_ALIGN;

    /** Constructors */
    FMcpMessage() {}
    FMcpMessage(EEventParm)
    {
        appMemzero(this, sizeof(FMcpMessage));
    }
};

struct FMcpMessageList
{
    FStringNoInit ToUniqueUserId;
    TArrayNoInit<struct FMcpMessage> Messages;

    /** Constructors */
    FMcpMessageList() {}
    FMcpMessageList(EEventParm)
    {
        appMemzero(this, sizeof(FMcpMessageList));
    }
};

struct FMcpMessageContents
{
    FStringNoInit MessageId;
    TArrayNoInit<BYTE> MessageContents;

    /** Constructors */
    FMcpMessageContents() {}
    FMcpMessageContents(EEventParm)
    {
        appMemzero(this, sizeof(FMcpMessageContents));
    }
};

struct McpMessageBase_eventOnQueryMessageContentsComplete_Parms
{
    FString MessageId;
    UBOOL bWasSuccessful;
    FString Error;
    McpMessageBase_eventOnQueryMessageContentsComplete_Parms(EEventParm)
    {
    }
};
struct McpMessageBase_eventOnQueryMessagesComplete_Parms
{
    FString UserId;
    UBOOL bWasSuccessful;
    FString Error;
    McpMessageBase_eventOnQueryMessagesComplete_Parms(EEventParm)
    {
    }
};
struct McpMessageBase_eventOnDeleteMessageComplete_Parms
{
    FString MessageId;
    UBOOL bWasSuccessful;
    FString Error;
    McpMessageBase_eventOnDeleteMessageComplete_Parms(EEventParm)
    {
    }
};
struct McpMessageBase_eventOnCreateMessageComplete_Parms
{
    struct FMcpMessage Message;
    UBOOL bWasSuccessful;
    FString Error;
    McpMessageBase_eventOnCreateMessageComplete_Parms(EEventParm)
    : Message(EC_EventParm)
    {
    }
};
class UMcpMessageBase : public UMcpServiceBase
{
public:
    //## BEGIN PROPS McpMessageBase
    FStringNoInit McpMessageManagerClassName;
    BYTE CompressionType;
    TArrayNoInit<struct FMcpMessageContents> MessageContentsList;
    TArrayNoInit<struct FMcpMessageList> MessageLists;
    FScriptDelegate __OnCreateMessageComplete__Delegate;
    FScriptDelegate __OnDeleteMessageComplete__Delegate;
    FScriptDelegate __OnQueryMessagesComplete__Delegate;
    FScriptDelegate __OnQueryMessageContentsComplete__Delegate;
    //## END PROPS McpMessageBase

    void delegateOnQueryMessageContentsComplete(const FString& MessageId,UBOOL bWasSuccessful,const FString& Error)
    {
        McpMessageBase_eventOnQueryMessageContentsComplete_Parms Parms(EC_EventParm);
        Parms.MessageId=MessageId;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Error=Error;
        ProcessDelegate(IPDRV_OnQueryMessageContentsComplete,&__OnQueryMessageContentsComplete__Delegate,&Parms);
    }
    void delegateOnQueryMessagesComplete(const FString& UserId,UBOOL bWasSuccessful,const FString& Error)
    {
        McpMessageBase_eventOnQueryMessagesComplete_Parms Parms(EC_EventParm);
        Parms.UserId=UserId;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Error=Error;
        ProcessDelegate(IPDRV_OnQueryMessagesComplete,&__OnQueryMessagesComplete__Delegate,&Parms);
    }
    void delegateOnDeleteMessageComplete(const FString& MessageId,UBOOL bWasSuccessful,const FString& Error)
    {
        McpMessageBase_eventOnDeleteMessageComplete_Parms Parms(EC_EventParm);
        Parms.MessageId=MessageId;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Error=Error;
        ProcessDelegate(IPDRV_OnDeleteMessageComplete,&__OnDeleteMessageComplete__Delegate,&Parms);
    }
    void delegateOnCreateMessageComplete(struct FMcpMessage Message,UBOOL bWasSuccessful,const FString& Error)
    {
        McpMessageBase_eventOnCreateMessageComplete_Parms Parms(EC_EventParm);
        Parms.Message=Message;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Error=Error;
        ProcessDelegate(IPDRV_OnCreateMessageComplete,&__OnCreateMessageComplete__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UMcpMessageBase,UMcpServiceBase,0|CLASS_Config,IpDrv)
    NO_DEFAULT_CONSTRUCTOR(UMcpMessageBase)
};

struct FMcpCompressMessageRequest
{
    TArrayNoInit<BYTE> SourceBuffer;
    TArrayNoInit<BYTE> DestBuffer;
    INT OutCompressedSize;
    class UHttpRequestInterface* Request;
    FAsyncTask<FCompressAsyncWorker>* CompressionWorker;

    /** Constructors */
    FMcpCompressMessageRequest() {}
    FMcpCompressMessageRequest(EEventParm)
    {
        appMemzero(this, sizeof(FMcpCompressMessageRequest));
    }
};

struct FMcpUncompressMessageRequest
{
    FStringNoInit MessageId;
    TArrayNoInit<BYTE> SourceBuffer;
    TArrayNoInit<BYTE> DestBuffer;
    INT OutUncompressedSize;
    FAsyncTask<FUncompressAsyncWorker>* UncompressionWorker;

    /** Constructors */
    FMcpUncompressMessageRequest() {}
    FMcpUncompressMessageRequest(EEventParm)
    {
        appMemzero(this, sizeof(FMcpUncompressMessageRequest));
    }
};

struct McpMessageManager_eventFinishedAsyncUncompression_Parms
{
    UBOOL bWasSuccessful;
    TArray<BYTE> UncompressedMessageContents;
    FString MessageId;
    McpMessageManager_eventFinishedAsyncUncompression_Parms(EEventParm)
    {
    }
};
class UMcpMessageManager : public UMcpMessageBase, public FTickableObject
{
public:
    //## BEGIN PROPS McpMessageManager
    FStringNoInit CreateMessageUrl;
    FStringNoInit DeleteMessageUrl;
    FStringNoInit QueryMessagesUrl;
    FStringNoInit QueryMessageContentsUrl;
    FStringNoInit DeleteAllMessagesUrl;
    TArrayNoInit<struct FMcpCompressMessageRequest> CompressMessageRequests;
    TArrayNoInit<struct FMcpUncompressMessageRequest> UncompressMessageRequests;
    //## END PROPS McpMessageManager

    virtual UBOOL StartAsyncCompression(BYTE MessageCompressionType,const TArray<BYTE>& MessageContent,class UHttpRequestInterface* Request);
    virtual UBOOL StartAsyncUncompression(const FString& MessageId,BYTE MessageCompressionType,const TArray<BYTE>& MessageContent);
    DECLARE_FUNCTION(execStartAsyncCompression)
    {
        P_GET_BYTE(MessageCompressionType);
        P_GET_TARRAY_REF(BYTE,MessageContent);
        P_GET_OBJECT(UHttpRequestInterface,Request);
        P_FINISH;
        *(UBOOL*)Result=this->StartAsyncCompression(MessageCompressionType,MessageContent,Request);
    }
    DECLARE_FUNCTION(execStartAsyncUncompression)
    {
        P_GET_STR(MessageId);
        P_GET_BYTE(MessageCompressionType);
        P_GET_TARRAY_REF(BYTE,MessageContent);
        P_FINISH;
        *(UBOOL*)Result=this->StartAsyncUncompression(MessageId,MessageCompressionType,MessageContent);
    }
    void eventFinishedAsyncUncompression(UBOOL bWasSuccessful,const TArray<BYTE>& UncompressedMessageContents,const FString& MessageId)
    {
        McpMessageManager_eventFinishedAsyncUncompression_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.UncompressedMessageContents=UncompressedMessageContents;
        Parms.MessageId=MessageId;
        ProcessEvent(FindFunctionChecked(IPDRV_FinishedAsyncUncompression),&Parms);
    }
    DECLARE_CLASS(UMcpMessageManager,UMcpMessageBase,0|CLASS_Config,IpDrv)
// FTickableObject interface

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}

	/**
	 * Used to determine if an object should be ticked when the game is paused.
	 *
	 * @return always TRUE as networking needs to be ticked even when paused
	 */
	virtual UBOOL IsTickableWhenPaused() const
	{
		return TRUE;
	}

	/**
	 * Needs to be overridden by child classes
	 *
	 * @param ignored
	 */
	virtual void Tick(FLOAT);
};

struct FMcpUserCloudFileInfo : public FEmsFile
{
    FStringNoInit CreationDate;
    FStringNoInit LastUpdateDate;
    FStringNoInit CompressionType;

    /** Constructors */
    FMcpUserCloudFileInfo() {}
    FMcpUserCloudFileInfo(EEventParm)
    {
        appMemzero(this, sizeof(FMcpUserCloudFileInfo));
    }
};

struct FMcpUserCloudFilesEntry
{
    FStringNoInit UserId;
    TArrayNoInit<struct FTitleFileWeb> DownloadedFiles;
    TArrayNoInit<struct FMcpUserCloudFileInfo> EnumeratedFiles;
    class UHttpRequestInterface* HTTPRequestEnumerateFiles;

    /** Constructors */
    FMcpUserCloudFilesEntry() {}
    FMcpUserCloudFilesEntry(EEventParm)
    {
        appMemzero(this, sizeof(FMcpUserCloudFilesEntry));
    }
};

struct McpUserCloudFileDownload_eventOnDeleteUserFileComplete_Parms
{
    UBOOL bWasSuccessful;
    FString UserId;
    FString Filename;
    McpUserCloudFileDownload_eventOnDeleteUserFileComplete_Parms(EEventParm)
    {
    }
};
struct McpUserCloudFileDownload_eventOnWriteUserFileComplete_Parms
{
    UBOOL bWasSuccessful;
    FString UserId;
    FString Filename;
    McpUserCloudFileDownload_eventOnWriteUserFileComplete_Parms(EEventParm)
    {
    }
};
struct McpUserCloudFileDownload_eventOnReadUserFileComplete_Parms
{
    UBOOL bWasSuccessful;
    FString UserId;
    FString Filename;
    McpUserCloudFileDownload_eventOnReadUserFileComplete_Parms(EEventParm)
    {
    }
};
struct McpUserCloudFileDownload_eventOnEnumerateUserFilesComplete_Parms
{
    UBOOL bWasSuccessful;
    FString UserId;
    McpUserCloudFileDownload_eventOnEnumerateUserFilesComplete_Parms(EEventParm)
    {
    }
};
class UMcpUserCloudFileDownload : public UMcpServiceBase
{
public:
    //## BEGIN PROPS McpUserCloudFileDownload
    FStringNoInit EnumerateCloudFilesUrl;
    FStringNoInit ReadCloudFileUrl;
    FStringNoInit WriteCloudFileUrl;
    FStringNoInit DeleteCloudFileUrl;
    TArrayNoInit<struct FMcpUserCloudFilesEntry> UserCloudFileRequests;
    TArrayNoInit<FScriptDelegate> EnumerateUserFilesCompleteDelegates;
    TArrayNoInit<FScriptDelegate> ReadUserFileCompleteDelegates;
    TArrayNoInit<FScriptDelegate> WriteUserFileCompleteDelegates;
    TArrayNoInit<FScriptDelegate> DeleteUserFileCompleteDelegates;
    FScriptDelegate __OnEnumerateUserFilesComplete__Delegate;
    FScriptDelegate __OnReadUserFileComplete__Delegate;
    FScriptDelegate __OnWriteUserFileComplete__Delegate;
    FScriptDelegate __OnDeleteUserFileComplete__Delegate;
    //## END PROPS McpUserCloudFileDownload

    void delegateOnDeleteUserFileComplete(UBOOL bWasSuccessful,const FString& UserId,const FString& Filename)
    {
        McpUserCloudFileDownload_eventOnDeleteUserFileComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.UserId=UserId;
        Parms.Filename=Filename;
        ProcessDelegate(IPDRV_OnDeleteUserFileComplete,&__OnDeleteUserFileComplete__Delegate,&Parms);
    }
    void delegateOnWriteUserFileComplete(UBOOL bWasSuccessful,const FString& UserId,const FString& Filename)
    {
        McpUserCloudFileDownload_eventOnWriteUserFileComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.UserId=UserId;
        Parms.Filename=Filename;
        ProcessDelegate(IPDRV_OnWriteUserFileComplete,&__OnWriteUserFileComplete__Delegate,&Parms);
    }
    void delegateOnReadUserFileComplete(UBOOL bWasSuccessful,const FString& UserId,const FString& Filename)
    {
        McpUserCloudFileDownload_eventOnReadUserFileComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.UserId=UserId;
        Parms.Filename=Filename;
        ProcessDelegate(IPDRV_OnReadUserFileComplete,&__OnReadUserFileComplete__Delegate,&Parms);
    }
    void delegateOnEnumerateUserFilesComplete(UBOOL bWasSuccessful,const FString& UserId)
    {
        McpUserCloudFileDownload_eventOnEnumerateUserFilesComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.UserId=UserId;
        ProcessDelegate(IPDRV_OnEnumerateUserFilesComplete,&__OnEnumerateUserFilesComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UMcpUserCloudFileDownload,UMcpServiceBase,0|CLASS_Config,IpDrv)
    NO_DEFAULT_CONSTRUCTOR(UMcpUserCloudFileDownload)
};

struct FConnectionBandwidthStats
{
    INT UpstreamRate;
    INT DownstreamRate;
    INT RoundtripLatency;


		/** Constructors */
		FConnectionBandwidthStats() {}
		FConnectionBandwidthStats(EEventParm)
		{
			appMemzero(this, sizeof(FConnectionBandwidthStats));
		}
		/**
		 * Serialize from NBO buffer to FConnectionBandwidthStats
		 */
		friend FNboSerializeFromBuffer& operator>>(FNboSerializeFromBuffer& Ar,FConnectionBandwidthStats& BandwidthStats);
		/**
		 * Serialize from FConnectionBandwidthStats to NBO buffer
		 */
		friend FNboSerializeToBuffer& operator<<(FNboSerializeToBuffer& Ar,const FConnectionBandwidthStats& BandwidthStats);
	
};

struct FPlayerMember
{
    INT TeamNum;
    INT Skill;
    struct FUniqueNetId NetId;

		/** Constructors */
		FPlayerMember() {}
		FPlayerMember(EEventParm)
		{
			appMemzero(this, sizeof(FPlayerMember));
		}
		/**
		 * Serialize from NBO buffer to FPlayerMember
		 */
		friend FNboSerializeFromBuffer& operator>>(FNboSerializeFromBuffer& Ar,FPlayerMember& PlayerEntry);
		/**
		 * Serialize from FPlayerMember to NBO buffer
		 */
		friend FNboSerializeToBuffer& operator<<(FNboSerializeToBuffer& Ar,const FPlayerMember& PlayerEntry);
	
};

struct MeshBeacon_eventDestroyBeacon_Parms
{
    MeshBeacon_eventDestroyBeacon_Parms(EEventParm)
    {
    }
};
class UMeshBeacon : public UObject, public FTickableObject
{
public:
    //## BEGIN PROPS MeshBeacon
    INT MeshBeaconPort;
    FSocket* Socket;
    BITFIELD bIsInTick:1;
    BITFIELD bWantsDeferredDestroy:1;
    BITFIELD bShouldTick:1;
    FLOAT HeartbeatTimeout;
    FLOAT ElapsedHeartbeatTime;
    FName BeaconName;
    INT SocketSendBufferSize;
    INT SocketReceiveBufferSize;
    INT MaxBandwidthTestBufferSize;
    INT MinBandwidthTestBufferSize;
    FLOAT MaxBandwidthTestSendTime;
    FLOAT MaxBandwidthTestReceiveTime;
    INT MaxBandwidthHistoryEntries;
    //## END PROPS MeshBeacon

    virtual void DestroyBeacon();
    DECLARE_FUNCTION(execDestroyBeacon)
    {
        P_FINISH;
        this->DestroyBeacon();
    }
    void eventDestroyBeacon()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_DestroyBeacon),NULL);
    }
    DECLARE_CLASS(UMeshBeacon,UObject,0|CLASS_Config,IpDrv)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	// FTickableObject interface

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}

	/**
	 * Used to determine if an object should be ticked when the game is paused.
	 *
	 * @return always TRUE as networking needs to be ticked even when paused
	 */
	virtual UBOOL IsTickableWhenPaused() const
	{
		return TRUE;
	}

	/**
	 * Ticks the network layer to see if there are any requests or responses to requests
	 *
	 * @param DeltaTime the amount of time that has elapsed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Sends a heartbeat packet to the specified socket
	 *
	 * @param Socket the socket to send the data on
	 *
	 * @return TRUE if it sent ok, FALSE if there was an error
	 */
	UBOOL SendHeartbeat(FSocket* Socket);

	/**
	 * Handles dummy packets that are received by reading from the buffer until there is no more data or a non-dummy packet is seen.
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessDummyPackets(FNboSerializeFromBuffer& FromBuffer);
};

struct FClientConnectionRequest
{
    struct FUniqueNetId PlayerNetId;
    BYTE NatType;
    SCRIPT_ALIGN;
    BITFIELD bCanHostVs:1;
    FLOAT GoodHostRatio;
    TArrayNoInit<struct FConnectionBandwidthStats> BandwidthHistory;
    INT MinutesSinceLastTest;

    /** Constructors */
    FClientConnectionRequest() {}
    FClientConnectionRequest(EEventParm)
    {
        appMemzero(this, sizeof(FClientConnectionRequest));
    }
};

struct FClientBandwidthTestData
{
    BYTE TestType;
    BYTE CurrentState;
    INT NumBytesToSendTotal;
    INT NumBytesSentTotal;
    INT NumBytesSentLast;
    FLOAT ElapsedTestTime;

    /** Constructors */
    FClientBandwidthTestData() {}
    FClientBandwidthTestData(EEventParm)
    {
        appMemzero(this, sizeof(FClientBandwidthTestData));
    }
};

struct MeshBeaconClient_eventOnCreateNewSessionRequestReceived_Parms
{
    FName SessionName;
    class UClass* SearchClass;
    TArray<struct FPlayerMember> Players;
    MeshBeaconClient_eventOnCreateNewSessionRequestReceived_Parms(EEventParm)
    {
    }
};
struct MeshBeaconClient_eventOnTravelRequestReceived_Parms
{
    FName SessionName;
    class UClass* SearchClass;
    BYTE PlatformSpecificInfo[80];
    MeshBeaconClient_eventOnTravelRequestReceived_Parms(EEventParm)
    {
    }
};
struct MeshBeaconClient_eventOnReceivedBandwidthTestResults_Parms
{
    BYTE TestType;
    BYTE TestResult;
    struct FConnectionBandwidthStats BandwidthStats;
    MeshBeaconClient_eventOnReceivedBandwidthTestResults_Parms(EEventParm)
    {
    }
};
struct MeshBeaconClient_eventOnReceivedBandwidthTestRequest_Parms
{
    BYTE TestType;
    MeshBeaconClient_eventOnReceivedBandwidthTestRequest_Parms(EEventParm)
    {
    }
};
struct MeshBeaconClient_eventOnConnectionRequestResult_Parms
{
    BYTE ConnectionResult;
    MeshBeaconClient_eventOnConnectionRequestResult_Parms(EEventParm)
    {
    }
};
class UMeshBeaconClient : public UMeshBeacon
{
public:
    //## BEGIN PROPS MeshBeaconClient
    struct FOnlineGameSearchResult HostPendingRequest;
    struct FClientConnectionRequest ClientPendingRequest;
    struct FClientBandwidthTestData CurrentBandwidthTest;
    BYTE ClientBeaconState;
    BYTE ClientBeaconRequestType;
    FLOAT ConnectionRequestTimeout;
    FLOAT ConnectionRequestElapsedTime;
    FStringNoInit ResolverClassName;
    class UClass* ResolverClass;
    class UClientBeaconAddressResolver* Resolver;
    BITFIELD bUsingRegisteredAddr:1;
    FScriptDelegate __OnConnectionRequestResult__Delegate;
    FScriptDelegate __OnReceivedBandwidthTestRequest__Delegate;
    FScriptDelegate __OnReceivedBandwidthTestResults__Delegate;
    FScriptDelegate __OnTravelRequestReceived__Delegate;
    FScriptDelegate __OnCreateNewSessionRequestReceived__Delegate;
    //## END PROPS MeshBeaconClient

    virtual void DestroyBeacon();
    virtual UBOOL RequestConnection(const struct FOnlineGameSearchResult& DesiredHost,const struct FClientConnectionRequest& ClientRequest,UBOOL bRegisterSecureAddress);
    virtual UBOOL BeginBandwidthTest(BYTE TestType,INT TestBufferSize);
    virtual UBOOL SendHostNewGameSessionResponse(UBOOL bSuccess,FName SessionName,class UClass* SearchClass,const BYTE* PlatformSpecificInfo);
    DECLARE_FUNCTION(execRequestConnection)
    {
        P_GET_STRUCT_REF(struct FOnlineGameSearchResult,DesiredHost);
        P_GET_STRUCT_INIT_REF(struct FClientConnectionRequest,ClientRequest);
        P_GET_UBOOL(bRegisterSecureAddress);
        P_FINISH;
        *(UBOOL*)Result=this->RequestConnection(DesiredHost,ClientRequest,bRegisterSecureAddress);
    }
    DECLARE_FUNCTION(execBeginBandwidthTest)
    {
        P_GET_BYTE(TestType);
        P_GET_INT(TestBufferSize);
        P_FINISH;
        *(UBOOL*)Result=this->BeginBandwidthTest(TestType,TestBufferSize);
    }
    DECLARE_FUNCTION(execSendHostNewGameSessionResponse)
    {
        P_GET_UBOOL(bSuccess);
        P_GET_NAME(SessionName);
        P_GET_OBJECT(UClass,SearchClass);
        P_GET_ARRAY_REF(BYTE,PlatformSpecificInfo);
        P_FINISH;
        *(UBOOL*)Result=this->SendHostNewGameSessionResponse(bSuccess,SessionName,SearchClass,PlatformSpecificInfo);
    }
    void delegateOnCreateNewSessionRequestReceived(FName SessionName,class UClass* SearchClass,const TArray<struct FPlayerMember>& Players)
    {
        MeshBeaconClient_eventOnCreateNewSessionRequestReceived_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.SearchClass=SearchClass;
        Parms.Players=Players;
        ProcessDelegate(IPDRV_OnCreateNewSessionRequestReceived,&__OnCreateNewSessionRequestReceived__Delegate,&Parms);
    }
    void delegateOnTravelRequestReceived(FName SessionName,class UClass* SearchClass,const BYTE* PlatformSpecificInfo)
    {
        MeshBeaconClient_eventOnTravelRequestReceived_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.SearchClass=SearchClass;
        appMemcpy(Parms.PlatformSpecificInfo,PlatformSpecificInfo,sizeof(Parms.PlatformSpecificInfo));
        ProcessDelegate(IPDRV_OnTravelRequestReceived,&__OnTravelRequestReceived__Delegate,&Parms);
    }
    void delegateOnReceivedBandwidthTestResults(BYTE TestType,BYTE TestResult,const struct FConnectionBandwidthStats& BandwidthStats)
    {
        MeshBeaconClient_eventOnReceivedBandwidthTestResults_Parms Parms(EC_EventParm);
        Parms.TestType=TestType;
        Parms.TestResult=TestResult;
        Parms.BandwidthStats=BandwidthStats;
        ProcessDelegate(IPDRV_OnReceivedBandwidthTestResults,&__OnReceivedBandwidthTestResults__Delegate,&Parms);
    }
    void delegateOnReceivedBandwidthTestRequest(BYTE TestType)
    {
        MeshBeaconClient_eventOnReceivedBandwidthTestRequest_Parms Parms(EC_EventParm);
        Parms.TestType=TestType;
        ProcessDelegate(IPDRV_OnReceivedBandwidthTestRequest,&__OnReceivedBandwidthTestRequest__Delegate,&Parms);
    }
    void delegateOnConnectionRequestResult(BYTE ConnectionResult)
    {
        MeshBeaconClient_eventOnConnectionRequestResult_Parms Parms(EC_EventParm);
        Parms.ConnectionResult=ConnectionResult;
        ProcessDelegate(IPDRV_OnConnectionRequestResult,&__OnConnectionRequestResult__Delegate,&Parms);
    }
    DECLARE_CLASS(UMeshBeaconClient,UMeshBeacon,0|CLASS_Config,IpDrv)
	/**
	 * Ticks the network layer to see if there are any requests or responses to requests
	 *
	 * @param DeltaTime the amount of time that has elapsed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Loads the class specified for the Resolver and constructs it if needed
	 */
	void InitResolver(void);

	/**
	 * Creates a beacon that will send requests to remote hosts
	 *
	 * @param Addr the address that we are connecting to (needs to be resolved)
	 * @return true if the beacon was created successfully, false otherwise
	 */
	UBOOL InitClientBeacon(const FInternetIpAddr& Addr);

	/** 
	 * Unregisters the address and zeros the members involved to prevent multiple releases 
	 */
	void CleanupAddress(void);

	/**
	 * Handles checking for the transition from connecting to connected (socket established)
	 */
	void CheckConnectionStatus(void);

	/**
	 * Sends all the data for a new client connection on the host.
	 * Client data includes the player net id, cient NAT type, and previous bandwidth history.
	 * Assumes that a connection has successfully been established with the host.
	 */
	void SendClientConnectionRequest(void);

	/**
	 * Checks the socket for a response from the host and processes if present
	 */
	void ReadHostData(void);

	/**
	 * Processes a packet that was received from the host 
	 *
	 * @param Packet the packet that the host sent
	 * @param PacketSize the size of the packet to process
	 */
	void ProcessHostPacket(BYTE* Packet,INT PacketSize);

	/**
	 * Routes the response packet received from a host to the correct handler based on its type.
	 *
	 * @param HostPacketType packet ID from EMeshBeaconPacketType that represents a host response to this client
	 * @param FromBuffer the packet serializer to read from
	 * @return TRUE if the data packet type was processed
	 */
	UBOOL HandleHostPacketByType(BYTE HostPacketType,FNboSerializeFromBuffer& FromBuffer);

	/** 
	 * Common routine for notifying of a timeout trying to talk to host 
	 */
	void ProcessHostTimeout(void);

	/**
	 * Processes a heartbeat update, sends a heartbeat back, and clears the timer
	 */
	void ProcessHeartbeat(void);

	/**
	 * Update a bandwidth test that is currently in progress for this client.
	 * All other host packets are ignored until the current test finishes or timeout occurs.
	 */
	void ProcessInProgressBandwidthTest(void);

	/**
	 * Reads the host response to the client's connection request. 
	 * Triggers a delegate.
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessHostResponseConnectionRequest(FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Handles a new bandwidth test request initiated by the host for this client. 
	 * Triggers a delegate.
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessHostRequestBandwidthTest(FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Handles a host response that all upstream bandwidth data was received by the host.
	 * Triggers a delegate.
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessHostFinishedBandwidthTest(FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Processes a travel request packet that was received from the host
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessHostTravelRequest(FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Processes a request packet that was received from the host to create a new game session
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessHostCreateNewSessionRequest(FNboSerializeFromBuffer& FromBuffer);
};

struct FClientConnectionBandwidthTestData
{
    BYTE CurrentState;
    BYTE TestType;
    INT BytesTotalNeeded;
    INT BytesReceived;
    DOUBLE RequestTestStartTime;
    DOUBLE TestStartTime;
    struct FConnectionBandwidthStats BandwidthStats;

    /** Constructors */
    FClientConnectionBandwidthTestData() {}
    FClientConnectionBandwidthTestData(EEventParm)
    {
        appMemzero(this, sizeof(FClientConnectionBandwidthTestData));
    }
};

struct FClientMeshBeaconConnection
{
    struct FUniqueNetId PlayerNetId;
    FLOAT ElapsedHeartbeatTime;
    FSocket* Socket;
    BITFIELD bConnectionAccepted:1;
    SCRIPT_ALIGN;
    struct FClientConnectionBandwidthTestData BandwidthTest;
    BYTE NatType;
    SCRIPT_ALIGN;
    BITFIELD bCanHostVs:1;
    FLOAT GoodHostRatio;
    TArrayNoInit<struct FConnectionBandwidthStats> BandwidthHistory;
    INT MinutesSinceLastTest;

    /** Constructors */
    FClientMeshBeaconConnection() {}
    FClientMeshBeaconConnection(EEventParm)
    {
        appMemzero(this, sizeof(FClientMeshBeaconConnection));
    }
};

struct MeshBeaconHost_eventOnReceivedClientCreateNewSessionResult_Parms
{
    UBOOL bSucceeded;
    FName SessionName;
    class UClass* SearchClass;
    BYTE PlatformSpecificInfo[80];
    MeshBeaconHost_eventOnReceivedClientCreateNewSessionResult_Parms(EEventParm)
    {
    }
};
struct MeshBeaconHost_eventOnAllPendingPlayersConnected_Parms
{
    MeshBeaconHost_eventOnAllPendingPlayersConnected_Parms(EEventParm)
    {
    }
};
struct MeshBeaconHost_eventOnFinishedBandwidthTest_Parms
{
    struct FUniqueNetId PlayerNetId;
    BYTE TestType;
    BYTE TestResult;
    struct FConnectionBandwidthStats BandwidthStats;
    MeshBeaconHost_eventOnFinishedBandwidthTest_Parms(EEventParm)
    {
    }
};
struct MeshBeaconHost_eventOnStartedBandwidthTest_Parms
{
    struct FUniqueNetId PlayerNetId;
    BYTE TestType;
    MeshBeaconHost_eventOnStartedBandwidthTest_Parms(EEventParm)
    {
    }
};
struct MeshBeaconHost_eventOnReceivedClientConnectionRequest_Parms
{
    struct FClientMeshBeaconConnection NewClientConnection;
    MeshBeaconHost_eventOnReceivedClientConnectionRequest_Parms(EEventParm)
    : NewClientConnection(EC_EventParm)
    {
    }
};
class UMeshBeaconHost : public UMeshBeacon
{
public:
    //## BEGIN PROPS MeshBeaconHost
    TArrayNoInit<struct FClientMeshBeaconConnection> ClientConnections;
    TArrayNoInit<struct FUniqueNetId> PendingPlayerConnections;
    struct FUniqueNetId OwningPlayerId;
    BITFIELD bAllowBandwidthTesting:1;
    INT ConnectionBacklog;
    FScriptDelegate __OnReceivedClientConnectionRequest__Delegate;
    FScriptDelegate __OnStartedBandwidthTest__Delegate;
    FScriptDelegate __OnFinishedBandwidthTest__Delegate;
    FScriptDelegate __OnAllPendingPlayersConnected__Delegate;
    FScriptDelegate __OnReceivedClientCreateNewSessionResult__Delegate;
    //## END PROPS MeshBeaconHost

    virtual UBOOL InitHostBeacon(struct FUniqueNetId InOwningPlayerId);
    virtual void DestroyBeacon();
    virtual UBOOL RequestClientBandwidthTest(struct FUniqueNetId PlayerNetId,BYTE TestType,INT TestBufferSize);
    virtual UBOOL HasInProgressBandwidthTest();
    virtual void CancelInProgressBandwidthTests();
    virtual UBOOL HasPendingBandwidthTest();
    virtual void CancelPendingBandwidthTests();
    virtual INT GetConnectionIndexForPlayer(struct FUniqueNetId PlayerNetId);
    virtual UBOOL AllPlayersConnected(const TArray<struct FUniqueNetId>& Players);
    virtual void TellClientsToTravel(FName SessionName,class UClass* SearchClass,const BYTE* PlatformSpecificInfo);
    virtual UBOOL RequestClientCreateNewSession(struct FUniqueNetId PlayerNetId,FName SessionName,class UClass* SearchClass,const TArray<struct FPlayerMember>& Players);
    DECLARE_FUNCTION(execInitHostBeacon)
    {
        P_GET_STRUCT(struct FUniqueNetId,InOwningPlayerId);
        P_FINISH;
        *(UBOOL*)Result=this->InitHostBeacon(InOwningPlayerId);
    }
    DECLARE_FUNCTION(execRequestClientBandwidthTest)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerNetId);
        P_GET_BYTE(TestType);
        P_GET_INT(TestBufferSize);
        P_FINISH;
        *(UBOOL*)Result=this->RequestClientBandwidthTest(PlayerNetId,TestType,TestBufferSize);
    }
    DECLARE_FUNCTION(execHasInProgressBandwidthTest)
    {
        P_FINISH;
        *(UBOOL*)Result=this->HasInProgressBandwidthTest();
    }
    DECLARE_FUNCTION(execCancelInProgressBandwidthTests)
    {
        P_FINISH;
        this->CancelInProgressBandwidthTests();
    }
    DECLARE_FUNCTION(execHasPendingBandwidthTest)
    {
        P_FINISH;
        *(UBOOL*)Result=this->HasPendingBandwidthTest();
    }
    DECLARE_FUNCTION(execCancelPendingBandwidthTests)
    {
        P_FINISH;
        this->CancelPendingBandwidthTests();
    }
    DECLARE_FUNCTION(execGetConnectionIndexForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerNetId);
        P_FINISH;
        *(INT*)Result=this->GetConnectionIndexForPlayer(PlayerNetId);
    }
    DECLARE_FUNCTION(execAllPlayersConnected)
    {
        P_GET_TARRAY_REF(struct FUniqueNetId,Players);
        P_FINISH;
        *(UBOOL*)Result=this->AllPlayersConnected(Players);
    }
    DECLARE_FUNCTION(execTellClientsToTravel)
    {
        P_GET_NAME(SessionName);
        P_GET_OBJECT(UClass,SearchClass);
        P_GET_ARRAY_REF(BYTE,PlatformSpecificInfo);
        P_FINISH;
        this->TellClientsToTravel(SessionName,SearchClass,PlatformSpecificInfo);
    }
    DECLARE_FUNCTION(execRequestClientCreateNewSession)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerNetId);
        P_GET_NAME(SessionName);
        P_GET_OBJECT(UClass,SearchClass);
        P_GET_TARRAY_REF(struct FPlayerMember,Players);
        P_FINISH;
        *(UBOOL*)Result=this->RequestClientCreateNewSession(PlayerNetId,SessionName,SearchClass,Players);
    }
    void delegateOnReceivedClientCreateNewSessionResult(UBOOL bSucceeded,FName SessionName,class UClass* SearchClass,const BYTE* PlatformSpecificInfo)
    {
        MeshBeaconHost_eventOnReceivedClientCreateNewSessionResult_Parms Parms(EC_EventParm);
        Parms.bSucceeded=bSucceeded ? FIRST_BITFIELD : FALSE;
        Parms.SessionName=SessionName;
        Parms.SearchClass=SearchClass;
        appMemcpy(Parms.PlatformSpecificInfo,PlatformSpecificInfo,sizeof(Parms.PlatformSpecificInfo));
        ProcessDelegate(IPDRV_OnReceivedClientCreateNewSessionResult,&__OnReceivedClientCreateNewSessionResult__Delegate,&Parms);
    }
    void delegateOnAllPendingPlayersConnected()
    {
        ProcessDelegate(IPDRV_OnAllPendingPlayersConnected,&__OnAllPendingPlayersConnected__Delegate,NULL);
    }
    void delegateOnFinishedBandwidthTest(struct FUniqueNetId PlayerNetId,BYTE TestType,BYTE TestResult,const struct FConnectionBandwidthStats& BandwidthStats)
    {
        MeshBeaconHost_eventOnFinishedBandwidthTest_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        Parms.TestType=TestType;
        Parms.TestResult=TestResult;
        Parms.BandwidthStats=BandwidthStats;
        ProcessDelegate(IPDRV_OnFinishedBandwidthTest,&__OnFinishedBandwidthTest__Delegate,&Parms);
    }
    void delegateOnStartedBandwidthTest(struct FUniqueNetId PlayerNetId,BYTE TestType)
    {
        MeshBeaconHost_eventOnStartedBandwidthTest_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        Parms.TestType=TestType;
        ProcessDelegate(IPDRV_OnStartedBandwidthTest,&__OnStartedBandwidthTest__Delegate,&Parms);
    }
    void delegateOnReceivedClientConnectionRequest(const struct FClientMeshBeaconConnection& NewClientConnection)
    {
        MeshBeaconHost_eventOnReceivedClientConnectionRequest_Parms Parms(EC_EventParm);
        Parms.NewClientConnection=NewClientConnection;
        ProcessDelegate(IPDRV_OnReceivedClientConnectionRequest,&__OnReceivedClientConnectionRequest__Delegate,&Parms);
    }
    DECLARE_CLASS(UMeshBeaconHost,UMeshBeacon,0|CLASS_Config,IpDrv)
	/**
	 * Ticks the network layer to see if there are any requests or responses to requests
	 *
	 * @param DeltaTime the amount of time that has elapsed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/** 
	 * Accepts any pending connections and adds them to our queue 
	 */
	void AcceptConnections(void);

	/**
	 * Reads the socket and processes any data from it
	 *
	 * @param ClientConn the client connection that sent the packet
	 * @return TRUE if the socket is ok, FALSE if it is in error
	 */
	UBOOL ReadClientData(FClientMeshBeaconConnection& ClientConn);

	/**
	 * Processes a packet that was received from a client
	 *
	 * @param Packet the packet that the client sent
	 * @param PacketSize the size of the packet to process
	 * @param ClientConn the client connection that sent the packet
	 */
	void ProcessClientPacket(BYTE* Packet,INT PacketSize,FClientMeshBeaconConnection& ClientConn);

	/**
	 * Routes the packet received from a client to the correct handler based on its type.
	 * Overridden by base implementations to handle custom data packet types
	 *
	 * @param ClientPacketType packet ID from EMeshBeaconPacketType (or derived version) that represents a client request
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 * @return TRUE if the requested packet type was processed
	 */
	UBOOL HandleClientPacketByType(BYTE ClientPacketType,FNboSerializeFromBuffer& FromBuffer,FClientMeshBeaconConnection& ClientConn);

	/**
	 * Read the client data for a new connection request. Includes player ID, NAT type, bandwidth history.
	 *
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 */
	void ProcessClientConnectionRequest(FNboSerializeFromBuffer& FromBuffer,FClientMeshBeaconConnection& ClientConn);

	/**
	 * Sends the results of a connection request by the client.
	 *
	 * @param ConnectionResult result of the connection request
	 * @param ClientConn the client connection with socket to send the response on
	 */
	void SendClientConnectionResponse(EMeshBeaconConnectionResult ConnectionResult,FClientMeshBeaconConnection& ClientConn);

	/**
	 * The client has started sending data for a new bandwidth test. 
	 * Begin measurements for test and process data that is received.
	 *
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 */
	void ProcessClientBeginBandwidthTest(FNboSerializeFromBuffer& FromBuffer,FClientMeshBeaconConnection& ClientConn);

	/**
	 * The client currently has a bandwidth test that has been started and is now in progress.
	 * Process data that is received and handle timeout and finishing the test.
	 * Only packets of type MB_Packet_DummyData are expected from the client once the test has started.
	 *
	 * @param PacketType type of packet read from the buffer
	 * @param AvailableToRead data still available to read from the buffer
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 */
	void ProcessClientInProgressBandwidthTest(BYTE PacketType,INT AvailableToRead,FNboSerializeFromBuffer& FromBuffer,FClientMeshBeaconConnection& ClientConn);

	/**
	 * Begin processing for a new upstream bandwidth test on a client.  All packets
	 * from the client are expected to be dummy packets from this point until NumBytesBeingSent is 
	 * reached or we hit timeout receiving the data (MaxBandwidthTestReceiveTime).
	 *
	 * @param ClientConn the client connection that is sending packets for the test
	 * @param NumBytesBeingSent expected size of test data being sent in bytes for the bandwidth test to complete
	 */
	void BeginUpstreamTest(FClientMeshBeaconConnection& ClientConn, INT NumBytesBeingSent);
	
	/**
	 * Finish process for an in-progress upstream bandwidth test on a client.  The test
	 * is marked as completed successfully if all the expected data for the test was received
	 * or if the test ended prematurely but there was still enough data (MinBandwidthTestBufferSize) 
	 * to calculate results.
	 *
	 * @param ClientConn the client connection that is sending packets for the test
	 */
	void FinishUpstreamTest(FClientMeshBeaconConnection& ClientConn);
	
	/**
	 * Sends a request to client to start a new bandwidth test.
	 *
	 * @param TestType EMeshBeaconBandwidthTestType type of bandwidth test to request
	 * @param TestBufferSize size of buffer to use for the test
	 * @param ClientConn the client connection with socket to send the response on
	 */
	void SendBandwidthTestStartRequest(BYTE TestType,INT TestBufferSize,FClientMeshBeaconConnection& ClientConn);

	/**
	 * Sends the results of a completed bandwidth test to the client.
	 *
	 * @param TestResult result of the bandwidth test
	 * @param ClientConn the client connection with socket to send the response on
	 */
	void SendBandwidthTestCompletedResponse(EMeshBeaconBandwidthTestResult TestResult,FClientMeshBeaconConnection& ClientConn);

	/**
	 * The client has create a new game session and has sent the session results back.
	 *
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 */
	void ProcessClientCreateNewSessionResponse(FNboSerializeFromBuffer& FromBuffer,FClientMeshBeaconConnection& ClientConn);
};

struct OnlineAuthInterfaceImpl_eventOnServerConnectionClose_Parms
{
    class UPlayer* ServerConnection;
    OnlineAuthInterfaceImpl_eventOnServerConnectionClose_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnClientConnectionClose_Parms
{
    class UPlayer* ClientConnection;
    OnlineAuthInterfaceImpl_eventOnClientConnectionClose_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnServerAuthRetryRequest_Parms
{
    class UPlayer* ClientConnection;
    OnlineAuthInterfaceImpl_eventOnServerAuthRetryRequest_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnClientAuthEndSessionRequest_Parms
{
    class UPlayer* ServerConnection;
    OnlineAuthInterfaceImpl_eventOnClientAuthEndSessionRequest_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnServerAuthComplete_Parms
{
    UBOOL bSuccess;
    struct FUniqueNetId ServerUID;
    class UPlayer* ServerConnection;
    FString ExtraInfo;
    OnlineAuthInterfaceImpl_eventOnServerAuthComplete_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnClientAuthComplete_Parms
{
    UBOOL bSuccess;
    struct FUniqueNetId ClientUID;
    class UPlayer* ClientConnection;
    FString ExtraInfo;
    OnlineAuthInterfaceImpl_eventOnClientAuthComplete_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnServerAuthResponse_Parms
{
    struct FUniqueNetId ServerUID;
    INT ServerIP;
    INT AuthTicketUID;
    OnlineAuthInterfaceImpl_eventOnServerAuthResponse_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnClientAuthResponse_Parms
{
    struct FUniqueNetId ClientUID;
    INT ClientIP;
    INT AuthTicketUID;
    OnlineAuthInterfaceImpl_eventOnClientAuthResponse_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnServerAuthRequest_Parms
{
    class UPlayer* ClientConnection;
    struct FUniqueNetId ClientUID;
    INT ClientIP;
    INT ClientPort;
    OnlineAuthInterfaceImpl_eventOnServerAuthRequest_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnClientAuthRequest_Parms
{
    struct FUniqueNetId ServerUID;
    INT ServerIP;
    INT ServerPort;
    UBOOL bSecure;
    OnlineAuthInterfaceImpl_eventOnClientAuthRequest_Parms(EEventParm)
    {
    }
};
struct OnlineAuthInterfaceImpl_eventOnAuthReady_Parms
{
    OnlineAuthInterfaceImpl_eventOnAuthReady_Parms(EEventParm)
    {
    }
};
class UOnlineAuthInterfaceImpl : public UObject, public IOnlineAuthInterface
{
public:
    //## BEGIN PROPS OnlineAuthInterfaceImpl
    class UOnlineSubsystemCommonImpl* OwningSubsystem;
    BITFIELD bAuthReady:1;
    SCRIPT_ALIGN;
    TSparseArray<FAuthSession> ClientAuthSessions;
    TSparseArray<FAuthSession> ServerAuthSessions;
    TSparseArray<FAuthSession> PeerAuthSessions;
    TSparseArray<FLocalAuthSession> LocalClientAuthSessions;
    TSparseArray<FLocalAuthSession> LocalServerAuthSessions;
    TSparseArray<FLocalAuthSession> LocalPeerAuthSessions;
    TArrayNoInit<FScriptDelegate> AuthReadyDelegates;
    TArrayNoInit<FScriptDelegate> ClientAuthRequestDelegates;
    TArrayNoInit<FScriptDelegate> ServerAuthRequestDelegates;
    TArrayNoInit<FScriptDelegate> ClientAuthResponseDelegates;
    TArrayNoInit<FScriptDelegate> ServerAuthResponseDelegates;
    TArrayNoInit<FScriptDelegate> ClientAuthCompleteDelegates;
    TArrayNoInit<FScriptDelegate> ServerAuthCompleteDelegates;
    TArrayNoInit<FScriptDelegate> ClientAuthEndSessionRequestDelegates;
    TArrayNoInit<FScriptDelegate> ServerAuthRetryRequestDelegates;
    TArrayNoInit<FScriptDelegate> ClientConnectionCloseDelegates;
    TArrayNoInit<FScriptDelegate> ServerConnectionCloseDelegates;
    FScriptDelegate __OnAuthReady__Delegate;
    FScriptDelegate __OnClientAuthRequest__Delegate;
    FScriptDelegate __OnServerAuthRequest__Delegate;
    FScriptDelegate __OnClientAuthResponse__Delegate;
    FScriptDelegate __OnServerAuthResponse__Delegate;
    FScriptDelegate __OnClientAuthComplete__Delegate;
    FScriptDelegate __OnServerAuthComplete__Delegate;
    FScriptDelegate __OnClientAuthEndSessionRequest__Delegate;
    FScriptDelegate __OnServerAuthRetryRequest__Delegate;
    FScriptDelegate __OnClientConnectionClose__Delegate;
    FScriptDelegate __OnServerConnectionClose__Delegate;
    //## END PROPS OnlineAuthInterfaceImpl

    virtual UBOOL SendClientAuthResponse(INT AuthTicketUID);
    virtual UBOOL SendServerAuthResponse(class UPlayer* ClientConnection,INT AuthTicketUID);
    virtual UBOOL SendClientAuthEndSessionRequest(class UPlayer* ClientConnection);
    virtual UBOOL SendServerAuthRetryRequest();
    void EndLocalClientAuthSession(struct FUniqueNetId ServerUID,INT ServerIP,INT ServerPort);
    void EndRemoteClientAuthSession(struct FUniqueNetId ClientUID,INT ClientIP);
    virtual void EndAllLocalClientAuthSessions();
    virtual void EndAllRemoteClientAuthSessions();
    void EndLocalServerAuthSession(struct FUniqueNetId ClientUID,INT ClientIP);
    void EndRemoteServerAuthSession(struct FUniqueNetId ServerUID,INT ServerIP);
    virtual void EndAllLocalServerAuthSessions();
    virtual void EndAllRemoteServerAuthSessions();
    virtual UBOOL FindClientAuthSession(class UPlayer* ClientConnection,struct FAuthSession& OutSessionInfo);
    virtual UBOOL FindLocalClientAuthSession(class UPlayer* ServerConnection,struct FLocalAuthSession& OutSessionInfo);
    virtual UBOOL FindServerAuthSession(class UPlayer* ServerConnection,struct FAuthSession& OutSessionInfo);
    virtual UBOOL FindLocalServerAuthSession(class UPlayer* ClientConnection,struct FLocalAuthSession& OutSessionInfo);
    DECLARE_FUNCTION(execSendClientAuthResponse)
    {
        P_GET_INT(AuthTicketUID);
        P_FINISH;
        *(UBOOL*)Result=this->SendClientAuthResponse(AuthTicketUID);
    }
    DECLARE_FUNCTION(execSendServerAuthResponse)
    {
        P_GET_OBJECT(UPlayer,ClientConnection);
        P_GET_INT(AuthTicketUID);
        P_FINISH;
        *(UBOOL*)Result=this->SendServerAuthResponse(ClientConnection,AuthTicketUID);
    }
    DECLARE_FUNCTION(execSendClientAuthEndSessionRequest)
    {
        P_GET_OBJECT(UPlayer,ClientConnection);
        P_FINISH;
        *(UBOOL*)Result=this->SendClientAuthEndSessionRequest(ClientConnection);
    }
    DECLARE_FUNCTION(execSendServerAuthRetryRequest)
    {
        P_FINISH;
        *(UBOOL*)Result=this->SendServerAuthRetryRequest();
    }
    DECLARE_FUNCTION(execEndLocalClientAuthSession)
    {
        P_GET_STRUCT(struct FUniqueNetId,ServerUID);
        P_GET_INT(ServerIP);
        P_GET_INT(ServerPort);
        P_FINISH;
        this->EndLocalClientAuthSession(ServerUID,ServerIP,ServerPort);
    }
    DECLARE_FUNCTION(execEndRemoteClientAuthSession)
    {
        P_GET_STRUCT(struct FUniqueNetId,ClientUID);
        P_GET_INT(ClientIP);
        P_FINISH;
        this->EndRemoteClientAuthSession(ClientUID,ClientIP);
    }
    DECLARE_FUNCTION(execEndAllLocalClientAuthSessions)
    {
        P_FINISH;
        this->EndAllLocalClientAuthSessions();
    }
    DECLARE_FUNCTION(execEndAllRemoteClientAuthSessions)
    {
        P_FINISH;
        this->EndAllRemoteClientAuthSessions();
    }
    DECLARE_FUNCTION(execEndLocalServerAuthSession)
    {
        P_GET_STRUCT(struct FUniqueNetId,ClientUID);
        P_GET_INT(ClientIP);
        P_FINISH;
        this->EndLocalServerAuthSession(ClientUID,ClientIP);
    }
    DECLARE_FUNCTION(execEndRemoteServerAuthSession)
    {
        P_GET_STRUCT(struct FUniqueNetId,ServerUID);
        P_GET_INT(ServerIP);
        P_FINISH;
        this->EndRemoteServerAuthSession(ServerUID,ServerIP);
    }
    DECLARE_FUNCTION(execEndAllLocalServerAuthSessions)
    {
        P_FINISH;
        this->EndAllLocalServerAuthSessions();
    }
    DECLARE_FUNCTION(execEndAllRemoteServerAuthSessions)
    {
        P_FINISH;
        this->EndAllRemoteServerAuthSessions();
    }
    DECLARE_FUNCTION(execAllClientAuthSessions);
    DECLARE_FUNCTION(execAllLocalClientAuthSessions);
    DECLARE_FUNCTION(execAllServerAuthSessions);
    DECLARE_FUNCTION(execAllLocalServerAuthSessions);
    DECLARE_FUNCTION(execFindClientAuthSession)
    {
        P_GET_OBJECT(UPlayer,ClientConnection);
        P_GET_STRUCT_REF(struct FAuthSession,OutSessionInfo);
        P_FINISH;
        *(UBOOL*)Result=this->FindClientAuthSession(ClientConnection,OutSessionInfo);
    }
    DECLARE_FUNCTION(execFindLocalClientAuthSession)
    {
        P_GET_OBJECT(UPlayer,ServerConnection);
        P_GET_STRUCT_REF(struct FLocalAuthSession,OutSessionInfo);
        P_FINISH;
        *(UBOOL*)Result=this->FindLocalClientAuthSession(ServerConnection,OutSessionInfo);
    }
    DECLARE_FUNCTION(execFindServerAuthSession)
    {
        P_GET_OBJECT(UPlayer,ServerConnection);
        P_GET_STRUCT_REF(struct FAuthSession,OutSessionInfo);
        P_FINISH;
        *(UBOOL*)Result=this->FindServerAuthSession(ServerConnection,OutSessionInfo);
    }
    DECLARE_FUNCTION(execFindLocalServerAuthSession)
    {
        P_GET_OBJECT(UPlayer,ClientConnection);
        P_GET_STRUCT_REF(struct FLocalAuthSession,OutSessionInfo);
        P_FINISH;
        *(UBOOL*)Result=this->FindLocalServerAuthSession(ClientConnection,OutSessionInfo);
    }
    void delegateOnServerConnectionClose(class UPlayer* ServerConnection)
    {
        OnlineAuthInterfaceImpl_eventOnServerConnectionClose_Parms Parms(EC_EventParm);
        Parms.ServerConnection=ServerConnection;
        ProcessDelegate(IPDRV_OnServerConnectionClose,&__OnServerConnectionClose__Delegate,&Parms);
    }
    void delegateOnClientConnectionClose(class UPlayer* ClientConnection)
    {
        OnlineAuthInterfaceImpl_eventOnClientConnectionClose_Parms Parms(EC_EventParm);
        Parms.ClientConnection=ClientConnection;
        ProcessDelegate(IPDRV_OnClientConnectionClose,&__OnClientConnectionClose__Delegate,&Parms);
    }
    void delegateOnServerAuthRetryRequest(class UPlayer* ClientConnection)
    {
        OnlineAuthInterfaceImpl_eventOnServerAuthRetryRequest_Parms Parms(EC_EventParm);
        Parms.ClientConnection=ClientConnection;
        ProcessDelegate(IPDRV_OnServerAuthRetryRequest,&__OnServerAuthRetryRequest__Delegate,&Parms);
    }
    void delegateOnClientAuthEndSessionRequest(class UPlayer* ServerConnection)
    {
        OnlineAuthInterfaceImpl_eventOnClientAuthEndSessionRequest_Parms Parms(EC_EventParm);
        Parms.ServerConnection=ServerConnection;
        ProcessDelegate(IPDRV_OnClientAuthEndSessionRequest,&__OnClientAuthEndSessionRequest__Delegate,&Parms);
    }
    void delegateOnServerAuthComplete(UBOOL bSuccess,struct FUniqueNetId ServerUID,class UPlayer* ServerConnection,const FString& ExtraInfo)
    {
        OnlineAuthInterfaceImpl_eventOnServerAuthComplete_Parms Parms(EC_EventParm);
        Parms.bSuccess=bSuccess ? FIRST_BITFIELD : FALSE;
        Parms.ServerUID=ServerUID;
        Parms.ServerConnection=ServerConnection;
        Parms.ExtraInfo=ExtraInfo;
        ProcessDelegate(IPDRV_OnServerAuthComplete,&__OnServerAuthComplete__Delegate,&Parms);
    }
    void delegateOnClientAuthComplete(UBOOL bSuccess,struct FUniqueNetId ClientUID,class UPlayer* ClientConnection,const FString& ExtraInfo)
    {
        OnlineAuthInterfaceImpl_eventOnClientAuthComplete_Parms Parms(EC_EventParm);
        Parms.bSuccess=bSuccess ? FIRST_BITFIELD : FALSE;
        Parms.ClientUID=ClientUID;
        Parms.ClientConnection=ClientConnection;
        Parms.ExtraInfo=ExtraInfo;
        ProcessDelegate(IPDRV_OnClientAuthComplete,&__OnClientAuthComplete__Delegate,&Parms);
    }
    void delegateOnServerAuthResponse(struct FUniqueNetId ServerUID,INT ServerIP,INT AuthTicketUID)
    {
        OnlineAuthInterfaceImpl_eventOnServerAuthResponse_Parms Parms(EC_EventParm);
        Parms.ServerUID=ServerUID;
        Parms.ServerIP=ServerIP;
        Parms.AuthTicketUID=AuthTicketUID;
        ProcessDelegate(IPDRV_OnServerAuthResponse,&__OnServerAuthResponse__Delegate,&Parms);
    }
    void delegateOnClientAuthResponse(struct FUniqueNetId ClientUID,INT ClientIP,INT AuthTicketUID)
    {
        OnlineAuthInterfaceImpl_eventOnClientAuthResponse_Parms Parms(EC_EventParm);
        Parms.ClientUID=ClientUID;
        Parms.ClientIP=ClientIP;
        Parms.AuthTicketUID=AuthTicketUID;
        ProcessDelegate(IPDRV_OnClientAuthResponse,&__OnClientAuthResponse__Delegate,&Parms);
    }
    void delegateOnServerAuthRequest(class UPlayer* ClientConnection,struct FUniqueNetId ClientUID,INT ClientIP,INT ClientPort)
    {
        OnlineAuthInterfaceImpl_eventOnServerAuthRequest_Parms Parms(EC_EventParm);
        Parms.ClientConnection=ClientConnection;
        Parms.ClientUID=ClientUID;
        Parms.ClientIP=ClientIP;
        Parms.ClientPort=ClientPort;
        ProcessDelegate(IPDRV_OnServerAuthRequest,&__OnServerAuthRequest__Delegate,&Parms);
    }
    void delegateOnClientAuthRequest(struct FUniqueNetId ServerUID,INT ServerIP,INT ServerPort,UBOOL bSecure)
    {
        OnlineAuthInterfaceImpl_eventOnClientAuthRequest_Parms Parms(EC_EventParm);
        Parms.ServerUID=ServerUID;
        Parms.ServerIP=ServerIP;
        Parms.ServerPort=ServerPort;
        Parms.bSecure=bSecure ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnClientAuthRequest,&__OnClientAuthRequest__Delegate,&Parms);
    }
    void delegateOnAuthReady()
    {
        ProcessDelegate(IPDRV_OnAuthReady,&__OnAuthReady__Delegate,NULL);
    }
    DECLARE_CLASS(UOnlineAuthInterfaceImpl,UObject,0,IpDrv)
    DECLARE_WITHIN(UOnlineSubsystemCommonImpl)
    virtual UObject* GetUObjectInterfaceOnlineAuthInterface(){return this;}
    #include "UOnlineAuthInterfaceImpl.h"
};

struct OnlineGameInterfaceImpl_eventOnQosStatusChanged_Parms
{
    INT NumComplete;
    INT NumTotal;
    OnlineGameInterfaceImpl_eventOnQosStatusChanged_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnJoinMigratedOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnJoinMigratedOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnMigrateOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnMigrateOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnRecalculateSkillRatingComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnRecalculateSkillRatingComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnGameInviteAccepted_Parms
{
    struct FOnlineGameSearchResult InviteResult;
    OnlineGameInterfaceImpl_eventOnGameInviteAccepted_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnArbitrationRegistrationComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnArbitrationRegistrationComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnEndOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnEndOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnStartOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnStartOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnUnregisterPlayerComplete_Parms
{
    FName SessionName;
    struct FUniqueNetId PlayerID;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnUnregisterPlayerComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnRegisterPlayerComplete_Parms
{
    FName SessionName;
    struct FUniqueNetId PlayerID;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnRegisterPlayerComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnJoinOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnJoinOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnCancelFindOnlineGamesComplete_Parms
{
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnCancelFindOnlineGamesComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnDestroyOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnDestroyOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnUpdateOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnUpdateOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnCreateOnlineGameComplete_Parms
{
    FName SessionName;
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnCreateOnlineGameComplete_Parms(EEventParm)
    {
    }
};
struct OnlineGameInterfaceImpl_eventOnFindOnlineGamesComplete_Parms
{
    UBOOL bWasSuccessful;
    OnlineGameInterfaceImpl_eventOnFindOnlineGamesComplete_Parms(EEventParm)
    {
    }
};
class UOnlineGameInterfaceImpl : public UObject
{
public:
    //## BEGIN PROPS OnlineGameInterfaceImpl
    class UOnlineSubsystemCommonImpl* OwningSubsystem;
    class UOnlineGameSettings* GameSettings;
    class UOnlineGameSearch* GameSearch;
    TArrayNoInit<FScriptDelegate> CreateOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> UpdateOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> DestroyOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> JoinOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> MigrateOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> JoinMigratedOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> RecalculateSkillRatingCompleteDelegates;
    TArrayNoInit<FScriptDelegate> StartOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> EndOnlineGameCompleteDelegates;
    TArrayNoInit<FScriptDelegate> FindOnlineGamesCompleteDelegates;
    TArrayNoInit<FScriptDelegate> CancelFindOnlineGamesCompleteDelegates;
    BYTE LanBeaconState;
    BYTE LanNonce[8];
    INT LanAnnouncePort;
    INT LanGameUniqueId;
    INT LanPacketPlatformMask;
    FLOAT LanQueryTimeLeft;
    FLOAT LanQueryTimeout;
    FLanBeacon* LanBeacon;
    FSessionInfo* SessionInfo;
    FScriptDelegate __OnFindOnlineGamesComplete__Delegate;
    FScriptDelegate __OnCreateOnlineGameComplete__Delegate;
    FScriptDelegate __OnUpdateOnlineGameComplete__Delegate;
    FScriptDelegate __OnDestroyOnlineGameComplete__Delegate;
    FScriptDelegate __OnCancelFindOnlineGamesComplete__Delegate;
    FScriptDelegate __OnJoinOnlineGameComplete__Delegate;
    FScriptDelegate __OnRegisterPlayerComplete__Delegate;
    FScriptDelegate __OnUnregisterPlayerComplete__Delegate;
    FScriptDelegate __OnStartOnlineGameComplete__Delegate;
    FScriptDelegate __OnEndOnlineGameComplete__Delegate;
    FScriptDelegate __OnArbitrationRegistrationComplete__Delegate;
    FScriptDelegate __OnGameInviteAccepted__Delegate;
    FScriptDelegate __OnRecalculateSkillRatingComplete__Delegate;
    FScriptDelegate __OnMigrateOnlineGameComplete__Delegate;
    FScriptDelegate __OnJoinMigratedOnlineGameComplete__Delegate;
    FScriptDelegate __OnQosStatusChanged__Delegate;
    //## END PROPS OnlineGameInterfaceImpl

    virtual UBOOL CreateOnlineGame(BYTE HostingPlayerNum,FName SessionName,class UOnlineGameSettings* NewGameSettings);
    virtual UBOOL DestroyOnlineGame(FName SessionName);
    virtual UBOOL FindOnlineGames(BYTE SearchingPlayerNum,class UOnlineGameSearch* SearchSettings);
    virtual UBOOL CancelFindOnlineGames();
    virtual UBOOL FreeSearchResults(class UOnlineGameSearch* Search);
    virtual UBOOL JoinOnlineGame(BYTE PlayerNum,FName SessionName,const struct FOnlineGameSearchResult& DesiredGame);
    virtual UBOOL GetResolvedConnectString(FName SessionName,FString& ConnectInfo);
    virtual UBOOL StartOnlineGame(FName SessionName);
    virtual UBOOL EndOnlineGame(FName SessionName);
    virtual UBOOL ReadPlatformSpecificSessionInfo(const struct FOnlineGameSearchResult& DesiredGame,BYTE* PlatformSpecificInfo);
    virtual UBOOL BindPlatformSpecificSessionToSearch(BYTE SearchingPlayerNum,class UOnlineGameSearch* SearchSettings,BYTE* PlatformSpecificInfo);
    DECLARE_FUNCTION(execCreateOnlineGame)
    {
        P_GET_BYTE(HostingPlayerNum);
        P_GET_NAME(SessionName);
        P_GET_OBJECT(UOnlineGameSettings,NewGameSettings);
        P_FINISH;
        *(UBOOL*)Result=this->CreateOnlineGame(HostingPlayerNum,SessionName,NewGameSettings);
    }
    DECLARE_FUNCTION(execDestroyOnlineGame)
    {
        P_GET_NAME(SessionName);
        P_FINISH;
        *(UBOOL*)Result=this->DestroyOnlineGame(SessionName);
    }
    DECLARE_FUNCTION(execFindOnlineGames)
    {
        P_GET_BYTE(SearchingPlayerNum);
        P_GET_OBJECT(UOnlineGameSearch,SearchSettings);
        P_FINISH;
        *(UBOOL*)Result=this->FindOnlineGames(SearchingPlayerNum,SearchSettings);
    }
    DECLARE_FUNCTION(execCancelFindOnlineGames)
    {
        P_FINISH;
        *(UBOOL*)Result=this->CancelFindOnlineGames();
    }
    DECLARE_FUNCTION(execFreeSearchResults)
    {
        P_GET_OBJECT(UOnlineGameSearch,Search);
        P_FINISH;
        *(UBOOL*)Result=this->FreeSearchResults(Search);
    }
    DECLARE_FUNCTION(execJoinOnlineGame)
    {
        P_GET_BYTE(PlayerNum);
        P_GET_NAME(SessionName);
        P_GET_STRUCT_REF(struct FOnlineGameSearchResult,DesiredGame);
        P_FINISH;
        *(UBOOL*)Result=this->JoinOnlineGame(PlayerNum,SessionName,DesiredGame);
    }
    DECLARE_FUNCTION(execGetResolvedConnectString)
    {
        P_GET_NAME(SessionName);
        P_GET_STR_REF(ConnectInfo);
        P_FINISH;
        *(UBOOL*)Result=this->GetResolvedConnectString(SessionName,ConnectInfo);
    }
    DECLARE_FUNCTION(execStartOnlineGame)
    {
        P_GET_NAME(SessionName);
        P_FINISH;
        *(UBOOL*)Result=this->StartOnlineGame(SessionName);
    }
    DECLARE_FUNCTION(execEndOnlineGame)
    {
        P_GET_NAME(SessionName);
        P_FINISH;
        *(UBOOL*)Result=this->EndOnlineGame(SessionName);
    }
    DECLARE_FUNCTION(execReadPlatformSpecificSessionInfo)
    {
        P_GET_STRUCT_REF(struct FOnlineGameSearchResult,DesiredGame);
        P_GET_ARRAY_REF(BYTE,PlatformSpecificInfo);
        P_FINISH;
        *(UBOOL*)Result=this->ReadPlatformSpecificSessionInfo(DesiredGame,PlatformSpecificInfo);
    }
    DECLARE_FUNCTION(execBindPlatformSpecificSessionToSearch)
    {
        P_GET_BYTE(SearchingPlayerNum);
        P_GET_OBJECT(UOnlineGameSearch,SearchSettings);
        P_GET_ARRAY(BYTE,PlatformSpecificInfo);
        P_FINISH;
        *(UBOOL*)Result=this->BindPlatformSpecificSessionToSearch(SearchingPlayerNum,SearchSettings,PlatformSpecificInfo);
    }
    void delegateOnQosStatusChanged(INT NumComplete,INT NumTotal)
    {
        OnlineGameInterfaceImpl_eventOnQosStatusChanged_Parms Parms(EC_EventParm);
        Parms.NumComplete=NumComplete;
        Parms.NumTotal=NumTotal;
        ProcessDelegate(IPDRV_OnQosStatusChanged,&__OnQosStatusChanged__Delegate,&Parms);
    }
    void delegateOnJoinMigratedOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnJoinMigratedOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnJoinMigratedOnlineGameComplete,&__OnJoinMigratedOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnMigrateOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnMigrateOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnMigrateOnlineGameComplete,&__OnMigrateOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnRecalculateSkillRatingComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnRecalculateSkillRatingComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnRecalculateSkillRatingComplete,&__OnRecalculateSkillRatingComplete__Delegate,&Parms);
    }
    void delegateOnGameInviteAccepted(const struct FOnlineGameSearchResult& InviteResult)
    {
        OnlineGameInterfaceImpl_eventOnGameInviteAccepted_Parms Parms(EC_EventParm);
        Parms.InviteResult=InviteResult;
        ProcessDelegate(IPDRV_OnGameInviteAccepted,&__OnGameInviteAccepted__Delegate,&Parms);
    }
    void delegateOnArbitrationRegistrationComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnArbitrationRegistrationComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnArbitrationRegistrationComplete,&__OnArbitrationRegistrationComplete__Delegate,&Parms);
    }
    void delegateOnEndOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnEndOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnEndOnlineGameComplete,&__OnEndOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnStartOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnStartOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnStartOnlineGameComplete,&__OnStartOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnUnregisterPlayerComplete(FName SessionName,struct FUniqueNetId PlayerID,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnUnregisterPlayerComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.PlayerID=PlayerID;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnUnregisterPlayerComplete,&__OnUnregisterPlayerComplete__Delegate,&Parms);
    }
    void delegateOnRegisterPlayerComplete(FName SessionName,struct FUniqueNetId PlayerID,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnRegisterPlayerComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.PlayerID=PlayerID;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnRegisterPlayerComplete,&__OnRegisterPlayerComplete__Delegate,&Parms);
    }
    void delegateOnJoinOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnJoinOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnJoinOnlineGameComplete,&__OnJoinOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnCancelFindOnlineGamesComplete(UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnCancelFindOnlineGamesComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnCancelFindOnlineGamesComplete,&__OnCancelFindOnlineGamesComplete__Delegate,&Parms);
    }
    void delegateOnDestroyOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnDestroyOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnDestroyOnlineGameComplete,&__OnDestroyOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnUpdateOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnUpdateOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnUpdateOnlineGameComplete,&__OnUpdateOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnCreateOnlineGameComplete(FName SessionName,UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnCreateOnlineGameComplete_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnCreateOnlineGameComplete,&__OnCreateOnlineGameComplete__Delegate,&Parms);
    }
    void delegateOnFindOnlineGamesComplete(UBOOL bWasSuccessful)
    {
        OnlineGameInterfaceImpl_eventOnFindOnlineGamesComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnFindOnlineGamesComplete,&__OnFindOnlineGamesComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UOnlineGameInterfaceImpl,UObject,0|CLASS_Config,IpDrv)
    DECLARE_WITHIN(UOnlineSubsystemCommonImpl)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    #include "UOnlineGameInterfaceImpl.h"
};

#define UCONST_PRIVATE_MATCH 3
#define UCONST_REC_MATCH 2
#define UCONST_RANKED_MATCH 1
#define UCONST_PLAYER_MATCH 0

struct FConfiguredGameSetting
{
    INT GameSettingId;
    FStringNoInit GameSettingsClassName;
    FStringNoInit URL;
    class UOnlineGameSettings* GameSettings;

    /** Constructors */
    FConfiguredGameSetting() {}
    FConfiguredGameSetting(EEventParm)
    {
        appMemzero(this, sizeof(FConfiguredGameSetting));
    }
};

struct FInventorySwap
{
    FName Original;
    FStringNoInit SwapTo;

    /** Constructors */
    FInventorySwap() {}
    FInventorySwap(EEventParm)
    {
        appMemzero(this, sizeof(FInventorySwap));
    }
};

struct FPlaylist
{
    TArrayNoInit<struct FConfiguredGameSetting> ConfiguredGames;
    INT PlaylistId;
    INT LoadBalanceId;
    FStringNoInit LocalizationString;
    TArrayNoInit<INT> ContentIds;
    INT TeamSize;
    INT TeamCount;
    INT MaxPartySize;
    FStringNoInit Name;
    FStringNoInit URL;
    INT MatchType;
    BITFIELD bDisableDedicatedServerSearches:1;
    TArrayNoInit<FName> MapCycle;
    TArrayNoInit<struct FInventorySwap> InventorySwaps;

    /** Constructors */
    FPlaylist() {}
    FPlaylist(EEventParm)
    {
        appMemzero(this, sizeof(FPlaylist));
    }
};

struct FPlaylistPopulation
{
    INT PlaylistId;
    INT WorldwideTotal;
    INT RegionTotal;

    /** Constructors */
    FPlaylistPopulation() {}
    FPlaylistPopulation(EEventParm)
    {
        appMemzero(this, sizeof(FPlaylistPopulation));
    }
};

struct OnlinePlaylistManager_eventSendPlaylistPopulationUpdate_Parms
{
    INT NumPlayers;
    OnlinePlaylistManager_eventSendPlaylistPopulationUpdate_Parms(EEventParm)
    {
    }
};
struct OnlinePlaylistManager_eventOnPlaylistPopulationDataUpdated_Parms
{
    OnlinePlaylistManager_eventOnPlaylistPopulationDataUpdated_Parms(EEventParm)
    {
    }
};
struct OnlinePlaylistManager_eventOnReadPlaylistComplete_Parms
{
    UBOOL bWasSuccessful;
    OnlinePlaylistManager_eventOnReadPlaylistComplete_Parms(EEventParm)
    {
    }
};
class UOnlinePlaylistManager : public UObject, public FTickableObject
{
public:
    //## BEGIN PROPS OnlinePlaylistManager
    TArrayNoInit<struct FPlaylist> Playlists;
    TArrayNoInit<FString> PlaylistFileNames;
    TArrayNoInit<FName> DatastoresToRefresh;
    INT DownloadCount;
    INT SuccessfulCount;
    INT VersionNumber;
    TArrayNoInit<struct FPlaylistPopulation> PopulationData;
    INT WorldwideTotalPlayers;
    INT RegionTotalPlayers;
    TScriptInterface<class IInterface> TitleFileInterface;
    FStringNoInit PopulationFileName;
    FLOAT NextPlaylistPopulationUpdateTime;
    FLOAT PlaylistPopulationUpdateInterval;
    INT MinPlaylistIdToReport;
    INT CurrentPlaylistId;
    FName EventsInterfaceName;
    INT DataCenterId;
    FStringNoInit DataCenterFileName;
    FLOAT LastPlaylistDownloadTime;
    FLOAT PlaylistRefreshInterval;
    FScriptDelegate __OnReadPlaylistComplete__Delegate;
    FScriptDelegate __OnPlaylistPopulationDataUpdated__Delegate;
    //## END PROPS OnlinePlaylistManager

    virtual void DetermineFilesToDownload();
    virtual UBOOL ShouldRefreshPlaylists();
    virtual void FinalizePlaylistObjects();
    virtual void ParsePlaylistPopulationData(const TArray<BYTE>& Data);
    virtual void ParseDataCenterId(const TArray<BYTE>& Data);
    DECLARE_FUNCTION(execDetermineFilesToDownload)
    {
        P_FINISH;
        this->DetermineFilesToDownload();
    }
    DECLARE_FUNCTION(execShouldRefreshPlaylists)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ShouldRefreshPlaylists();
    }
    DECLARE_FUNCTION(execFinalizePlaylistObjects)
    {
        P_FINISH;
        this->FinalizePlaylistObjects();
    }
    DECLARE_FUNCTION(execParsePlaylistPopulationData)
    {
        P_GET_TARRAY_REF(BYTE,Data);
        P_FINISH;
        this->ParsePlaylistPopulationData(Data);
    }
    DECLARE_FUNCTION(execParseDataCenterId)
    {
        P_GET_TARRAY_REF(BYTE,Data);
        P_FINISH;
        this->ParseDataCenterId(Data);
    }
    void eventSendPlaylistPopulationUpdate(INT NumPlayers)
    {
        OnlinePlaylistManager_eventSendPlaylistPopulationUpdate_Parms Parms(EC_EventParm);
        Parms.NumPlayers=NumPlayers;
        ProcessEvent(FindFunctionChecked(IPDRV_SendPlaylistPopulationUpdate),&Parms);
    }
    void delegateOnPlaylistPopulationDataUpdated()
    {
        ProcessDelegate(IPDRV_OnPlaylistPopulationDataUpdated,&__OnPlaylistPopulationDataUpdated__Delegate,NULL);
    }
    void delegateOnReadPlaylistComplete(UBOOL bWasSuccessful)
    {
        OnlinePlaylistManager_eventOnReadPlaylistComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(IPDRV_OnReadPlaylistComplete,&__OnReadPlaylistComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UOnlinePlaylistManager,UObject,0|CLASS_Config,IpDrv)
    static const TCHAR* StaticConfigName() {return TEXT("Playlist");}

// FTickableObject interface

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags(RF_Unreachable | RF_AsyncLoading);
	}

	/**
	 * Used to determine if an object should be ticked when the game is paused.
	 *
	 * @return always TRUE as networking needs to be ticked even when paused
	 */
	virtual UBOOL IsTickableWhenPaused() const
	{
		return TRUE;
	}

	/**
	 * Determines whether an update of the playlist population information is needed or not
	 *
	 * @param DeltaTime the amount of time that has passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);
};

struct OnlineSubsystemCommonImpl_eventGetPlayerNicknameFromIndex_Parms
{
    INT UserIndex;
    FString ReturnValue;
    OnlineSubsystemCommonImpl_eventGetPlayerNicknameFromIndex_Parms(EEventParm)
    {
    }
};
class UOnlineSubsystemCommonImpl : public UOnlineSubsystem
{
public:
    //## BEGIN PROPS OnlineSubsystemCommonImpl
    class FVoiceInterface* VoiceEngine;
    INT MaxLocalTalkers;
    INT MaxRemoteTalkers;
    BITFIELD bIsUsingSpeechRecognition:1;
    class UOnlineGameInterfaceImpl* GameInterfaceImpl;
    class UOnlineAuthInterfaceImpl* AuthInterfaceImpl;
    //## END PROPS OnlineSubsystemCommonImpl

    virtual UBOOL IsPlayerInSession(FName SessionName,struct FUniqueNetId PlayerID);
    DECLARE_FUNCTION(execIsPlayerInSession)
    {
        P_GET_NAME(SessionName);
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_FINISH;
        *(UBOOL*)Result=this->IsPlayerInSession(SessionName,PlayerID);
    }
    FString eventGetPlayerNicknameFromIndex(INT UserIndex)
    {
        OnlineSubsystemCommonImpl_eventGetPlayerNicknameFromIndex_Parms Parms(EC_EventParm);
        Parms.UserIndex=UserIndex;
        ProcessEvent(FindFunctionChecked(IPDRV_GetPlayerNicknameFromIndex),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UOnlineSubsystemCommonImpl,UOnlineSubsystem,0|CLASS_Config,IpDrv)
    #include "UOnlineSubsystemCommonImpl.h"
};

struct FPlayerReservation
{
    struct FUniqueNetId NetId;
    INT Skill;
    INT XpLevel;
    DOUBLE Mu;
    DOUBLE Sigma;
    FLOAT ElapsedSessionTime;

		/** Constructors */
		FPlayerReservation() {}
		FPlayerReservation(EEventParm)
		{
			appMemzero(this, sizeof(FPlayerReservation));
		}
		/**
		 * Serialize from NBO buffer to FPlayerReservation
		 */
		friend FNboSerializeFromBuffer& operator>>(FNboSerializeFromBuffer& Ar,FPlayerReservation& PlayerRes);
		/**
		 * Serialize from FPlayerReservation to NBO buffer
		 */
		friend FNboSerializeToBuffer& operator<<(FNboSerializeToBuffer& Ar,const FPlayerReservation& PlayerRes);
	
};

struct FPartyReservation
{
    INT TeamNum;
    struct FUniqueNetId PartyLeader;
    TArrayNoInit<struct FPlayerReservation> PartyMembers;

    /** Constructors */
    FPartyReservation() {}
    FPartyReservation(EEventParm)
    {
        appMemzero(this, sizeof(FPartyReservation));
    }
};

struct PartyBeacon_eventOnDestroyComplete_Parms
{
    PartyBeacon_eventOnDestroyComplete_Parms(EEventParm)
    {
    }
};
struct PartyBeacon_eventDestroyBeacon_Parms
{
    PartyBeacon_eventDestroyBeacon_Parms(EEventParm)
    {
    }
};
class UPartyBeacon : public UObject, public FTickableObject
{
public:
    //## BEGIN PROPS PartyBeacon
    INT PartyBeaconPort;
    FSocket* Socket;
    BITFIELD bIsInTick:1;
    BITFIELD bWantsDeferredDestroy:1;
    BITFIELD bShouldTick:1;
    FLOAT HeartbeatTimeout;
    FLOAT ElapsedHeartbeatTime;
    FName BeaconName;
    FScriptDelegate __OnDestroyComplete__Delegate;
    //## END PROPS PartyBeacon

    virtual void DestroyBeacon();
    DECLARE_FUNCTION(execDestroyBeacon)
    {
        P_FINISH;
        this->DestroyBeacon();
    }
    void delegateOnDestroyComplete()
    {
        ProcessDelegate(IPDRV_OnDestroyComplete,&__OnDestroyComplete__Delegate,NULL);
    }
    void eventDestroyBeacon()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_DestroyBeacon),NULL);
    }
    DECLARE_CLASS(UPartyBeacon,UObject,0|CLASS_Config,IpDrv)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

// FTickableObject interface

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}

	/**
	 * Used to determine if an object should be ticked when the game is paused.
	 *
	 * @return always TRUE as networking needs to be ticked even when paused
	 */
	virtual UBOOL IsTickableWhenPaused() const
	{
		return TRUE;
	}

	/**
	 * Ticks the network layer to see if there are any requests or responses to requests
	 *
	 * @param DeltaTime the amount of time that has elapsed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Converts a host response code to a readable string
	 *
	 * @param Result the code to translate
	 *
	 * @return the string that maps to it
	 */
	inline const TCHAR* PartyReservationResultToString(EPartyReservationResult Result)
	{
		switch (Result)
		{
			case PRR_PartyLimitReached: return TEXT("PRR_PartyLimitReached");
			case PRR_IncorrectPlayerCount: return TEXT("PRR_IncorrectPlayerCount");
			case PRR_RequestTimedOut: return TEXT("PRR_RequestTimedOut");
			case PRR_ReservationDuplicate: return TEXT("PRR_ReservationDuplicate");
			case PRR_ReservationNotFound: return TEXT("PRR_ReservationNotFound");
			case PRR_ReservationAccepted: return TEXT("PRR_ReservationAccepted");
			case PRR_ReservationDenied: return TEXT("PRR_ReservationDenied");
		}
		return TEXT("PRR_GeneralError");
	}

	/**
	 * Sends a heartbeat packet to the specified socket
	 *
	 * @param Socket the socket to send the data on
	 *
	 * @return TRUE if it sent ok, FALSE if there was an error
	 */
	UBOOL SendHeartbeat(FSocket* Socket);

	/**
	 * @return the max value for the packet types handled by this beacon 
	 */
	virtual BYTE GetMaxPacketValue()
	{
		return RPT_MAX;
	}
};

struct PartyBeaconClient_eventOnHostHasCancelled_Parms
{
    PartyBeaconClient_eventOnHostHasCancelled_Parms(EEventParm)
    {
    }
};
struct PartyBeaconClient_eventOnHostIsReady_Parms
{
    PartyBeaconClient_eventOnHostIsReady_Parms(EEventParm)
    {
    }
};
struct PartyBeaconClient_eventOnTravelRequestReceived_Parms
{
    FName SessionName;
    class UClass* SearchClass;
    BYTE PlatformSpecificInfo[80];
    PartyBeaconClient_eventOnTravelRequestReceived_Parms(EEventParm)
    {
    }
};
struct PartyBeaconClient_eventOnReservationCountUpdated_Parms
{
    INT ReservationRemaining;
    PartyBeaconClient_eventOnReservationCountUpdated_Parms(EEventParm)
    {
    }
};
struct PartyBeaconClient_eventOnReservationRequestComplete_Parms
{
    BYTE ReservationResult;
    PartyBeaconClient_eventOnReservationRequestComplete_Parms(EEventParm)
    {
    }
};
class UPartyBeaconClient : public UPartyBeacon
{
public:
    //## BEGIN PROPS PartyBeaconClient
    struct FOnlineGameSearchResult HostPendingRequest;
    struct FPartyReservation PendingRequest;
    BYTE ClientBeaconState;
    BYTE ClientBeaconRequestType;
    FLOAT ReservationRequestTimeout;
    FLOAT ReservationRequestElapsedTime;
    FStringNoInit ResolverClassName;
    class UClass* ResolverClass;
    class UClientBeaconAddressResolver* Resolver;
    FScriptDelegate __OnReservationRequestComplete__Delegate;
    FScriptDelegate __OnReservationCountUpdated__Delegate;
    FScriptDelegate __OnTravelRequestReceived__Delegate;
    FScriptDelegate __OnHostIsReady__Delegate;
    FScriptDelegate __OnHostHasCancelled__Delegate;
    //## END PROPS PartyBeaconClient

    virtual UBOOL RequestReservation(const struct FOnlineGameSearchResult& DesiredHost,struct FUniqueNetId RequestingPartyLeader,const TArray<struct FPlayerReservation>& Players);
    virtual UBOOL RequestReservationUpdate(const struct FOnlineGameSearchResult& DesiredHost,struct FUniqueNetId RequestingPartyLeader,const TArray<struct FPlayerReservation>& PlayersToAdd);
    virtual UBOOL CancelReservation(struct FUniqueNetId CancellingPartyLeader);
    virtual void DestroyBeacon();
    DECLARE_FUNCTION(execRequestReservation)
    {
        P_GET_STRUCT_REF(struct FOnlineGameSearchResult,DesiredHost);
        P_GET_STRUCT(struct FUniqueNetId,RequestingPartyLeader);
        P_GET_TARRAY_REF(struct FPlayerReservation,Players);
        P_FINISH;
        *(UBOOL*)Result=this->RequestReservation(DesiredHost,RequestingPartyLeader,Players);
    }
    DECLARE_FUNCTION(execRequestReservationUpdate)
    {
        P_GET_STRUCT_REF(struct FOnlineGameSearchResult,DesiredHost);
        P_GET_STRUCT(struct FUniqueNetId,RequestingPartyLeader);
        P_GET_TARRAY_REF(struct FPlayerReservation,PlayersToAdd);
        P_FINISH;
        *(UBOOL*)Result=this->RequestReservationUpdate(DesiredHost,RequestingPartyLeader,PlayersToAdd);
    }
    DECLARE_FUNCTION(execCancelReservation)
    {
        P_GET_STRUCT(struct FUniqueNetId,CancellingPartyLeader);
        P_FINISH;
        *(UBOOL*)Result=this->CancelReservation(CancellingPartyLeader);
    }
    void delegateOnHostHasCancelled()
    {
        ProcessDelegate(IPDRV_OnHostHasCancelled,&__OnHostHasCancelled__Delegate,NULL);
    }
    void delegateOnHostIsReady()
    {
        ProcessDelegate(IPDRV_OnHostIsReady,&__OnHostIsReady__Delegate,NULL);
    }
    void delegateOnTravelRequestReceived(FName SessionName,class UClass* SearchClass,BYTE* PlatformSpecificInfo)
    {
        PartyBeaconClient_eventOnTravelRequestReceived_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.SearchClass=SearchClass;
        appMemcpy(Parms.PlatformSpecificInfo,PlatformSpecificInfo,sizeof(Parms.PlatformSpecificInfo));
        ProcessDelegate(IPDRV_OnTravelRequestReceived,&__OnTravelRequestReceived__Delegate,&Parms);
    }
    void delegateOnReservationCountUpdated(INT ReservationRemaining)
    {
        PartyBeaconClient_eventOnReservationCountUpdated_Parms Parms(EC_EventParm);
        Parms.ReservationRemaining=ReservationRemaining;
        ProcessDelegate(IPDRV_OnReservationCountUpdated,&__OnReservationCountUpdated__Delegate,&Parms);
    }
    void delegateOnReservationRequestComplete(BYTE ReservationResult)
    {
        PartyBeaconClient_eventOnReservationRequestComplete_Parms Parms(EC_EventParm);
        Parms.ReservationResult=ReservationResult;
        ProcessDelegate(IPDRV_OnReservationRequestComplete,&__OnReservationRequestComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UPartyBeaconClient,UPartyBeacon,0|CLASS_Config,IpDrv)
	/**
	 * Ticks the network layer to see if there are any requests or responses to requests
	 *
	 * @param DeltaTime the amount of time that has elapsed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Loads the class specified for the Resolver and constructs it if needed
	 */
	void InitResolver(void);

	/**
	 * Creates a beacon that will send requests to remote hosts
	 *
	 * @param Addr the address that we are connecting to (needs to be resolved)
	 *
	 * @return true if the beacon was created successfully, false otherwise
	 */
	UBOOL InitClientBeacon(const FInternetIpAddr& Addr);

	/**
	 * Once the socket has been established, it sends the pending request to the host
	 */
	virtual void SendReservationRequest(void);

	/**
	 * Processes a packet that was received from the host indicating success or
	 * failure for our reservation
	 *
	 * @param Packet the packet that the host sent
	 * @param PacketSize the size of the packet to process
	 */
	void ProcessHostResponse(BYTE* Packet,INT PacketSize);

	/**
	 * Routes the response packet received from a host to the correct handler based on its type.
	 * Overridden by base implementations to handle custom packet types
	 *
	 * @param HostResponsePacketType packet ID from EReservationPacketType (or derived version) that represents a host response to this client
	 * @param FromBuffer the packet serializer to read from
	 * @return TRUE if the data packet type was processed
	 */
	virtual UBOOL HandleHostResponsePacketType(BYTE HostResponsePacketType,FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Processes a reservation response packet that was received from the host
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	virtual void ProcessReservationResponse(FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Processes a reservation count update packet that was received from the host
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	virtual void ProcessReservationCountUpdate(FNboSerializeFromBuffer& FromBuffer);

	/**
	 * Processes a heartbeat update, sends a heartbeat back, and clears the timer
	 */
	void ProcessHeartbeat(void);

	/**
	 * Notifies the delegates that the host is ready to play
	 */
	void ProcessHostIsReady(void);

	/**
	 * Processes a travel request packet that was received from the host
	 *
	 * @param FromBuffer the packet serializer to read from
	 */
	void ProcessTravelRequest(FNboSerializeFromBuffer& FromBuffer);

	/** Unregisters the address and zeros the members involved to prevent multiple releases */
	void CleanupAddress(void);

	/**
	 * Handles checking for the transition from connecting to connected (socket established)
	 */
	void CheckConnectionStatus(void);

	/**
	 * Checks the socket for a response from the and processes if present
	 */
	void ReadResponse(void);

	/** Common routine for canceling matchmaking */
	inline void ProcessHostCancelled(void)
	{
		CleanupAddress();
		delegateOnHostHasCancelled();
	}

	/** Common routine for notifying of a timeout trying to talk to host */
	inline void ProcessHostTimeout(void)
	{
		CleanupAddress();
		delegateOnReservationRequestComplete(PRR_RequestTimedOut);
	}
};

struct FClientBeaconConnection
{
    struct FUniqueNetId PartyLeader;
    FLOAT ElapsedHeartbeatTime;
    FSocket* Socket;

    /** Constructors */
    FClientBeaconConnection() {}
    FClientBeaconConnection(EEventParm)
    {
        appMemzero(this, sizeof(FClientBeaconConnection));
    }
};

struct PartyBeaconHost_eventUnregisterParty_Parms
{
    struct FUniqueNetId PartyLeader;
    PartyBeaconHost_eventUnregisterParty_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventUnregisterPartyMembers_Parms
{
    PartyBeaconHost_eventUnregisterPartyMembers_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventRegisterPartyMembers_Parms
{
    PartyBeaconHost_eventRegisterPartyMembers_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventOnClientCancellationReceived_Parms
{
    struct FUniqueNetId PartyLeader;
    PartyBeaconHost_eventOnClientCancellationReceived_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventOnReservationsFull_Parms
{
    PartyBeaconHost_eventOnReservationsFull_Parms(EEventParm)
    {
    }
};
struct PartyBeaconHost_eventOnReservationChange_Parms
{
    PartyBeaconHost_eventOnReservationChange_Parms(EEventParm)
    {
    }
};
class UPartyBeaconHost : public UPartyBeacon
{
public:
    //## BEGIN PROPS PartyBeaconHost
    TArrayNoInit<struct FClientBeaconConnection> Clients;
    INT NumTeams;
    INT NumPlayersPerTeam;
    INT NumReservations;
    INT NumConsumedReservations;
    TArrayNoInit<struct FPartyReservation> Reservations;
    FName OnlineSessionName;
    INT ConnectionBacklog;
    INT ForceTeamNum;
    INT ReservedHostTeamNum;
    BITFIELD bBestFitTeamAssignment:1;
    SCRIPT_ALIGN;
    BYTE BeaconState;
    FScriptDelegate __OnReservationChange__Delegate;
    FScriptDelegate __OnReservationsFull__Delegate;
    FScriptDelegate __OnClientCancellationReceived__Delegate;
    //## END PROPS PartyBeaconHost

    virtual void PauseReservationRequests(UBOOL bPause);
    virtual UBOOL InitHostBeacon(INT InNumTeams,INT InNumPlayersPerTeam,INT InNumReservations,FName InSessionName,INT InForceTeamNum=0);
    virtual BYTE AddPartyReservationEntry(struct FUniqueNetId PartyLeader,const TArray<struct FPlayerReservation>& PlayerMembers,INT TeamNum,UBOOL bIsHost);
    virtual BYTE UpdatePartyReservationEntry(struct FUniqueNetId PartyLeader,const TArray<struct FPlayerReservation>& PlayerMembers);
    virtual INT GetExistingReservation(const struct FUniqueNetId& PartyLeader);
    virtual void HandlePlayerLogout(struct FUniqueNetId PlayerID,UBOOL bMaintainParty);
    virtual void DestroyBeacon();
    virtual void TellClientsToTravel(FName SessionName,class UClass* SearchClass,BYTE* PlatformSpecificInfo);
    virtual void TellClientsHostIsReady();
    virtual void TellClientsHostHasCancelled();
    virtual void AppendReservationSkillsToSearch(class UOnlineGameSearch* Search);
    virtual INT GetMaxAvailableTeamSize();
    DECLARE_FUNCTION(execPauseReservationRequests)
    {
        P_GET_UBOOL(bPause);
        P_FINISH;
        this->PauseReservationRequests(bPause);
    }
    DECLARE_FUNCTION(execInitHostBeacon)
    {
        P_GET_INT(InNumTeams);
        P_GET_INT(InNumPlayersPerTeam);
        P_GET_INT(InNumReservations);
        P_GET_NAME(InSessionName);
        P_GET_INT_OPTX(InForceTeamNum,0);
        P_FINISH;
        *(UBOOL*)Result=this->InitHostBeacon(InNumTeams,InNumPlayersPerTeam,InNumReservations,InSessionName,InForceTeamNum);
    }
    DECLARE_FUNCTION(execAddPartyReservationEntry)
    {
        P_GET_STRUCT(struct FUniqueNetId,PartyLeader);
        P_GET_TARRAY_REF(struct FPlayerReservation,PlayerMembers);
        P_GET_INT(TeamNum);
        P_GET_UBOOL(bIsHost);
        P_FINISH;
        *(BYTE*)Result=this->AddPartyReservationEntry(PartyLeader,PlayerMembers,TeamNum,bIsHost);
    }
    DECLARE_FUNCTION(execUpdatePartyReservationEntry)
    {
        P_GET_STRUCT(struct FUniqueNetId,PartyLeader);
        P_GET_TARRAY_REF(struct FPlayerReservation,PlayerMembers);
        P_FINISH;
        *(BYTE*)Result=this->UpdatePartyReservationEntry(PartyLeader,PlayerMembers);
    }
    DECLARE_FUNCTION(execGetExistingReservation)
    {
        P_GET_STRUCT_REF(struct FUniqueNetId,PartyLeader);
        P_FINISH;
        *(INT*)Result=this->GetExistingReservation(PartyLeader);
    }
    DECLARE_FUNCTION(execHandlePlayerLogout)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_UBOOL(bMaintainParty);
        P_FINISH;
        this->HandlePlayerLogout(PlayerID,bMaintainParty);
    }
    DECLARE_FUNCTION(execTellClientsToTravel)
    {
        P_GET_NAME(SessionName);
        P_GET_OBJECT(UClass,SearchClass);
        P_GET_ARRAY(BYTE,PlatformSpecificInfo);
        P_FINISH;
        this->TellClientsToTravel(SessionName,SearchClass,PlatformSpecificInfo);
    }
    DECLARE_FUNCTION(execTellClientsHostIsReady)
    {
        P_FINISH;
        this->TellClientsHostIsReady();
    }
    DECLARE_FUNCTION(execTellClientsHostHasCancelled)
    {
        P_FINISH;
        this->TellClientsHostHasCancelled();
    }
    DECLARE_FUNCTION(execAppendReservationSkillsToSearch)
    {
        P_GET_OBJECT(UOnlineGameSearch,Search);
        P_FINISH;
        this->AppendReservationSkillsToSearch(Search);
    }
    DECLARE_FUNCTION(execGetMaxAvailableTeamSize)
    {
        P_FINISH;
        *(INT*)Result=this->GetMaxAvailableTeamSize();
    }
    void eventUnregisterParty(struct FUniqueNetId PartyLeader)
    {
        PartyBeaconHost_eventUnregisterParty_Parms Parms(EC_EventParm);
        Parms.PartyLeader=PartyLeader;
        ProcessEvent(FindFunctionChecked(IPDRV_UnregisterParty),&Parms);
    }
    void eventUnregisterPartyMembers()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_UnregisterPartyMembers),NULL);
    }
    void eventRegisterPartyMembers()
    {
        ProcessEvent(FindFunctionChecked(IPDRV_RegisterPartyMembers),NULL);
    }
    void delegateOnClientCancellationReceived(struct FUniqueNetId PartyLeader)
    {
        PartyBeaconHost_eventOnClientCancellationReceived_Parms Parms(EC_EventParm);
        Parms.PartyLeader=PartyLeader;
        ProcessDelegate(IPDRV_OnClientCancellationReceived,&__OnClientCancellationReceived__Delegate,&Parms);
    }
    void delegateOnReservationsFull()
    {
        ProcessDelegate(IPDRV_OnReservationsFull,&__OnReservationsFull__Delegate,NULL);
    }
    void delegateOnReservationChange()
    {
        ProcessDelegate(IPDRV_OnReservationChange,&__OnReservationChange__Delegate,NULL);
    }
    DECLARE_CLASS(UPartyBeaconHost,UPartyBeacon,0|CLASS_Config,IpDrv)
	/**
	 * Ticks the network layer to see if there are any requests or responses to requests
	 *
	 * @param DeltaTime the amount of time that has elapsed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/** Accepts any pending connections and adds them to our queue */
	void AcceptConnections(void);

	/**
	 * Reads the socket and processes any data from it
	 *
	 * @param ClientConn the client connection that sent the packet
	 *
	 * @return TRUE if the socket is ok, FALSE if it is in error
	 */
	UBOOL ReadClientData(FClientBeaconConnection& ClientConn);

	/**
	 * Processes a packet that was received from a client
	 *
	 * @param Packet the packet that the client sent
	 * @param PacketSize the size of the packet to process
	 * @param ClientConn the client connection that sent the packet
	 */
	void ProcessRequest(BYTE* Packet,INT PacketSize,FClientBeaconConnection& ClientConn);

	/**
	 * Routes the packet received from a client to the correct handler based on its type.
	 * Overridden by base implementations to handle custom data packet types
	 *
	 * @param RequestPacketType packet ID from EReservationPacketType (or derived version) that represents a client request
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 * @return TRUE if the requested packet type was processed
	 */
	virtual UBOOL HandleClientRequestPacketType(BYTE RequestPacketType,FNboSerializeFromBuffer& FromBuffer,FClientBeaconConnection& ClientConn);

	/**
	 * Processes a reservation packet that was received from a client
	 *
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 */
	virtual void ProcessReservationRequest(FNboSerializeFromBuffer& FromBuffer,FClientBeaconConnection& ClientConn);

	/**
	 * Processes a reservation update packet that was received from a client
	 * The update finds an existing reservation based on the party leader and
	 * then tries to add new players to it (can't remove). Then sends a response to
	 * the client based on the update results (see EPartyReservationResult).
	 *
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 */
	virtual void ProcessReservationUpdateRequest(FNboSerializeFromBuffer& FromBuffer,FClientBeaconConnection& ClientConn);

	/**
	 * Processes a cancellation packet that was received from a client
	 *
	 * @param FromBuffer the packet serializer to read from
	 * @param ClientConn the client connection that sent the packet
	 */
	virtual void ProcessCancellationRequest(FNboSerializeFromBuffer& FromBuffer,FClientBeaconConnection& ClientConn);

	/**
	 * Sends a client the specified response code
	 *
	 * @param Result the result being sent to the client
	 * @param ClientSocket the client socket to send the response on
	 */
	void SendReservationResponse(EPartyReservationResult Result,FSocket* ClientSocket);

	/**
	 * Tells clients that a reservation update has occured and sends them the current
	 * number of remaining reservations so they can update their UI
	 */
	void SendReservationUpdates(void);

	/**
	 * Initializes the team array so that random choices can be made from it
	 * Also initializes the host's team number (random from range)
	 */
	void InitTeamArray(void);

	/** 
	 * Determine if there are any teams that can fit the current party request.
	 * 
	 * @param PartySize number of players in the party making a reservation request
	 * @return TRUE if there are teams available, FALSE otherwise 
	 */
	virtual UBOOL AreTeamsAvailable(INT PartySize);

	/**
	 * Determine the team number for the given party reservation request.
	 * Uses the list of current reservations to determine what teams have open slots.
	 *
	 * @param PartyRequest the party reservation request received from the client beacon
	 * @return index of the team to assign to all members of this party
	 */
	virtual INT GetTeamAssignment(const FPartyReservation& PartyRequest);

	/**
	 * Readjust existing team assignments for party reservations in order to open the max
	 * available slots possible.
	 */
	void BestFitTeamAssignmentJiggle();

	/**
	 * Determine the number of players on a given team based on current reservation entries
	 *
	 * @param TeamIdx index of team to search for
	 * @return number of players on a given team
	 */
	INT GetNumPlayersOnTeam(INT TeamIdx) const;

	/**
	 * Find an existing player entry in a party reservation 
	 *
	 * @param ExistingReservation party reservation entry
	 * @param PlayerMember member to search for in the existing party reservation
	 * @return index of party member in the given reservation, -1 if not found
	 */
	INT GetReservationPlayerMember(const FPartyReservation& ExistingReservation, const FUniqueNetId& PlayerMember) const;

	/**
	 * Removes the specified party leader (and party) from the arrays and notifies
	 * any connected clients of the change in status
	 *
	 * @param PartyLeader the leader of the party to remove
	 * @param ClientConn the client connection that sent the packet
	 */
	void CancelPartyReservation(FUniqueNetId& PartyLeader,FClientBeaconConnection& ClientConn);
	
	/**
	 * Determine if the reservation entry for a disconnected client should be removed.
	 *
	 * @param ClientConn the client connection that is disconnecting
	 * @return TRUE if the reservation for the disconnected client should be removed
	 */
	virtual UBOOL ShouldCancelReservationOnDisconnect(const FClientBeaconConnection& ClientConn);

	/**
	 * Called whenever a new player is added to a reservation on this beacon
	 *
	 * @param PlayerRes player reservation entry that was added
	 */
	virtual void NewPlayerAdded(const FPlayerReservation& PlayerRes);
};

class UWebRequest : public UObject
{
public:
    //## BEGIN PROPS WebRequest
    FStringNoInit RemoteAddr;
    FStringNoInit URI;
    FStringNoInit UserName;
    FStringNoInit Password;
    INT ContentLength;
    FStringNoInit ContentType;
    BYTE RequestType;
    SCRIPT_ALIGN;
    TMultiMap<FString, FString> HeaderMap;
    TMultiMap<FString, FString> VariableMap;
    //## END PROPS WebRequest

    FString DecodeBase64(const FString& Encoded);
    FString EncodeBase64(const FString& Decoded);
    void AddHeader(const FString& HeaderName,const FString& Value);
    FString GetHeader(const FString& HeaderName,const FString& DefaultValue=TEXT(""));
    void GetHeaders(TArray<FString>& Headers);
    void AddVariable(const FString& VariableName,const FString& Value);
    FString GetVariable(const FString& VariableName,const FString& DefaultValue=TEXT(""));
    INT GetVariableCount(const FString& VariableName);
    FString GetVariableNumber(const FString& VariableName,INT Number,const FString& DefaultValue=TEXT(""));
    void GetVariables(TArray<FString>& varNames);
    void Dump();
    DECLARE_FUNCTION(execDecodeBase64)
    {
        P_GET_STR(Encoded);
        P_FINISH;
        *(FString*)Result=this->DecodeBase64(Encoded);
    }
    DECLARE_FUNCTION(execEncodeBase64)
    {
        P_GET_STR(Decoded);
        P_FINISH;
        *(FString*)Result=this->EncodeBase64(Decoded);
    }
    DECLARE_FUNCTION(execAddHeader)
    {
        P_GET_STR(HeaderName);
        P_GET_STR(Value);
        P_FINISH;
        this->AddHeader(HeaderName,Value);
    }
    DECLARE_FUNCTION(execGetHeader)
    {
        P_GET_STR(HeaderName);
        P_GET_STR_OPTX(DefaultValue,TEXT(""));
        P_FINISH;
        *(FString*)Result=this->GetHeader(HeaderName,DefaultValue);
    }
    DECLARE_FUNCTION(execGetHeaders)
    {
        P_GET_TARRAY_REF(FString,Headers);
        P_FINISH;
        this->GetHeaders(Headers);
    }
    DECLARE_FUNCTION(execAddVariable)
    {
        P_GET_STR(VariableName);
        P_GET_STR(Value);
        P_FINISH;
        this->AddVariable(VariableName,Value);
    }
    DECLARE_FUNCTION(execGetVariable)
    {
        P_GET_STR(VariableName);
        P_GET_STR_OPTX(DefaultValue,TEXT(""));
        P_FINISH;
        *(FString*)Result=this->GetVariable(VariableName,DefaultValue);
    }
    DECLARE_FUNCTION(execGetVariableCount)
    {
        P_GET_STR(VariableName);
        P_FINISH;
        *(INT*)Result=this->GetVariableCount(VariableName);
    }
    DECLARE_FUNCTION(execGetVariableNumber)
    {
        P_GET_STR(VariableName);
        P_GET_INT(Number);
        P_GET_STR_OPTX(DefaultValue,TEXT(""));
        P_FINISH;
        *(FString*)Result=this->GetVariableNumber(VariableName,Number,DefaultValue);
    }
    DECLARE_FUNCTION(execGetVariables)
    {
        P_GET_TARRAY_REF(FString,varNames);
        P_FINISH;
        this->GetVariables(varNames);
    }
    DECLARE_FUNCTION(execDump)
    {
        P_FINISH;
        this->Dump();
    }
    DECLARE_CLASS(UWebRequest,UObject,0,IpDrv)
    NO_DEFAULT_CONSTRUCTOR(UWebRequest)
};

struct WebResponse_eventSendBinary_Parms
{
    INT Count;
    BYTE B[255];
    WebResponse_eventSendBinary_Parms(EEventParm)
    {
    }
};
struct WebResponse_eventSendText_Parms
{
    FString Text;
    UBOOL bNoCRLF;
    WebResponse_eventSendText_Parms(EEventParm)
    {
    }
};
class UWebResponse : public UObject
{
public:
    //## BEGIN PROPS WebResponse
    TArrayNoInit<FString> Headers;
    TMultiMap<FString, FString> ReplacementMap;
    FStringNoInit IncludePath;
    FStringNoInit CharSet;
    class AWebConnection* Connection;
    BITFIELD bSentText:1;
    BITFIELD bSentResponse:1;
    SCRIPT_ALIGN;
    //## END PROPS WebResponse

    UBOOL FileExists(const FString& Filename);
    void Subst(const FString& Variable,const FString& Value,UBOOL bClear=FALSE);
    void ClearSubst();
    UBOOL IncludeUHTM(const FString& Filename);
    UBOOL IncludeBinaryFile(const FString& Filename);
    FString LoadParsedUHTM(const FString& Filename);
    FString GetHTTPExpiration(INT OffsetSeconds=0);
    void Dump();
    DECLARE_FUNCTION(execFileExists)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->FileExists(Filename);
    }
    DECLARE_FUNCTION(execSubst)
    {
        P_GET_STR(Variable);
        P_GET_STR(Value);
        P_GET_UBOOL_OPTX(bClear,FALSE);
        P_FINISH;
        this->Subst(Variable,Value,bClear);
    }
    DECLARE_FUNCTION(execClearSubst)
    {
        P_FINISH;
        this->ClearSubst();
    }
    DECLARE_FUNCTION(execIncludeUHTM)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->IncludeUHTM(Filename);
    }
    DECLARE_FUNCTION(execIncludeBinaryFile)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->IncludeBinaryFile(Filename);
    }
    DECLARE_FUNCTION(execLoadParsedUHTM)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(FString*)Result=this->LoadParsedUHTM(Filename);
    }
    DECLARE_FUNCTION(execGetHTTPExpiration)
    {
        P_GET_INT_OPTX(OffsetSeconds,0);
        P_FINISH;
        *(FString*)Result=this->GetHTTPExpiration(OffsetSeconds);
    }
    DECLARE_FUNCTION(execDump)
    {
        P_FINISH;
        this->Dump();
    }
    void eventSendBinary(INT Count,BYTE* B)
    {
        WebResponse_eventSendBinary_Parms Parms(EC_EventParm);
        Parms.Count=Count;
        appMemcpy(Parms.B,B,sizeof(Parms.B));
        ProcessEvent(FindFunctionChecked(IPDRV_SendBinary),&Parms);
    }
    void eventSendText(const FString& Text,UBOOL bNoCRLF=FALSE)
    {
        WebResponse_eventSendText_Parms Parms(EC_EventParm);
        Parms.Text=Text;
        Parms.bNoCRLF=bNoCRLF ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(IPDRV_SendText),&Parms);
    }
    DECLARE_CLASS(UWebResponse,UObject,0|CLASS_Config,IpDrv)
    static const TCHAR* StaticConfigName() {return TEXT("Web");}

private:
	void SendInParts(const FString &S);
	bool IncludeTextFile(const FString &Root, const FString &Filename, bool bCache=false, FString *Result = NULL);
	bool ValidWebFile(const FString &Filename);
	FString GetIncludePath();

	//Hack to workaround script compiler code generation (mirrors the old code with fix)
    void SendBinary(INT Count,BYTE* B)
    {
        WebResponse_eventSendBinary_Parms Parms(EC_EventParm);
        Parms.Count=Count;
        appMemcpy(&Parms.B,B,sizeof(Parms.B));
        ProcessEvent(FindFunctionChecked(IPDRV_SendBinary),&Parms);
    }
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_IPDRV_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AInternetLink,-1,execGetLocalIP);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execStringToIpAddr);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execIpAddrToString);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execGetLastError);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execResolve);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execParseURL);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execIsDataPending);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execReadBinary);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execReadText);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execSendBinary);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execSendText);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execIsConnected);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execClose);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execOpen);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execListen);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execBindPort);
AUTOGENERATE_FUNCTION(UOnlineEventsInterfaceMcp,-1,execUploadMatchmakingStats);
AUTOGENERATE_FUNCTION(UOnlineEventsInterfaceMcp,-1,execUpdatePlaylistPopulation);
AUTOGENERATE_FUNCTION(UOnlineEventsInterfaceMcp,-1,execUploadGameplayEventsData);
AUTOGENERATE_FUNCTION(UOnlineEventsInterfaceMcp,-1,execUploadPlayerData);
AUTOGENERATE_FUNCTION(UOnlineNewsInterfaceMcp,-1,execReadNews);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadBase,-1,execGetUrlForFile);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadMcp,-1,execClearDownloadedFile);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadMcp,-1,execClearDownloadedFiles);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadMcp,-1,execGetTitleFileContents);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadMcp,-1,execReadTitleFile);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadWeb,-1,execClearDownloadedFile);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadWeb,-1,execClearDownloadedFiles);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadWeb,-1,execGetTitleFileContents);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadWeb,-1,execTriggerDelegates);
AUTOGENERATE_FUNCTION(UOnlineTitleFileDownloadWeb,-1,execUncompressTitleFileContents);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execDeleteTitleFile);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execDeleteTitleFiles);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execClearCachedFile);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execClearCachedFiles);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execGetTitleFileLogicalName);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execGetTitleFileHash);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execGetTitleFileState);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execGetTitleFileContents);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execSaveTitleFile);
AUTOGENERATE_FUNCTION(UTitleFileDownloadCache,-1,execLoadTitleFile);
AUTOGENERATE_FUNCTION(UMcpMessageManager,-1,execStartAsyncUncompression);
AUTOGENERATE_FUNCTION(UMcpMessageManager,-1,execStartAsyncCompression);
AUTOGENERATE_FUNCTION(UMeshBeacon,-1,execDestroyBeacon);
AUTOGENERATE_FUNCTION(UMeshBeaconClient,-1,execSendHostNewGameSessionResponse);
AUTOGENERATE_FUNCTION(UMeshBeaconClient,-1,execBeginBandwidthTest);
AUTOGENERATE_FUNCTION(UMeshBeaconClient,-1,execRequestConnection);
AUTOGENERATE_FUNCTION(UMeshBeaconClient,-1,execDestroyBeacon);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execRequestClientCreateNewSession);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execTellClientsToTravel);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execAllPlayersConnected);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execGetConnectionIndexForPlayer);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execCancelPendingBandwidthTests);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execHasPendingBandwidthTest);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execCancelInProgressBandwidthTests);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execHasInProgressBandwidthTest);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execRequestClientBandwidthTest);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execDestroyBeacon);
AUTOGENERATE_FUNCTION(UMeshBeaconHost,-1,execInitHostBeacon);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execFindLocalServerAuthSession);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execFindServerAuthSession);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execFindLocalClientAuthSession);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execFindClientAuthSession);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execAllLocalServerAuthSessions);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execAllServerAuthSessions);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execAllLocalClientAuthSessions);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execAllClientAuthSessions);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execEndAllRemoteServerAuthSessions);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execEndAllLocalServerAuthSessions);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execEndRemoteServerAuthSession);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execEndLocalServerAuthSession);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execEndAllRemoteClientAuthSessions);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execEndAllLocalClientAuthSessions);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execEndRemoteClientAuthSession);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execEndLocalClientAuthSession);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execSendServerAuthRetryRequest);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execSendClientAuthEndSessionRequest);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execSendServerAuthResponse);
AUTOGENERATE_FUNCTION(UOnlineAuthInterfaceImpl,-1,execSendClientAuthResponse);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execBindPlatformSpecificSessionToSearch);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execReadPlatformSpecificSessionInfo);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execEndOnlineGame);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execStartOnlineGame);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execGetResolvedConnectString);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execJoinOnlineGame);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execFreeSearchResults);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execCancelFindOnlineGames);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execFindOnlineGames);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execDestroyOnlineGame);
AUTOGENERATE_FUNCTION(UOnlineGameInterfaceImpl,-1,execCreateOnlineGame);
AUTOGENERATE_FUNCTION(UOnlinePlaylistManager,-1,execParseDataCenterId);
AUTOGENERATE_FUNCTION(UOnlinePlaylistManager,-1,execParsePlaylistPopulationData);
AUTOGENERATE_FUNCTION(UOnlinePlaylistManager,-1,execFinalizePlaylistObjects);
AUTOGENERATE_FUNCTION(UOnlinePlaylistManager,-1,execShouldRefreshPlaylists);
AUTOGENERATE_FUNCTION(UOnlinePlaylistManager,-1,execDetermineFilesToDownload);
AUTOGENERATE_FUNCTION(UOnlineSubsystemCommonImpl,-1,execIsPlayerInSession);
AUTOGENERATE_FUNCTION(UPartyBeacon,-1,execDestroyBeacon);
AUTOGENERATE_FUNCTION(UPartyBeaconClient,-1,execDestroyBeacon);
AUTOGENERATE_FUNCTION(UPartyBeaconClient,-1,execCancelReservation);
AUTOGENERATE_FUNCTION(UPartyBeaconClient,-1,execRequestReservationUpdate);
AUTOGENERATE_FUNCTION(UPartyBeaconClient,-1,execRequestReservation);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execGetMaxAvailableTeamSize);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execAppendReservationSkillsToSearch);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execTellClientsHostHasCancelled);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execTellClientsHostIsReady);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execTellClientsToTravel);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execDestroyBeacon);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execHandlePlayerLogout);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execGetExistingReservation);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execUpdatePartyReservationEntry);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execAddPartyReservationEntry);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execInitHostBeacon);
AUTOGENERATE_FUNCTION(UPartyBeaconHost,-1,execPauseReservationRequests);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execDump);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execGetVariables);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execGetVariableNumber);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execGetVariableCount);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execGetVariable);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execAddVariable);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execGetHeaders);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execGetHeader);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execAddHeader);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execEncodeBase64);
AUTOGENERATE_FUNCTION(UWebRequest,-1,execDecodeBase64);
AUTOGENERATE_FUNCTION(UWebResponse,-1,execDump);
AUTOGENERATE_FUNCTION(UWebResponse,-1,execGetHTTPExpiration);
AUTOGENERATE_FUNCTION(UWebResponse,-1,execLoadParsedUHTM);
AUTOGENERATE_FUNCTION(UWebResponse,-1,execIncludeBinaryFile);
AUTOGENERATE_FUNCTION(UWebResponse,-1,execIncludeUHTM);
AUTOGENERATE_FUNCTION(UWebResponse,-1,execClearSubst);
AUTOGENERATE_FUNCTION(UWebResponse,-1,execSubst);
AUTOGENERATE_FUNCTION(UWebResponse,-1,execFileExists);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef IPDRV_NATIVE_DEFS
#define IPDRV_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_IPDRV \
	UClientBeaconAddressResolver::StaticClass(); \
	UHTTPDownload::StaticClass(); \
	AInternetLink::StaticClass(); \
	GNativeLookupFuncs.Set(FName("InternetLink"), GIpDrvAInternetLinkNatives); \
	ATcpLink::StaticClass(); \
	GNativeLookupFuncs.Set(FName("TcpLink"), GIpDrvATcpLinkNatives); \
	UMcpServiceBase::StaticClass(); \
	UMCPBase::StaticClass(); \
	UOnlineEventsInterfaceMcp::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineEventsInterfaceMcp"), GIpDrvUOnlineEventsInterfaceMcpNatives); \
	UOnlineNewsInterfaceMcp::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineNewsInterfaceMcp"), GIpDrvUOnlineNewsInterfaceMcpNatives); \
	UOnlineTitleFileDownloadBase::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineTitleFileDownloadBase"), GIpDrvUOnlineTitleFileDownloadBaseNatives); \
	UOnlineTitleFileDownloadMcp::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineTitleFileDownloadMcp"), GIpDrvUOnlineTitleFileDownloadMcpNatives); \
	UOnlineTitleFileDownloadWeb::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineTitleFileDownloadWeb"), GIpDrvUOnlineTitleFileDownloadWebNatives); \
	UTitleFileDownloadCache::StaticClass(); \
	GNativeLookupFuncs.Set(FName("TitleFileDownloadCache"), GIpDrvUTitleFileDownloadCacheNatives); \
	UMcpMessageBase::StaticClass(); \
	UMcpMessageManager::StaticClass(); \
	GNativeLookupFuncs.Set(FName("McpMessageManager"), GIpDrvUMcpMessageManagerNatives); \
	UMcpUserCloudFileDownload::StaticClass(); \
	UMeshBeacon::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MeshBeacon"), GIpDrvUMeshBeaconNatives); \
	UMeshBeaconClient::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MeshBeaconClient"), GIpDrvUMeshBeaconClientNatives); \
	UMeshBeaconHost::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MeshBeaconHost"), GIpDrvUMeshBeaconHostNatives); \
	UOnlineAuthInterfaceImpl::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineAuthInterfaceImpl"), GIpDrvUOnlineAuthInterfaceImplNatives); \
	UOnlineGameInterfaceImpl::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineGameInterfaceImpl"), GIpDrvUOnlineGameInterfaceImplNatives); \
	UOnlinePlaylistManager::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlinePlaylistManager"), GIpDrvUOnlinePlaylistManagerNatives); \
	UOnlineSubsystemCommonImpl::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineSubsystemCommonImpl"), GIpDrvUOnlineSubsystemCommonImplNatives); \
	UPartyBeacon::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PartyBeacon"), GIpDrvUPartyBeaconNatives); \
	UPartyBeaconClient::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PartyBeaconClient"), GIpDrvUPartyBeaconClientNatives); \
	UPartyBeaconHost::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PartyBeaconHost"), GIpDrvUPartyBeaconHostNatives); \
	UTcpipConnection::StaticClass(); \
	UTcpNetDriver::StaticClass(); \
	UWebRequest::StaticClass(); \
	GNativeLookupFuncs.Set(FName("WebRequest"), GIpDrvUWebRequestNatives); \
	UWebResponse::StaticClass(); \
	GNativeLookupFuncs.Set(FName("WebResponse"), GIpDrvUWebResponseNatives); \

#endif // IPDRV_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GIpDrvAInternetLinkNatives[] = 
{ 
	MAP_NATIVE(AInternetLink, execGetLocalIP)
	MAP_NATIVE(AInternetLink, execStringToIpAddr)
	MAP_NATIVE(AInternetLink, execIpAddrToString)
	MAP_NATIVE(AInternetLink, execGetLastError)
	MAP_NATIVE(AInternetLink, execResolve)
	MAP_NATIVE(AInternetLink, execParseURL)
	MAP_NATIVE(AInternetLink, execIsDataPending)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvATcpLinkNatives[] = 
{ 
	MAP_NATIVE(ATcpLink, execReadBinary)
	MAP_NATIVE(ATcpLink, execReadText)
	MAP_NATIVE(ATcpLink, execSendBinary)
	MAP_NATIVE(ATcpLink, execSendText)
	MAP_NATIVE(ATcpLink, execIsConnected)
	MAP_NATIVE(ATcpLink, execClose)
	MAP_NATIVE(ATcpLink, execOpen)
	MAP_NATIVE(ATcpLink, execListen)
	MAP_NATIVE(ATcpLink, execBindPort)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUOnlineEventsInterfaceMcpNatives[] = 
{ 
	MAP_NATIVE(UOnlineEventsInterfaceMcp, execUploadMatchmakingStats)
	MAP_NATIVE(UOnlineEventsInterfaceMcp, execUpdatePlaylistPopulation)
	MAP_NATIVE(UOnlineEventsInterfaceMcp, execUploadGameplayEventsData)
	MAP_NATIVE(UOnlineEventsInterfaceMcp, execUploadPlayerData)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUOnlineNewsInterfaceMcpNatives[] = 
{ 
	MAP_NATIVE(UOnlineNewsInterfaceMcp, execReadNews)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUOnlineTitleFileDownloadBaseNatives[] = 
{ 
	MAP_NATIVE(UOnlineTitleFileDownloadBase, execGetUrlForFile)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUOnlineTitleFileDownloadMcpNatives[] = 
{ 
	MAP_NATIVE(UOnlineTitleFileDownloadMcp, execClearDownloadedFile)
	MAP_NATIVE(UOnlineTitleFileDownloadMcp, execClearDownloadedFiles)
	MAP_NATIVE(UOnlineTitleFileDownloadMcp, execGetTitleFileContents)
	MAP_NATIVE(UOnlineTitleFileDownloadMcp, execReadTitleFile)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUOnlineTitleFileDownloadWebNatives[] = 
{ 
	MAP_NATIVE(UOnlineTitleFileDownloadWeb, execClearDownloadedFile)
	MAP_NATIVE(UOnlineTitleFileDownloadWeb, execClearDownloadedFiles)
	MAP_NATIVE(UOnlineTitleFileDownloadWeb, execGetTitleFileContents)
	MAP_NATIVE(UOnlineTitleFileDownloadWeb, execTriggerDelegates)
	MAP_NATIVE(UOnlineTitleFileDownloadWeb, execUncompressTitleFileContents)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUTitleFileDownloadCacheNatives[] = 
{ 
	MAP_NATIVE(UTitleFileDownloadCache, execDeleteTitleFile)
	MAP_NATIVE(UTitleFileDownloadCache, execDeleteTitleFiles)
	MAP_NATIVE(UTitleFileDownloadCache, execClearCachedFile)
	MAP_NATIVE(UTitleFileDownloadCache, execClearCachedFiles)
	MAP_NATIVE(UTitleFileDownloadCache, execGetTitleFileLogicalName)
	MAP_NATIVE(UTitleFileDownloadCache, execGetTitleFileHash)
	MAP_NATIVE(UTitleFileDownloadCache, execGetTitleFileState)
	MAP_NATIVE(UTitleFileDownloadCache, execGetTitleFileContents)
	MAP_NATIVE(UTitleFileDownloadCache, execSaveTitleFile)
	MAP_NATIVE(UTitleFileDownloadCache, execLoadTitleFile)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUMcpMessageManagerNatives[] = 
{ 
	MAP_NATIVE(UMcpMessageManager, execStartAsyncUncompression)
	MAP_NATIVE(UMcpMessageManager, execStartAsyncCompression)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUMeshBeaconNatives[] = 
{ 
	MAP_NATIVE(UMeshBeacon, execDestroyBeacon)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUMeshBeaconClientNatives[] = 
{ 
	MAP_NATIVE(UMeshBeaconClient, execSendHostNewGameSessionResponse)
	MAP_NATIVE(UMeshBeaconClient, execBeginBandwidthTest)
	MAP_NATIVE(UMeshBeaconClient, execRequestConnection)
	MAP_NATIVE(UMeshBeaconClient, execDestroyBeacon)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUMeshBeaconHostNatives[] = 
{ 
	MAP_NATIVE(UMeshBeaconHost, execRequestClientCreateNewSession)
	MAP_NATIVE(UMeshBeaconHost, execTellClientsToTravel)
	MAP_NATIVE(UMeshBeaconHost, execAllPlayersConnected)
	MAP_NATIVE(UMeshBeaconHost, execGetConnectionIndexForPlayer)
	MAP_NATIVE(UMeshBeaconHost, execCancelPendingBandwidthTests)
	MAP_NATIVE(UMeshBeaconHost, execHasPendingBandwidthTest)
	MAP_NATIVE(UMeshBeaconHost, execCancelInProgressBandwidthTests)
	MAP_NATIVE(UMeshBeaconHost, execHasInProgressBandwidthTest)
	MAP_NATIVE(UMeshBeaconHost, execRequestClientBandwidthTest)
	MAP_NATIVE(UMeshBeaconHost, execDestroyBeacon)
	MAP_NATIVE(UMeshBeaconHost, execInitHostBeacon)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUOnlineAuthInterfaceImplNatives[] = 
{ 
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execFindLocalServerAuthSession)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execFindServerAuthSession)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execFindLocalClientAuthSession)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execFindClientAuthSession)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execAllLocalServerAuthSessions)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execAllServerAuthSessions)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execAllLocalClientAuthSessions)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execAllClientAuthSessions)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execEndAllRemoteServerAuthSessions)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execEndAllLocalServerAuthSessions)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execEndRemoteServerAuthSession)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execEndLocalServerAuthSession)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execEndAllRemoteClientAuthSessions)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execEndAllLocalClientAuthSessions)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execEndRemoteClientAuthSession)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execEndLocalClientAuthSession)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execSendServerAuthRetryRequest)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execSendClientAuthEndSessionRequest)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execSendServerAuthResponse)
	MAP_NATIVE(UOnlineAuthInterfaceImpl, execSendClientAuthResponse)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUOnlineGameInterfaceImplNatives[] = 
{ 
	MAP_NATIVE(UOnlineGameInterfaceImpl, execBindPlatformSpecificSessionToSearch)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execReadPlatformSpecificSessionInfo)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execEndOnlineGame)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execStartOnlineGame)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execGetResolvedConnectString)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execJoinOnlineGame)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execFreeSearchResults)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execCancelFindOnlineGames)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execFindOnlineGames)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execDestroyOnlineGame)
	MAP_NATIVE(UOnlineGameInterfaceImpl, execCreateOnlineGame)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUOnlinePlaylistManagerNatives[] = 
{ 
	MAP_NATIVE(UOnlinePlaylistManager, execParseDataCenterId)
	MAP_NATIVE(UOnlinePlaylistManager, execParsePlaylistPopulationData)
	MAP_NATIVE(UOnlinePlaylistManager, execFinalizePlaylistObjects)
	MAP_NATIVE(UOnlinePlaylistManager, execShouldRefreshPlaylists)
	MAP_NATIVE(UOnlinePlaylistManager, execDetermineFilesToDownload)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUOnlineSubsystemCommonImplNatives[] = 
{ 
	MAP_NATIVE(UOnlineSubsystemCommonImpl, execIsPlayerInSession)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUPartyBeaconNatives[] = 
{ 
	MAP_NATIVE(UPartyBeacon, execDestroyBeacon)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUPartyBeaconClientNatives[] = 
{ 
	MAP_NATIVE(UPartyBeaconClient, execDestroyBeacon)
	MAP_NATIVE(UPartyBeaconClient, execCancelReservation)
	MAP_NATIVE(UPartyBeaconClient, execRequestReservationUpdate)
	MAP_NATIVE(UPartyBeaconClient, execRequestReservation)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUPartyBeaconHostNatives[] = 
{ 
	MAP_NATIVE(UPartyBeaconHost, execGetMaxAvailableTeamSize)
	MAP_NATIVE(UPartyBeaconHost, execAppendReservationSkillsToSearch)
	MAP_NATIVE(UPartyBeaconHost, execTellClientsHostHasCancelled)
	MAP_NATIVE(UPartyBeaconHost, execTellClientsHostIsReady)
	MAP_NATIVE(UPartyBeaconHost, execTellClientsToTravel)
	MAP_NATIVE(UPartyBeaconHost, execDestroyBeacon)
	MAP_NATIVE(UPartyBeaconHost, execHandlePlayerLogout)
	MAP_NATIVE(UPartyBeaconHost, execGetExistingReservation)
	MAP_NATIVE(UPartyBeaconHost, execUpdatePartyReservationEntry)
	MAP_NATIVE(UPartyBeaconHost, execAddPartyReservationEntry)
	MAP_NATIVE(UPartyBeaconHost, execInitHostBeacon)
	MAP_NATIVE(UPartyBeaconHost, execPauseReservationRequests)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUWebRequestNatives[] = 
{ 
	MAP_NATIVE(UWebRequest, execDump)
	MAP_NATIVE(UWebRequest, execGetVariables)
	MAP_NATIVE(UWebRequest, execGetVariableNumber)
	MAP_NATIVE(UWebRequest, execGetVariableCount)
	MAP_NATIVE(UWebRequest, execGetVariable)
	MAP_NATIVE(UWebRequest, execAddVariable)
	MAP_NATIVE(UWebRequest, execGetHeaders)
	MAP_NATIVE(UWebRequest, execGetHeader)
	MAP_NATIVE(UWebRequest, execAddHeader)
	MAP_NATIVE(UWebRequest, execEncodeBase64)
	MAP_NATIVE(UWebRequest, execDecodeBase64)
	{NULL, NULL}
};

FNativeFunctionLookup GIpDrvUWebResponseNatives[] = 
{ 
	MAP_NATIVE(UWebResponse, execDump)
	MAP_NATIVE(UWebResponse, execGetHTTPExpiration)
	MAP_NATIVE(UWebResponse, execLoadParsedUHTM)
	MAP_NATIVE(UWebResponse, execIncludeBinaryFile)
	MAP_NATIVE(UWebResponse, execIncludeUHTM)
	MAP_NATIVE(UWebResponse, execClearSubst)
	MAP_NATIVE(UWebResponse, execSubst)
	MAP_NATIVE(UWebResponse, execFileExists)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UClientBeaconAddressResolver,ClientBeaconAddressResolver,BeaconPort)
VERIFY_CLASS_OFFSET_NODIE(UClientBeaconAddressResolver,ClientBeaconAddressResolver,BeaconName)
VERIFY_CLASS_SIZE_NODIE(UClientBeaconAddressResolver)
VERIFY_CLASS_OFFSET_NODIE(AInternetLink,InternetLink,LinkMode)
VERIFY_CLASS_OFFSET_NODIE(AInternetLink,InternetLink,DataPending)
VERIFY_CLASS_SIZE_NODIE(AInternetLink)
VERIFY_CLASS_OFFSET_NODIE(ATcpLink,TcpLink,LinkState)
VERIFY_CLASS_OFFSET_NODIE(ATcpLink,TcpLink,RecvBuf)
VERIFY_CLASS_SIZE_NODIE(ATcpLink)
VERIFY_CLASS_OFFSET_NODIE(UMcpServiceBase,McpServiceBase,McpConfigClassName)
VERIFY_CLASS_OFFSET_NODIE(UMcpServiceBase,McpServiceBase,McpConfig)
VERIFY_CLASS_SIZE_NODIE(UMcpServiceBase)
VERIFY_CLASS_SIZE_NODIE(UMCPBase)
VERIFY_CLASS_OFFSET_NODIE(UOnlineEventsInterfaceMcp,OnlineEventsInterfaceMcp,EventUploadConfigs)
VERIFY_CLASS_OFFSET_NODIE(UOnlineEventsInterfaceMcp,OnlineEventsInterfaceMcp,DisabledUploadTypes)
VERIFY_CLASS_SIZE_NODIE(UOnlineEventsInterfaceMcp)
VERIFY_CLASS_OFFSET_NODIE(UOnlineNewsInterfaceMcp,OnlineNewsInterfaceMcp,NewsItems)
VERIFY_CLASS_OFFSET_NODIE(UOnlineNewsInterfaceMcp,OnlineNewsInterfaceMcp,__OnReadNewsCompleted__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineNewsInterfaceMcp)
VERIFY_CLASS_OFFSET_NODIE(UOnlineTitleFileDownloadBase,OnlineTitleFileDownloadBase,ReadTitleFileCompleteDelegates)
VERIFY_CLASS_OFFSET_NODIE(UOnlineTitleFileDownloadBase,OnlineTitleFileDownloadBase,__OnRequestTitleFileListComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineTitleFileDownloadBase)
VERIFY_CLASS_OFFSET_NODIE(UOnlineTitleFileDownloadMcp,OnlineTitleFileDownloadMcp,TitleFiles)
VERIFY_CLASS_OFFSET_NODIE(UOnlineTitleFileDownloadMcp,OnlineTitleFileDownloadMcp,DownloadCount)
VERIFY_CLASS_SIZE_NODIE(UOnlineTitleFileDownloadMcp)
VERIFY_CLASS_OFFSET_NODIE(UOnlineTitleFileDownloadWeb,OnlineTitleFileDownloadWeb,TitleFiles)
VERIFY_CLASS_SIZE_NODIE(UOnlineTitleFileDownloadWeb)
VERIFY_CLASS_OFFSET_NODIE(UTitleFileDownloadCache,TitleFileDownloadCache,TitleFiles)
VERIFY_CLASS_OFFSET_NODIE(UTitleFileDownloadCache,TitleFileDownloadCache,__OnSaveTitleFileComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UTitleFileDownloadCache)
VERIFY_CLASS_OFFSET_NODIE(UMcpMessageBase,McpMessageBase,McpMessageManagerClassName)
VERIFY_CLASS_OFFSET_NODIE(UMcpMessageBase,McpMessageBase,__OnQueryMessageContentsComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UMcpMessageBase)
VERIFY_CLASS_OFFSET_NODIE(UMcpMessageManager,McpMessageManager,CreateMessageUrl)
VERIFY_CLASS_OFFSET_NODIE(UMcpMessageManager,McpMessageManager,UncompressMessageRequests)
VERIFY_CLASS_SIZE_NODIE(UMcpMessageManager)
VERIFY_CLASS_OFFSET_NODIE(UMcpUserCloudFileDownload,McpUserCloudFileDownload,EnumerateCloudFilesUrl)
VERIFY_CLASS_OFFSET_NODIE(UMcpUserCloudFileDownload,McpUserCloudFileDownload,__OnDeleteUserFileComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UMcpUserCloudFileDownload)
VERIFY_CLASS_OFFSET_NODIE(UMeshBeacon,MeshBeacon,MeshBeaconPort)
VERIFY_CLASS_OFFSET_NODIE(UMeshBeacon,MeshBeacon,MaxBandwidthHistoryEntries)
VERIFY_CLASS_SIZE_NODIE(UMeshBeacon)
VERIFY_CLASS_OFFSET_NODIE(UMeshBeaconClient,MeshBeaconClient,HostPendingRequest)
VERIFY_CLASS_OFFSET_NODIE(UMeshBeaconClient,MeshBeaconClient,__OnCreateNewSessionRequestReceived__Delegate)
VERIFY_CLASS_SIZE_NODIE(UMeshBeaconClient)
VERIFY_CLASS_OFFSET_NODIE(UMeshBeaconHost,MeshBeaconHost,ClientConnections)
VERIFY_CLASS_OFFSET_NODIE(UMeshBeaconHost,MeshBeaconHost,__OnReceivedClientCreateNewSessionResult__Delegate)
VERIFY_CLASS_SIZE_NODIE(UMeshBeaconHost)
VERIFY_CLASS_OFFSET_NODIE(UOnlineAuthInterfaceImpl,OnlineAuthInterfaceImpl,OwningSubsystem)
VERIFY_CLASS_OFFSET_NODIE(UOnlineAuthInterfaceImpl,OnlineAuthInterfaceImpl,__OnServerConnectionClose__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineAuthInterfaceImpl)
VERIFY_CLASS_OFFSET_NODIE(UOnlineGameInterfaceImpl,OnlineGameInterfaceImpl,OwningSubsystem)
VERIFY_CLASS_OFFSET_NODIE(UOnlineGameInterfaceImpl,OnlineGameInterfaceImpl,__OnQosStatusChanged__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineGameInterfaceImpl)
VERIFY_CLASS_OFFSET_NODIE(UOnlinePlaylistManager,OnlinePlaylistManager,Playlists)
VERIFY_CLASS_OFFSET_NODIE(UOnlinePlaylistManager,OnlinePlaylistManager,__OnPlaylistPopulationDataUpdated__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlinePlaylistManager)
VERIFY_CLASS_OFFSET_NODIE(UOnlineSubsystemCommonImpl,OnlineSubsystemCommonImpl,VoiceEngine)
VERIFY_CLASS_OFFSET_NODIE(UOnlineSubsystemCommonImpl,OnlineSubsystemCommonImpl,AuthInterfaceImpl)
VERIFY_CLASS_SIZE_NODIE(UOnlineSubsystemCommonImpl)
VERIFY_CLASS_OFFSET_NODIE(UPartyBeacon,PartyBeacon,PartyBeaconPort)
VERIFY_CLASS_OFFSET_NODIE(UPartyBeacon,PartyBeacon,__OnDestroyComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UPartyBeacon)
VERIFY_CLASS_OFFSET_NODIE(UPartyBeaconClient,PartyBeaconClient,HostPendingRequest)
VERIFY_CLASS_OFFSET_NODIE(UPartyBeaconClient,PartyBeaconClient,__OnHostHasCancelled__Delegate)
VERIFY_CLASS_SIZE_NODIE(UPartyBeaconClient)
VERIFY_CLASS_OFFSET_NODIE(UPartyBeaconHost,PartyBeaconHost,Clients)
VERIFY_CLASS_OFFSET_NODIE(UPartyBeaconHost,PartyBeaconHost,__OnClientCancellationReceived__Delegate)
VERIFY_CLASS_SIZE_NODIE(UPartyBeaconHost)
VERIFY_CLASS_OFFSET_NODIE(UWebRequest,WebRequest,RemoteAddr)
VERIFY_CLASS_OFFSET_NODIE(UWebRequest,WebRequest,VariableMap)
VERIFY_CLASS_SIZE_NODIE(UWebRequest)
VERIFY_CLASS_OFFSET_NODIE(UWebResponse,WebResponse,Headers)
VERIFY_CLASS_OFFSET_NODIE(UWebResponse,WebResponse,Connection)
VERIFY_CLASS_SIZE_NODIE(UWebResponse)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
