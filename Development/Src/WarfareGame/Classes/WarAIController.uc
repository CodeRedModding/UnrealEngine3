class WarAIController extends AIController
	native;

cpptext
{
};

// PLAYER INFO =======================================================================

/**
 * Contains all known information about the given player, updated as new
 * information is made available.
 */
struct native PlayerInfo
{
	/** Player this data is associated with it */
	var	Controller Player;

	/** Are they friendly to us? */
	var bool bFriendly;

	/** Are they currently visible? */
	var bool bVisible;

	/** Last time they were considered visible */
	var float LastSeenTime;

	/** Last location they were seen at */
	var vector LastSeenLocation;

	/** Are they currently audible? */
	var bool bAudible;

	/** Last time they were considered audible */
	var float LastHeardTime;

	/** Last location they were heard at */
	var vector LastHeardLocation;
};

/** List of all known player */
var transient array<PlayerInfo> PlayerList;

/** Index into PlayerList of our currently selected enemy, -1 for no enemy */
var transient int EnemyIdx;

// NOISE INFO ========================================================================

/** How long a player remains visible without new updates */
const SIGHT_DURATION = 10.f;

/** How long a player remains audible without new updates */
const NOISE_DURATION = 15.f;

/**
 * Contains all the relevant information pertaining to a noise generation event.
 */
struct native NoiseInfo
{
	/** Actor that generated the noise event */
	var Actor NoiseMaker;

	/** Loudness of the noise that was generated */
	var float Loudness;

	/** Time at which the noise event occured */
	var float HeardTime;

	/** Location at which the noise event occured */
	var vector HeardLocation;
};

/** List of all recently heard noises */
var transient array<NoiseInfo>				RecentNoise;

// GOAL VARIABLES ====================================================================

/** Max number of direct moves or pathfinding moves to attempt via MoveToGoal */
const MAX_MOVE_ATTEMPTS = 10;

struct native GoalInfo
{
	/** Actor that represents this goal */
	var Actor GoalActor;

	/** Can this move be interrupted by enemy detection? */
	var bool bInterruptable;

	/** Is GoalActor known to be directly reachable? */
	var transient bool bReachable;

	/** Cached pathfind movetarget, to avoid duplicate searches */
	var transient Actor CachedMoveTarget; 

	/** How many attempts have been made to reach this move target */
	var transient byte MoveAttempts;
};

/** Current move goal used by MoveToGoal state */
var transient GoalInfo MoveGoal;

/** Was the current move aborted? */
var transient bool bMoveAborted;

/** Are we delaying the current move for a half second? */
var transient bool bDelayingMove;

/** Current step aside goal, for StepAside state */
var transient Actor StepAsideGoal;

/** Distance to attempt to step aside when bumping into other players */
var const float MaxStepAsideDist;

/** List of invalid move goals, generated by failed attempts in MoveToGoal state */
var transient array<Actor> InvalidMoveGoals;

struct native RouteGoalInfo
{
	/** Actual route actor containing move information */
	var Route GoalRoute;

	/** Current move direction (1 or -1), for ERT_Loop */
	var int MoveDirection;

	/** Is this route move interruptable? */
	var bool bInterruptable;
};

/** Current route goal use by MoveAlongRoute state */
var transient RouteGoalInfo RouteGOal;

/** Current target we're shooting at, for purposes of scripting */
var transient Actor ShootTarget;

// MISC VARIABLES ====================================================================

/** Last time we were shot at */
var transient float LastShotTime;

/** Current threshold of being under fire, incremented by being shot at */
var transient float UnderFireMeter;

/** Debug log file handle */
var transient FileLog AILogFile;

// DEBUG FUNCTIONS ===================================================================

/**
 * Dumps a formatted log statement to the log file associated with
 * this AI controller.
 *
 * @param	logText - string to dump to log file
 * 
 * @param	logCategory - category of information being dumped (for
 * 			filtering)
 */
native final function AILog(string logText,Name logCategory);

//=====================================================
// PLAYER INFO FUNCTIONS

/**
 * Returns true is the specified player is friendly to us.
 */
final function bool IsFriendly(Controller checkPlayer)
{
	return (checkPlayer.PlayerReplicationInfo != None &&
			checkPlayer.PlayerReplicationInfo.Team != None &&
			checkPlayer.PlayerReplicationInfo.Team == PlayerReplicationInfo.Team);
}

/**
 * Returns true if the specified player is in the known player
 * list, optionally specifying the index.
 */
final function bool IsInPlayerList(Controller checkPlayer,optional out int playerIdx)
{
	local int idx;
	local bool bFoundPlayer;
	if (checkPlayer != None)
	{
		for (idx = 0; idx < PlayerList.Length && !bFoundPlayer; idx++)
		{
			if (PlayerList[idx].Player == checkPlayer)
			{
				bFoundPlayer = true;
				playerIdx = idx;
			}
		}
	}
	return bFoundPlayer;
}

/**
 * Searches for the index of the specified player in PlayerList,
 * adding it to the list if it's not already there, or -1 if
 * specified an invalid player.
 */
final function int GetPlayerIdx(Controller chkPlayer)
{
	local int idx;
	idx = -1;
	if (chkPlayer != None)
	{
		if (!IsInPlayerList(chkPlayer,idx))
		{
			idx = PlayerList.Length;
			PlayerList.Length = idx + 1;
			PlayerList[idx].Player = chkPlayer;
			PlayerList[idx].bFriendly = IsFriendly(chkPlayer);
		}
	}
	return idx;
}

/* epic ===============================================
* ::IsValidPlayerIdx
*
* Validates the given index in regards to the player
* list.
*
* =====================================================
*/
final function bool IsValidPlayerIdx(int playerIdx)
{
	return (playerIdx >= 0 &&
			playerIdx < PlayerList.Length);
}

/** 
 * Evaluates all the players in our list, checking to
 * see if they are still visible/audible.
 */
final function UpdatePlayerList()
{
	local int idx;
	for (idx = 0; idx < PlayerList.Length; idx++)
	{
		if (PlayerList[idx].Player != None &&
			PlayerList[idx].Player.Pawn != None)
		{
			// check last vis time
			if (PlayerList[idx].bVisible &&
				Level.TimeSeconds - PlayerList[idx].LastSeenTime > SIGHT_DURATION)
			{
				PlayerList[idx].bVisible = false;
			}
			// check last aud time
			if (PlayerList[idx].bAudible &&
				Level.TimeSeconds - PlayerList[idx].LastHeardTime > NOISE_DURATION)
			{
				PlayerList[idx].bAudible = false;
			}
		}
		else
		{
			// remove from list
			PlayerList.Remove(idx--,1);
		}
	}
}

/**
 * Returns the nearest enemy, potentially None.
 */
final function Pawn GetNearestEnemy(optional out float enemyDist)
{
	local float dist, bestDist;
	local Pawn bestEnemy;
	local int idx;
	for (idx = 0; idx < PlayerList.Length; idx++)
	{
		if (PlayerList[idx].Player != None &&
			PlayerList[idx].Player.Pawn != None &&
			!PlayerList[idx].bFriendly)
		{
			dist = VSize(PlayerList[idx].Player.Pawn.Location-Pawn.Location);
			if (bestEnemy == None ||
				dist < bestDist)
			{
				bestEnemy = PlayerList[idx].Player.Pawn;
				bestDist = dist;
			}
		}
	}
	enemyDist = bestDist;
	return bestEnemy;
}

//=====================================================
// SENSORY FUNCTIONS

/**
 * Called whenever another player is sighted, at which point
 * the player is added to the master list if not already added,
 * keeping track of the last known location and time.
 */
event SeePlayer(Pawn Seen)
{
	local int playerIdx;
	local bool bNewEnemy;
	if (Seen.Controller != None)
	{
		if (!IsInPlayerList(Seen.Controller,playerIdx))
		{
			// add the new entry
			playerIdx = PlayerList.Length;
			PlayerList.Length = playerIdx + 1;
			PlayerList[playerIdx].Player = Seen.Controller;
			PlayerList[playerIdx].bFriendly = IsFriendly(Seen.Controller);
			bNewEnemy = true;
			AILog("Added new visible player:"@Seen.Controller,'Sensory');
		}
		// update the entry
		PlayerList[playerIdx].bVisible = true;
		PlayerList[playerIdx].LastSeenTime = Level.TimeSeconds;
		PlayerList[playerIdx].LastSeenLocation = Seen.Location;
		// notify if it's an enemy
		if (!PlayerList[playerIdx].bFriendly)
		{
			// fire any see enemy events
			Pawn.ActivateEventClass(class'SeqEvent_AISeeEnemy',Seen);
			OnSeeEnemy(playerIdx,bNewEnemy);
		}
	}
}

/**
 * Called whenever our Pawn receives damage via TakeDamage().  Redirects
 * to SeePlayer(), registering the instigator as a visible enemy.
 */
function NotifyTakeHit(Pawn InstigatedBy, vector HitLocation, int Damage, class<DamageType> damageType, vector Momentum)
{
	Super.NotifyTakeHit(InstigatedBy,HitLocation,Damage,damageType,Momentum);
	SeePlayer(InstigatedBy);
	LastShotTime = Level.TimeSeconds;
	UnderFireMeter += 0.3f;
}

/**
 * Overridden to adjust the under fire meter.
 */
function NotifyNearMiss(Pawn shooter)
{
	if (!IsFriendly(shooter.Controller))
	{
		SeePlayer(shooter);
		AILog("NEAR MISS FROM"@shooter,'Combat');
		LastShotTime = Level.TimeSeconds;
		UnderFireMeter += 0.2f;
	}
}

function UpdateUnderFireMeter()
{
	// add a random chance to clear our under fire meter
	if (FRand() > 0.85f)
	{
		UnderFireMeter = 0.f;
		LastShotTime = -1.f;
	}
	else
	{
		if (Level.TimeSeconds - LastShotTime > 0.3f)
		{
			UnderFireMeter *= 0.5f;
		}
	}
}

/**
 * Called from SeePlayer when we encounter an enemy,
 * override when waiting for enemy selection.
 * 
 * @param	playerIdx - index to PlayerList of seen enemy
 * 
 * @param	bNewEnemy - true if this is the first time this
 * 			enemy has been sighted
 */
function OnSeeEnemy(int playerIdx, bool bNewEnemy)
{
}

function OnHearEnemy(int playerIdx)
{
}

/* epic ===============================================
* ::HearNoise
*
* Adds the heard player to the list if not already there,
* otherwise updates with latest information.  Also adds
* to the list of recently heard noises for investigative
* purposes.
*
* =====================================================
*/
event HearNoise(float Loudness, Actor NoiseMaker)
{
	local int idx;
	local Controller player;
	local bool bNewEnemy;
	if (NoiseMaker != None &&
		Loudness > 0.f &&
		VSize(NoiseMaker.Location-Pawn.Location) < 1024.f * Loudness)
	{
		// add the recent noise entry
		idx = RecentNoise.Length;
		RecentNoise.Length = idx + 1;
		RecentNoise[idx].NoiseMaker = NoiseMaker;
		RecentNoise[idx].Loudness = Loudness;
		RecentNoise[idx].HeardTime = Level.TimeSeconds;
		RecentNoise[idx].HeardLocation = NoiseMaker.Location;
		// and update player info
		if (NoiseMaker.IsA('Controller'))
		{
			player = Controller(NoiseMaker);
		}
		else
		if (NoiseMaker.IsA('Pawn'))
		{
			player = Pawn(NoiseMaker).Controller;
		}
		if (player != None &&
			player != self &&
			player.Pawn != None)
		{
			if (!IsInPlayerList(player,idx))
			{
				// add the new entry
				idx = PlayerList.Length;
				PlayerList.Length = idx + 1;
				PlayerList[idx].Player = player;
				PlayerList[idx].bFriendly = IsFriendly(player);
				AILog("Added new audible player:"@player,'Sensory');
				AILog("-"@PlayerReplicationInfo.Team@player.PlayerReplicationInfo.Team,'Sensory');
				bNewEnemy = true;
			}
			// update the entry
			PlayerList[idx].bAudible = true;
			PlayerList[idx].LastHeardTime = Level.TimeSeconds;
			PlayerList[idx].LastHeardLocation = player.Pawn.Location;
			if (!PlayerList[idx].bFriendly &&
				bNewEnemy)
			{
				OnHearEnemy(idx);
			}
		}
	}
}

/* epic ===============================================
* ::UpdateRecentNoise
*
* Called at a regular interval, used to cull out old
* noises.
*
* =====================================================
*/
final function UpdateRecentNoise()
{
	local int idx;
	for (idx = 0; idx < RecentNoise.Length; idx++)
	{
		if (RecentNoise[idx].NoiseMaker == None ||
			Level.TimeSeconds - RecentNoise[idx].HeardTime > NOISE_DURATION)
		{
			RecentNoise.Remove(idx--,1);
		}
	}
}

//=====================================================
// EVALUATION FUNCTIONS

/* epic ===============================================
* ::EvaluateSituation
*
* Iterates through all our given behaviors/actions and
* chooses the one best suited for the given situation.
*
* NOTE: This function will most likely instigate a
* state transition.
*
* =====================================================
*/
function EvaluateSituation()
{
	GotoState('Idle');
}

/**
 * Returns our currently assigned WarTeamInfo.
 */
final function WarTeamInfo GetTeam()
{
	return WarTeamInfo(PlayerReplicationInfo.Team);
}

/**
 * Returns our WarPRI.  Wow.
 */
final function WarPRI GetPRI()
{
	return WarPRI(PlayerReplicationInfo);
}

//=====================================================
// COMBAT FUNCTIONS

/* epic ===============================================
* ::CheckForEnemy
*
* Evaluates the player list looking for potential enemies
* and attempts to acquire one.
*
* =====================================================
*/
function bool CheckForEnemy()
{
	local int idx;
	local bool bAcquired;
	if (HasValidEnemy())
	{
		bAcquired = true;
	}
	else
	{
		for (idx = 0; idx < PlayerList.Length; idx++)
		{
			if (PlayerList[idx].Player != None &&
				!PlayerList[idx].bFriendly)
			{
				bAcquired = AcquireEnemy(idx);
			}
		}
	}
	return bAcquired;
}

/**
 * Checks the enemy list and acquires the first visible one
 * that is a valid enemy.
 * 
 * @return	true if a new enemy was acquired
 */
function bool CheckForVisibleEnemy()
{
	local int idx;
	local bool bAcquired;
	if (IsEnemyVisible())
	{
		bAcquired = true;
	}
	else
	{
		for (idx = 0; idx < PlayerList.Length && !bAcquired; idx++)
		{
			if (PlayerList[idx].Player != None &&
				!PlayerList[idx].bFriendly &&
				PlayerList[idx].bVisible)
			{
				bAcquired = AcquireEnemy(idx,true);
			}
		}
	}
	return bAcquired;
}

function bool CheckForUnCoveredEnemy()
{
	local int idx;
	local bool bAcquired;
	local WarPawn wfPawn;
	if (IsEnemyBehindCover())
	{
		bAcquired = true;
	}
	else
	{
		for (idx = 0; idx < PlayerList.Length && !bAcquired; idx++)
		{
			if (PlayerList[idx].Player != None &&
				!PlayerList[idx].bFriendly &&
				PlayerList[idx].bVisible)
			{
				wfPawn = WarPawn(PlayerList[idx].Player.Pawn);
				if (wfPawn != None &&
					wfPawn.CoverType == CT_None ||
					(wfPawn.CoverType != CT_None &&
					 wfPawn.CoverAction != CA_Default))
				{
					bAcquired = AcquireEnemy(idx,true);
				}
			}
		}
	}
	return bAcquired;
}

/* epic ===============================================
* ::AcquireEnemy
*
* Evaluates the specified enemy against our current
* selection and potentially changes.
*
* =====================================================
*/
function bool AcquireEnemy(int playerIdx, optional bool bForce)
{
	local bool bAcquire;
	if (IsValidPlayerIdx(playerIdx) &&
		playerIdx != enemyIdx &&
		!PlayerList[playerIdx].bFriendly)
	{
		bAcquire = true;
		// compare against our current enemy if applicable
		if (!bForce	&&
			HasValidEnemy())
		{
			if (RateEnemy(PlayerList[playerIdx].Player) < RateEnemy(PlayerList[EnemyIdx].Player))
			{
				bAcquire = false;
			}
		}
		if (bAcquire)
		{
			// set the new enemy
			Enemy = PlayerList[playerIdx].Player.Pawn;
			if (Enemy != None)
			{
				EnemyIdx = playerIdx;
				Focus = Enemy;
				AILog("Acquired new enemy:"@Enemy@Enemy.Controller@bForce,'Combat');
			}
			else
			{
				bAcquire = false;
			}
		}
	}
	return bAcquire;
}

/* epic ===============================================
* ::RateEnemy
*
* Returns a weight reflecting the desire to acquire
* the given player as our new enemy.
*
* =====================================================
*/
function float RateEnemy(Controller inPlayer)
{
	local float weight;
	return weight;
}

/* epic ===============================================
* ::ClearEnemy
*
* Clears our previous enemy selection.
*
* =====================================================
*/
final function ClearEnemy()
{
	EnemyIdx = -1;
	Enemy = None;
}

/* epic ===============================================
* ::IsEnemyVisible
*
* Is our enemy currently or recently visible?
*
* =====================================================
*/
final function bool IsEnemyVisible()
{
	return (HasValidEnemy() &&
			(PlayerList[EnemyIdx].bVisible &&
			 Level.TimeSeconds - PlayerList[EnemyIdx].LastSeenTime < 1.5f));
}

/**
 * Checks to see if our enemy would be visible from the given location.
 * 
 * @param	chkLocation - location to test LOS from
 * 
 * @return	true if our enemy is visible from that location
 */
final function bool IsEnemyVisibleFrom(vector chkLocation)
{
	return (HasValidEnemy() &&
			LineOfSightTo(Enemy,chkLocation));
}

/* epic ===============================================
* ::HasValidEnemy
*
* Returns whether or not we have a valid enemy currently
* acquired.
*
* =====================================================
*/
final function bool HasValidEnemy()
{
	return (Enemy != None &&
			IsValidPlayerIdx(EnemyIdx) &&
			!PlayerList[EnemyIdx].bFriendly &&
			PlayerList[EnemyIdx].Player != None &&
			PlayerList[EnemyIdx].Player.Pawn != None &&
			PlayerList[EnemyIdx].Player.Pawn.Health > 0);
}

/**
 * Returns true if our enemy is currently behind BTW cover.
 */
final function bool IsEnemyBehindCover()
{
	local WarPawn wfPawn;
	wfPawn = WarPawn(Enemy);
	return (HasValidEnemy() &&
			wfPawn.CoverType != CT_None &&
			wfPawn.CoverType != CT_Crouching &&
			wfPawn.CoverAction == CA_Default);
}

//=====================================================
// WEAPON FUNCTIONS

/**
 * Evaluates all weapons in the inventory chain and activates the
 * highest rated one.
 */
function EvaluateWeapons()
{
	// need to be re-interfaced with new InventoryManager class.
	local Inventory inv;
	local Weapon weap, bestWeap;
	local float rating, bestRating;
	if (Pawn != None)
	{
		AILog("Evaluating weapon selection, current:"@Pawn.Weapon,'Combat');
		for (inv = Pawn.InvManager.InventoryChain; inv != None; inv = inv.Inventory)
		{
			AILog("- inspecting inventory item:"@inv,'Combat');
			weap = Weapon(inv);
			if (weap != None)
			{
				rating = RateWeapon(weap);
				AILog("- evaluated weapon"@weap$", rating:"@rating,'Combat');
				if (rating != -1.f &&
					(bestWeap == None ||
					 rating > bestRating))
				{
					bestWeap = weap;
					bestRating = rating;
				}
			}
		}
		if (bestWeap != None)
		{
			// select the new best weapon
			if (bestWeap != Pawn.Weapon)
			{
				AILog("- evaluated weapons, best:"@bestWeap,'Combat');
				Pawn.InvManager.SetCurrentWeapon(bestWeap);
    		}
		}
	}
}

/**
 * Returns a value representing the overall desire to use the
 * specified weapon.
 * 
 * @param	inWeapon - weapon to rate
 *
 * @return	weighted desire to use inWeapon
 */
function float RateWeapon(Weapon inWeapon)
{
	local InventoryManager inv;
	local float weight;
	inv = Pawn.InvManager;
	if (inWeapon != None &&
		inWeapon.HasAnyAmmo())
	{
		weight += 0.25f;
		// tend to stick with the same weapon
		if (inWeapon == Pawn.Weapon)
		{
			weight += 0.15f;
		}
	}
	else
	{
		weight = -1.f;
	}
	return weight;
}

/**
 * Makes our weapon start firing.
 */
function StartFiring()
{
	if (Pawn != None &&
		Pawn.Weapon != None)
	{
		bFire = 1;
		Pawn.StartFire(0);
	}
}

/**
 * Makes our weapon start reloading.
 */
function StartReload()
{
	local WarWeapon weap;
	AILog("Starting weapon reload",'Weapon');
	if (Pawn != None)
	{
		weap = WarWeapon(Pawn.Weapon);
		if (weap != None)
		{
			weap.ForceReload();
		}
	}
}

/**
 * Checks to see if we should reload our current weapon.
 * 
 * @return	true if the weapon should be reloaded
 */
function bool CheckWeaponReload(optional float reloadPct)
{
	local WarWeapon weap;
	if (reloadPct == 0.f)
	{
		reloadPct = 0.7f;
	}
	if (Pawn != None)
	{
		weap = WarWeapon(Pawn.Weapon);
	}
	return (weap != None &&
            (weap.AmmoUsedCount/float(weap.MagazineSize)) > reloadPct);
}

/**
 * Returns true if our weapon is currently reloading.
 */
function bool IsReloading()
{
	local WarWeapon weap;
	if (Pawn != None)
	{
		weap = WarWeapon(Pawn.Weapon);
	}
	return (weap != None &&
			weap.CurrentFireMode == class'WarWeapon'.const.RELOAD_FIREMODE);
}

//=====================================================
// MISC FUNCTIONS

/**
 * Overridden to clean up any dangling objects.
 */
event Destroyed()
{
	if (AILogFile != None)
	{
		AILogFile.Destroy();
		AILogFile = None;
	}
	Super.Destroyed();
}

/**
 * Removes all latent actions of the specified type from the array.
 */
final function CompleteLatentActions(class<SeqAct_Latent> latentClass)
{
	local int idx;
	for (idx = 0; idx < LatentActions.Length; idx++)
	{
		if (LatentActions[idx] == None ||
			ClassIsChildOf(LatentActions[idx].Class,latentClass))
		{
			LatentActions.Remove(idx--,1);
		}
	}
}

//=====================================================
// STARTUP STATE

auto state WaitingForPawn
{
	function Possess(Pawn newPawn)
	{
		if (newPawn != None)
		{
			AILog("Received new pawn:"@newPawn,'WaitingForPawn');
			newPawn.SetMovementPhysics();
			// startup any logic timers
			SetTimer(5.f,true,'UpdateRecentNoise');
			SetTimer(1.f,true,'UpdatePlayerList');
			SetTimer(0.5f,true,'UpdateUnderFireMeter');
			// and transition to idle state
			GotoState('Idle');
		}
		Super.Possess(newPawn);
	}

	function BeginState()
	{
		// initialize transient data
		PlayerList.Length = 0;
		RecentNoise.Length = 0;
	}
}

function Possess(Pawn newPawn)
{
	super.Possess( NewPawn );

	if( Pawn != None )
	{
		log("add default inventory for" @ pawn );
 		// Add our default inventory
		Level.Game.AddDefaultInventory( Pawn );
	}
}	
//=====================================================
// IDLE STATE

state Idle
{
	function OnSeeEnemy(int playerIdx, bool bNewEnemy)
	{
		// acquire as a new enemy and evaluate the situation
		if (AcquireEnemy(playerIdx))
		{
			EvaluateSituation();
		}
	}
	
	function OnHearEnemy(int playerIdx)
	{
		GotoState('Idle','InvestigateNoise');
	}

	function BeginState()
	{
		// clear any left-overs
		ClearEnemy();
	}

	function EndState()
	{
	}

Begin:
	EvaluateWeapons();
}

//=====================================================
// DEAD STATE

state Dead
{
Begin:
	AILog("Entered dead state",'Dead');
	// nuke ourselves
	Destroy();
}

//=====================================================
// MOVETOGOAL STATE

/**
 * Set the current move goal information for use by the MoveToGoal
 * state.
 * 
 * @param	inGoalActor - actor to move to
 * 
 * @param	inbInterruptable - opt. is this move interruptable?
 * 
 * @param	inbReachable - opt. is the actor known to be reachable?
 * 
 * @param	inMoveTarget - opt. cached move target if pathfinding has already
 * 			been performed on inGoalActor
 */
function SetMoveGoal(Actor inGoalActor, optional bool inbInterruptable, optional bool inbReachable, optional Actor inMoveTarget)
{
	if (inGoalActor != None)
	{
		MoveGoal.GoalActor = inGoalActor;
		MoveGOal.bInterruptable = inbInterruptable;
		MoveGoal.bReachable = inbReachable;
		MoveGoal.CachedMoveTarget = inMoveTarget;
		// reset the move attempts as well
		MoveGoal.MoveAttempts = 0;
		if (!IsInState('MoveToGoal'))
		{
			PushState('MoveToGoal');
		}
		else
		{
			GotoState('MoveToGoal','Begin');
		}
	}
}

/**
 * Determines whether or not the current move goal is valid, by checking
 * both a valid GoalActor, and making sure it's not in the bad path
 * list.
 *
 * @return	true if the move goal is valid
 */
final function bool HasValidMoveGoal()
{
	return (MoveGoal.GoalActor != None &&
			!IsInvalidatedMoveGoal(MoveGoal.GoalActor));
}

/**
 * Is the specified actor in the invalid move goal list?
 */
final function bool IsInvalidatedMoveGoal(Actor chkGoal)
{
	local int idx;
	for (idx = 0; idx < InvalidMoveGoals.Length; idx++)
	{
		if (InvalidMoveGOals[idx] == chkGoal)
		{
			return true;
		}
	}
	return false;
}

/** 
 * Pops off entries in the route cache until we hit a reachable 
 * entry that we're not already at. 
 * 
 * @return	the next entry in the route cache
 */
final function Actor DecrementRouteCache()
{
	local int i, j;
	local Actor newRoute;
	// iterate through the current route cache
	for (i = 0; i < RouteCache.Length; i++)
	{
		if (RouteCache[i] == None)
		{
			// nothing left to check
			break;
		}
		// see if this point requires movement, and is reachable
		// TODO: If ActorReachable() fails for a point in the list, it is extremely likely that further points in the list
		// will also fail
		// So it might be better at that point to just nuke the routecache and bail out
		if (!Pawn.ReachedDestination(RouteCache[i]) && ActorReachable(RouteCache[i]))
		{
			newRoute = RouteCache[i];
			// set this as our new route cache entry
			for (j = 0; j < RouteCache.Length; j++)
			{
				RouteCache[j] = RouteCache[i];
				RouteCache[i] = None;
				i++;
				// see if there are any more entries to adjust
				if (i >= RouteCache.Length ||
					RouteCache[i] == None)
				{
					// all done
					break;
				}
			}
			break;
		}
		else
		{
			// clear this entry since it is invalid
			RouteCache[i] = None;
		}
	}
	return newRoute;
}

/**
 * Invalidates the current move goal.
 * 
 * @param	bInvalidMove - opt. add this goal actor to the bad path
 * 			list to avoid future attempts
 */
function InvalidateMoveGoal(optional bool bInvalidMove)
{
	local int idx;
	local bool bFoundEntry;
	if (MoveGoal.GoalActor != None)
	{
		if (bInvalidMove)
		{
			// make sure it doesn't already exist in the list
			for (idx = 0; idx < InvalidMoveGoals.Length && !bFoundEntry; idx++)
			{
				bFoundEntry = InvalidMoveGoals[idx] == MoveGoal.GoalActor;
			}
			if (!bFoundEntry)
			{
				// add to the end
				InvalidMoveGoals[InvalidMoveGoals.Length] = MoveGoal.GoalActor;
			}
			AILog("Invalidated move goal"@MoveGoal.GoalActor,'Move');
		}
		MoveGoal.GoalActor = None;
		MoveGoal.bReachable = false;
		MoveGoal.CachedMoveTarget = None;
		MoveGoal.MoveAttempts = 0;
	}
}

event bool NotifyBump(Actor Other, vector HitNormal)
{
	local Pawn bumpPawn;
	AILog("Global notify bump"@Other,'Sensory');
	if (bumpPawn != None &&
		IsFriendly(bumpPawn.Controller))
	{
		// try to step aside for them
		StepAsideFor(bumpPawn);
	}
	return Super.NotifyBump(Other,HitNormal);
}

function bool IsAtMoveGoal()
{
	return false;
}

/**
 * Generic move to goal state, accessed by SetMoveGoal().  Handles direct movement and
 * pathfinding, centralizing the code for reuse and maintenance.
 */
state MoveToGoal
{
	function BeginState()
	{
		AILog("Entered MoveToGoal w/o PushState",'Error');
	}

	/**
	 * Override enemy sighted event to check for bInterruptable.
	 */
	function OnSeeEnemy(int playerIdx, bool bNewEnemy)
	{
		if ((!HasValidEnemy() ||
			 bNewEnemy) &&
			MoveGoal.bInterruptable)
		{
			InvalidateMoveGoal();
			GotoState('Idle');
		}
	}

	/**
	 * Checks to see if the pawn has reached the move goal.
	 * 
	 * @return	true if the pawn has reached the goal
	 */
	function bool IsAtMoveGoal()
	{
		return Pawn.ReachedDestination(MoveGoal.GoalActor);
	}

	event PushedState()
	{
		bMoveAborted = false;
	}

	event PoppedState()
	{
		// check for any latent move actions, unless we're in a route move
		if (!HasValidRouteGoal())
		{
			ClearLatentAction(class'SeqAct_AIMoveToActor',bMoveAborted);
		}
	}

	event bool NotifyBump(Actor Other, vector HitNormal)
	{
		local Pawn bumpPawn;
		if (!bMoveAborted &&
			!bDelayingMove)
		{
			AILog("Bumped into"@Other@VSize(Pawn.Velocity),'Sensory');
			bumpPawn = Pawn(Other);
			// check to see if we've reached our destination, or they are standing on our destination
			if (IsAtMoveGoal() ||
				(bumpPawn != None &&
				 bumpPawn.ReachedDestination(MoveGoal.GoalActor)))
			{
				AILog("- reached goal or they're standing on the goal, finishing move",'Sensory');
				GotoState('MoveToGoal','FinishedMove');
			}
			else
			{
				if (bumpPawn != None &&
					IsFriendly(bumpPawn.Controller))
				{
					// see if they will step aside for us
					if (bumpPawn.Controller.IsA('WarAIController') &&
						WarAIController(bumpPawn.Controller).StepAsideFor(Pawn))
					{
						AILog("- other stepping aside for me, delaying",'Move');
						Pawn.Velocity = vect(0,0,0);
						GotoState('MoveToGoal','DelayMove');
						bDelayingMove = true;
					}
					// try to step aside for them
					else
					{
						StepAsideFor(bumpPawn);
					}
				}
			}
		}
		return false;
	}

Begin:
	bDelayingMove = false;
	if (MoveGoal.MoveAttempts++ > MAX_MOVE_ATTEMPTS)
	{
		AILog("Exceeded max move attempts, aborting move",'Move');
AbortMove:
		InvalidateMoveGoal(true);
		bMoveAborted = true;
		Pawn.Velocity = vect(0,0,0);
	}
	else
	if (HasValidMoveGoal())
	{
		// if it's directly reachable,
		if (MoveGoal.bReachable ||
			(MoveGoal.CachedMoveTarget == None &&
			 ActorReachable(MoveGoal.GoalActor)))
		{
			AILog("Attempting direct move to"@MoveGoal.GoalActor,'Move');
			// then move directly towards it
			MoveToward(MoveGoal.GoalActor);
			if (!IsAtMoveGoal())
			{
				AILog("Failed to reach goal via direct move, trying again",'Move');
				MoveGoal.bReachable = false;
				Goto('DelayMove');
			}
		}
		else
		{
			// otherwise build a path to the goal
			AILog("Attempting path find to"@MoveGoal.GoalActor,'Move');
			if (MoveGoal.CachedMoveTarget != None)
			{
				// used initial cached search
				MoveTarget = MoveGoal.CachedMoveTarget;
				// and invalidate
				MoveGoal.CachedMoveTarget = None;
			}
			else
			{
				MoveTarget = FindPathToward(MoveGoal.GoalActor);
			}
			if (MoveTarget != None)
			{
				// and step through the path
				do
				{
					MoveToward(MoveTarget);
					// get next path entry
					MoveTarget = DecrementRouteCache();
				}
				until (MoveTarget == None);
				if (!IsAtMoveGoal())
				{
					AILog("Failed to reach goal via path finding, trying again",'Move');
					Goto('DelayMove');
				}
			}
			else
			{
				AILog("Failed to find path to"@MoveGoal.GoalActor,'Move');
				// add to bad path list
				InvalidateMoveGoal(true);
				// and delay
				Sleep(0.25f);
			}
		}
	}
	else
	{
		AILog("Invalid move goal",'Move');
		Sleep(1.f);
		bMoveAborted = true;
	}
FinishedMove:
	AILog("Returning to previous state",'Move');
	Pawn.Velocity = vect(0,0,0);
	PopState();

DelayMove:
	AILog("Delay....",'Move');
	bDelayingMove = true;
	StopLatentExecution();
	Pawn.Velocity = vect(0,0,0);
	Sleep(RandRange(0.4,0.7f));
	bDelayingMove = false;
	Goto('Begin');
}

/**
 * Returns true if we can step aside for the specified player.
 */
function bool StepAsideFor(Pawn chkPawn)
{
	if (chkPawn != None)
	{
		AILog(chkPawn@"asked me to step aside",'Sensory');
		if (chkPawn != StepAsideGoal)
		{
			StepAsideGoal = chkPawn;
			if (GetStateName() != 'StepAside')
			{
				PushState('StepAside');
			}
			else
			{
				GotoState('StepAside','Begin');
			}
		}
		return true;
	}
	return false;
}

/**
 * Generic step aside state for moving out of the way of friendlies.
 */
state StepAside
{
	event bool NotifyBump(Actor Other, vector HitNormal)
	{
		if (Other != StepAsideGoal)
		{
			// look for another step aside location?
		}
		return false;
	}
	
	/**
	 * Returns true if the specified vector is valid for us to move to.
	 */
	function bool IsValidMoveLocation(vector chkLoc)
	{
		return PointReachable(chkLoc);
	}

	function PoppedState()
	{
		StepAsideGoal = None;
	}

	/**
	 * Returns a location that best moves out of the way of StepAsideGoal.
	 */
	function vector GetStepAsideLocation()
	{
		local vector x, y, z;
		local array<vector> chkLocs;
		local int idx;
		// first try a direction perpendicular to the target's velocity
		if (VSize(StepAsideGoal.Velocity) > 0)
		{
			x = Normal(StepAsideGoal.Velocity);
			z = vect(0,0,1);
			y = Normal(x cross z);
			chkLocs.Length = 6;
			// test first dir at max distance
			chkLocs[0] = Pawn.Location + y * MaxStepAsideDist;
			// half distance
			chkLocs[1] = Pawn.Location + y * MaxStepAsideDist * 0.5f;
			// other dir max distance
			chkLocs[2] = Pawn.Location - y * MaxStepAsideDist;
			// other dir half distance
			chkLocs[3] = Pawn.Location - y * MaxStepAsideDist * 0.5f;
			// half dir max distance
			chkLocs[4] = Pawn.Location + x * MaxStepAsideDist * 0.5f + y * MaxStepAsideDist * 0.5f;
			// half other dir max distance
			chkLocs[5] = Pawn.Location + x * MaxStepAsideDist * 0.5f - y * MaxStepAsideDist * 0.5f;
			// return the first valid one
			for (idx = 0; idx < chkLocs.Length; idx++)
			{
				if (IsValidMoveLocation(chkLocs[idx]))
				{
					return chkLocs[idx];
				}
			}
		}
		return Pawn.Location;
	}

Begin:
	if (StepAsideGoal != None)
	{
		MoveTo(GetStepAsideLocation(),StepAsideGoal);
	}
	PopState();
}

/**
 * Sets the new route goal and transitions to the MoveAlongRoute state.
 */
final function SetRouteGoal(Route inRoute, optional bool inbInterruptable)
{
	AILog("Receiving route goal"@inRoute@RouteGoal.GoalRoute,'Route');
	if (inRoute != None &&
		inRoute != RouteGoal.GoalRoute)
	{
		RouteGoal.GoalRoute = inRoute;
		RouteGoal.MoveDirection = 1;
		RouteGoal.bInterruptable = inbInterruptable;
		PushState('MoveAlongRoute');
	}
}

/**
 * Do we have a valid route?
 * 
 * @param	true if a valid route, with valid moves
 */
final function bool HasValidRouteGoal()
{
	return (RouteGoal.GoalRoute != None &&
			RouteGoal.GoalRoute.MoveList.Length > 0);
}

/**
 * Invalidates the current route goal.
 */
final function InvalidateRouteGoal()
{
	RouteGoal.GoalRoute = None;
}

state MoveAlongRoute
{
	/**
	 * Figures out the current location in the route and returns the
	 * next move target, or None if the route should no longer be
	 * followed.
	 * 
	 * @return	next desired move goal along the route
	 */
	function Actor UpdateRouteGoal()
	{
		local int idx, closestIdx;
		local Actor nextPt, closestPt, pt;
		local float closestDist, dist;
		local Route goalRoute;
		goalRoute = RouteGoal.GoalRoute;
		// find the closest point in the route
		for (idx = 0; idx < goalRoute.MoveList.Length; idx++)
		{
			pt = goalRoute.MoveList[idx];
			if (pt != None)
			{
				dist = VSize(pt.Location-Pawn.Location);
				if (closestPt == None ||
					dist < closestDist)
				{
					closestIdx = idx;
					closestPt = pt;
					closestDist = dist;
				}
			}
		}
		if (closestPt != None)
		{
			idx = closestIdx + RouteGoal.MoveDirection;
			AILog("Closest route goal point is:"@closestPt@closestIdx@idx,'Route');
			if (idx >= goalRoute.MoveList.Length ||
				idx < 0)
			{
				// check for a loop
				if (goalRoute.RouteType == ERT_Loop)
				{
					// reverse direction
					RouteGoal.MoveDirection *= -1;
					idx = closestIdx + RouteGoal.MoveDirection;
					nextPt = goalRoute.MoveList[idx];
				}
				else
				if (goalRoute.RouteType == ERT_Circle)
				{
					// reset at the beginning
					idx = 0;
					nextPt = goalRoute.MoveList[idx];
				}
			}
			else
			{
				nextPt = goalRoute.MoveList[idx];
			}
		}
		return nextPt;
	}

	event PoppedState()
	{
		ClearLatentAction(class'SeqAct_AIMoveToActor',bMoveAborted);
	}

Begin:
	if (HasValidRouteGoal())
	{
		// figure out the next move goal
		// and push move to goal
		MoveTarget = UpdateRouteGoal();
		AILog("Next route goal is"@MoveTarget,'Route');
		if (MoveTarget != None)
		{
			SetMoveGoal(MoveTarget,RouteGoal.bInterruptable);
			// move to next point
			Goto('Begin');
		}
		// invalidate the route goal
		InvalidateRouteGoal();
	}
	AILog("Returning to previous state",'Route');
	PopState();
}

state ShootAtTarget
{
	/**
	 * Overridden here to check for an abort.
	 */
	function OnAIShootAtTarget(SeqAct_AIShootAtTarget inAction)
	{
		if (inAction.InputLinks[1].bHasImpulse)
		{
			// invalidate the shoot target
			ShootTarget = None;
			StopFiring();
		}
		else
		{
			Global.OnAIShootAtTarget(inAction);
		}
	}

	function PoppedState()
	{
		ClearLatentAction(class'SeqAct_AIShootAtTarget');
	}

	function EndState()
	{
		ClearLatentAction(class'SeqAct_AIShootAtTarget');
	}
	
	simulated event GetPlayerViewPoint( out vector out_Location, out Rotator out_rotation )
	{
		if (Pawn != None)
		{
			out_Location = Pawn.Location + vect(0,0,24);
		}
		else
		{
			out_Location = Location;
		}
		if (ShootTarget != None)
		{
			out_rotation = rotator((ShootTarget.Location + VRand() * 96.f) - out_Location);
		}
		else
		{
			out_rotation = Rotation;
		}
	}

Begin:
	MoveTarget = None;
	Pawn.Velocity = vect(0,0,0);
	while (ShootTarget != None)
	{
		if (ShootTarget.IsA('Controller'))
		{
			ShootTarget = Controller(ShootTarget).Pawn;
		}
		if (ShootTarget != None)
		{
			Focus = ShootTarget;
			Sleep(0.3f);
			StartFiring();
			Sleep(RandRange(1.f,1.85f));
			StopFiring();
			Sleep(0.2f);
		}
	}
	PopState();
}

//=====================================================
// SCRIPTING FUNCTIONS

/**
 * Scripting hook to move this AI to a specific actor.
 */
function OnMoveToActor(SeqAct_MoveToActor inAction)
{
	local array<Object> objVars;
	local int idx;
	local bool bMoved;
	AILog("Received move action",'Scripted');
	// abort any previous latent moves
	ClearLatentAction(class'SeqAct_AIMoveToActor',true);
	// find the destination
	inAction.GetObjectVars(objVars,"Destination");
	for (idx = 0; idx < objVars.Length && !bMoved; idx++)
	{
		// check for a route
		if (Route(objVars[idx]) != None)
		{
			AILog("Moving along route:"@objVars[idx],'Scripted');
			SetRouteGoal(Route(objVars[idx]),inAction.bInterruptable);
			bMoved = true;
		}
		else
		// next check for a move to player
		if (Controller(objVars[idx]) != None &&
			Controller(objVars[idx]).Pawn != None)
		{
			AILog("Moving to player:"@objVars[idx],'Scripted');
			SetMoveGoal(Controller(objVars[idx]).Pawn,inAction.bInterruptable);
			bMoved = true;
		}
		else
		if (Actor(objVars[idx]) != None)
		{
			AILog("Moving to actor:"@objVars[idx],'Scripted');
			SetMoveGoal(Actor(objVars[idx]),inAction.bInterruptable);
			bMoved = true;
		}
	}
}
  

/**
 * Scripting hook to move this AI to a specific actor.
 */
function OnAIMoveToActor(SeqAct_AIMoveToActor inAction)
{
	local array<Object> objVars;
	local int idx;
	local bool bMoved;
	AILog("Received latent move action",'Scripted');
	// abort any previous latent moves
	ClearLatentAction(class'SeqAct_AIMoveToActor',true,inAction);
	// find the destination
	inAction.GetObjectVars(objVars,"Destination");
	for (idx = 0; idx < objVars.Length && !bMoved; idx++)
	{
		// check for a route
		if (Route(objVars[idx]) != None)
		{
			AILog("Moving along route:"@objVars[idx],'Scripted');
			SetRouteGoal(Route(objVars[idx]),inAction.bInterruptable);
			bMoved = true;
		}
		else
		// next check for a move to player
		if (Controller(objVars[idx]) != None &&
			Controller(objVars[idx]).Pawn != None)
		{
			AILog("Moving to player:"@objVars[idx],'Scripted');
			SetMoveGoal(Controller(objVars[idx]).Pawn,inAction.bInterruptable);
			bMoved = true;
		}
		else
		if (Actor(objVars[idx]) != None)
		{
			AILog("Moving to actor:"@objVars[idx],'Scripted');
			SetMoveGoal(Actor(objVars[idx]),inAction.bInterruptable);
			bMoved = true;
		}
	}
}

/**
 * Aborts the current latent move action, if any.
 */
function OnAIAbortMoveToActor(SeqAct_AIAbortMoveToActor inAction)
{
	local int idx;
	AILog("Received abort move action",'Scripted');
	// check to see if we have a latent move
	for (idx = 0; idx < LatentActions.Length; idx++)
	{
		if (ClassIsChildOf(LatentActions[idx].class,class'SeqAct_AIMoveToActor'))
		{
			AILog("- aborting move"@LatentActions[idx],'Scripted');
			LatentActions[idx].AbortFor(self);
			InvalidateRouteGoal();
			InvalidateMoveGoal();
			LatentActions.Remove(idx--,1);
		}
	}
}

/**
 * Causes the AI to transition to a state where it will fire at
 * the given target until it is no longer valid, or we are otherwise
 * interrupted.
 */
function OnAIShootAtTarget(SeqAct_AIShootAtTarget inAction)
{
	local array<Object> objVars;
	local int idx;
	if (inAction.InputLinks[0].bHasImpulse)
	{
		// figure out the shoot target
		inAction.GetObjectVars(objVars,"Shoot Target");
		ShootTarget = None;
		for (idx = 0; idx < objVars.Length && ShootTarget == None; idx++)
		{
			ShootTarget = Actor(objVars[idx]);
		}
		if (ShootTarget != None &&
			!IsInState('ShootAtTarget'))
		{
			PushState('ShootAtTarget');
		}
	}
}

simulated event GetPlayerViewPoint( out vector out_Location, out Rotator out_rotation )
{
	local vector aimLoc, randOffset;
	if (Pawn != None)
	{
		out_Location = Pawn.Location + vect(0,0,24);
	}
	else
	{
		out_Location = Location;
	}
	if (Enemy != None)
	{
		aimLoc = Enemy.Location + vect(0,0,15);
		//@temp - skew accuracy more if they're behind cover
		if (IsEnemyBehindCover())
		{
			randOffset = VRand() * 128.f;
		}
		else
		{
			randOffset = VRand() * 96.f;
		}
		randOffset.Z = abs(randOffset.Z);
		out_rotation = rotator((aimLoc + randOffset) - out_Location);
	}
	else
	{
		out_rotation = Rotation;
	}
}

function DrawDebug(WarHUD HUD)
{
	local WarPC pc;
	local vector cameraLoc, screenLoc;
	local rotator cameraRot;
	local Canvas Canvas;
	local array<string> debugInfo;
	local int idx;
	local float textW, textH, maxW;
	pc = WarPC(HUD.PlayerOwner);
	Canvas = HUD.Canvas;
	// get debug strings
	GetDebugInfo(debugInfo);
	// if valid debug info to draw
	if (Pawn != None &&
		debugInfo.Length > 0)
	{
		Canvas.Font = class'Engine'.default.SmallFont;
		// project location onto the hud
		pc.GetPlayerViewPoint(cameraLoc, cameraRot);
		screenLoc = Canvas.Project(Pawn.Location);
		// draw a cheap background
		Canvas.SetPos(screenLoc.X - 2,screenLoc.Y - 2);
		Canvas.SetDrawColor(47,47,47,128);
		for (idx = 0; idx < debugInfo.Length; idx++)
		{
			Canvas.TextSize(debugInfo[idx],textW,textH);
			if (textW > maxW)
			{
				maxW = textW;
			}
		}
		Canvas.DrawTile(Texture'WhiteSquareTexture',maxW+4,debugInfo.Length*10+8,0,0,2,2);
		// and draw debug info
		Canvas.SetDrawColor(255,255,255,255);
		for (idx = 0; idx < debugInfo.Length; idx++)
		{
			Canvas.SetPos(screenLoc.X,screenLoc.Y + (idx*10));
			Canvas.DrawText(debugInfo[idx]);
		}
	}
}

/**
 * Fills specified array of strings with useful debug info for this AI.
 */
function GetDebugInfo(out array<string> debugInfo)
{
	debugInfo.Length = 0;
	debugInfo[debugInfo.Length] = string(Name);
	debugInfo[debugInfo.Length] = "State:"@GetStateName();
}

defaultproperties
{
	MaxStepAsideDist=128.f
	bIsPlayer=true
	EnemyIdx=-1
}
