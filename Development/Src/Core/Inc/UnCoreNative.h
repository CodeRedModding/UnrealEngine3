/*=============================================================================
	UnCoreNative.h: Native function lookup table for static libraries.
	Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
=============================================================================*/

#ifndef UNCORENATIVE_H
#define UNCORENATIVE_H

/** A struct that maps a string name to a native function */
struct FNativeFunctionLookup
{
	const ANSICHAR* Name;
	Native Pointer;
};

/** A #define for autogenerated headers to fill out an FNativeFunctionLookup structure */
#define MAP_NATIVE(Class, FunctionName) \
	{ #Class #FunctionName, (Native)&Class::FunctionName },

/**
 * @todo Lookup function, but really, this doesn't even need a function
 * GNativeLookupFuncs could just be a map from Name to the array of 
 * name to function pointer thingie above
 */
extern TMap<FName, FNativeFunctionLookup*> GNativeLookupFuncs;

/**
 * Finds a native function by string name, using the function's class name
 * to look up it's lookup function that loops over it's name->function table
 *
 * @param ClassName Name of the class that owns the function
 * @param NativeName String name of the function to look up
 *
 * @return The native function pointer, or NULL on failure
 */
FORCEINLINE Native FindNative( FName ClassName, ANSICHAR* NativeName )
{
	FNativeFunctionLookup* LookupTable = GNativeLookupFuncs.FindRef(ClassName);

	// if the class has a lookup table associated with it, loop over the table
	if (LookupTable)
	{
		// loop over the functions until we get a NULL name (or it's found)
		INT FunctionIndex = 0; 
		while (LookupTable[FunctionIndex].Name)
		{
			// does the name match?
			if (appStrcmpANSI(NativeName, LookupTable[FunctionIndex].Name) == 0)
			{
				// if so, return it
				return LookupTable[FunctionIndex].Pointer;
			}

			// otherwise, move to the next function
			FunctionIndex++;
		}
	}

	// if anything failed to be found, return NULL
	return NULL;
}

#endif

