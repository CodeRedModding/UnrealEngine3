/*=============================================================================
	UnInterpolation.cpp: Code for supporting interpolation of properties in-game.
	Copyright 2004 Epic Games, Inc. All Rights Reserved.

	Revision history:
		* Created by James Golding
=============================================================================*/

#include "EnginePrivate.h"
#include "EngineSequenceClasses.h"
#include "EngineInterpolationClasses.h"
#include "UnLinkedObjDrawUtils.h"
#include "UnInterpolationHitProxy.h"

IMPLEMENT_CLASS(AInterpActor);

IMPLEMENT_CLASS(USeqAct_Interp);

IMPLEMENT_CLASS(UInterpData);

IMPLEMENT_CLASS(UInterpGroup);
IMPLEMENT_CLASS(UInterpGroupInst);

IMPLEMENT_CLASS(UInterpGroupDirector);
IMPLEMENT_CLASS(UInterpGroupInstDirector);

IMPLEMENT_CLASS(UInterpTrack);
IMPLEMENT_CLASS(UInterpTrackInst);

IMPLEMENT_CLASS(UInterpTrackMove);
IMPLEMENT_CLASS(UInterpTrackInstMove);

IMPLEMENT_CLASS(UInterpTrackFloatBase);

IMPLEMENT_CLASS(UInterpTrackFloatProp);
IMPLEMENT_CLASS(UInterpTrackInstFloatProp);

IMPLEMENT_CLASS(UInterpTrackEvent);
IMPLEMENT_CLASS(UInterpTrackInstEvent);

IMPLEMENT_CLASS(UInterpTrackDirector);
IMPLEMENT_CLASS(UInterpTrackInstDirector);

IMPLEMENT_CLASS(UInterpTrackFade);
IMPLEMENT_CLASS(UInterpTrackInstFade);

IMPLEMENT_CLASS(UInterpTrackSlomo);
IMPLEMENT_CLASS(UInterpTrackInstSlomo);


UBOOL AActor::FindInterpMoveTrack(UInterpTrackMove** OutMoveTrack, UInterpTrackInstMove** OutMoveTrackInst, USeqAct_Interp** OutSeq)
{
	for(INT i=0; i<LatentActions.Num(); i++)
	{
		USeqAct_Interp* InterpAct = Cast<USeqAct_Interp>(LatentActions(i) );
		if(InterpAct)
		{
			UInterpGroupInst* GrInst = InterpAct->FindGroupInst(this);
			check(GrInst); // Should have an instance of some group for this actor.
			check(GrInst->Group);

			for(INT i=0; i<GrInst->Group->InterpTracks.Num(); i++)
			{
				UInterpTrackMove* MoveTrack = Cast<UInterpTrackMove>( GrInst->Group->InterpTracks(i) );
				if(MoveTrack)
				{
					*OutMoveTrack = MoveTrack;
					*OutMoveTrackInst = CastChecked<UInterpTrackInstMove>( GrInst->TrackInst(i) );
					*OutSeq = InterpAct;
					return true;
				}
			}
		}
	}

	*OutMoveTrack = NULL;
	*OutMoveTrackInst = NULL;
	*OutSeq = NULL;
	return false;
}
	
/*-----------------------------------------------------------------------------
  UInterpData
-----------------------------------------------------------------------------*/

FString UInterpData::GetValueStr()
{
	return FString::Printf( TEXT("Matinee Data (%3.1fs)"), InterpLength );
}

/** Search through all InterpGroups in this InterpData to find a group whose GroupName matches the given name. Returns NULL if not group found. */
INT UInterpData::FindGroupByName(FName GroupName)
{
	if(GroupName != NAME_None)
	{
		for(INT i=0; i<InterpGroups.Num(); i++)
		{
			if( InterpGroups(i)->GroupName == GroupName )
			{
				return i;
			}
		}
	}

	return INDEX_NONE;
}

/** Search through all groups to find all tracks of the given class. */
void UInterpData::FindTracksByClass(UClass* TrackClass, TArray<UInterpTrack*>& OutputTracks)
{
	for(INT i=0; i<InterpGroups.Num(); i++)
	{
		UInterpGroup* Group = InterpGroups(i);
		Group->FindTracksByClass(TrackClass, OutputTracks);
	}
}

/** Find a DirectorGroup in the data. Should only ever be 0 or 1 of these! */
UInterpGroupDirector* UInterpData::FindDirectorGroup()
{
	UInterpGroupDirector* DirGroup = NULL;

	for(INT i=0; i<InterpGroups.Num(); i++)
	{
		UInterpGroupDirector* TestDirGroup = Cast<UInterpGroupDirector>( InterpGroups(i) );
		if(TestDirGroup)
		{
			check(!DirGroup); // Should only have 1 DirectorGroup at most!
			DirGroup = TestDirGroup;
		}
	}

	return DirGroup;
}

/** Get all the names of events in EventTracks generated by this InterpData. */
void UInterpData::GetAllEventNames(TArray<FName>& OutEventNames)
{
	TArray<UInterpTrack*> Tracks;
	FindTracksByClass(UInterpTrackEvent::StaticClass(), Tracks);

	for(INT i=0; i<Tracks.Num(); i++)
	{
		UInterpTrackEvent* EventTrack = CastChecked<UInterpTrackEvent>( Tracks(i) );

		for(INT i=0; i<EventTrack->EventTrack.Num(); i++)
		{
			OutEventNames.AddUniqueItem( EventTrack->EventTrack(i).EventName );
		}
	}
}


/*-----------------------------------------------------------------------------
  USeqAct_Interp
-----------------------------------------------------------------------------*/

void USeqAct_Interp::Serialize(	FArchive& Ar )
{
	Super::Serialize(Ar);

	// If before InterpData was stored exeternally - we 'externalise' it here!
	if(Ar.Ver() < 179)
	{
		USequence* ParentSeq = CastChecked<USequence>( GetOuter() );
		UInterpData* IData = InterpData;

		// Before we rename, make sure there is not some InterpData in the same sequence with the same name already.
		// If so, rename it.
		FName DataName = IData->GetFName();
		UInterpData* Found = FindObject<UInterpData>( ParentSeq, *DataName );
		if(Found)
		{
			Found->Rename();
		}

		// Set Outer of InterpData to be the sequence (like all SequenceVariables should be).
		IData->Rename( IData->GetName(), ParentSeq );

		// Add to parent sequence. Is this safe?
		ParentSeq->SequenceObjects.AddItem(IData);

		// Set the position of the data object to be somewhere near the SeqAct_Interp.
		IData->ObjPosX = ObjPosX;
		IData->ObjPosY = ObjPosY + DrawHeight + 20;

		// Add new VariableLink to the SeqAct_Interp
		FSeqVarLink NewLink;
		appMemzero(&NewLink, sizeof(FSeqVarLink));
		NewLink.MinVars = 1;
		NewLink.MaxVars = 1;
		NewLink.ExpectedType = UInterpData::StaticClass();
		NewLink.LinkDesc = FString( TEXT("Data") );
		NewLink.LinkedVariables.AddItem(IData);

		VariableLinks.InsertZeroed(0);
		VariableLinks(0) = NewLink;

		InterpData = NULL;
	}
}

/** When you create a SeqAct_Interp (aka Matinee action) automatically create an InterpData as well and connect it. */
void USeqAct_Interp::OnCreated()
{
	Super::OnCreated();

	// Declared in default properties
	check(VariableLinks.Num() == 1);
	check(VariableLinks(0).ExpectedType == UInterpData::StaticClass());
	check(VariableLinks(0).LinkedVariables.Num() == 0);

	// Create new InterpData to go along with the new Matinee
	USequence* ParentSeq = CastChecked<USequence>( GetOuter() );
	UInterpData* NewData = ConstructObject<UInterpData>( UInterpData::StaticClass(), ParentSeq, NAME_None, RF_Transactional);

	NewData->ObjPosX = ObjPosX;
	NewData->ObjPosY = ObjPosY + 130;
	NewData->Modify();

	// Add to links of Matinee action.
	VariableLinks(0).LinkedVariables.AddItem(NewData);

	// Add the same sequence as Matinee action.
	ParentSeq->SequenceObjects.AddItem(NewData);
}

static USequenceVariable* GetFirstVar( const FSeqVarLink& VarLink )
{
	for (INT idx = 0; idx < VarLink.LinkedVariables.Num(); idx++)
	{
		if(VarLink.LinkedVariables(idx) != NULL)
		{
			return VarLink.LinkedVariables(idx);
		}
	}

	return NULL;
}

/** 
 *	Return the InterpData currently connected to this Matinee action. Returns NULL if none connected. 
 *	Should never allow more than 1 InterpData connected.
 */
UInterpData* USeqAct_Interp::FindInterpDataFromVariable()
{
	// First variable connector should always be the InterpData.
	check(VariableLinks.Num() > 0);
	check(VariableLinks(0).ExpectedType == UInterpData::StaticClass());
	check(VariableLinks(0).LinkedVariables.Num() == 0 || VariableLinks(0).LinkedVariables.Num() == 1);

	USequence* RootSeq = GetRootSequence();
	check(RootSeq);

	if(VariableLinks(0).LinkedVariables.Num() > 0)
	{
		// We need to handle the case where the InterpData is connected via an External or Named variable.
		// Here we keep traversing these until we either find an InterpData, or fail (returning NULL).
		USequenceVariable* Var = VariableLinks(0).LinkedVariables(0);
		while(Var)
		{
			UInterpData* Data = Cast<UInterpData>(Var);
			if( Data )
			{
				return Data;
			}

			USeqVar_External* ExtVar = Cast<USeqVar_External>(Var);
			USeqVar_Named* NamedVar = Cast<USeqVar_Named>(Var);
			Var = NULL;

			if(ExtVar)
			{
				USequence* ParentSeq = Cast<USequence>(ExtVar->GetOuter());
				if (ParentSeq != NULL)
				{
					for (INT varIdx = 0; varIdx < ParentSeq->VariableLinks.Num(); varIdx++)
					{
						if (ParentSeq->VariableLinks(varIdx).LinkVar == ExtVar->GetFName())
						{
							Var = GetFirstVar( ParentSeq->VariableLinks(varIdx) );					
						}
					}
				}
			}
			else if(NamedVar)
			{
				TArray<USequenceVariable*> Vars;
				RootSeq->FindNamedVariables(NamedVar->FindVarName, false, Vars);

				if( Vars.Num() == 1 )
				{
					Data = Cast<UInterpData>( Vars(0) );
					if(Data)
					{
						return Data;
					}
				}
			}
		}
	}

	return NULL;
}

/** Synchronise the variable connectors with the currently attached InterpData. */
void USeqAct_Interp::UpdateConnectorsFromData()
{
	UInterpData* Data = FindInterpDataFromVariable();
	if(Data)
	{
		// Remove any connectors for which there is no Group (or group is a Director Group). Note, we don't check the MatineeData connector!
		for(INT i=VariableLinks.Num()-1; i>=1; i--)
		{
			INT GroupIndex = Data->FindGroupByName( FName(*VariableLinks(i).LinkDesc) );
			if( GroupIndex == INDEX_NONE || Data->InterpGroups(GroupIndex)->IsA(UInterpGroupDirector::StaticClass()) )
			{
				VariableLinks.Remove(i);
			}
		}

		// Ensure there is a connector for each InterpGroup.
		for(INT i=0; i<Data->InterpGroups.Num(); i++)
		{
			if( !Data->InterpGroups(i)->IsA(UInterpGroupDirector::StaticClass()) )
			{
				FName GroupName = Data->InterpGroups(i)->GroupName;
				if(FindConnectorIndex( FString(*GroupName), LOC_VARIABLE ) == INDEX_NONE)
				{
					FSeqVarLink NewLink;
					appMemset(&NewLink, 0, sizeof(FSeqVarLink));
					NewLink.MinVars = 0;
					NewLink.MaxVars = 255;
					NewLink.ExpectedType = USeqVar_Object::StaticClass();
					NewLink.LinkDesc = FString( *Data->InterpGroups(i)->GroupName );

					VariableLinks.AddItem(NewLink);
				}
			}
		}

		// Take care of output connectors in a similar way.
		TArray<FName> EventNames;
		Data->GetAllEventNames(EventNames);

		for(INT i=OutputLinks.Num()-1; i>=2; i--)
		{		
			FName LinkName(*OutputLinks(i).LinkDesc);
			if( !EventNames.ContainsItem(LinkName) )
			{
				OutputLinks.Remove(i);
			}
		}

		for(INT i=0; i<EventNames.Num(); i++)
		{
			FString EventString( *EventNames(i) );
			INT OutputIndex = FindConnectorIndex( EventString, LOC_OUTPUT );
			if(OutputIndex == INDEX_NONE)
			{
				INT NewOutIndex = OutputLinks.AddZeroed();

				FSeqOpOutputLink NewOut;
				appMemset( &NewOut, 0, sizeof(FSeqOpOutputLink) );
				NewOut.LinkDesc = EventString;

				OutputLinks(NewOutIndex) = NewOut;
			}
		}
	}
	else
	{
		// First variable link is always there  - for MatineeData
		if(VariableLinks.Num() > 1)
		{
			VariableLinks.Remove(1, VariableLinks.Num() - 1);
		}

		// First 2 output links are always there - for Completed and Aborted outputs
		if(OutputLinks.Num() > 2)
		{
			OutputLinks.Remove(2, OutputLinks.Num() - 2);
		}
	}
}

void USeqAct_Interp::Activated()
{
	if( bIsPlaying )
	{
		// Don't think we should ever get here...
		return;
	}
		
	// See if the 'Play' or 'Reverse' inputs have got an impulse. If so, start up action and get it ticking.
	if( InputLinks(0).bHasImpulse || InputLinks(1).bHasImpulse )
	{
		// For each Actor being interpolated- add us to its LatentActions list, and add it to our LatentActors list.
		// Similar to USequenceAction::Activated - but we don't call a handler function on the Object. Should we?
		TArray<UObject**> objectVars;
		GetObjectVars(objectVars);

		for(INT i=0; i<objectVars.Num(); i++)
		{
			AActor* Actor = Cast<AActor>( *(objectVars(i)) );
			if(Actor)
			{
				PreActorHandle(Actor);
			}
		}

		InitInterp();

		if( InputLinks(0).bHasImpulse )
		{
			Play();
		}
		else if( InputLinks(1).bHasImpulse )
		{
			Reverse();
		}
	}
}

// Returning true from here indicated we are done.
UBOOL USeqAct_Interp::UpdateOp(FLOAT deltaTime)
{
	if(!bIsPlaying)
	{
		// If we have stopped playing - return 'true' to indicate so.
		return true;
	}

	// First check inputs, to see if there is an input that might change direction etc.
	if( InputLinks(0).bHasImpulse )
	{
		Play();
	}
	else if( InputLinks(1).bHasImpulse )
	{
		Reverse();
	}
	else if( InputLinks(2).bHasImpulse )
	{
		Stop();
	}

	// Clear all the inputs now.
	InputLinks(0).bHasImpulse = 0;
	InputLinks(1).bHasImpulse = 0;
	InputLinks(2).bHasImpulse = 0;

	// Update the current position and do any interpolation work.
	StepInterp(deltaTime, false);

	// This is a latent function. To indicate we are still doing something - return false.
	return false;

}

void USeqAct_Interp::DeActivated()
{
	// Never fire any outputs if no Matinee Data attached.
	if(InterpData)
	{
		// If we are at the start, fire off the 'Aborted' output.
		if(Position < KINDA_SMALL_NUMBER)
		{
			OutputLinks(1).bHasImpulse = true;
		}
		// If we reached the end, fire off the 'Complete' output.
		else if(Position > (InterpData->InterpLength - KINDA_SMALL_NUMBER))
		{
			OutputLinks(0).bHasImpulse = true;
		}
		// If we are in the middle (ie. stopped because the 'Stop' input was hit). Don't fire any output.
	}

	// Remove this latent action from all actors it was working on, and empty our list of actors.
	for(INT i=0; i<LatentActors.Num(); i++)
	{
		AActor* Actor = LatentActors(i);
		Actor->LatentActions.RemoveItem(this);
	}

	LatentActors.Empty();

	// Do any interpolation sequence cleanup-  destroy track/group instances etc.
	TermInterp();
}

void USeqAct_Interp::Play()
{
	// See if we should rewind to beginning...
	if(bRewindOnPlay && (!bIsPlaying || bRewindIfAlreadyPlaying))
	{
		// 'Jump' interpolation to the start (ie. will not fire events between current position and start).
		UpdateInterp(0.f, false, true);
	}

	bReversePlayback = false;
	bIsPlaying = true;
}

void USeqAct_Interp::Stop()
{
	bIsPlaying = false;
}

void USeqAct_Interp::Reverse()
{
	bReversePlayback = true;
	bIsPlaying = true;
}

/**
 *	Advance current position in sequence and call UpdateInterp to update each group/track and the actor it is working on.
 *
 *	@param	DeltaSeconds	Amount to step sequence on by.
 *	@param	bPreview		If we are previewing sequence (ie. viewing in editor without gameplay running)
 */
void USeqAct_Interp::StepInterp(FLOAT DeltaSeconds, UBOOL bPreview)
{
	// Do nothing if not playing.
	if(!bIsPlaying || !InterpData)
		return;

	FLOAT NewPosition;

	// Playing forwards
	if(!bReversePlayback)
	{
		NewPosition = Position + (DeltaSeconds * PlayRate);

		if(NewPosition > InterpData->InterpLength)
		{
			// If looping, play to end, jump to start, and set target to somewhere near the beginning.
			if(bLooping)
			{
				UpdateInterp(InterpData->InterpLength, bPreview);
				UpdateInterp(0.f, bPreview, true);

				while(NewPosition > InterpData->InterpLength)
				{
					NewPosition -= InterpData->InterpLength;
				}
			}
			// If not looping, snap to end and stop playing.
			else
			{
				NewPosition = InterpData->InterpLength;
				bIsPlaying = false;
			}
		}
	}
	// Playing backwards.
	else
	{
		NewPosition = Position - (DeltaSeconds * PlayRate);

		if(NewPosition < 0.f)
		{
			// If looping, play to start, jump to end, and set target to somewhere near the end.
			if(bLooping)
			{
				UpdateInterp(0.f, bPreview);
				UpdateInterp(InterpData->InterpLength, bPreview, true);

				while(NewPosition < 0.f)
				{
					NewPosition += InterpData->InterpLength;
				}
			}
			// If not looping, snap to start and stop playing.
			else
			{
				NewPosition = 0.f;
				bIsPlaying = false;
			}
		}
	}

	UpdateInterp(NewPosition, bPreview);
}

// For each Actor connected to a particular group, create an instance.
void USeqAct_Interp::InitInterp()
{
	// Get the InterpData that this SeqAct_Interp is linked to.
	InterpData = FindInterpDataFromVariable();

	// Only continue if we successfully found some data.
	if(InterpData)
	{
		for(INT i=0; i<InterpData->InterpGroups.Num(); i++)
		{
			UInterpGroup* Group = InterpData->InterpGroups(i);

			// If this is a DirectorGroup, we find a player controller and pass it in instead of looking to a variable.
			UInterpGroupDirector* DirGroup = Cast<UInterpGroupDirector>(Group);
			if(DirGroup)
			{
				APlayerController* PC = NULL;

				ULevel *Level = GetLevel();
				if (Level != NULL && Level->GetLevelInfo()->bBegunPlay)
				{
					// iterate through the controller list
					for (AController *cont = Level->GetLevelInfo()->ControllerList; (cont != NULL) && (PC == NULL); cont = cont->NextController)
					{
						// if it's a player, use it.
						APlayerController* TestPC = Cast<APlayerController>(cont);
						if (TestPC)
						{
							PC = TestPC;
						}
					}
				}

				UInterpGroupInstDirector* NewGroupInstDir = ConstructObject<UInterpGroupInstDirector>(UInterpGroupInstDirector::StaticClass(), this, NAME_None, RF_Transactional);
				GroupInst.AddItem(NewGroupInstDir);

				NewGroupInstDir->InitGroupInst(DirGroup, PC);
			}
			else
			{
				TArray<UObject**> ObjectVars;
				GetObjectVars(ObjectVars, *(Group->GroupName));

				// We create at least one instance for every group - even if no Actor is attached.
				// Allows for tracks that dont require an Actor (eg. Event tracks).

				for(INT j=0; j<ObjectVars.Num() || j==0; j++)
				{
					AActor* Actor = NULL;
					if( j < ObjectVars.Num() )
					{
						UObject *Obj = *(ObjectVars(j));
						Actor = Cast<AActor>(Obj);

						// See if there is already a group working on this actor.
						UInterpGroupInst* TestInst = FindGroupInst(Actor);
						if(TestInst)
						{
							debugf( TEXT("Skipping instancing group - an Actor may only be connected to one Group!") );
							//Actor = NULL;
						}
					}

					UInterpGroupInst* NewGroupInst = ConstructObject<UInterpGroupInst>(UInterpGroupInst::StaticClass(), this, NAME_None, RF_Transactional);
					GroupInst.AddItem(NewGroupInst);

					NewGroupInst->InitGroupInst(Group, Actor);
				}
			}
		}
	}
}

void USeqAct_Interp::TermInterp()
{
	// Destroy each group instance.
	for(INT i=0; i<GroupInst.Num(); i++)
	{
		GroupInst(i)->TermGroupInst();
		delete GroupInst(i);
		GroupInst(i) = NULL;
	}

	GroupInst.Empty();

	// Drop reference to interpolation data.
	InterpData = NULL;
}


void USeqAct_Interp::UpdateInterp(FLOAT NewPosition, UBOOL bPreview, UBOOL bJump)
{
	if(!InterpData)
	{
		return;
	}

	NewPosition = Clamp(NewPosition, 0.f, InterpData->InterpLength);

	for(INT i=0; i<GroupInst.Num(); i++)
	{
		UInterpGroupInst* GrInst = GroupInst(i);

		check(GrInst->Group);
		GrInst->Group->UpdateGroup(NewPosition, GrInst, bPreview, bJump);
	}

	Position = NewPosition;
}

UInterpGroupInst* USeqAct_Interp::FindGroupInst(AActor* Actor)
{
	if(!Actor || Actor->bDeleteMe)
	{
		return NULL;
	}

	for(INT i=0; i<GroupInst.Num(); i++)
	{
		if( GroupInst(i)->GetGroupActor() == Actor )
		{
			return GroupInst(i);
		}
	}

	return NULL;
}

UInterpGroupInst* USeqAct_Interp::FindFirstGroupInst(UInterpGroup* InGroup)
{
	if(!InGroup)
	{
		return NULL;
	}

	for(INT i=0; i<GroupInst.Num(); i++)
	{
		if( GroupInst(i)->Group == InGroup )
		{
			return GroupInst(i);
		}
	}

	return NULL;
}

UInterpGroupInst* USeqAct_Interp::FindFirstGroupInstByName(FName InGroupName)
{
	if(InGroupName == NAME_None)
	{
		return NULL;
	}

	for(INT i=0; i<GroupInst.Num(); i++)
	{
		if( GroupInst(i)->Group->GroupName == InGroupName )
		{
			return GroupInst(i);
		}
	}

	return NULL;
}


/** If we have a DirectorGroup, use it to find the viewed group at the give time, then the first instance of that group, and the Actor it is bound to. */
AActor* USeqAct_Interp::FindViewedActor()
{
	UInterpGroupDirector* DirGroup = InterpData->FindDirectorGroup();
	if(DirGroup)
	{
		UInterpTrackDirector* DirTrack = DirGroup->GetDirectorTrack();
		if(DirTrack)
		{
			FName ViewGroupName = DirTrack->GetViewedGroupName(Position);
			UInterpGroupInst* ViewGroupInst = FindFirstGroupInstByName(ViewGroupName);
			if(ViewGroupInst)
			{
				return ViewGroupInst->GetGroupActor();
			}
		}
	}

	return NULL;
}

/*-----------------------------------------------------------------------------
 UInterpGroup
-----------------------------------------------------------------------------*/

void UInterpGroup::UpdateGroup(FLOAT NewPosition, UInterpGroupInst* GrInst, UBOOL bPreview, UBOOL bJump)
{
	check( InterpTracks.Num() == GrInst->TrackInst.Num() );

	for(INT i=0; i<InterpTracks.Num(); i++)
	{
		UInterpTrack* Track = InterpTracks(i);
		UInterpTrackInst* TrInst = GrInst->TrackInst(i);

		if(bPreview)
		{
			Track->PreviewUpdateTrack(NewPosition, TrInst);
		}
		else
		{
			Track->UpdateTrack(NewPosition, TrInst, bJump);
		}
	}
}

void UInterpGroup::EnsureUniqueName()
{
	UInterpData* IData = CastChecked<UInterpData>( GetOuter() );

	FName NameBase = GroupName;
	INT Suffix = 0;

	// Test all other groups apart from this one to see if name is already in use
	UBOOL bNameInUse = false;
	for(INT i=0; i<IData->InterpGroups.Num(); i++)
	{
		if( (IData->InterpGroups(i) != this) && (IData->InterpGroups(i)->GroupName == GroupName) )
		{
			bNameInUse = true;
		}
	}

	// If so - keep appending numbers until we find a name that isn't!
	while( bNameInUse )
	{
		FString GroupNameString = FString::Printf(TEXT("%s%d"), *NameBase, Suffix);
		GroupName = FName( *GroupNameString );
		Suffix++;

		bNameInUse = false;
		for(INT i=0; i<IData->InterpGroups.Num(); i++)
		{
			if( (IData->InterpGroups(i) != this) && (IData->InterpGroups(i)->GroupName == GroupName) )
			{
				bNameInUse = true;
			}
		}
	}
}

/** Add all tracks within this group of supplied class to array. */
void UInterpGroup::FindTracksByClass(UClass* TrackClass, TArray<UInterpTrack*>& OutputTracks)
{
	for(INT i=0; i<InterpTracks.Num(); i++)
	{
		UInterpTrack* Track = InterpTracks(i);
		if( Track->IsA(TrackClass) )
		{
			OutputTracks.AddItem(Track);
		}
	}
}

/*-----------------------------------------------------------------------------
 UInterpGroupInst
-----------------------------------------------------------------------------*/

AActor* UInterpGroupInst::GetGroupActor()
{
	if(!GroupActor || GroupActor->bDeleteMe)
	{
		return NULL;
	}
	else
	{
		return GroupActor;
	}
}

void UInterpGroupInst::SaveGroupActorState()
{
	for(INT i=0; i<TrackInst.Num(); i++)
	{
		TrackInst(i)->SaveActorState();
	}
}

void UInterpGroupInst::RestoreGroupActorState()
{
	for(INT i=0; i<TrackInst.Num(); i++)
	{
		TrackInst(i)->RestoreActorState();
	}
}

void UInterpGroupInst::InitGroupInst(UInterpGroup* InGroup, AActor* InGroupActor)
{
	Group = InGroup;
	GroupActor = InGroupActor;

	for(INT i=0; i<InGroup->InterpTracks.Num(); i++)
	{
		UInterpTrack* Track = InGroup->InterpTracks(i);

		UInterpTrackInst* TrInst = ConstructObject<UInterpTrackInst>( Track->TrackInstClass, this, NAME_None, RF_Transactional );
		TrackInst.AddItem(TrInst);

		TrInst->InitTrackInst(Track);
	}
}

void UInterpGroupInst::TermGroupInst()
{
	for(INT i=0; i<TrackInst.Num(); i++)
	{
		TrackInst(i)->TermTrackInst();
		delete TrackInst(i);
		TrackInst(i) = NULL;
	}

	TrackInst.Empty();
}

/*-----------------------------------------------------------------------------
 UInterpGroupDirector
-----------------------------------------------------------------------------*/

void UInterpGroupDirector::UpdateGroup(FLOAT NewPosition, UInterpGroupInst* GrInst, UBOOL bPreview)
{
	Super::UpdateGroup(NewPosition, GrInst, bPreview);
}

/** Returns the director track inside this Director group - if present. */
UInterpTrackDirector* UInterpGroupDirector::GetDirectorTrack()
{
	for(INT i=0; i<InterpTracks.Num(); i++)
	{
		UInterpTrackDirector* DirTrack = Cast<UInterpTrackDirector>( InterpTracks(i) );
		if( DirTrack )
		{
			return DirTrack;
		}
	}

	return NULL;
}

/** Returns the fade track inside this Director group - if present. */
UInterpTrackFade* UInterpGroupDirector::GetFadeTrack()
{
	for(INT i=0; i<InterpTracks.Num(); i++)
	{
		UInterpTrackFade* FadeTrack = Cast<UInterpTrackFade>( InterpTracks(i) );
		if( FadeTrack )
		{
			return FadeTrack;
		}
	}

	return NULL;
}

/** Returns the slomo track inside this Director group - if present. */
UInterpTrackSlomo* UInterpGroupDirector::GetSlomoTrack()
{
	for(INT i=0; i<InterpTracks.Num(); i++)
	{
		UInterpTrackSlomo* SlomoTrack = Cast<UInterpTrackSlomo>( InterpTracks(i) );
		if( SlomoTrack )
		{
			return SlomoTrack;
		}
	}

	return NULL;
}

/*-----------------------------------------------------------------------------
 UInterpTrackInst
-----------------------------------------------------------------------------*/

AActor* UInterpTrackInst::GetGroupActor()
{
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( GetOuter() );
	return GrInst->GetGroupActor();
}

/*-----------------------------------------------------------------------------
 UInterpTrackMove
-----------------------------------------------------------------------------*/

INT UInterpTrackMove::GetNumKeyframes()
{
	check( PosTrack.Points.Num() == EulerTrack.Points.Num() );
	return PosTrack.Points.Num();
}

void UInterpTrackMove::GetTimeRange(FLOAT& StartTime, FLOAT& EndTime)
{
	check( PosTrack.Points.Num() == EulerTrack.Points.Num() );

	if(PosTrack.Points.Num() == 0)
	{
		StartTime = 0.f;
		EndTime = 0.f;
	}
	else
	{
		// PosTrack and EulerTrack should have the same number of keys at the same times.
		check( (PosTrack.Points(0).InVal - EulerTrack.Points(0).InVal) < KINDA_SMALL_NUMBER );
		check( (PosTrack.Points(PosTrack.Points.Num()-1).InVal - EulerTrack.Points(EulerTrack.Points.Num()-1).InVal) < KINDA_SMALL_NUMBER );

		StartTime = PosTrack.Points(0).InVal;
		EndTime = PosTrack.Points( PosTrack.Points.Num()-1 ).InVal;
	}
}

FLOAT UInterpTrackMove::GetKeyframeTime(INT KeyIndex)
{
	check( PosTrack.Points.Num() == EulerTrack.Points.Num() );
	if( KeyIndex < 0 || KeyIndex >= PosTrack.Points.Num() )
		return 0.f;

	check( (PosTrack.Points(KeyIndex).InVal - EulerTrack.Points(KeyIndex).InVal) < KINDA_SMALL_NUMBER );

	return PosTrack.Points(KeyIndex).InVal;
}

INT UInterpTrackMove::AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst)
{
	check( PosTrack.Points.Num() == EulerTrack.Points.Num() );

	AActor* Actor = TrInst->GetGroupActor();
	if(!Actor)
	{
		return INDEX_NONE;
	}

	INT NewKeyIndex = PosTrack.AddPoint( Time, FVector(0,0,0) );
	PosTrack.Points(NewKeyIndex).InterpMode = CIM_CurveAuto;

	INT NewRotKeyIndex = EulerTrack.AddPoint( Time, FVector(0.f) );
	EulerTrack.Points(NewRotKeyIndex).InterpMode = CIM_CurveAuto;

	check(NewKeyIndex == NewRotKeyIndex);

	UpdateKeyframe(NewKeyIndex, TrInst);

	PosTrack.AutoSetTangents(LinCurveTension);
	EulerTrack.AutoSetTangents(AngCurveTension);

	return NewKeyIndex;
}

FVector WindNumToEuler(const FVector& WindNum)
{
	FVector OutEuler;
	OutEuler.X = appRound(WindNum.X) * 360.f;
	OutEuler.Y = appRound(WindNum.Y) * 360.f;
	OutEuler.Z = appRound(WindNum.Z) * 360.f;
	return OutEuler;
}

void UInterpTrackMove::UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst)
{
	check( PosTrack.Points.Num() == EulerTrack.Points.Num() );
	if( KeyIndex < 0 || KeyIndex >= EulerTrack.Points.Num() )
	{
		return;
	}

	AActor* Actor = TrInst->GetGroupActor();
	if(!Actor)
	{
		return;
	}

	AActor* BaseActor = Actor->GetBase();
	FMatrix BaseTM = FMatrix::Identity;
	if(BaseActor)
	{
		BaseTM = FMatrix(BaseActor->Location, BaseActor->Rotation);
		BaseTM.RemoveScaling();
	}

	// Don't want to record keyframes if track disabled.
	if(bDisableMovement)
	{
		return;
	}

	UInterpTrackInstMove* MoveTrackInst = CastChecked<UInterpTrackInstMove>(TrInst);

	// Take the Actor Rotator and turn it into Winding and Remainder parts
	FRotator ActorWind, ActorRem;
	Actor->Rotation.GetWindingAndRemainder(ActorWind, ActorRem);

	// Convert fractional rotation part and convert into transform
	FQuat ActorRemQuat = ActorRem.Quaternion();
	FMatrix WorldKeyTM = FMatrix( Actor->Location, ActorRemQuat );

	// Find number of complete rotations around each axis from winding part.
	FVector ActorWindNum = ActorWind.Euler() / 360.f;

	if(MoveFrame == IMF_World)
	{
		if(BaseActor)
		{
			FMatrix InvBaseTM = BaseTM.Inverse();

			FMatrix RelKeyTM = WorldKeyTM * InvBaseTM;
			FVector RelKeyWindEuler = WindNumToEuler( InvBaseTM.TransformNormal(ActorWindNum) );

			PosTrack.Points(KeyIndex).OutVal = RelKeyTM.GetOrigin();
			EulerTrack.Points(KeyIndex).OutVal = FQuat(RelKeyTM).Euler() + RelKeyWindEuler;
		}
		else
		{
			PosTrack.Points(KeyIndex).OutVal = Actor->Location;
			EulerTrack.Points(KeyIndex).OutVal = Actor->Rotation.Euler();
		}
	}
	else if(MoveFrame == IMF_RelativeToInitial)
	{
		FMatrix InvInitialTM;
		if(BaseActor)
		{
			InvInitialTM = (MoveTrackInst->InitialTM * BaseTM).Inverse();
		}
		else
		{
			InvInitialTM = MoveTrackInst->InitialTM.Inverse();
		}

		FMatrix RelKeyTM = WorldKeyTM * InvInitialTM;
		FVector RelKeyWindEuler = WindNumToEuler( InvInitialTM.TransformNormal(ActorWindNum) );

		PosTrack.Points(KeyIndex).OutVal = RelKeyTM.GetOrigin();
		EulerTrack.Points(KeyIndex).OutVal = FQuat(RelKeyTM).Euler() + RelKeyWindEuler;
	}
	else 
	{
		appMsgf( 0, TEXT("Unknown Interpolation Type!") );
		PosTrack.Points(KeyIndex).OutVal = FVector(0.f);
		EulerTrack.Points(KeyIndex).OutVal = FVector(0.f);
	}

	// Update the tangent vectors for the changed point, and its neighbours.
	PosTrack.AutoSetTangents(LinCurveTension);
	EulerTrack.AutoSetTangents(AngCurveTension);
}

INT UInterpTrackMove::SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder)
{
	check( PosTrack.Points.Num() == EulerTrack.Points.Num() );
	if( KeyIndex < 0 || KeyIndex >= PosTrack.Points.Num() )
		return KeyIndex;

	INT NewKeyIndex = KeyIndex;
	if(bUpdateOrder)
	{
		NewKeyIndex = PosTrack.MovePoint(KeyIndex, NewKeyTime);
		INT NewEulerKeyIndex = EulerTrack.MovePoint(KeyIndex, NewKeyTime);
		check( NewKeyIndex == NewEulerKeyIndex );
	}
	else
	{
		PosTrack.Points(KeyIndex).InVal = NewKeyTime;
		EulerTrack.Points(KeyIndex).InVal = NewKeyTime;
	}

	PosTrack.AutoSetTangents(LinCurveTension);
	EulerTrack.AutoSetTangents(AngCurveTension);

	return NewKeyIndex;
}

void UInterpTrackMove::RemoveKeyframe(INT KeyIndex)
{
	check( PosTrack.Points.Num() == EulerTrack.Points.Num() );
	if( KeyIndex < 0 || KeyIndex >= PosTrack.Points.Num() )
		return;

	PosTrack.Points.Remove(KeyIndex);
	EulerTrack.Points.Remove(KeyIndex);

	PosTrack.AutoSetTangents(LinCurveTension);
	EulerTrack.AutoSetTangents(AngCurveTension);
}

INT UInterpTrackMove::DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime)
{
	check( PosTrack.Points.Num() == EulerTrack.Points.Num() );
	if( KeyIndex < 0 || KeyIndex >= PosTrack.Points.Num() )
		return INDEX_NONE;

	FInterpCurvePoint<FVector> PosPoint = PosTrack.Points(KeyIndex);
	INT NewPosIndex = PosTrack.AddPoint(NewKeyTime, 0.f);
	PosTrack.Points(NewPosIndex) = PosPoint; // Copy properties from source key.
	PosTrack.Points(NewPosIndex).InVal = NewKeyTime;

	FInterpCurvePoint<FVector> EulerPoint = EulerTrack.Points(KeyIndex);
	INT NewEulerIndex = EulerTrack.AddPoint(NewKeyTime, 0.f);
	EulerTrack.Points(NewEulerIndex) = EulerPoint;
	EulerTrack.Points(NewEulerIndex).InVal = NewKeyTime;

	check(NewPosIndex == NewEulerIndex);

	PosTrack.AutoSetTangents(LinCurveTension);
	EulerTrack.AutoSetTangents(AngCurveTension);

	return NewPosIndex;
}

void UInterpTrackMove::PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst)
{
	AActor* Actor = TrInst->GetGroupActor();
	if(!Actor)
	{
		return;
	}

	if(bDisableMovement)
	{
		NewPosition = 0.0f;
	}

	FVector NewPos = Actor->Location;
	FRotator NewRot = Actor->Rotation;

	GetLocationAtTime(TrInst, NewPosition, NewPos, NewRot);

	Actor->Location = NewPos;
	Actor->Rotation = NewRot;

	Actor->InvalidateLightingCache();
	Actor->UpdateComponents();
}

void UInterpTrackMove::PostEditChange(UProperty* PropertyThatChanged)
{
	Super::PostEditChange(PropertyThatChanged);

	check( PosTrack.Points.Num() == EulerTrack.Points.Num() );

	PosTrack.AutoSetTangents(LinCurveTension);
	EulerTrack.AutoSetTangents(AngCurveTension);
}

void UInterpTrackMove::PostLoad()
{
	Super::PostLoad();

	// If older version which used RotTrack instead of EulerTrack
	if( (EulerTrack.Points.Num() != RotTrack.Points.Num()) && 
		(RotTrack.Points.Num() > 0) && 
		(EulerTrack.Points.Num() == 0) &&
		(RotTrack.Points.Num() == PosTrack.Points.Num()) )
	{
		EulerTrack.Points.Empty();
		EulerTrack.Points.AddZeroed( RotTrack.Points.Num() );

		for(INT i=0; i<EulerTrack.Points.Num(); i++)
		{
			EulerTrack.Points(i).InVal = RotTrack.Points(i).InVal;
			EulerTrack.Points(i).OutVal = RotTrack.Points(i).OutVal.Euler();

			EulerTrack.Points(i).InterpMode = PosTrack.Points(i).InterpMode;
		}

		// Throw away old RotTrack data.
		RotTrack.Points.Empty();

		EulerTrack.AutoSetTangents(0.f);
	}

	// If things are still wrong - no choice but to clear data...
	if(EulerTrack.Points.Num() != PosTrack.Points.Num())
	{
		EulerTrack.Points.Empty();
		PosTrack.Points.Empty();
	}
}

FMatrix UInterpTrackMove::GetKeyTransformAtTime(UInterpTrackInstMove* MoveTrackInst, FLOAT Time)
{
	FQuat KeyQuat;
	if(bUseQuatInterpolation)
	{
		INT NumPoints = EulerTrack.Points.Num();

		// If no point in curve, return the Default value we passed in.
		if( NumPoints == 0 )
		{
			KeyQuat = FQuat::Identity;
		}
		// If only one point, or before the first point in the curve, return the first points value.
		else if( NumPoints < 2 || (Time <= EulerTrack.Points(0).InVal) )
		{
			KeyQuat = FQuat::MakeFromEuler(EulerTrack.Points(0).OutVal);
		}
		// If beyond the last point in the curve, return its value.
		else if( Time >= EulerTrack.Points(NumPoints-1).InVal )
		{
			KeyQuat = FQuat::MakeFromEuler(EulerTrack.Points(NumPoints-1).OutVal);
		}
		// Somewhere with curve range - linear search to find value.
		else
		{			
			UBOOL bFoundPos = false;
			for( INT i=1; i<NumPoints && !bFoundPos; i++ )
			{	
				if( Time < EulerTrack.Points(i).InVal )
				{
					FLOAT Delta = EulerTrack.Points(i).InVal - EulerTrack.Points(i-1).InVal;
					FLOAT Alpha = Clamp( (Time - EulerTrack.Points(i-1).InVal) / Delta, 0.f, 1.f );

					FQuat Key1Quat = FQuat::MakeFromEuler(EulerTrack.Points(i-1).OutVal);
					FQuat Key2Quat = FQuat::MakeFromEuler(EulerTrack.Points(i).OutVal);

					KeyQuat = SlerpQuat( Key1Quat, Key2Quat, Alpha );

					bFoundPos = true;
				}
			}
		}
	}
	else
	{
		KeyQuat = FQuat::MakeFromEuler( EulerTrack.Eval(Time, FVector(0.f)) );
	}

	return FMatrix( PosTrack.Eval(Time, FVector(0.f)), KeyQuat );
}

// The inputs here are treated as the 'default' output ie. if there is no track data.
void UInterpTrackMove::GetLocationAtTime(UInterpTrackInst* TrInst, FLOAT Time, FVector& OutPos, FRotator& OutRot)
{
	UInterpTrackInstMove* MoveTrackInst = CastChecked<UInterpTrackInstMove>(TrInst);
	AActor* Actor = TrInst->GetGroupActor();
	if(!Actor)
	{
		debugf( TEXT("WARNING: UInterpTrackMove::GetLocationAtTime: No Actor or Actor deleted. Aborting.") );
		OutPos = FVector(0.f);
		OutRot = FRotator(0,0,0);
		return;
	}

	check(EulerTrack.Points.Num() == PosTrack.Points.Num());

	// Do nothing if no data on this track.
	if(EulerTrack.Points.Num() == 0)
	{
		return;
	}

	// Find the transform for the given time.
	FMatrix RelTM = GetKeyTransformAtTime(MoveTrackInst, Time);
	
	// Find the reference frame the key is considered in.
	FMatrix ParentTM = GetMoveRefFrame(MoveTrackInst);

	// Then apply keyframed position to base to find desired position in world frame.
	FMatrix WorldTM = RelTM * ParentTM;

	OutPos = WorldTM.GetOrigin();
	OutRot = WorldTM.Rotator();

	// Replace rotation if using a special rotation mode.
	if(RotMode == IMR_LookAtGroup)
	{		
		if(LookAtGroupName != NAME_None)
		{
			UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( TrInst->GetOuter() );
			USeqAct_Interp* Seq = CastChecked<USeqAct_Interp>( GrInst->GetOuter() );
			UInterpGroupInst* LookAtGroupInst = Seq->FindFirstGroupInstByName(LookAtGroupName);

			if(LookAtGroupInst && LookAtGroupInst->GetGroupActor())
			{
				AActor* LookAtActor = LookAtGroupInst->GetGroupActor();

				// Slight hack here so that if we are trying to look at a Player variable, it looks at their Pawn.
				APlayerController* PC = Cast<APlayerController>(LookAtActor);
				if(PC && PC->Pawn)
				{
					LookAtActor = PC->Pawn;
				}

				// Find Rotator that points at LookAtActor
				FVector LookDir = (LookAtActor->Location - Actor->Location).SafeNormal();
				OutRot = LookDir.Rotation();
			}
		}
	}
}

/** 
 *	Return the reference frame that the animation is currently working within.
 *	Looks at the current MoveFrame setting and whether the Actor is based on something.
 */
FMatrix UInterpTrackMove::GetMoveRefFrame(UInterpTrackInstMove* MoveTrackInst)
{
	AActor* Actor = MoveTrackInst->GetGroupActor();

	AActor* BaseActor = NULL;
	if(Actor)
	{
		BaseActor = Actor->GetBase();
	}

	FMatrix RefTM = FMatrix::Identity;
	if( MoveFrame == IMF_World )
	{
		if(BaseActor)
		{
			RefTM = FMatrix(BaseActor->Location, BaseActor->Rotation);
			RefTM.RemoveScaling();
		}
		else
		{
			RefTM = FMatrix::Identity;
		}
	}
	else if( MoveFrame == IMF_RelativeToInitial )
	{
		if(BaseActor)
		{
			RefTM = MoveTrackInst->InitialTM * FMatrix(BaseActor->Location, BaseActor->Rotation);
			RefTM.RemoveScaling();
		}
		else
		{
			RefTM = MoveTrackInst->InitialTM;
		}
	}

	return RefTM;
}

/*-----------------------------------------------------------------------------
 UInterpTrackInstMove
-----------------------------------------------------------------------------*/

void UInterpTrackInstMove::SaveActorState()
{
	AActor* Actor = GetGroupActor();
	if(!Actor)
	{
		return;
	}

	ResetLocation = Actor->Location;
	ResetRotation = Actor->Rotation;
}

void UInterpTrackInstMove::RestoreActorState()
{
	AActor* Actor = GetGroupActor();
	if(!Actor)
	{
		return;
	}

	Actor->Location = ResetLocation;
	Actor->Rotation = ResetRotation;

	Actor->InvalidateLightingCache();
	Actor->UpdateComponents();
	Actor->PostEditMove();
}

void UInterpTrackInstMove::InitTrackInst(UInterpTrack* Track)
{
	UInterpTrackMove* MoveTrack = CastChecked<UInterpTrackMove>( Track );
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( GetOuter() );
	USeqAct_Interp* Seq = CastChecked<USeqAct_Interp>( GrInst->GetOuter() );

	AActor* Actor = GetGroupActor();
	if(!Actor)
	{
		return;
	}

	// The following is only used in the case of IMF_RelativeToInitial

	FMatrix ActorTM = FMatrix( Actor->Location,  Actor->Rotation.Quaternion() );
	ActorTM.RemoveScaling();

	// If this Actor has a base, transform its current position into the frame of its Base.
	AActor* BaseActor = Actor->GetBase();
	if(BaseActor)
	{
		FMatrix BaseTM(BaseActor->Location, BaseActor->Rotation);
		BaseTM.RemoveScaling();

		FMatrix InvBaseTM = BaseTM.Inverse();

		ActorTM = ActorTM * InvBaseTM;
	}

	// Find the current relative position according to the interpolation.
	FMatrix RelTM = MoveTrack->GetKeyTransformAtTime(this, Seq->Position);

	// Initial position is the current position of the Actor, minus the transform from the beginning of the track.
	// This is so that we can stop a 'relative to initial' interpolation and restart it again etc.
	InitialTM = RelTM.Inverse() * ActorTM;
	InitialTM.RemoveScaling();

	InitialQuat = FQuat(InitialTM);
}

/*-----------------------------------------------------------------------------
  UInterpTrackFloatBase
-----------------------------------------------------------------------------*/

INT UInterpTrackFloatBase::GetNumKeyframes()
{
	return FloatTrack.Points.Num();
}

void UInterpTrackFloatBase::GetTimeRange(FLOAT& StartTime, FLOAT& EndTime)
{
	if(FloatTrack.Points.Num() == 0)
	{
		StartTime = 0.f;
		EndTime = 0.f;
	}
	else
	{
		StartTime = FloatTrack.Points(0).InVal;
		EndTime = FloatTrack.Points( FloatTrack.Points.Num()-1 ).InVal;
	}
}

FLOAT UInterpTrackFloatBase::GetKeyframeTime(INT KeyIndex)
{
	if( KeyIndex < 0 || KeyIndex >= FloatTrack.Points.Num() )
		return 0.f;

	return FloatTrack.Points(KeyIndex).InVal;
}

INT UInterpTrackFloatBase::SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder)
{
	if( KeyIndex < 0 || KeyIndex >= FloatTrack.Points.Num() )
		return KeyIndex;

	INT NewKeyIndex = KeyIndex;
	if(bUpdateOrder)
	{
		NewKeyIndex = FloatTrack.MovePoint(KeyIndex, NewKeyTime);
	}
	else
	{
		FloatTrack.Points(KeyIndex).InVal = NewKeyTime;
	}

	FloatTrack.AutoSetTangents(CurveTension);

	return NewKeyIndex;
}

void UInterpTrackFloatBase::RemoveKeyframe(INT KeyIndex)
{
	if( KeyIndex < 0 || KeyIndex >= FloatTrack.Points.Num() )
		return;

	FloatTrack.Points.Remove(KeyIndex);

	FloatTrack.AutoSetTangents(CurveTension);
}


INT UInterpTrackFloatBase::DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime)
{
	if( KeyIndex < 0 || KeyIndex >= FloatTrack.Points.Num() )
		return INDEX_NONE;

	FInterpCurvePoint<FLOAT> FloatPoint = FloatTrack.Points(KeyIndex);
	INT NewKeyIndex = FloatTrack.AddPoint(NewKeyTime, 0.f);
	FloatTrack.Points(NewKeyIndex) = FloatPoint; // Copy properties from source key.
	FloatTrack.Points(NewKeyIndex).InVal = NewKeyTime;

	FloatTrack.AutoSetTangents(CurveTension);

	return NewKeyIndex;
}

void UInterpTrackFloatBase::PostEditChange(UProperty* PropertyThatChanged)
{
	Super::PostEditChange(PropertyThatChanged);

	FloatTrack.AutoSetTangents(CurveTension);
}

/*-----------------------------------------------------------------------------
	UInterpTrackFloatProp
-----------------------------------------------------------------------------*/


INT UInterpTrackFloatProp::AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst)
{
	UInterpTrackInstFloatProp* PropInst = CastChecked<UInterpTrackInstFloatProp>(TrInst);
	if( !PropInst->FloatProp )
		return INDEX_NONE;

	INT NewKeyIndex = FloatTrack.AddPoint( Time, 0.f );
	FloatTrack.Points(NewKeyIndex).InterpMode = CIM_CurveAuto;

	UpdateKeyframe(NewKeyIndex, TrInst);

	FloatTrack.AutoSetTangents(CurveTension);

	return NewKeyIndex;
}

void UInterpTrackFloatProp::UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst)
{
	UInterpTrackInstFloatProp* PropInst = CastChecked<UInterpTrackInstFloatProp>(TrInst);
	if( !PropInst->FloatProp )
		return;

	if( KeyIndex < 0 || KeyIndex >= FloatTrack.Points.Num() )
		return;

	FloatTrack.Points(KeyIndex).OutVal = *((FLOAT*)(PropInst->FloatProp));

	FloatTrack.AutoSetTangents(CurveTension);
}


void UInterpTrackFloatProp::PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst)
{
	UpdateTrack(NewPosition, TrInst);
}

void UInterpTrackFloatProp::UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump)
{
	AActor* Actor = TrInst->GetGroupActor();
	if(!Actor)
	{
		return;
	}

	UInterpTrackInstFloatProp* PropInst = CastChecked<UInterpTrackInstFloatProp>(TrInst);
	if(!PropInst->FloatProp)
		return;

	FLOAT NewFloatValue = FloatTrack.Eval( NewPosition, *((FLOAT*)(PropInst->FloatProp)) );
	*((FLOAT*)(PropInst->FloatProp)) = NewFloatValue;

	// We update components, so things like draw scale take effect.
	Actor->UpdateComponents();
}


/*-----------------------------------------------------------------------------
  UInterpTrackInstFloatProp
-----------------------------------------------------------------------------*/

void UInterpTrackInstFloatProp::SaveActorState()
{
	AActor* Actor = GetGroupActor();
	if(!Actor)
	{
		return;
	}

	if(!FloatProp)
		return;

	// Remember current value of property for when we quite Matinee
	ResetFloat = *((FLOAT*)(FloatProp));
}

void UInterpTrackInstFloatProp::RestoreActorState()
{
	AActor* Actor = GetGroupActor();
	if(!Actor)
	{
		return;
	}

	if(!FloatProp)
		return;

	// Restore original value of property
	*((FLOAT*)(FloatProp)) = ResetFloat;

	// We update components, so things like draw scale take effect.
	Actor->UpdateComponents();
}

void UInterpTrackInstFloatProp::InitTrackInst(UInterpTrack* Track)
{
	AActor* Actor = GetGroupActor();
	if(!Actor)
	{
		return;
	}

	UInterpTrackFloatProp* TrackProp = Cast<UInterpTrackFloatProp>(Track);

	FloatProp = Actor->GetInterpPropertyRef(TrackProp->PropertyName);
}

/*-----------------------------------------------------------------------------
	UInterpTrackEvent
-----------------------------------------------------------------------------*/

INT UInterpTrackEvent::GetNumKeyframes()
{
	return EventTrack.Num();
}

void UInterpTrackEvent::GetTimeRange(FLOAT& StartTime, FLOAT& EndTime)
{
	if(EventTrack.Num() == 0)
	{
		StartTime = 0.f;
		EndTime = 0.f;
	}
	else
	{
		StartTime = EventTrack(0).Time;
		EndTime = EventTrack( EventTrack.Num()-1 ).Time;
	}
}

FLOAT UInterpTrackEvent::GetKeyframeTime(INT KeyIndex)
{
	if( KeyIndex < 0 || KeyIndex >= EventTrack.Num() )
		return 0.f;

	return EventTrack(KeyIndex).Time;
}

INT UInterpTrackEvent::AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst)
{
	FEventTrackKey NewEventKey;
	NewEventKey.EventName = NAME_None;
	NewEventKey.Time = Time;

	// Find the correct index to insert this key.
	INT i=0; for( i=0; i<EventTrack.Num() && EventTrack(i).Time < Time; i++);
	EventTrack.Insert(i);
	EventTrack(i) = NewEventKey;

	return i;
}

INT UInterpTrackEvent::SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder)
{
	if( KeyIndex < 0 || KeyIndex >= EventTrack.Num() )
		return KeyIndex;

	if(bUpdateOrder)
	{
		// First, remove keyframe from track
		FEventTrackKey MoveKey = EventTrack(KeyIndex);
		EventTrack.Remove(KeyIndex);

		// Set its time to the new one.
		MoveKey.Time = NewKeyTime;

		// Find correct new position and insert.
		INT i=0; 
		for( i=0; i<EventTrack.Num() && EventTrack(i).Time < NewKeyTime; i++);
		EventTrack.Insert(i);
		EventTrack(i) = MoveKey;

		return i;
	}
	else
	{
		EventTrack(KeyIndex).Time = NewKeyTime;

		return KeyIndex;
	}
}

void UInterpTrackEvent::RemoveKeyframe(INT KeyIndex)
{
	if( KeyIndex < 0 || KeyIndex >= EventTrack.Num() )
		return;

	EventTrack.Remove(KeyIndex);
}

INT UInterpTrackEvent::DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime)
{
	if( KeyIndex < 0 || KeyIndex >= EventTrack.Num() )
		return INDEX_NONE;

	FEventTrackKey NewEventKey;
	NewEventKey.EventName = EventTrack(KeyIndex).EventName;
	NewEventKey.Time = NewKeyTime;

	// Find the correct index to insert this key.
	INT i=0; for( i=0; i<EventTrack.Num() && EventTrack(i).Time < NewKeyTime; i++);
	EventTrack.Insert(i);
	EventTrack(i) = NewEventKey;

	return i;
}

void UInterpTrackEvent::UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump)
{
	UInterpTrackInstEvent* EventInst = CastChecked<UInterpTrackInstEvent>(TrInst);
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( EventInst->GetOuter() );
	USeqAct_Interp* Seq = CastChecked<USeqAct_Interp>( GrInst->GetOuter() );
	UInterpGroup* Group = CastChecked<UInterpGroup>( GetOuter() );
	UInterpData* IData = CastChecked<UInterpData>( Group->GetOuter() );

	// Find the interval between last update and this to check events with.
	UBOOL bFireEvents = true;
	FLOAT MinTime, MaxTime;

	if(bJump)
	{
		bFireEvents = false;
	}

	// If playing sequence forwards.
	if(!Seq->bReversePlayback)
	{
		MinTime = EventInst->LastUpdatePosition;
		MaxTime = NewPosition;

		// Slight hack here.. if playing forwards and reaching the end of the sequence, force it over a little to ensure we fire events actually on the end of the sequence.
		if(MaxTime == IData->InterpLength)
		{
			MaxTime += (FLOAT)KINDA_SMALL_NUMBER;
		}

		if(!bFireEventsWhenForwards)
		{
			bFireEvents = false;
		}
	}
	// If playing sequence backwards.
	else
	{
		MinTime = NewPosition;
		MaxTime = EventInst->LastUpdatePosition;

		// Same small hack as above for backwards case.
		if(MinTime == 0.f)
		{
			MinTime -= (FLOAT)KINDA_SMALL_NUMBER;
		}

		if(!bFireEventsWhenBackwards)
		{
			bFireEvents = false;
		}
	}

	// If we should be firing events for this track...
	if(bFireEvents)
	{
		// See which events fall into traversed region.
		for(INT i=0; i<EventTrack.Num(); i++)
		{
			FLOAT EventTime = EventTrack(i).Time;

			// Need to be slightly careful here and make behaviour for firing events symmetric when playing forwards of backwards.
			UBOOL bFireThisEvent = false;
			if(!Seq->bReversePlayback)
			{
				if( EventTime >= MinTime && EventTime < MaxTime )
				{
					bFireThisEvent = true;
				}
			}
			else
			{
				if( EventTime > MinTime && EventTime <= MaxTime )
				{
					bFireThisEvent = true;
				}
			}

			if( bFireThisEvent )
			{
				// Fire event at EventIndex.
				FName EventName = EventTrack(i).EventName;

				//debugf( TEXT("UInterpTrackEvent: FIRE EVENT: %s"), *EventName );

				// Find output with give name 
				INT OutputIndex = Seq->FindConnectorIndex( FString(*EventName), LOC_OUTPUT );
				if(OutputIndex != INDEX_NONE)
				{
					Seq->OutputLinks(OutputIndex).bHasImpulse = true;
				}
			}
		}
	}

	// Update LastUpdatePosition.
	EventInst->LastUpdatePosition = NewPosition;
}

/*-----------------------------------------------------------------------------
	UInterpTrackInstEvent
-----------------------------------------------------------------------------*/

void UInterpTrackInstEvent::InitTrackInst(UInterpTrack* Track)
{
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( GetOuter() );
	USeqAct_Interp* Seq = CastChecked<USeqAct_Interp>( GrInst->GetOuter() );

	LastUpdatePosition = Seq->Position;
}


/*-----------------------------------------------------------------------------
	UInterpTrackDirector
-----------------------------------------------------------------------------*/

INT UInterpTrackDirector::GetNumKeyframes()
{
	return CutTrack.Num();
}

void UInterpTrackDirector::GetTimeRange(FLOAT& StartTime, FLOAT& EndTime)
{
	if(CutTrack.Num() == 0)
	{
		StartTime = 0.f;
		EndTime = 0.f;
	}
	else
	{
		StartTime = CutTrack(0).Time;
		EndTime = CutTrack( CutTrack.Num()-1 ).Time;
	}
}

FLOAT UInterpTrackDirector::GetKeyframeTime(INT KeyIndex)
{
	if( KeyIndex < 0 || KeyIndex >= CutTrack.Num() )
		return 0.f;

	return CutTrack(KeyIndex).Time;
}

INT UInterpTrackDirector::AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst)
{
	FDirectorTrackCut NewCut;
	NewCut.TargetCamGroup = NAME_None;
	NewCut.Time = Time;

	// Find the correct index to insert this cut.
	INT i=0; for( i=0; i<CutTrack.Num() && CutTrack(i).Time < Time; i++);
	CutTrack.Insert(i);
	CutTrack(i) = NewCut;

	return i;
}

INT UInterpTrackDirector::SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder)
{
	if( KeyIndex < 0 || KeyIndex >= CutTrack.Num() )
		return KeyIndex;

	if(bUpdateOrder)
	{
		// First, remove cut from track
		FDirectorTrackCut MoveCut = CutTrack(KeyIndex);
		CutTrack.Remove(KeyIndex);

		// Set its time to the new one.
		MoveCut.Time = NewKeyTime;

		// Find correct new position and insert.
		INT i=0; 
		for( i=0; i<CutTrack.Num() && CutTrack(i).Time < NewKeyTime; i++);
		CutTrack.Insert(i);
		CutTrack(i) = MoveCut;

		return i;
	}
	else
	{
		CutTrack(KeyIndex).Time = NewKeyTime;

		return KeyIndex;
	}
}

void UInterpTrackDirector::RemoveKeyframe(INT KeyIndex)
{
	if( KeyIndex < 0 || KeyIndex >= CutTrack.Num() )
		return;

	CutTrack.Remove(KeyIndex);
}

INT UInterpTrackDirector::DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime)
{
	if( KeyIndex < 0 || KeyIndex >= CutTrack.Num() )
		return INDEX_NONE;

	FDirectorTrackCut NewCut;
	NewCut.TargetCamGroup = CutTrack(KeyIndex).TargetCamGroup;
	NewCut.Time = NewKeyTime;

	// Find the correct index to insert this key.
	INT i=0; for( i=0; i<CutTrack.Num() && CutTrack(i).Time < NewKeyTime; i++);
	CutTrack.Insert(i);
	CutTrack(i) = NewCut;

	return i;
}

void UInterpTrackDirector::UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump)
{
	UInterpTrackInstDirector* DirInst = CastChecked<UInterpTrackInstDirector>(TrInst);
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( TrInst->GetOuter() );

	// Actor for a Director group should be a PlayerController.
	APlayerController* PC = Cast<APlayerController>(GrInst->GetGroupActor());
	if(PC)
	{
		USeqAct_Interp* Seq = CastChecked<USeqAct_Interp>( GrInst->GetOuter() );

		FName ViewGroupName = GetViewedGroupName(NewPosition);
		UInterpGroupInst* ViewGroupInst = Seq->FindFirstGroupInstByName(ViewGroupName);
		if(ViewGroupInst && ViewGroupInst->GetGroupActor() && (ViewGroupInst->GetGroupActor() != PC))
		{
			// If our desired view target is different from our current one...
			if(PC->ViewTarget != ViewGroupInst->GroupActor)
			{
				// If we don't have a backed up ViewTarget, back up this one.
				if(!DirInst->OldViewTarget)
				{
					DirInst->OldViewTarget = PC->ViewTarget;
				}

				// Change view to desired view target.
				PC->SetViewTarget( ViewGroupInst->GroupActor );			
			}
		}
		// If assigning to nothing or the PlayerController, restore any backed up viewtarget.
		else if(DirInst->OldViewTarget && !DirInst->OldViewTarget->bDeleteMe)
		{
			PC->SetViewTarget( DirInst->OldViewTarget );
			DirInst->OldViewTarget = NULL;
		}
	}
}

/** For the supplied time, find which group name we should be viewing from. */
FName UInterpTrackDirector::GetViewedGroupName(FLOAT CurrentTime)
{
	INT PrevKeyIndex = INDEX_NONE; // Index of key before current time.

	if(CutTrack.Num() > 0 && CutTrack(0).Time < CurrentTime)
	{
		for( INT i=0; i < CutTrack.Num() && CutTrack(i).Time < CurrentTime; i++)
		{
			PrevKeyIndex = i;
		}
	}

	if(PrevKeyIndex == INDEX_NONE)
	{
		UInterpGroup* Group = CastChecked<UInterpGroup>( GetOuter() );
		return Group->GroupName;
	}
	else
	{
		return CutTrack(PrevKeyIndex).TargetCamGroup;
	}
}

/*-----------------------------------------------------------------------------
	UInterpTrackInstDirector
-----------------------------------------------------------------------------*/

/** Use this to ensure we always cut back to the players last view-target. Need this in case there was no explicit cut back to the Dir track. */
void UInterpTrackInstDirector::TermTrackInst()
{
	if(OldViewTarget)
	{
		UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( GetOuter() );
		APlayerController* PC = Cast<APlayerController>(GrInst->GetGroupActor());
		if(PC)
		{
			PC->SetViewTarget( OldViewTarget );
		}

		OldViewTarget = NULL;
	}
}


/*-----------------------------------------------------------------------------
	UInterpTrackFade
-----------------------------------------------------------------------------*/

INT UInterpTrackFade::AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst)
{
	INT NewKeyIndex = FloatTrack.AddPoint( Time, 0.f );
	FloatTrack.Points(NewKeyIndex).InterpMode = CIM_CurveAuto;

	FloatTrack.AutoSetTangents(CurveTension);

	return NewKeyIndex;
}

void UInterpTrackFade::UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst)
{
	// Do nothing here - fading is all set up through curve editor.
}

void UInterpTrackFade::PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst)
{
	// Do nothing - in the editor Matinee itself handles updating the editor viewports.
}

void UInterpTrackFade::UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump)
{
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( TrInst->GetOuter() );

	// Actor for a Director group should be a PlayerController.
	APlayerController* PC = Cast<APlayerController>(GrInst->GetGroupActor());
	if(PC && PC->PlayerCamera && !PC->PlayerCamera->bDeleteMe)
	{
		PC->PlayerCamera->bEnableFading = true;
		PC->PlayerCamera->FadeAmount = GetFadeAmountAtTime(NewPosition);
	}
}

/** Return the amount of fading we want at the given time. */
FLOAT UInterpTrackFade::GetFadeAmountAtTime(FLOAT Time)
{
	FLOAT Fade = FloatTrack.Eval(Time, 0.f);
	Fade = Clamp(Fade, 0.f, 1.f);
	return Fade;
}

/*-----------------------------------------------------------------------------
	UInterpTrackInstFade
-----------------------------------------------------------------------------*/

/** Use this to turn off any fading that was applied by this track to this player controller. */
void UInterpTrackInstFade::TermTrackInst()
{
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( GetOuter() );
	APlayerController* PC = Cast<APlayerController>(GrInst->GroupActor);
	if(PC && PC->PlayerCamera && !PC->PlayerCamera->bDeleteMe)
	{
		PC->PlayerCamera->bEnableFading = false;
		PC->PlayerCamera->FadeAmount = 0.f;
	}
}

/*-----------------------------------------------------------------------------
	UInterpTrackSlomo
-----------------------------------------------------------------------------*/

INT UInterpTrackSlomo::AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst)
{
	INT NewKeyIndex = FloatTrack.AddPoint( Time, 0.f );
	FloatTrack.Points(NewKeyIndex).InterpMode = CIM_CurveAuto;

	FloatTrack.AutoSetTangents(CurveTension);

	return NewKeyIndex;
}

void UInterpTrackSlomo::UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst)
{
	// Do nothing here - slomo is all set up through curve editor.
}

void UInterpTrackSlomo::PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst)
{
	// Do nothing - in the editor Matinee itself handles updating the editor viewports.
}

void UInterpTrackSlomo::UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump)
{
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( TrInst->GetOuter() );

	// Actor for a Director group should be a PlayerController.
	APlayerController* PC = Cast<APlayerController>(GrInst->GroupActor);
	if(PC && PC->Level)
	{
		PC->Level->TimeDilation = GetSlomoFactorAtTime(NewPosition);
	}
}

/** Return the slomo factor we want at the given time. */
FLOAT UInterpTrackSlomo::GetSlomoFactorAtTime(FLOAT Time)
{
	FLOAT Slomo = FloatTrack.Eval(Time, 0.f);
	Slomo = ::Max(Slomo, 0.1f);
	return Slomo;
}

/** Set the slomo track to a default of one key at time zero and a slomo factor of 1.0 (ie no slomo) */
void UInterpTrackSlomo::SetTrackToSensibleDefault()
{
	FloatTrack.Points.Empty();
	FloatTrack.AddPoint(0.f, 1.f);
}	

/*-----------------------------------------------------------------------------
	UInterpTrackInstSlomo
-----------------------------------------------------------------------------*/

/** In editor, backup the LevelInfo->TimeDilation when opening Matinee. */
void UInterpTrackInstSlomo::SaveActorState()
{
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( GetOuter() );
	USeqAct_Interp* Seq = CastChecked<USeqAct_Interp>( GrInst->GetOuter() );
	USequence* RootSeq = Seq->GetRootSequence();
	ULevel* Level = Cast<ULevel>( RootSeq->GetOuter() );

	if( Level )
	{
		OldTimeDilation = Level->GetLevelInfo()->TimeDilation;
	}
}

/** In the editor, when we exit Matinee, restore levels TimeDilation to the backed-up value. */
void UInterpTrackInstSlomo::RestoreActorState()
{
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( GetOuter() );
	USeqAct_Interp* Seq = CastChecked<USeqAct_Interp>( GrInst->GetOuter() );
	USequence* RootSeq = Seq->GetRootSequence();
	ULevel* Level = Cast<ULevel>( RootSeq->GetOuter() );

	if( Level )
	{
		Level->GetLevelInfo()->TimeDilation = OldTimeDilation;
	}
}


/** Remember the slomo factor applied when interpolation begins. */
void UInterpTrackInstSlomo::InitTrackInst(UInterpTrack* Track)
{
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( GetOuter() );
	APlayerController* PC = Cast<APlayerController>(GrInst->GroupActor);
	if(PC && PC->Level)
	{
		OldTimeDilation = PC->Level->TimeDilation;
	}
}

/** Ensure the slomo factor is restored to what it was when interpolation begins. */
void UInterpTrackInstSlomo::TermTrackInst()
{
	UInterpGroupInst* GrInst = CastChecked<UInterpGroupInst>( GetOuter() );
	APlayerController* PC = Cast<APlayerController>(GrInst->GroupActor);
	if(PC && PC->Level)
	{
		PC->Level->TimeDilation = OldTimeDilation;
	}
}