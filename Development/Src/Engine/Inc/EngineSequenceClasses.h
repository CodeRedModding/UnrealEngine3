/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_SEQUENCE_ENUMS
#define INCLUDED_ENGINE_SEQUENCE_ENUMS 1

enum EPointSelection
{
    PS_Normal               =0,
    PS_Random               =1,
    PS_Reverse              =2,
    PS_MAX                  =3,
};
#define FOREACH_ENUM_EPOINTSELECTION(op) \
    op(PS_Normal) \
    op(PS_Random) \
    op(PS_Reverse) 
enum EMeshType
{
    MeshType_StaticMesh     =0,
    MeshType_SkeletalMesh   =1,
    MeshType_MAX            =2,
};
#define FOREACH_ENUM_EMESHTYPE(op) \
    op(MeshType_StaticMesh) \
    op(MeshType_SkeletalMesh) 
enum EParticleEventOutputType
{
    ePARTICLEOUT_Spawn      =0,
    ePARTICLEOUT_Death      =1,
    ePARTICLEOUT_Collision  =2,
    ePARTICLEOUT_AttractorCollision=3,
    ePARTICLEOUT_Kismet     =4,
    ePARTICLEOUT_MAX        =5,
};
#define FOREACH_ENUM_EPARTICLEEVENTOUTPUTTYPE(op) \
    op(ePARTICLEOUT_Spawn) \
    op(ePARTICLEOUT_Death) \
    op(ePARTICLEOUT_Collision) \
    op(ePARTICLEOUT_AttractorCollision) \
    op(ePARTICLEOUT_Kismet) 

#endif // !INCLUDED_ENGINE_SEQUENCE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_SEQUENCE_CLASSES
#define INCLUDED_ENGINE_SEQUENCE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct SequenceObject_eventGetObjClassVersion_Parms
{
    INT ReturnValue;
    SequenceObject_eventGetObjClassVersion_Parms(EEventParm)
    {
    }
};
struct SequenceObject_eventShouldClearNameOnPasting_Parms
{
    UBOOL ReturnValue;
    SequenceObject_eventShouldClearNameOnPasting_Parms(EEventParm)
    {
    }
};
struct SequenceObject_eventIsPastingIntoLevelSequenceAllowed_Parms
{
    UBOOL ReturnValue;
    SequenceObject_eventIsPastingIntoLevelSequenceAllowed_Parms(EEventParm)
    {
    }
};
struct SequenceObject_eventIsValidLevelSequenceObject_Parms
{
    UBOOL ReturnValue;
    SequenceObject_eventIsValidLevelSequenceObject_Parms(EEventParm)
    {
    }
};
class USequenceObject : public UObject
{
public:
    //## BEGIN PROPS SequenceObject
    INT ObjInstanceVersion;
    class USequence* ParentSequence;
#if WITH_EDITORONLY_DATA
    INT ObjPosX;
    INT ObjPosY;
#endif // WITH_EDITORONLY_DATA
    FStringNoInit ObjName;
#if WITH_EDITORONLY_DATA
    FStringNoInit ObjCategory;
    TArrayNoInit<FString> ObjRemoveInProject;
    FColor ObjColor;
#endif // WITH_EDITORONLY_DATA
    FStringNoInit ObjComment;
    BITFIELD bDeletable:1;
    BITFIELD bDrawFirst:1;
    BITFIELD bDrawLast:1;
    BITFIELD bOutputObjCommentToScreen:1;
    BITFIELD bSuppressAutoComment:1;
    INT DrawWidth;
    INT DrawHeight;
#if WITH_EDITORONLY_DATA
    class USequenceObject* PIESequenceObject;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS SequenceObject

    void ScriptLog(const FString& LogText,UBOOL bWarning=TRUE);
    class AWorldInfo* GetWorldInfo();
    DECLARE_FUNCTION(execScriptLog)
    {
        P_GET_STR(LogText);
        P_GET_UBOOL_OPTX(bWarning,TRUE);
        P_FINISH;
        this->ScriptLog(LogText,bWarning);
    }
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=this->GetWorldInfo();
    }
    INT eventGetObjClassVersion()
    {
        SequenceObject_eventGetObjClassVersion_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetObjClassVersion),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventShouldClearNameOnPasting()
    {
        SequenceObject_eventShouldClearNameOnPasting_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ShouldClearNameOnPasting),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsPastingIntoLevelSequenceAllowed()
    {
        SequenceObject_eventIsPastingIntoLevelSequenceAllowed_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsPastingIntoLevelSequenceAllowed),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsValidLevelSequenceObject()
    {
        SequenceObject_eventIsValidLevelSequenceObject_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsValidLevelSequenceObject),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(USequenceObject,UObject,0,Engine)
public:
#if WITH_EDITOR
	virtual void CheckForErrors() {};
#endif

	/**
	 * Notification that this object has been connected to another sequence object via a link.  Called immediately after
	 * the designer creates a link between two sequence objects.
	 *
	 * @param	connObj		the object that this op was just connected to.
	 * @param	connIdx		the index of the connection that was created.  Depends on the type of sequence op that is being connected.
	 */
	virtual void OnConnect(USequenceObject *connObj,INT connIdx) {}

	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime) {};
	virtual void DrawLogicLinks(FCanvas* Canvas, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex) {};
	virtual void DrawVariableLinks(FCanvas* Canvas, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex) {};
	virtual void OnCreated()
	{
		ObjInstanceVersion = eventGetObjClassVersion();
	};
	virtual void OnDelete() {}
	virtual void OnSelected() {};

	virtual void OnExport();

	FString GetSeqObjFullName();
	FString GetSeqObjFullLevelName();

	/**
	 * Traverses the ParentSequence chain until a non-sequence object is found, starting with this object.
	 *
	 * @erturn	a pointer to the first object (including this one) in the ParentSequence chain that does
	 *			has a NULL ParentSequence.
	 */
	USequence* GetRootSequence( UBOOL bOuterFallback=FALSE );
	/**
	 * Traverses the ParentSequence chain until a non-sequence object is found, starting with this object.
	 *
	 * @erturn	a pointer to the first object (including this one) in the ParentSequence chain that does
	 *			has a NULL ParentSequence.
	 */
	const USequence* GetRootSequence( UBOOL bOuterFallback=FALSE ) const;
	/**
	 * Traverses the ParentSequence chain until a non-sequence object is found, starting with this object's ParentSequence.
	 *
	 * @erturn	a pointer to the first object (not including this one) in the ParentSequence chain that does
	 *			has a NULL ParentSequence.
	 */
	USequence* GetParentSequenceRoot( UBOOL bOuterFallback=FALSE ) const;

	virtual void UpdateObject()
	{
		// set the new instance version to match the class version
		const INT ObjClassVersion = eventGetObjClassVersion();
		const UBOOL bDirty = ObjInstanceVersion != ObjClassVersion;
		ObjInstanceVersion = ObjClassVersion;
		if ( bDirty )
		{
			MarkPackageDirty();
		}
	}

	/** Converts this SequenceObject into another sequence object. Returns TRUE if this SequenceObject needs to be deleted */
	virtual USequenceObject* ConvertObject()
	{
		return NULL;
	}

	virtual void DrawKismetRefs( FViewport* Viewport, const FSceneView* View, FCanvas* Canvas ) {}

	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void UpdateStatus() {}

	USequenceObject* FindKismetObject();

	/**
	 * Get the name of the class to use for handling user interaction events (such as mouse-clicks) with this sequence object
	 * in the kismet editor.
	 *
	 * @return	a string containing the path name of a class in an editor package which can handle user input events for this
	 *			sequence object.
	 */
	virtual const FString GetEdHelperClassName() const
	{
		return FString( TEXT("UnrealEd.SequenceObjectHelper") );
	}

	virtual UBOOL IsPendingKill() const;

	/**
	 * Provides a way for non-deletable SequenceObjects (those with bDeletable=false) to be removed programatically.  The
	 * user will not be able to remove this object from the sequence via the UI, but calls to RemoveObject will succeed.
	 */
	virtual UBOOL IsDeletable() const { return bDeletable; }

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return FALSE; }

	/** called when the level that contains this sequence object is being removed/unloaded */
	virtual void CleanUp();

	/**
	 * Builds a list of objects which have this object in their archetype chain.
	 *
	 * All archetype propagation for sequence objects would be handled by prefab code, so this version just skips the iteration.
	 *
	 * @param	Instances	receives the list of objects which have this one in their archetype chain
	 */
	virtual void GetArchetypeInstances( TArray<UObject*>& Instances );

	/**
	 * Serializes all objects which have this object as their archetype into GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 * Called when a property value is about to be modified in an archetype object.
	 *
	 * Since archetype propagation for sequence objects is handled by the prefab code, this version simply routes the call
	 * to the owning prefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void SaveInstancesIntoPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * De-serializes all objects which have this object as their archetype from the GMemoryArchive, then recursively calls this function
	 * on each of those objects until the full list has been processed.
	 *
	 * Since archetype propagation for sequence objects is handled by the prefab code, this version simply routes the call
	 * to the owning prefab so that it can handle the propagation at the appropriate time.
	 *
	 * @param	AffectedObjects		unused
	 */
	virtual void LoadInstancesFromPropagationArchive( TArray<UObject*>& AffectedObjects );

	/**
	 * Determines whether this object is contained within a UPrefab.
	 *
	 * @param	OwnerPrefab		if specified, receives a pointer to the owning prefab.
	 *
	 * @return	TRUE if this object is contained within a UPrefab; FALSE if it IS a UPrefab or isn't contained within one.
	 */
	virtual UBOOL IsAPrefabArchetype( class UObject** OwnerPrefab=NULL ) const;

	/**
	 * @return	TRUE if the object is a UPrefabInstance or part of a prefab instance.
	 */
	virtual UBOOL IsInPrefabInstance() const;

	virtual void Initialize() {}
#if WITH_EDITOR
	virtual void PrePathBuild(  AScout* Scout ) {}
	virtual void PostPathBuild( AScout* Scout ) {}

	FColor GetBorderColor(UBOOL bSelected, UBOOL bMouseOver);
	FIntPoint GetTitleBarSize(FCanvas* Canvas);

	/** Gives op a chance to customize the title bar text.  e.g. to include important data.  Returns string to display in the title bar. */
	virtual FString GetDisplayTitle() const;
	virtual FString GetAutoComment() const;
	
	virtual void DrawTitleBar(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, const FIntPoint& Pos, const FIntPoint& Size);

	virtual FIntRect GetSeqObjBoundingBox();
	
	// Gives op a chance to add realtime debugging information (when enabled)
	virtual void GetRealtimeComments(TArray<FString> &OutComments) {}

	void SnapPosition(INT Gridsize, INT MaxSequenceSize);
#endif

protected:
	virtual void ConvertObjectInternal(USequenceObject* NewSeqObj, INT LinkIdx = -1) {}
};

class USequenceFrame : public USequenceObject
{
public:
    //## BEGIN PROPS SequenceFrame
    INT SizeX;
    INT SizeY;
    INT BorderWidth;
    BITFIELD bDrawBox:1;
    BITFIELD bFilled:1;
    BITFIELD bTileFill:1;
    SCRIPT_ALIGN;
    FColor BorderColor;
    FColor FillColor;
#if WITH_EDITORONLY_DATA
    class UTexture2D* FillTexture;
    class UMaterial* FillMaterial;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS SequenceFrame

    DECLARE_CLASS(USequenceFrame,USequenceObject,0,Engine)
#if WITH_EDITOR
	/** Draws the box part of the comment (including handle) */
	void DrawFrameBox(FCanvas* Canvas, UBOOL bSelected);

	// SequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
#endif
};

class USequenceFrameWrapped : public USequenceFrame
{
public:
    //## BEGIN PROPS SequenceFrameWrapped
    //## END PROPS SequenceFrameWrapped

    DECLARE_CLASS(USequenceFrameWrapped,USequenceFrame,0,Engine)
#if WITH_EDITOR
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
#endif
};

struct FSeqOpInputLink
{
    FStringNoInit LinkDesc;
    BITFIELD bHasImpulse:1;
    INT QueuedActivations;
    BITFIELD bDisabled:1;
    BITFIELD bDisabledPIE:1;
    class USequenceOp* LinkedOp;
    INT DrawY;
    BITFIELD bHidden:1;
    FLOAT ActivateDelay;
    BITFIELD bMoving:1;
    BITFIELD bClampedMax:1;
    BITFIELD bClampedMin:1;
#if WITH_EDITORONLY_DATA
    INT OverrideDelta;
#else
    SCRIPT_ALIGN;
#endif // WITH_EDITORONLY_DATA

     /** Constructors */
    FSeqOpInputLink() {}
    FSeqOpInputLink(EEventParm)
    {
		appMemzero(this, sizeof(FSeqOpInputLink));
    }

	/**
	 * Activates this output link if bDisabled is not true
	 */
	UBOOL ActivateInputLink()
	{
		if ( !bDisabled && !(bDisabledPIE && GIsEditor))
		{
			// if already active then mark in the queue, unless it's a latent op since those are handled uniquely currently
			if (bHasImpulse)
			{
				QueuedActivations++;
			}
			bHasImpulse = TRUE;
			return TRUE;
		}

		return FALSE;
	}

};

struct FSeqOpOutputInputLink
{
    class USequenceOp* LinkedOp;
    INT InputLinkIdx;

		/** Default ctor */
		FSeqOpOutputInputLink() {}
		FSeqOpOutputInputLink(EEventParm) : LinkedOp(NULL), InputLinkIdx(0)
		{
		}
		FSeqOpOutputInputLink( USequenceOp* InOp, INT InLinkIdx=0 ) : LinkedOp(InOp), InputLinkIdx(InLinkIdx)
		{
		}

		/** Operators */
		/** native serialization operator */
		friend FArchive& operator<<( FArchive& Ar, FSeqOpOutputInputLink& OutputInputLink );

		/** Comparison operator */
		UBOOL operator==( const FSeqOpOutputInputLink& Other ) const;
		UBOOL operator!=( const FSeqOpOutputInputLink& Other ) const;
	
};

struct FSeqOpOutputLink
{
    TArrayNoInit<struct FSeqOpOutputInputLink> Links;
    FStringNoInit LinkDesc;
    BITFIELD bHasImpulse:1;
    BITFIELD bDisabled:1;
    BITFIELD bDisabledPIE:1;
    class USequenceOp* LinkedOp;
    FLOAT ActivateDelay;
    INT DrawY;
    BITFIELD bHidden:1;
    BITFIELD bMoving:1;
    BITFIELD bClampedMax:1;
    BITFIELD bClampedMin:1;
#if WITH_EDITORONLY_DATA
    INT OverrideDelta;
    FLOAT PIEActivationTime;
#endif // WITH_EDITORONLY_DATA
    BITFIELD bIsActivated:1;
    SCRIPT_ALIGN;

     /** Constructors */
    FSeqOpOutputLink() {}
    FSeqOpOutputLink(EEventParm)
    {
		appMemzero(this, sizeof(FSeqOpOutputLink));
    }

	/**
	 * Activates this output link if bDisabled is not true
	 */
	UBOOL ActivateOutputLink()
	{
		if ( !bDisabled && !(bDisabledPIE && GIsEditor))
		{
			bHasImpulse = TRUE;
			return TRUE;
		}
		return FALSE;
	}

	UBOOL HasLinkTo(USequenceOp *Op, INT LinkIdx = -1)
	{
		if (Op != NULL)
		{
			for (INT Idx = 0; Idx < Links.Num(); Idx++)
			{
				if (Links(Idx).LinkedOp == Op &&
					(LinkIdx == -1 || Links(Idx).InputLinkIdx == LinkIdx))
				{
					return TRUE;
				}
			}
		}
		return FALSE;
	}

};

struct FSeqVarLink
{
    class UClass* ExpectedType;
    TArrayNoInit<class USequenceVariable*> LinkedVariables;
    FStringNoInit LinkDesc;
    FName LinkVar;
    FName PropertyName;
    BITFIELD bWriteable:1;
    BITFIELD bSequenceNeverReadsOnlyWritesToThisVar:1;
    BITFIELD bModifiesLinkedObject:1;
    BITFIELD bHidden:1;
    INT MinVars;
    INT MaxVars;
    INT DrawX;
    class UProperty* CachedProperty;
    BITFIELD bAllowAnyType:1;
    BITFIELD bMoving:1;
    BITFIELD bClampedMax:1;
    BITFIELD bClampedMin:1;
#if WITH_EDITORONLY_DATA
    INT OverrideDelta;
#else
    SCRIPT_ALIGN;
#endif // WITH_EDITORONLY_DATA

    /** Constructors */
    FSeqVarLink() {}
    FSeqVarLink(EEventParm)
    {
	appMemzero(this, sizeof(FSeqVarLink));
    }

	/**
	 * Determines whether this variable link can be associated with the specified sequence variable class.
	 *
	 * @param	SequenceVariableClass	the class to check for compatibility with this variable link; must be a child of SequenceVariable
	 * @param	bRequireExactClass		if FALSE, child classes of the specified class return a match as well.
	 *
	 * @return	TRUE if this variable link can be linked to the a SequenceVariable of the specified type.
	 */
	UBOOL SupportsVariableType( UClass* SequenceVariableClass, UBOOL bRequireExactClass=TRUE ) const;

};

struct FSeqEventLink
{
    class UClass* ExpectedType;
    TArrayNoInit<class USequenceEvent*> LinkedEvents;
    FStringNoInit LinkDesc;
    INT DrawX;
    BITFIELD bHidden:1;
    BITFIELD bMoving:1;
    BITFIELD bClampedMax:1;
    BITFIELD bClampedMin:1;
#if WITH_EDITORONLY_DATA
    INT OverrideDelta;
#else
    SCRIPT_ALIGN;
#endif // WITH_EDITORONLY_DATA

    /** Constructors */
    FSeqEventLink() {}
    FSeqEventLink(EEventParm)
    {
        appMemzero(this, sizeof(FSeqEventLink));
    }
};

struct SequenceOp_eventVersionUpdated_Parms
{
    INT OldVersion;
    INT NewVersion;
    SequenceOp_eventVersionUpdated_Parms(EEventParm)
    {
    }
};
struct SequenceOp_eventDeactivated_Parms
{
    SequenceOp_eventDeactivated_Parms(EEventParm)
    {
    }
};
struct SequenceOp_eventActivated_Parms
{
    SequenceOp_eventActivated_Parms(EEventParm)
    {
    }
};
class USequenceOp : public USequenceObject
{
public:
    //## BEGIN PROPS SequenceOp
    BITFIELD bIsActivated:1;
    BITFIELD bIsCurrentDebuggerOp:1;
    BITFIELD bActive:1;
    BITFIELD bLatentExecution:1;
    BITFIELD bAutoActivateOutputLinks:1;
    BITFIELD bHaveMovingVarConnector:1;
    BITFIELD bHaveMovingInputConnector:1;
    BITFIELD bHaveMovingOutputConnector:1;
    BITFIELD bPendingVarConnectorRecalc:1;
    BITFIELD bPendingInputConnectorRecalc:1;
    BITFIELD bPendingOutputConnectorRecalc:1;
    BITFIELD bIsBreakpointSet:1;
    BITFIELD bIsHiddenBreakpointSet:1;
#if WITH_EDITORONLY_DATA
    FLOAT PIEActivationTime;
    class USequenceOp* ActivatorSeqOp;
    INT LastActivatedInputLink;
    INT LastActivatedOutputLink;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<struct FSeqOpInputLink> InputLinks;
    TArrayNoInit<struct FSeqOpOutputLink> OutputLinks;
    TArrayNoInit<struct FSeqVarLink> VariableLinks;
    TArrayNoInit<struct FSeqEventLink> EventLinks;
    INT PlayerIndex;
    BYTE GamepadID;
    INT ActivateCount;
protected:
    INT SearchTag;
public:
    //## END PROPS SequenceOp

    UBOOL HasLinkedOps(UBOOL bConsiderInputLinks=FALSE) const;
    void GetLinkedObjects(TArray<class USequenceObject*>& out_Objects,class UClass* ObjectType=NULL,UBOOL bRecurse=FALSE);
    UBOOL ActivateOutputLink(INT OutputIdx);
    UBOOL ActivateNamedOutputLink(const FString& LinkDesc);
    virtual void PopulateLinkedVariableValues();
    virtual void PublishLinkedVariableValues();
    void ForceActivateInput(INT InputIdx);
    void ForceActivateOutput(INT OutputIdx);
    DECLARE_FUNCTION(execHasLinkedOps)
    {
        P_GET_UBOOL_OPTX(bConsiderInputLinks,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->HasLinkedOps(bConsiderInputLinks);
    }
    DECLARE_FUNCTION(execGetLinkedObjects)
    {
        P_GET_TARRAY_REF(class USequenceObject*,out_Objects);
        P_GET_OBJECT_OPTX(UClass,ObjectType,NULL);
        P_GET_UBOOL_OPTX(bRecurse,FALSE);
        P_FINISH;
        this->GetLinkedObjects(out_Objects,ObjectType,bRecurse);
    }
    DECLARE_FUNCTION(execGetObjectVars);
    DECLARE_FUNCTION(execGetInterpDataVars);
    DECLARE_FUNCTION(execGetBoolVars);
    DECLARE_FUNCTION(execLinkedVariables);
    DECLARE_FUNCTION(execActivateOutputLink)
    {
        P_GET_INT(OutputIdx);
        P_FINISH;
        *(UBOOL*)Result=this->ActivateOutputLink(OutputIdx);
    }
    DECLARE_FUNCTION(execActivateNamedOutputLink)
    {
        P_GET_STR(LinkDesc);
        P_FINISH;
        *(UBOOL*)Result=this->ActivateNamedOutputLink(LinkDesc);
    }
    DECLARE_FUNCTION(execPopulateLinkedVariableValues)
    {
        P_FINISH;
        this->PopulateLinkedVariableValues();
    }
    DECLARE_FUNCTION(execPublishLinkedVariableValues)
    {
        P_FINISH;
        this->PublishLinkedVariableValues();
    }
    DECLARE_FUNCTION(execForceActivateInput)
    {
        P_GET_INT(InputIdx);
        P_FINISH;
        this->ForceActivateInput(InputIdx);
    }
    DECLARE_FUNCTION(execForceActivateOutput)
    {
        P_GET_INT(OutputIdx);
        P_FINISH;
        this->ForceActivateOutput(OutputIdx);
    }
    void eventVersionUpdated(INT OldVersion,INT NewVersion)
    {
        SequenceOp_eventVersionUpdated_Parms Parms(EC_EventParm);
        Parms.OldVersion=OldVersion;
        Parms.NewVersion=NewVersion;
        ProcessEvent(FindFunctionChecked(ENGINE_VersionUpdated),&Parms);
    }
    void eventDeactivated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Deactivated),NULL);
    }
    void eventActivated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Activated),NULL);
    }
    DECLARE_ABSTRACT_CLASS(USequenceOp,USequenceObject,0,Engine)
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	// USequenceOp interface
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void Activated();
	virtual void DeActivated();
	/**
	 * Called after all the op has been deactivated and all linked variable values have been propagated to the next op
	 * in the sequence.
	 */
    virtual void PostDeActivated() {};

	/**
	 * Notification that an input link on this sequence op has been given impulse by another op.  Propagates the value of
	 * PlayerIndex from the ActivatorOp to this one.
	 *
	 * @param	ActivatorOp		the sequence op that applied impulse to this op's input link
	 * @param	InputLinkIndex	the index [into this op's InputLinks array] for the input link that was given impulse
	 */
	virtual void OnReceivedImpulse( class USequenceOp* ActivatorOp, INT InputLinkIndex );

	/**
	 * Allows the operation to initialize the values for any VariableLinks that need to be filled prior to executing this
	 * op's logic.  This is a convenient hook for filling VariableLinks that aren't necessarily associated with an actual
	 * member variable of this op, or for VariableLinks that are used in the execution of this ops logic.
	 */
	virtual void InitializeLinkedVariableValues();

	/** Gathers references to all values of the specified type from the linked variables, optionally specified by InDesc. */
	template<typename VarType, typename SeqVarType> 
	void GetOpVars(TArray<VarType*> &outVars, const TCHAR *InDesc) const
	{
		for (INT Idx = 0; Idx < VariableLinks.Num(); Idx++)
		{
			const FSeqVarLink &VarLink = VariableLinks(Idx);
			if (VarLink.SupportsVariableType(SeqVarType::StaticClass()) && (InDesc == NULL || VarLink.LinkDesc == InDesc))
			{
				for (INT LinkIdx = 0; LinkIdx < VarLink.LinkedVariables.Num(); LinkIdx++)
				{
					if (VarLink.LinkedVariables(LinkIdx) != NULL)
					{
						SeqVarType *LinkedVar = Cast<SeqVarType>(VarLink.LinkedVariables(LinkIdx));
						if (LinkedVar != NULL)
						{
							VarType *VarRef = LinkedVar->GetRef();
							if (VarRef != NULL)
							{
								outVars.AddItem(VarRef);
							}
						}
					}
				}
			}
		}
	}
	/** Wrapper functions for GetOpVars() */
	void GetBoolVars(TArray<UBOOL*> &outBools, const TCHAR *inDesc = NULL) const;
	void GetIntVars(TArray<INT*> &outInts, const TCHAR *inDesc = NULL) const;
	void GetFloatVars(TArray<FLOAT*> &outFloats, const TCHAR *inDesc = NULL) const;
	void GetVectorVars(TArray<FVector*> &outVectors, const TCHAR *inDesc = NULL) const;
	void GetStringVars(TArray<FString*> &outStrings, const TCHAR *inDesc = NULL) const;

	void GetObjectVars(TArray<UObject**> &outObjects, const TCHAR *inDesc = NULL) const;
	/** Retrieve list of UInterpData objects connected to this sequence op. */
	void GetInterpDataVars(TArray<class UInterpData*> &outIData, const TCHAR *inDesc = NULL);

	INT FindConnectorIndex(const FString& ConnName, INT ConnType);
	void CleanupConnections();

	/** Called via PostEditChange(), lets ops create/remove dynamic links based on data. */
	virtual void UpdateDynamicLinks() {}

	/**
	 * Handles updating this sequence op when the ObjClassVersion doesn't match the ObjInstanceVersion, indicating that the op's
	 * default values have been changed.
	 */
	virtual void UpdateObject();

	/** Called after the object is loaded */
	virtual void PostLoad();

#if WITH_EDITOR
	virtual FColor		GetConnectionColor( INT ConnType, INT ConnIndex, INT MouseOverConnType, INT MouseOverConnIndex );
	/** 
	 * Sets a pending connector position recalculation on this sequence object.
	 */
	void SetPendingConnectorRecalc();
	
	void MakeLinkedObjDrawInfo(struct FLinkedObjDrawInfo& ObjInfo, INT MouseOverConnType = -1, INT MouseOverConnIndex = INDEX_NONE);
	INT VisibleIndexToActualIndex(INT ConnType, INT VisibleIndex);

	// Gives op a chance to add realtime debugging information (when enabled)
	virtual void GetRealtimeComments(TArray<FString> &OutComments);

	FIntPoint GetLogicConnectorsSize(FCanvas* Canvas, INT* InputY=0, INT* OutputY=0);
	FIntPoint GetVariableConnectorsSize(FCanvas* Canvas);

	void DrawLogicConnectors(FCanvas* Canvas, const FIntPoint& Pos, const FIntPoint& Size, INT MouseOverConnType, INT MouseOverConnIndex);
	FColor GetVarConnectorColor(INT LinkIndex);

	void DrawVariableConnectors(FCanvas* Canvas, const FIntPoint& Pos, const FIntPoint& Size, INT MouseOverConnType, INT MouseOverConnIndex, INT VarWidth);

	virtual void DrawLogicLinks(FCanvas* Canvas, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex);
	virtual void DrawVariableLinks(FCanvas* Canvas, TArray<USequenceObject*> &SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex);	

	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntPoint	GetConnectionLocation(INT ConnType, INT ConnIndex);

	/**
	 * Adjusts the postions of a connector based on the Delta position passed in.
	 * 
	 * @param ConnType	The connector type to be moved
	 * @param ConnIndex	The index in the connector array where the connector is located
	 * @param DeltaX	The amount to move the connector in X
	 * @param DeltaY	The amount to move the connector in Y	
	 */
	virtual void		MoveConnectionLocation(INT ConnType, INT ConnIndex, INT DeltaX, INT DeltaY );

	/**
	 * Sets the member variable on the connector struct to bMoving so we can perform different calculations in the draw code
	 * 
	 * @param ConnType	The connector type to be moved
	 * @param ConnIndex	The index in the connector array where the connector is located
	 * @param bMoving	True if the connector is moving
	 */
	virtual void		SetConnectorMoving( INT ConnType, INT ConnIndex, UBOOL bMoving );

	virtual void OnVariableConnect(USequenceVariable *Var, INT LinkIdx) {}
	virtual void OnVariableDisconnect(USequenceVariable *Var, INT LinkIdx) {}

	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter){}

	virtual void SetBreakpoint(UBOOL bBreakpointOn);
	
#endif

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

protected:
	virtual void ConvertObjectInternal(USequenceObject* NewSeqObj, INT LinkIdx = -1);

private:
	static INT CurrentSearchTag;
	void GetLinkedObjectsInternal(TArray<USequenceObject*>& out_Objects, UClass* ObjectType, UBOOL bRecurse);
};

struct FActivateOp
{
    class USequenceOp* ActivatorOp;
    class USequenceOp* Op;
    INT InputIdx;
    FLOAT RemainingDelay;

    /** Constructors */
    FActivateOp() {}
    FActivateOp(EEventParm)
    {
        appMemzero(this, sizeof(FActivateOp));
    }
};

struct FQueuedActivationInfo
{
    class USequenceEvent* ActivatedEvent;
    class AActor* InOriginator;
    class AActor* InInstigator;
    TArrayNoInit<INT> ActivateIndices;
    BITFIELD bPushTop:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FQueuedActivationInfo() {}
    FQueuedActivationInfo(EEventParm)
    {
        appMemzero(this, sizeof(FQueuedActivationInfo));
    }
};

class USequence : public USequenceOp
{
public:
    //## BEGIN PROPS Sequence
    FPointer LogFile;
    TArrayNoInit<class USequenceObject*> SequenceObjects;
    TArrayNoInit<class USequenceOp*> ActiveSequenceOps;
    TArrayNoInit<class USequence*> NestedSequences;
    TArrayNoInit<class USequenceEvent*> UnregisteredEvents;
    TArrayNoInit<struct FActivateOp> DelayedActivatedOps;
    TArrayNoInit<class USequenceOp*> DelayedLatentOps;
private:
    BITFIELD bEnabled:1;
public:
    TArrayNoInit<struct FQueuedActivationInfo> QueuedActivations;
    INT DefaultViewX;
    INT DefaultViewY;
    FLOAT DefaultViewZoom;
    //## END PROPS Sequence

    void SetEnabled(UBOOL bInEnabled);
    DECLARE_FUNCTION(execFindSeqObjectsByClass);
    DECLARE_FUNCTION(execFindSeqObjectsByName);
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bInEnabled);
        P_FINISH;
        this->SetEnabled(bInEnabled);
    }
    DECLARE_CLASS(USequence,USequenceOp,0,Engine)
#define PREFAB_SEQCONTAINER_NAME	TEXT("Prefabs")

	virtual void PostLoad();

#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	/**
	 * Adds a new SequenceObject to this sequence's list of ops
	 *
	 * @param	NewObj		the sequence object to add.
	 * @param	bRecurse	if TRUE, recursively add any sequence objects attached to this one
	 *
	 * @return	TRUE if the object was successfully added to the sequence.
	 */
	virtual UBOOL AddSequenceObject( USequenceObject* NewObj, UBOOL bRecurse=FALSE );

	/**
	 * Removes the specified object from the SequenceObjects array, severing any links to that object.
	 *
	 * @param	ObjectToRemove	the SequenceObject to remove from this sequence.  All links to the object will be cleared.
	 * @param	ModifiedObjects	a list of objects that have been modified the objects that have been
	 */
	virtual void RemoveObject( USequenceObject* ObjectToRemove );

	/**
	 * Removes the specified objects from this Sequence's SequenceObjects array, severing any links to these objects.
	 *
	 * @param	ObjectsToRemove	the sequence objects to remove from this sequence.  All links to these objects will be cleared,
	 *							and the objects will be removed from all SequenceObject arrays.
	 */
	void RemoveObjects( const TArray<USequenceObject*>& ObjectsToRemove);

	/**
	 * Adds the specified SequenceOp to this sequence's list of ActiveOps.
	 *
	 * @param	NewSequenceOp	the sequence op to add to the list
	 * @param	bPushTop		if TRUE, adds the operation to the top of stack (meaning it will be executed first),
	 *							rather than the bottom
	 *
	 * @return	TRUE if the sequence operation was successfully added to the list.
	 */
	virtual UBOOL QueueSequenceOp( USequenceOp* NewSequenceOp, UBOOL bPushTop=FALSE );

	/**
	 * Adds the specified SequenceOp to this sequence's list of DelayedActivatedOps.
	 *
	 * @param	NewSequenceOp	the sequence op to add to the list
	 * @param	Link			the incoming link to NewSequenceOp
	 * @param   ActivateDelay	the total delay before NewSequenceOp should be executed
	 *
	 * @return	TRUE if the sequence operation was successfully added to the list.
	*/
	virtual UBOOL QueueDelayedSequenceOp( USequenceOp* NewSequenceOp, FSeqOpOutputInputLink* Link, FLOAT ActivateDelay );

	UBOOL ExecuteActiveOps(FLOAT DeltaTime, INT MaxSteps = 0);
	UBOOL UpdateOp(FLOAT DeltaTime);

	VARARG_DECL(void, void, {}, ScriptLogf, VARARG_NONE, const TCHAR*, VARARG_NONE, VARARG_NONE);
	VARARG_DECL(void, void, {}, ScriptWarnf, VARARG_NONE, const TCHAR*, VARARG_NONE, VARARG_NONE);

	virtual void Activated();

	virtual void UpdateObject()
	{
		// do nothing
	}

	virtual void OnCreated()
	{
		Super::OnCreated();
		// update our connectors
		UpdateConnectors();
	}

	virtual void OnExport();

	virtual void UpdateConnectors();
	void UpdateNamedVarStatus();
	void UpdateInterpActionConnectors();

	/**
	 * Initialize this kismet sequence.
	 *  - Creates the kismet script log (if this sequence has no parent sequence)
	 *  - Registers all events with the objects that they're associated with.
	 *  - Resolves all "named" and "external" variable links contained by this sequence.
	 */
	virtual void InitializeSequence();

	/**
	 * Conditionally creates the log file for this sequence.
	 */
	virtual void CreateKismetLog();

	/**
	 * Called from level startup.  Initializes the sequence and activates any level-startup
	 * events contained within the sequence.
	 */
	virtual void BeginPlay();
	virtual void FinishDestroy();
	/** called when streaming out a level to mark everything in this sequence as pending kill so they will be GC'ed */
	void MarkSequencePendingKill();
	/**
	 * Activates LevelStartup and/or LevelBeginning events in this sequence
	 *
	 * @param bShouldActivateLevelStartupEvents If TRUE, will activate all LevelStartup events
	 * @param bShouldActivateLevelBeginningEvents If TRUE, will activate all LevelBeginning events
	 * @param bShouldActivateLevelLoadedEvents If TRUE, will activate all LevelLoadedAndVisible events
	 */
	virtual void NotifyMatchStarted(UBOOL bShouldActivateLevelStartupEvents=TRUE, UBOOL bShouldActivateLevelBeginningEvents=TRUE, UBOOL bShouldActivateLevelLoadedEvents=FALSE);

	/**
	 * Find all sequence objects within this sequence that have an editor-visible property value containing the provided search string
	 *
	 * @param	SearchString	String to search for within the editor-visible property values
	 * @param	OutputObjects	Sequence objects within this sequence that have an editor-visible property value containing the search string
	 * @param	bRecursive		If TRUE, also search within subsequences in this sequence
	 */
	void FindSeqObjectsByPropertyValue( const FString& SearchString, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE ) const;
	void FindSeqObjectsByClass(UClass* DesiredClass, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE) const;
	void FindSeqObjectsByName(const FString& Name, UBOOL bCheckComment, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE, UBOOL bUseFullLevelName = FALSE) const;
	void FindSeqObjectsByObjectName(FName Name, TArray<USequenceObject*>& OutputObjects, UBOOL bRecursive = TRUE) const;
	void FindNamedVariables(FName VarName, UBOOL bFindUses, TArray<USequenceVariable*>& OutputVars, UBOOL bRecursive = TRUE) const;

	/**
	 * Finds all sequence objects contained by this sequence which are linked to any of the specified objects
	 *
	 * @param	SearchObjects	the collection of objects to search for references to
	 * @param	out_Referencers	will be filled in with the sequence objects which reference any objects in the SearchObjects set
	 * @param	bRecursive		TRUE to search subsequences as well
	 *
	 * @return	TRUE if at least one object in the sequence objects array is referencing one of the objects in the set
	 */
	UBOOL FindReferencingSequenceObjects( const TArray<class UObject*>& SearchObjects, TArray<class USequenceObject*>* out_Referencers=NULL, UBOOL bRecursive=TRUE ) const;

	/**
	 * Finds all sequence objects contained by this sequence which are linked to the specified object
	 *
	 * @param	SearchObject	the object to search for references to
	 * @param	out_Referencers	will be filled in with the sequence objects which reference the specified object
	 * @param	bRecursive		TRUE to search subsequences as well
	 *
	 * @return	TRUE if at least one object in the sequence objects array is referencing the object
	 */
	UBOOL FindReferencingSequenceObjects( UObject* SearchObject, TArray<class USequenceObject*>* out_Referencers=NULL, UBOOL bRecursive=TRUE ) const;

	/**
	 * Finds all sequence objects contained by this sequence which are linked to the specified sequence object.
	 *
	 * @param	SearchObject		the sequence object to search for link references to
	 * @param	out_Referencers		if specified, receieves the list of sequence objects contained by this sequence
	 *								which are linked to the specified op
	 *
	 * @return	TRUE if at least one object in the sequence objects array is linked to the specified op.
	 */
	virtual UBOOL FindSequenceOpReferencers( USequenceObject* SearchObject, TArray<USequenceObject*>* out_Referencers=NULL );

	/**
	 * Returns a list of output links from this sequence's ops which reference the specified op.
	 *
	 * @param	SeqOp	the sequence object to search for output links to
	 * @param	Links	[out] receives the list of output links which reference the specified op.
	 * @param   DupOp   copy of the sequence object to search for self-links when doing an object update
	 */
	void FindLinksToSeqOp(USequenceOp* SeqOp, TArray<FSeqOpOutputLink*> &Links, USequenceOp* DupOp=NULL);

	/**
	 * Get the sequence which contains all PrefabInstance sequences.
	 *
	 * @param	bCreateIfNecessary		indicates whether the Prefabs sequence should be created if it doesn't exist.
	 *
	 * @return	pointer to the sequence which serves as the parent for all PrefabInstance sequences in the map.
	 */
	USequence* GetPrefabsSequence( UBOOL bCreateIfNecessary=TRUE );

	/**
	 * @return	TRUE if this sequence is the special sequence which serves as the parent for all PrefabInstance sequences in a map.
	 */
	virtual UBOOL IsPrefabSequenceContainer() const { return FALSE; }

	/**
	 * Determine if this sequence (or any of its subsequences) references a certain object.
	 *
	 * @param	InObject	the object to search for references to
	 * @param	pReferencer	if specified, will be set to the SequenceObject that is referencing the search object.
	 *
	 * @return TRUE if this sequence references the specified object.
	 */
	UBOOL ReferencesObject( const UObject* InObject, USequenceObject** pReferencer=NULL ) const;

	/**
	 * Determines whether the specified SequenceObject is contained in the SequenceObjects array of this sequence.
	 *
	 * @param	SearchObject	the sequence object to look for
	 * @param	bRecursive		specify FALSE to limit the search to this sequence only (do not search in sub-sequences as well)
	 *
	 * @return	TRUE if the specified sequence object was found in the SequenceObjects array of this sequence or one of its sub-sequences
	 */
	UBOOL ContainsSequenceObject( USequenceObject* SearchObject, UBOOL bRecursive=TRUE ) const;

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }

	/**
	 * Ensures that the specified name can be used to create an object using this sequence as its Outer.  If any objects are found using
	 * the specified name, they will be renamed.
	 *
	 * @param	InName			the name to search for
	 * @param	RenameFlags		a bitmask of flags used to modify the behavior of a rename operation.
	 *
	 * @return	TRUE if at least one object was found and successfully renamed.
	 */
	UBOOL ClearNameUsage(FName InName, ERenameFlags RenameFlags=REN_None);

	/**
	 * Ensures that all external variables contained within TopSequence or any nested sequences have names which are unique throughout
	 * the entire sequence tree.  Any external variables that have the same name will be renamed.
	 *
	 * @param	TopSequence		the outermost sequence to search in.  specify NULL to start at the top-most sequence.
	 * @param	RenameFlags		a bitmask of flags used to modify the behavior of a rename operation.
	 *
	 * @return	TRUE if at least one object was found and successfully renamed.
	 */
	UBOOL ClearExternalVariableNameUsage( USequence* TopSequence, ERenameFlags RenameFlags=REN_None );

	/** Iterate over all SequenceObjects in this Sequence, making sure that their ParentSequence pointer points back to this Sequence. */
	void CheckParentSequencePointers();

	/**
	 * @return		The ULevel this sequence occurs in.
	 */
	ULevel* GetLevel() const;

	UBOOL IsEnabled() const;

	/** called when the level that contains this sequence object is being removed/unloaded */
	virtual void CleanUp();

#if WITH_EDITOR
	/** Draws the this sequence. */
	virtual void DrawSequence(FCanvas* Canvas, TArray<USequenceObject*>& SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
#endif
	
private:
	/**
	 * Look through levels contrary to the current objects scope and ensure no other name conflicts would be present.
	 * Helper function for ClearNameUsage
	 *
	 * @param	InName			the name to search for
	 * @param	ParentName		the name of the parent sequence
	 * @param	Flags			Flags for how the object is renamed
	 *
	 * @return	TRUE if at least one object was found and successfully renamed.
	 */
	UBOOL RenameAllObjectsInOtherLevels( const FName& InName, const FName& ParentName, ERenameFlags Flags );
};

class UPrefabSequence : public USequence
{
public:
    //## BEGIN PROPS PrefabSequence
protected:
    class APrefabInstance* OwnerPrefab;
public:
    //## END PROPS PrefabSequence

    void SetOwnerPrefab(class APrefabInstance* InOwner);
    class APrefabInstance* GetOwnerPrefab() const;
    DECLARE_FUNCTION(execSetOwnerPrefab)
    {
        P_GET_OBJECT(APrefabInstance,InOwner);
        P_FINISH;
        this->SetOwnerPrefab(InOwner);
    }
    DECLARE_FUNCTION(execGetOwnerPrefab)
    {
        P_FINISH;
        *(class APrefabInstance**)Result=this->GetOwnerPrefab();
    }
    DECLARE_CLASS(UPrefabSequence,USequence,0,Engine)
	/* === USequenceObject interface === */
	/**
	 * Provides a way for non-deletable SequenceObjects (those with bDeletable=false) to be removed programatically.  The
	 * user will not be able to remove this object from the sequence via the UI, but calls to RemoveObject will succeed.
	 */
	virtual UBOOL IsDeletable() const { return TRUE; }

	/* === UObject interface === */
	virtual void PostLoad();

	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 *
	 * Updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostEditImport();
	/**
	 * Called after this object is renamed; updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostRename();
	/**
	 * Called after duplication & serialization and before PostLoad.
	 *
	 * Updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostDuplicate();
};

class UPrefabSequenceContainer : public USequence
{
public:
    //## BEGIN PROPS PrefabSequenceContainer
    //## END PROPS PrefabSequenceContainer

    DECLARE_CLASS(UPrefabSequenceContainer,USequence,0,Engine)
	/* === USequenceObject interface === */
	/**
	 * Provides a way for non-deletable SequenceObjects (those with bDeletable=false) to be removed programatically.  The
	 * user will not be able to remove this object from the sequence via the UI, but calls to RemoveObject will succeed.
	 */
	virtual UBOOL IsDeletable() const { return TRUE; }

	/* === USequence interface === */
	/**
	 * @return	TRUE if this sequence is the special sequence which serves as the parent for all PrefabInstance sequences in a map.
	 */
	virtual UBOOL IsPrefabSequenceContainer() const { return TRUE; }

	/* === UObject interface === */
	/**
	 * Called after importing property values for this object (paste, duplicate or .t3d import)
	 * Allow the object to perform any cleanup for properties which shouldn't be duplicated or
	 * are unsupported by the script serialization
	 *
	 * Updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostEditImport();

	/**
	 * Called after this object is renamed; updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostRename();

	/**
	 * Called after duplication & serialization and before PostLoad.
	 *
	 * Updates the value of ObjName to match the name of the sequence.
	 */
	virtual void PostDuplicate();
};

class USequenceAction : public USequenceOp
{
public:
    //## BEGIN PROPS SequenceAction
    FName HandlerName;
    BITFIELD bCallHandler:1;
    TArrayNoInit<class UObject*> Targets;
    //## END PROPS SequenceAction

    DECLARE_ABSTRACT_CLASS(USequenceAction,USequenceOp,0,Engine)
	virtual void Activated();

	/** Called before the handler function is called on a target actor. */
	virtual void PreActorHandle(AActor *inActor) {}
};

class USeqAct_ActivateRemoteEvent : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ActivateRemoteEvent
    class AActor* Instigator;
    FName EventName;
    BITFIELD bStatusIsOk:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_ActivateRemoteEvent

    DECLARE_CLASS(USeqAct_ActivateRemoteEvent,USequenceAction,0,Engine)
public:
	void Activated();

	virtual void UpdateStatus();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

#if WITH_EDITOR	
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
protected:
	FString GetDisplayTitle() const;
#endif
};

class USeqAct_AndGate : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_AndGate
    BITFIELD bOpen:1;
    TArrayNoInit<UBOOL> LinkedOutputFiredStatus;
    TArrayNoInit<FSeqOpOutputLink*> LinkedOutputs;
    //## END PROPS SeqAct_AndGate

    DECLARE_CLASS(USeqAct_AndGate,USequenceAction,0,Engine)
	virtual void Initialize();
	virtual void Activated();
	virtual void OnReceivedImpulse( class USequenceOp* ActivatorOp, INT InputLinkIndex );
};

class USeqAct_ApplySoundNode : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ApplySoundNode
    class USoundCue* PlaySound;
    class USoundNode* ApplyNode;
    //## END PROPS SeqAct_ApplySoundNode

    DECLARE_CLASS(USeqAct_ApplySoundNode,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_AttachToEvent : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_AttachToEvent
    BITFIELD bPreferController:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_AttachToEvent

    DECLARE_CLASS(USeqAct_AttachToEvent,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_CameraFade : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CameraFade
    FColor FadeColor;
    FVector2D FadeAlpha_DEPRECATED;
    FLOAT FadeOpacity;
    FLOAT FadeTime;
    BITFIELD bPersistFade:1;
    BITFIELD bFadeAudio:1;
    FLOAT FadeTimeRemaining;
    TArrayNoInit<class APlayerController*> CachedPCs;
    //## END PROPS SeqAct_CameraFade

    DECLARE_CLASS(USeqAct_CameraFade,USequenceAction,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	virtual void UpdateObject();
};

class USeqAct_CameraLookAt : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CameraLookAt
    BITFIELD bAffectCamera:1;
    BITFIELD bAlwaysFocus:1;
    BITFIELD bAdjustCamera_DEPRECATED:1;
    BITFIELD bTurnInPlace:1;
    BITFIELD bIgnoreTrace:1;
    BITFIELD bAffectHead:1;
    BITFIELD bRotatePlayerWithCamera:1;
    BITFIELD bToggleGodMode:1;
    BITFIELD bLeaveCameraRotation:1;
    BITFIELD bDisableInput:1;
    BITFIELD bUsedTimer:1;
    BITFIELD bCheckLineOfSight:1;
    SCRIPT_ALIGN;
    FVector2D InterpSpeedRange;
    FVector2D InFocusFOV;
    FName FocusBoneName;
    FStringNoInit TextDisplay;
    FLOAT TotalTime;
    FLOAT CameraFOV;
    FLOAT RemainingTime;
    //## END PROPS SeqAct_CameraLookAt

    DECLARE_CLASS(USeqAct_CameraLookAt,USequenceAction,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	void DeActivated();

	void UpdateObject();
};

class USeqAct_CameraShake : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CameraShake
    class UCameraShake* Shake;
    FLOAT ShakeScale;
    BITFIELD bDoControllerVibration:1;
    BITFIELD bRadialShake:1;
    BITFIELD bOrientTowardRadialEpicenter:1;
    FLOAT RadialShake_InnerRadius;
    FLOAT RadialShake_OuterRadius;
    FLOAT RadialShake_Falloff;
    BYTE PlaySpace;
    class AActor* LocationActor;
    //## END PROPS SeqAct_CameraShake

    DECLARE_CLASS(USeqAct_CameraShake,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_CameraShake)
};

class USeqAct_ChangeCollision : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ChangeCollision
    BITFIELD bCollideActors:1;
    BITFIELD bBlockActors:1;
    BITFIELD bIgnoreEncroachers:1;
    SCRIPT_ALIGN;
    BYTE CollisionType;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_ChangeCollision

    DECLARE_CLASS(USeqAct_ChangeCollision,USequenceAction,0,Engine)
	void UpdateObject()
	{
		Super::UpdateObject();
		if (bBlockActors)
		{
			CollisionType = COLLIDE_BlockAll;
		}
		else
		if (bCollideActors)
		{
			CollisionType = COLLIDE_TouchAll;
		}
		else
		{
			CollisionType = COLLIDE_NoCollision;
		}
	}
};

class USeqAct_CommitMapChange : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_CommitMapChange
    //## END PROPS SeqAct_CommitMapChange

    DECLARE_CLASS(USeqAct_CommitMapChange,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_ConvertToString : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ConvertToString
    BITFIELD bIncludeVarComment:1;
    FStringNoInit VarSeparator;
    INT NumberOfInputs;
    //## END PROPS SeqAct_ConvertToString

    DECLARE_CLASS(USeqAct_ConvertToString,USequenceAction,0,Engine)
	void Activated();
	void AppendVariables(TArray<USequenceVariable*> &LinkedVariables, FString &CombinedString, INT &VarCount);
	void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class USeqAct_DrawText : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_DrawText
    FLOAT DisplayTimeSeconds;
    BITFIELD bDisplayOnObject:1;
    SCRIPT_ALIGN;
    struct FKismetDrawTextInfo DrawTextInfo;
    //## END PROPS SeqAct_DrawText

    DECLARE_CLASS(USeqAct_DrawText,USequenceAction,0,Engine)
	UBOOL UpdateOp(FLOAT deltaTime);
	virtual void Activated();
};

class USeqAct_FinishSequence : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_FinishSequence
    FStringNoInit OutputLabel;
    //## END PROPS SeqAct_FinishSequence

    DECLARE_CLASS(USeqAct_FinishSequence,USequenceAction,0,Engine)
#if WITH_EDITOR
protected:
	FString GetDisplayTitle() const;
#endif
public:
	virtual void Activated();
	virtual void OnCreated();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class USeqAct_Gate : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Gate
    BITFIELD bOpen:1;
    INT AutoCloseCount;
    INT CurrentCloseCount;
    //## END PROPS SeqAct_Gate

    DECLARE_CLASS(USeqAct_Gate,USequenceAction,0,Engine)
	virtual void PostLoad();

#if WITH_EDITOR
	virtual FString GetAutoComment() const;

	// Gives op a chance to add realtime debugging information (when enabled)
	virtual void GetRealtimeComments(TArray<FString> &OutComments);
#endif

	void Activated()
	{
		UBOOL bWasOpen = bOpen;
		// first look for an open/close impulse
		if (InputLinks(1).bHasImpulse)
		{
			// open the gate
			bOpen = TRUE;

			//Setup the next autocount threshold
			CurrentCloseCount = ActivateCount + AutoCloseCount;
			if (InputLinks(0).bHasImpulse)
			{
				//One of the uses occurs this go around
				CurrentCloseCount--;
			}
		}
		else
		if (InputLinks(2).bHasImpulse)
		{
			// close the gate
			bOpen = FALSE;
		}
		else
		if (InputLinks(3).bHasImpulse)
		{
			// toggle the gate
			bOpen = !bOpen;

			if (bOpen)
			{
				//Setup the next autocount threshold
				CurrentCloseCount = ActivateCount + AutoCloseCount;
				if (InputLinks(0).bHasImpulse)
				{
					//One of the uses occurs this go around
					CurrentCloseCount--;
				}
			}
		}
		KISMET_LOG(TEXT("- Gate status: %s (was: %s)"),bOpen?TEXT("Open"):TEXT("Closed"),bWasOpen?TEXT("Open"):TEXT("Closed"));
		// next check for an activation impulse
		if (bOpen && InputLinks(0).bHasImpulse)
		{
			if (!OutputLinks(0).bDisabled && 
				!(OutputLinks(0).bDisabledPIE && GIsEditor))
			{
				OutputLinks(0).bHasImpulse = TRUE;
			}
			if (AutoCloseCount > 0 && ActivateCount >= CurrentCloseCount)
			{
				//Closed due to autocount exceeded
				bOpen = FALSE;
			}
		}
	}
};

class USeqAct_GetDistance : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetDistance
    FLOAT Distance;
    //## END PROPS SeqAct_GetDistance

    DECLARE_CLASS(USeqAct_GetDistance,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_GetLocationAndRotation : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetLocationAndRotation
    FVector Location;
    FVector RotationVector;
    FVector Rotation;
    FName SocketOrBoneName;
    //## END PROPS SeqAct_GetLocationAndRotation

    DECLARE_CLASS(USeqAct_GetLocationAndRotation,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_GetProperty : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetProperty
    FName PropertyName;
    //## END PROPS SeqAct_GetProperty

    DECLARE_CLASS(USeqAct_GetProperty,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_GetVectorComponents : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetVectorComponents
    FVector InVector;
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
    //## END PROPS SeqAct_GetVectorComponents

    DECLARE_CLASS(USeqAct_GetVectorComponents,USequenceAction,0,Engine)
	void Activated()
	{
		X = InVector.X;
		Y = InVector.Y;
		Z = InVector.Z;
		OutputLinks(0).bHasImpulse = TRUE;
	}
};

class USeqAct_GetVelocity : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_GetVelocity
    FLOAT VelocityMag;
    FVector VelocityVect;
    //## END PROPS SeqAct_GetVelocity

    DECLARE_CLASS(USeqAct_GetVelocity,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_HeadTrackingControl : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_HeadTrackingControl
    TArrayNoInit<FName> TrackControllerName;
    FLOAT LookAtActorRadius;
    BITFIELD bDisableBeyondLimit:1;
    BITFIELD bLookAtPawns:1;
    FLOAT MaxLookAtTime;
    FLOAT MinLookAtTime;
    FLOAT MaxInterestTime;
    TArrayNoInit<class UClass*> ActorClassesToLookAt;
    TArrayNoInit<FName> TargetBoneNames;
    TArrayNoInit<class UObject*> LookAtTargets;
    TMap< class AActor*,class UHeadTrackingComponent* > ActorToComponentMap;
    //## END PROPS SeqAct_HeadTrackingControl

    DECLARE_CLASS(USeqAct_HeadTrackingControl,USequenceAction,0,Engine)
 	virtual void Activated();
};

class USeqAct_IsInObjectList : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_IsInObjectList
    BITFIELD bCheckForAllObjects:1;
    BITFIELD bObjectFound:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_IsInObjectList

    DECLARE_CLASS(USeqAct_IsInObjectList,USequenceAction,0,Engine)
	/**
	* When a IsInObjectList is Activated() it will look in the referenced
	* list and then determine if the referenced object is in it
	**/
	void Activated();

	/**
	* IsInObjectList determines which of its outputs should be
	* set to active
	**/
	void DeActivated();


private:
	/**
	* Helper functions to determine if objects are in the list for each of the cases
	**/
	UBOOL TestForAllObjectsInList();
	UBOOL TestForAnyObjectsInList();
};

struct SeqAct_Latent_eventUpdate_Parms
{
    FLOAT DeltaTime;
    UBOOL ReturnValue;
    SeqAct_Latent_eventUpdate_Parms(EEventParm)
    {
    }
};
class USeqAct_Latent : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Latent
    TArrayNoInit<class AActor*> LatentActors;
    BITFIELD bAborted:1;
    FLOAT LatentActivationTime;
    //## END PROPS SeqAct_Latent

    virtual void AbortFor(class AActor* latentActor);
    DECLARE_FUNCTION(execAbortFor)
    {
        P_GET_OBJECT(AActor,latentActor);
        P_FINISH;
        this->AbortFor(latentActor);
    }
    UBOOL eventUpdate(FLOAT DeltaTime)
    {
        SeqAct_Latent_eventUpdate_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Update),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(USeqAct_Latent,USequenceAction,0,Engine)
	virtual void PreActorHandle(AActor *inActor);
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void Activated();
	virtual void DeActivated();
};

class USeqAct_ActorFactory : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_ActorFactory
    BITFIELD bEnabled:1;
    BITFIELD bIsSpawning:1;
    BITFIELD bCheckSpawnCollision:1;
    class UActorFactory* Factory;
    BYTE PointSelection;
    TArrayNoInit<class AActor*> SpawnPoints;
    TArrayNoInit<FVector> SpawnLocations;
    TArrayNoInit<FVector> SpawnOrientations;
    INT SpawnCount;
    FLOAT SpawnDelay;
    INT LastSpawnIdx;
    INT CurrentSpawnIdx;
    INT SpawnedCount;
    FLOAT RemainingDelay;
    //## END PROPS SeqAct_ActorFactory

    DECLARE_CLASS(USeqAct_ActorFactory,USeqAct_Latent,0,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
	virtual void DeActivated();

	virtual void Spawned(UObject *NewSpawn);

	/**
	 * Checks any of the bEnabled inputs and sets the new value.
	 */
	void CheckToggle()
	{
		if (InputLinks(1).bHasImpulse)
		{
			bEnabled = TRUE;
		}
		else
		if (InputLinks(2).bHasImpulse)
		{
			bEnabled = FALSE;
		}
		else
		if (InputLinks(3).bHasImpulse)
		{
			bEnabled = !bEnabled;
		}
	}
};

class USeqAct_ActorFactoryEx : public USeqAct_ActorFactory
{
public:
    //## BEGIN PROPS SeqAct_ActorFactoryEx
    //## END PROPS SeqAct_ActorFactoryEx

    DECLARE_CLASS(USeqAct_ActorFactoryEx,USeqAct_ActorFactory,0,Engine)
	virtual void UpdateDynamicLinks();
	virtual void Spawned(UObject *NewSpawn);
};

class USeqAct_ProjectileFactory : public USeqAct_ActorFactory
{
public:
    //## BEGIN PROPS SeqAct_ProjectileFactory
    class UParticleSystem* PSTemplate;
    FName SocketName;
    FName BoneName;
    //## END PROPS SeqAct_ProjectileFactory

    DECLARE_CLASS(USeqAct_ProjectileFactory,USeqAct_ActorFactory,0,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual UBOOL UpdateOp(FLOAT DeltaTime);
	virtual void DeActivated();

	virtual void Spawned(UObject *NewSpawn);
};

class USeqAct_AIMoveToActor : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_AIMoveToActor
    BITFIELD bInterruptable:1;
    BITFIELD bPickClosest:1;
    TArrayNoInit<class AActor*> Destination;
    FLOAT MovementSpeedModifier;
    class AActor* LookAt;
    INT LastDestinationChoice;
    //## END PROPS SeqAct_AIMoveToActor

    DECLARE_CLASS(USeqAct_AIMoveToActor,USeqAct_Latent,0,Engine)
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void  Activated();
};

class USeqAct_Delay : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_Delay
    BITFIELD bDelayActive:1;
    BITFIELD bStartWillRestart:1;
    FLOAT DefaultDuration;
    FLOAT Duration;
    FLOAT LastUpdateTime;
    FLOAT RemainingTime;
    //## END PROPS SeqAct_Delay

    virtual void ResetDelayActive();
    DECLARE_FUNCTION(execResetDelayActive)
    {
        P_FINISH;
        this->ResetDelayActive();
    }
    DECLARE_CLASS(USeqAct_Delay,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
	virtual void PostLoad();

#if WITH_EDITOR
	virtual FString GetDisplayTitle() const;

	// Gives op a chance to add realtime debugging information (when enabled)
	virtual void GetRealtimeComments(TArray<FString> &OutComments);
#endif
};

class UDEPRECATED_SeqAct_DelaySwitch : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_DelaySwitch
    INT LinkCount;
    INT CurrentIdx;
    FLOAT SwitchDelay;
    FLOAT NextLinkTime;
    //## END PROPS SeqAct_DelaySwitch

    DECLARE_CLASS(UDEPRECATED_SeqAct_DelaySwitch,USeqAct_Latent,0|CLASS_Deprecated,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
	{
		// force at least one output link
		if (LinkCount <= 0)
		{
			LinkCount = 1;
		}
		if (OutputLinks.Num() < LinkCount)
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < LinkCount)
			{
				INT idx = OutputLinks.AddZeroed();
				OutputLinks(idx).LinkDesc = FString::Printf(TEXT("Link %d"),idx+1);
			}
		}
		else
		if (OutputLinks.Num() > LinkCount)
		{
			while (OutputLinks.Num() > LinkCount)
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		Super::PostEditChangeProperty(PropertyChangedEvent);
	}

	void Activated()
	{
		// reset the link index
		CurrentIdx = 0;
		// figure out the total delay
		TArray<FLOAT*> floatVars;
		GetFloatVars(floatVars,TEXT("Delay"));
		SwitchDelay = 0.f;
		for (INT idx = 0; idx < floatVars.Num(); idx++)
		{
			SwitchDelay += *(floatVars(idx));
		}
		NextLinkTime = SwitchDelay;
	}

	UBOOL UpdateOp(FLOAT deltaTime)
	{
		if (NextLinkTime <= 0.f)
		{
			if( CurrentIdx < OutputLinks.Num() && !OutputLinks(CurrentIdx).bDisabled &&
				!(OutputLinks(CurrentIdx).bDisabledPIE && GIsEditor))
			{
				// activate the new link
				OutputLinks(CurrentIdx).bHasImpulse = 1;
				// fill any variables attached
				TArray<INT*> intVars;
				GetIntVars(intVars,TEXT("Active Link"));
				for (INT idx = 0; idx < intVars.Num(); idx++)
				{
					// offset by 1 for non-programmer friendliness
					*(intVars(idx)) = CurrentIdx + 1;
				}
				// and increment the link index
				CurrentIdx++;
			}
			NextLinkTime = SwitchDelay;
		}
		else
		{
			NextLinkTime -= deltaTime;
		}
		return (CurrentIdx >= OutputLinks.Num());
	}

	void DeActivated()
	{
	}
};

class USeqAct_ForceGarbageCollection : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_ForceGarbageCollection
    //## END PROPS SeqAct_ForceGarbageCollection

    DECLARE_CLASS(USeqAct_ForceGarbageCollection,USeqAct_Latent,0,Engine)
	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

struct FSavedTransform
{
    FVector Location;
    FRotator Rotation;
    friend FArchive& operator<<(FArchive& Ar,FSavedTransform& MySavedTransform)
    {
        return Ar << MySavedTransform.Location << MySavedTransform.Rotation;
    }

    /** Constructors */
    FSavedTransform() {}
    FSavedTransform(EEventParm)
    {
        appMemzero(this, sizeof(FSavedTransform));
    }
};

struct FCameraCutInfo
{
    FVector Location;
    FLOAT TimeStamp;

    /** Constructors */
    FCameraCutInfo() {}
    FCameraCutInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCameraCutInfo));
    }
};

class USeqAct_Interp : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_Interp
    TMap< AActor*,FSavedTransform > SavedActorTransforms;
    TMap< AActor*,BYTE > SavedActorVisibilities;
    FLOAT PlayRate;
    FLOAT Position;
    FLOAT ForceStartPosition;
    BITFIELD bIsPlaying:1;
    BITFIELD bPaused:1;
    BITFIELD bIsBeingEdited:1;
    BITFIELD bLooping:1;
    BITFIELD bRewindOnPlay:1;
    BITFIELD bNoResetOnRewind:1;
    BITFIELD bRewindIfAlreadyPlaying:1;
    BITFIELD bReversePlayback:1;
    BITFIELD bInterpForPathBuilding:1;
    BITFIELD bForceStartPos:1;
    BITFIELD bDisableRadioFilter:1;
    BITFIELD bClientSideOnly:1;
    BITFIELD bSkipUpdateIfNotVisible:1;
    BITFIELD bIsSkippable:1;
    BITFIELD bShouldShowGore:1;
    TArrayNoInit<class ACoverLink*> LinkedCover;
    class UInterpData* InterpData;
    TArrayNoInit<class UInterpGroupInst*> GroupInst;
    class UClass* ReplicatedActorClass;
    class AMatineeActor* ReplicatedActor;
    INT PreferredSplitScreenNum;
    TArrayNoInit<struct FCameraCutInfo> CameraCuts;
    FLOAT TerminationTime;
    struct FRenderingPerformanceOverrides RenderingOverrides;
    BYTE ConstantCameraAnim;
    FLOAT ConstantCameraAnimRate;
    //## END PROPS SeqAct_Interp

    void SetPosition(FLOAT NewPosition,UBOOL bJump=FALSE);
    void Stop();
    void AddPlayerToDirectorTracks(class APlayerController* PC);
    DECLARE_FUNCTION(execSetPosition)
    {
        P_GET_FLOAT(NewPosition);
        P_GET_UBOOL_OPTX(bJump,FALSE);
        P_FINISH;
        this->SetPosition(NewPosition,bJump);
    }
    DECLARE_FUNCTION(execStop)
    {
        P_FINISH;
        this->Stop();
    }
    DECLARE_FUNCTION(execAddPlayerToDirectorTracks)
    {
        P_GET_OBJECT(APlayerController,PC);
        P_FINISH;
        this->AddPlayerToDirectorTracks(PC);
    }
    DECLARE_CLASS(USeqAct_Interp,USeqAct_Latent,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	// UObject interface.
	/**
	 * Serialize function.
	 *
	 * @param	Ar		The archive to serialize with.
	 */
	virtual void Serialize(FArchive& Ar);

	// USequenceAction interface

	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void DeActivated();
	virtual void OnCreated();
	virtual void Initialize();

	virtual void UpdateObject();

	// USeqAct_Interp interface

	/**
	 * Begin playback of this sequence. Only called in game.
	 * Will then advance Position by (PlayRate * Deltatime) each time the SeqAct_Interp is ticked.
	 */
	void Play(UBOOL OnlyAIGroup=FALSE);

	/** Similar to play, but the playback will go backwards until the beginning of the sequence is reached. */
	void Reverse();

	/** Hold playback at its current position, but leave the sequence initialised. Calling Pause again will continue playback in its current direction. */
	void Pause();

	/** Changes the direction of playback (go in reverse if it was going forward, or vice versa) */
	void ChangeDirection();

	/** Called to notify affected actors when a new impulse changes the interpolation (paused, reversed direction, etc) */
	void NotifyActorsOfChange();

	/** Increment track forwards by given timestep and iterate over each track updating any properties. */
	virtual void StepInterp(FLOAT DeltaTime, UBOOL bPreview=FALSE);

	/** Move interpolation to new position and iterate over each track updating any properties. */
	virtual void UpdateInterp(FLOAT NewPosition, UBOOL bPreview=FALSE, UBOOL bJump=FALSE, UBOOL OnlyAIGroup=FALSE);

	/**
	 *	Updates the streaming system with the camera locations for the upcoming camera cuts, so
	 *	that it can start streaming in textures for those locations now.
	 *
	 *	@param	CurrentTime		Current time within the matinee, in seconds
	 *	@param	bPreview		If we are previewing sequence (ie. viewing in editor without gameplay running)
	 */
	void UpdateStreamingForCameraCuts(FLOAT CurrentTime, UBOOL bPreview=FALSE);

	/** For each InterGroup/Actor combination, create a InterpGroupInst, assign Actor and initialise each track. */
	void InitInterp();

	/** Destroy all InterpGroupInst. */
	void TermInterp();

	/** Reset the 'initial transform' for all movement tracks to be from the current actor positions. */
	void ResetMovementInitialTransforms();

	/** See if there is an instance referring to the supplied Actor. Returns NULL if not. */
	class UInterpGroupInst* FindGroupInst(AActor* Actor);

	/** Find the first group instance based on the given InterpGroup. */
	class UInterpGroupInst* FindFirstGroupInst(class UInterpGroup* InGroup);

	/** Find the first group instance based on the InterpGroup with the given name. */
	class UInterpGroupInst* FindFirstGroupInstByName( FName InGroupName );
	class UInterpGroupInst* FindFirstGroupInstByName( const FString& InGroupName );

	/** Resolves Named and External variables for the matinee preview */
	void GetNamedObjVars(TArray<UObject**>& OutObjects, const TCHAR* InDesc);

	/** Find the InterpData connected to the first Variable connector. Returns NULL if none attached. */
	class UInterpData* FindInterpDataFromVariable();

	/** Finds and returns the Director group, or NULL if not found. */
	class UInterpGroupDirector* FindDirectorGroup();

	/** Synchronise the variable connectors with the currently attached InterpData. */
	virtual void UpdateConnectorsFromData();

	/** Use any existing DirectorGroup to see which Actor we currently want to view through. */
	class AActor* FindViewedActor();

	/**
	 *	Utility for getting all Actors currently being worked on by this Matinee action.
	 *	If bMovementTrackOnly is set, Actors must have a Movement track in their group to be included in the results.
	 */
	void GetAffectedActors(TArray<AActor*>& OutActors, UBOOL bMovementTrackOnly);

	/**
	 * Conditionally saves state for the specified actor and its children
	 */
	void ConditionallySaveActorState( UInterpGroupInst* GroupInst, AActor* Actor );

	/**
	 * Adds the specified actor and any actors attached to it to the list
	 * of saved actor transforms.  Does nothing if an actor has already
	 * been saved.
	 */
	void SaveActorTransforms( AActor* Actor, UBOOL bOnlyChildren );

	/**
	 * Applies the saved locations and rotations to all saved actors.
	 */
	void RestoreActorTransforms();

	/** Saves whether or not this actor is hidden so we can restore it later */
	void SaveActorVisibility( AActor* Actor );

	/** Applies the saved visibility state for all saved actors */
	void RestoreActorVisibilities();

	/**
	 * Stores the current scrub position, restores all saved actor transforms,
	 * then saves off the transforms for actors referenced (directly or indirectly)
	 * by group instances, and finally restores the scrub position.
	 */
	void RecaptureActorState();

	/** Disables the radio filter effect if "Disable Radio Filter" is checked. */
	void DisableRadioFilterIfNeeded();

	/** Enables the radio filter */
	void EnableRadioFilter();

	/** called when the level that contains this sequence object is being removed/unloaded */
	virtual void CleanUp();

	/** Sets up the group actor for the specified InterpGroup. */
	void InitGroupActorForGroup(class UInterpGroup* InGroup, class AActor* GroupActor);

	/** Sets up the group actor for the specified InterpGroup. */
	void InitSeqObjectForGroup(class UInterpGroup* InGroup, USequenceObject* SequenceObject);

	/**
	 * Checks to see if this Matinee should be associated with the specified player.  This is a relatively
	 * quick test to perform.
	 *
	 * @param InPC The player controller to check
	 *
	 * @return TRUE if this Matinee sequence is compatible with the specified player
	 */
	UBOOL IsMatineeCompatibleWithPlayer( APlayerController* InPC ) const;

	/**
	 * Activates the output for the named event.
	 */
	virtual void NotifyEventTriggered(class UInterpTrackEvent const* EventTrack, INT EventIdx);

	/** Scans the matinee for camera cuts and sets up the CameraCut array. */
	void SetupCameraCuts();

	/** Copies the values from all VariableLinks to the member variable [of this sequence op] associated with that VariableLink */
	virtual void PublishLinkedVariableValues();

	/** Retrieve group linked variable **/
	AActor * FindGroupLinkedVariable(INT Index, const TArray<UObject**> &ObjectVars);
	AActor * FindUnusedGroupLinkedVariable(FName GroupName);

#if WITH_EDITOR
	/** Refresh variable links if it needs to be **/
	virtual void OnVariableConnect(USequenceVariable *Var, INT LinkIdx);
#endif
};

class USeqAct_LevelStreamingBase : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_LevelStreamingBase
    BITFIELD bMakeVisibleAfterLoad:1;
    BITFIELD bShouldBlockOnLoad:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_LevelStreamingBase

    DECLARE_ABSTRACT_CLASS(USeqAct_LevelStreamingBase,USeqAct_Latent,0,Engine)
	/**
	 * Handles "Activated" for single ULevelStreaming object.
	 *
	 * @param	LevelStreamingObject	LevelStreaming object to handle "Activated" for.
	 */
	void ActivateLevel( ULevelStreaming* LevelStreamingObject );

	/**
	 * Handles "UpdateOp" for single ULevelStreaming object.
	 *
	 * @param	LevelStreamingObject	LevelStreaming object to handle "UpdateOp" for.
	 *
	 * @return TRUE if operation has completed, FALSE if still in progress
	 */
	UBOOL UpdateLevel( ULevelStreaming* LevelStreamingObject );
};

class USeqAct_LevelStreaming : public USeqAct_LevelStreamingBase
{
public:
    //## BEGIN PROPS SeqAct_LevelStreaming
    class ULevelStreaming* Level;
    FName LevelName;
    BITFIELD bStatusIsOk:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_LevelStreaming

    DECLARE_CLASS(USeqAct_LevelStreaming,USeqAct_LevelStreamingBase,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	virtual void UpdateStatus();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual USequenceObject* ConvertObject();

#if WITH_EDITOR
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
#endif
};

struct FLevelStreamingNameCombo
{
    class ULevelStreaming* Level;
    FName LevelName;

    /** Constructors */
    FLevelStreamingNameCombo() {}
    FLevelStreamingNameCombo(EEventParm)
    {
        appMemzero(this, sizeof(FLevelStreamingNameCombo));
    }
};

class USeqAct_MultiLevelStreaming : public USeqAct_LevelStreamingBase
{
public:
    //## BEGIN PROPS SeqAct_MultiLevelStreaming
    TArrayNoInit<struct FLevelStreamingNameCombo> Levels;
    BITFIELD bUnloadAllOtherLevels:1;
    BITFIELD bStatusIsOk:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_MultiLevelStreaming

    DECLARE_CLASS(USeqAct_MultiLevelStreaming,USeqAct_LevelStreamingBase,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	virtual void UpdateStatus();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

#if WITH_EDITOR
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
#endif
};

class USeqAct_LevelVisibility : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_LevelVisibility
    class ULevelStreaming* Level;
    FName LevelName;
    BITFIELD bStatusIsOk:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_LevelVisibility

    DECLARE_CLASS(USeqAct_LevelVisibility,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT DeltaTime);
	virtual void UpdateStatus();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

#if WITH_EDITOR
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
#endif
};

class USeqAct_PlaySound : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_PlaySound
    class USoundCue* PlaySound;
    FLOAT ExtraDelay;
    BITFIELD bDelayReached:1;
    BITFIELD bSuppressSubtitles:1;
    BITFIELD bStopped:1;
    FLOAT SoundDuration;
    FLOAT FadeInTime;
    FLOAT FadeOutTime;
    FLOAT VolumeMultiplier;
    FLOAT PitchMultiplier;
    FLOAT BeforeEndTime;
    //## END PROPS SeqAct_PlaySound

    DECLARE_CLASS(USeqAct_PlaySound,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
	/** stops the sound on all targets */
	void Stop();
	virtual void CleanUp();
	void ActivateSound();

#if WITH_EDITOR
	void DrawTitleBar(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, const FIntPoint& Pos, const FIntPoint& Size);
#endif
};

class USeqAct_PrepareMapChange : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_PrepareMapChange
    FName MainLevelName;
    TArrayNoInit<FName> InitiallyLoadedSecondaryLevelNames;
    BITFIELD bIsHighPriority:1;
    BITFIELD bStatusIsOk:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_PrepareMapChange

    DECLARE_CLASS(USeqAct_PrepareMapChange,USeqAct_Latent,0,Engine)
	virtual void PostLoad();

	/**
	 * Called when this sequence action is being activated. Kicks off async background loading.
	 */
	void Activated();

	void DeActivated();

	/**
	 * Called from parent sequence via ExecuteActiveOps, returns TRUE to indicate this
	 * action has completed, which in this case means the engine is ready to have
	 * CommitMapChange called.
	 *
	 * @return TRUE if action has completed, FALSE otherwise
	 */
	UBOOL UpdateOp(FLOAT DeltaTime);

	virtual void UpdateStatus();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

#if WITH_EDITOR
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
#endif
};

class USeqAct_SetDOFParams : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_SetDOFParams
    FLOAT FalloffExponent;
    FLOAT BlurKernelSize;
    FLOAT MaxNearBlurAmount;
    FLOAT MinBlurAmount;
    FLOAT MaxFarBlurAmount;
    FLOAT FocusInnerRadius;
    FLOAT FocusDistance;
    FVector FocusPosition;
    FLOAT InterpolateSeconds;
    FLOAT InterpolateElapsed;
    FLOAT OldFalloffExponent;
    FLOAT OldBlurKernelSize;
    FLOAT OldMaxNearBlurAmount;
    FLOAT OldMinBlurAmount;
    FLOAT OldMaxFarBlurAmount;
    FLOAT OldFocusInnerRadius;
    FLOAT OldFocusDistance;
    FVector OldFocusPosition;
    //## END PROPS SeqAct_SetDOFParams

    DECLARE_CLASS(USeqAct_SetDOFParams,USeqAct_Latent,0,Engine)
	void Activated();
	void DeActivated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_SetMotionBlurParams : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_SetMotionBlurParams
    FLOAT MotionBlurAmount;
    FLOAT InterpolateSeconds;
    FLOAT InterpolateElapsed;
    FLOAT OldMotionBlurAmount;
    //## END PROPS SeqAct_SetMotionBlurParams

    DECLARE_CLASS(USeqAct_SetMotionBlurParams,USeqAct_Latent,0,Engine)
	void Activated();
	void DeActivated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_StreamInTextures : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_StreamInTextures
    BITFIELD bLocationBased_DEPRECATED:1;
    BITFIELD bStreamingActive:1;
    BITFIELD bHasTriggeredAllLoaded:1;
    FLOAT Seconds;
    FLOAT StreamingDistanceMultiplier;
    INT NumWantingResourcesID;
    FLOAT StopTimestamp;
    TArrayNoInit<class UObject*> LocationActors;
    TArrayNoInit<class UMaterialInterface*> ForceMaterials;
    struct FTextureGroupContainer CinematicTextureGroups;
    INT SelectedCinematicTextureGroups;
    //## END PROPS SeqAct_StreamInTextures

    DECLARE_CLASS(USeqAct_StreamInTextures,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();
	virtual void UpdateObject();

	virtual void ApplyForceMipSettings( UBOOL bEnable, FLOAT Duration );

	/**
	 * Adds an error message to the map check dialog if Duration is invalid
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class USeqAct_WaitForLevelsVisible : public USeqAct_Latent
{
public:
    //## BEGIN PROPS SeqAct_WaitForLevelsVisible
    TArrayNoInit<FName> LevelNames;
    BITFIELD bShouldBlockOnLoad:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_WaitForLevelsVisible

    UBOOL CheckLevelsVisible();
    DECLARE_FUNCTION(execCheckLevelsVisible)
    {
        P_FINISH;
        *(UBOOL*)Result=this->CheckLevelsVisible();
    }
    DECLARE_CLASS(USeqAct_WaitForLevelsVisible,USeqAct_Latent,0,Engine)
	UBOOL UpdateOp(FLOAT DeltaTime);
};

class USeqAct_Log : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Log
    BITFIELD bOutputToScreen:1;
    BITFIELD bIncludeObjComment:1;
    FLOAT TargetDuration;
    FVector TargetOffset;
    FStringNoInit LogMessage;
    //## END PROPS SeqAct_Log

    DECLARE_CLASS(USeqAct_Log,USequenceAction,0,Engine)
	void Activated();
	virtual void PostLoad();
	void OutputLog();
};

class USeqAct_FeatureTest : public USeqAct_Log
{
public:
    //## BEGIN PROPS SeqAct_FeatureTest
    FStringNoInit FreezeAtParameters;
    FLOAT ScreenShotDelay;
    FStringNoInit ScreenShotName;
    FLOAT RemainingScreenShotDelay;
    //## END PROPS SeqAct_FeatureTest

    DECLARE_CLASS(USeqAct_FeatureTest,USeqAct_Log,0,Engine)
	virtual void PostLoad();
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
};

class USeqAct_ModifyCover : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ModifyCover
    TArrayNoInit<INT> Slots;
    BYTE ManualCoverType;
    SCRIPT_ALIGN;
    BITFIELD bManualAdjustPlayersOnly:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_ModifyCover

    DECLARE_CLASS(USeqAct_ModifyCover,USequenceAction,0,Engine)
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class USeqAct_ModifyHealth : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ModifyHealth
    class UClass* DamageType;
    FLOAT Momentum;
    FLOAT Amount;
    FLOAT Radius;
    BITFIELD bHeal:1;
    BITFIELD bRadial:1;
    BITFIELD bFalloff:1;
    class AActor* Instigator;
    //## END PROPS SeqAct_ModifyHealth

    DECLARE_CLASS(USeqAct_ModifyHealth,USequenceAction,0,Engine)
	void Activated();
	virtual void UpdateObject();
};

class USeqAct_ParticleEventGenerator : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_ParticleEventGenerator
    BITFIELD bEnabled:1;
    BITFIELD bUseEmitterLocation:1;
    class AActor* Instigator;
    TArrayNoInit<FString> EventNames;
    FLOAT EventTime;
    FVector EventLocation;
    FVector EventDirection;
    FVector EventVelocity;
    FVector EventNormal;
    //## END PROPS SeqAct_ParticleEventGenerator

    DECLARE_CLASS(USeqAct_ParticleEventGenerator,USequenceAction,0,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	void Activated();
	virtual UBOOL UpdateOp(FLOAT DeltaTime);
	void DeActivated();

	/**
	 * Checks any of the bEnabled inputs and sets the new value.
	 */
	void CheckToggle()
	{
		if (InputLinks(1).bHasImpulse)
		{
			bEnabled = TRUE;
		}
		else
		if (InputLinks(2).bHasImpulse)
		{
			bEnabled = FALSE;
		}
		else
		if (InputLinks(3).bHasImpulse)
		{
			bEnabled = !bEnabled;
		}
	}
};

class USeqAct_PlayCameraAnim : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_PlayCameraAnim
    class UCameraAnim* CameraAnim;
    BITFIELD bLoop:1;
    BITFIELD bRandomStartTime:1;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    FLOAT Rate;
    FLOAT IntensityScale;
    BYTE PlaySpace;
    class AActor* UserDefinedSpaceActor;
    //## END PROPS SeqAct_PlayCameraAnim

    DECLARE_CLASS(USeqAct_PlayCameraAnim,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_PlayFaceFXAnim : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_PlayFaceFXAnim
    class UFaceFXAnimSet* FaceFXAnimSetRef;
    FStringNoInit FaceFXGroupName;
    FStringNoInit FaceFXAnimName;
    class USoundCue* SoundCueToPlay;
    //## END PROPS SeqAct_PlayFaceFXAnim

    DECLARE_CLASS(USeqAct_PlayFaceFXAnim,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_PlayFaceFXAnim)
};

class USeqAct_PlayMusicTrack : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_PlayMusicTrack
    struct FMusicTrackStruct MusicTrack;
    //## END PROPS SeqAct_PlayMusicTrack

    DECLARE_CLASS(USeqAct_PlayMusicTrack,USequenceAction,0,Engine)
	virtual void Activated();
	virtual void PreSave();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class USeqAct_Possess : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Possess
    class APawn* PawnToPossess;
    BITFIELD bKillOldPawn:1;
    BITFIELD bTryToLeaveVehicle:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_Possess

    DECLARE_CLASS(USeqAct_Possess,USequenceAction,0,Engine)
	void Activated();
};

struct FSwitchRange
{
    INT Min;
    INT Max;

    /** Constructors */
    FSwitchRange() {}
    FSwitchRange(EEventParm)
    {
        appMemzero(this, sizeof(FSwitchRange));
    }
};

class UDEPRECATED_SeqAct_RangeSwitch : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_RangeSwitch
    TArrayNoInit<struct FSwitchRange> Ranges;
    //## END PROPS SeqAct_RangeSwitch

    DECLARE_CLASS(UDEPRECATED_SeqAct_RangeSwitch,USequenceAction,0|CLASS_Deprecated,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
	{
		if (OutputLinks.Num() < Ranges.Num())
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < Ranges.Num())
			{
				OutputLinks.AddZeroed();
			}
		}
		else
		if (OutputLinks.Num() > Ranges.Num())
		{
			while (OutputLinks.Num() > Ranges.Num())
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		// match all the link descriptions to the range values
		for (INT idx = 0; idx < Ranges.Num(); idx++)
		{
			OutputLinks(idx).LinkDesc = FString::Printf(TEXT("%d - %d"),Ranges(idx).Min,Ranges(idx).Max);
		}
		Super::PostEditChangeProperty(PropertyChangedEvent);
	}

	virtual void Activated()
	{
		USequenceOp::Activated();

		// get all of the attached int vars
		TArray<INT*> intVars;
		GetIntVars(intVars,TEXT("Index"));
		// and activate the matching outputs
		for (INT idx = 0; idx < intVars.Num(); idx++)
		{
			INT activeIdx = *(intVars(idx));
			for (INT rangeIdx = 0; rangeIdx < Ranges.Num(); rangeIdx++)
			{
				if (activeIdx >= Ranges(rangeIdx).Min	&&
					activeIdx <= Ranges(rangeIdx).Max	&&
					!OutputLinks(rangeIdx).bDisabled	&&
					!(OutputLinks(rangeIdx).bDisabledPIE && GIsEditor)
					)
				{
					OutputLinks(rangeIdx).bHasImpulse = 1;
				}
			}
		}
	}

	void DeActivated()
	{
		// do nothing, already activated output links
	}
};

class USeqAct_SetActiveAnimChild : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetActiveAnimChild
    FName NodeName;
    INT ChildIndex;
    FLOAT BlendTime;
    //## END PROPS SeqAct_SetActiveAnimChild

    DECLARE_CLASS(USeqAct_SetActiveAnimChild,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_SetApexClothingParam : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetApexClothingParam
    BITFIELD bEnableApexClothingSimulation:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_SetApexClothingParam

    DECLARE_CLASS(USeqAct_SetApexClothingParam,USequenceAction,0,Engine)
	virtual void Activated();
};

class USeqAct_SetBlockRigidBody : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetBlockRigidBody
    //## END PROPS SeqAct_SetBlockRigidBody

    DECLARE_CLASS(USeqAct_SetBlockRigidBody,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetBlockRigidBody)
};

class USeqAct_SetCameraTarget : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetCameraTarget
    class AActor* CameraTarget;
    struct FViewTargetTransitionParams TransitionParams;
    //## END PROPS SeqAct_SetCameraTarget

    DECLARE_CLASS(USeqAct_SetCameraTarget,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_SetMaterial : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMaterial
    class UMaterialInterface* NewMaterial;
    INT MaterialIndex;
    //## END PROPS SeqAct_SetMaterial

    DECLARE_CLASS(USeqAct_SetMaterial,USequenceAction,0,Engine)
	// UObject interface.
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class USeqAct_SetMatInstScalarParam : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMatInstScalarParam
    class UMaterialInstanceConstant* MatInst;
    FName ParamName;
    FLOAT ScalarValue;
    //## END PROPS SeqAct_SetMatInstScalarParam

    DECLARE_CLASS(USeqAct_SetMatInstScalarParam,USequenceAction,0,Engine)
	void Activated();
};

class USeqAct_SetMesh : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetMesh
    class USkeletalMesh* NewSkeletalMesh;
    class UStaticMesh* NewStaticMesh;
    BYTE MeshType;
    SCRIPT_ALIGN;
    BITFIELD bIsAllowedToMove:1;
    BITFIELD bAllowDecalsToReattach:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_SetMesh

    DECLARE_CLASS(USeqAct_SetMesh,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetMesh)
};

class USeqAct_SetPhysics : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetPhysics
    MS_ALIGN(4) BYTE newPhysics GCC_ALIGN(4); // Extra alignment flags needed because all properties are bytes
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_SetPhysics

    DECLARE_CLASS(USeqAct_SetPhysics,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetPhysics)
};

class USeqAct_SetRigidBodyIgnoreVehicles : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetRigidBodyIgnoreVehicles
    //## END PROPS SeqAct_SetRigidBodyIgnoreVehicles

    DECLARE_CLASS(USeqAct_SetRigidBodyIgnoreVehicles,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetRigidBodyIgnoreVehicles)
};

class USeqAct_SetSequenceVariable : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetSequenceVariable
    //## END PROPS SeqAct_SetSequenceVariable

    DECLARE_ABSTRACT_CLASS(USeqAct_SetSequenceVariable,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetSequenceVariable)
};

class USeqAct_AccessObjectList : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_AccessObjectList
    class UObject* OutputObject;
    INT ObjectIndex;
    //## END PROPS SeqAct_AccessObjectList

    DECLARE_CLASS(USeqAct_AccessObjectList,USeqAct_SetSequenceVariable,0,Engine)
	/**
	* When a AccessObjectList is Activated() it may do a number of things.
	* In each of those cases we make use of a helper function.
	**/
	void Activated();

public:
	/**
	* SeqAct_AccessObjectList determines which of its outputs should be
	* set to active
	**/
	void DeActivated();

};

class USeqAct_AddFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_AddFloat
    FLOAT ValueA;
    FLOAT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_AddFloat

    DECLARE_CLASS(USeqAct_AddFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA + ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_AddInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_AddInt
    INT ValueA;
    INT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_AddInt

    DECLARE_CLASS(USeqAct_AddInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA + ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_CastToFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_CastToFloat
    INT Value;
    FLOAT FloatResult;
    //## END PROPS SeqAct_CastToFloat

    DECLARE_CLASS(USeqAct_CastToFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		OutputLinks(0).bHasImpulse = TRUE;
		
		FloatResult = (FLOAT)Value;
	}
};

class USeqAct_CastToInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_CastToInt
    BITFIELD bTruncate:1;
    FLOAT Value;
    INT IntResult;
    //## END PROPS SeqAct_CastToInt

    DECLARE_CLASS(USeqAct_CastToInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		OutputLinks(0).bHasImpulse = TRUE;
		
		if( bTruncate )
		{
			IntResult = (INT)Value;
		}
		else
		{
			IntResult = appRound( Value );
		}
	}
};

class USeqAct_DivideFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_DivideFloat
    FLOAT ValueA;
    FLOAT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_DivideFloat

    DECLARE_CLASS(USeqAct_DivideFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		if( ValueB == 0.0f )
		{
			ValueB = 1.0f;
		}
		
		FloatResult = ValueA / ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_DivideInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_DivideInt
    INT ValueA;
    INT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_DivideInt

    DECLARE_CLASS(USeqAct_DivideInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		if( ValueB == 0 )
		{
			ValueB = 1;
		}
		
		FloatResult = ValueA / (FLOAT)ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_ModifyObjectList : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_ModifyObjectList
    INT ListEntriesCount;
    //## END PROPS SeqAct_ModifyObjectList

    DECLARE_CLASS(USeqAct_ModifyObjectList,USeqAct_SetSequenceVariable,0,Engine)
	/**
	* When a ModifyObjectList is Activated() it may do a number of things.
	* In each of those cases we make use of a helper function.
	**/
	void Activated();

private:
	void ActivatedAddRemove();
	void ActivateAddRemove_Helper( INT LinkNum );

public:
	/**
	* SeqAct_ModifyObjectList determines which of its outputs should be
	* set to active
	**/
	void DeActivated();

};

class USeqAct_MultiplyFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_MultiplyFloat
    FLOAT ValueA;
    FLOAT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_MultiplyFloat

    DECLARE_CLASS(USeqAct_MultiplyFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA * ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_MultiplyInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_MultiplyInt
    INT ValueA;
    INT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_MultiplyInt

    DECLARE_CLASS(USeqAct_MultiplyInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA * (FLOAT)ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_SetBool : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetBool
    BITFIELD DefaultValue:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqAct_SetBool

    DECLARE_CLASS(USeqAct_SetBool,USeqAct_SetSequenceVariable,0,Engine)
	void Activated();
};

class USeqAct_SetFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetFloat
    FLOAT Target;
    TArrayNoInit<FLOAT> Value;
    //## END PROPS SeqAct_SetFloat

    DECLARE_CLASS(USeqAct_SetFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		// assign the new value
		Target = 0.f;
		for( INT ValueIdx = 0; ValueIdx < Value.Num(); ++ValueIdx)
		{
			Target += Value(ValueIdx);
		}
	}
};

class USeqAct_SetInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetInt
    INT Target;
    TArrayNoInit<INT> Value;
    //## END PROPS SeqAct_SetInt

    DECLARE_CLASS(USeqAct_SetInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		// assign the new value
		Target = 0;
		for( INT ValueIdx = 0; ValueIdx < Value.Num(); ++ValueIdx)
		{
			Target += Value(ValueIdx);
		}
	}
};

class USeqAct_SetLocation : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetLocation
    BITFIELD bSetLocation:1;
    BITFIELD bSetRotation:1;
    SCRIPT_ALIGN;
    FVector LocationValue;
    FRotator RotationValue;
    class UObject* Target;
    //## END PROPS SeqAct_SetLocation

    DECLARE_CLASS(USeqAct_SetLocation,USeqAct_SetSequenceVariable,0,Engine)
	void Activated();
};

class USeqAct_SetObject : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetObject
    class UObject* DefaultValue;
    class UObject* Value;
    //## END PROPS SeqAct_SetObject

    DECLARE_CLASS(USeqAct_SetObject,USeqAct_SetSequenceVariable,0,Engine)
	virtual void Activated();
};

class USeqAct_SetString : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SetString
    FStringNoInit Target;
    FStringNoInit Value;
    //## END PROPS SeqAct_SetString

    DECLARE_CLASS(USeqAct_SetString,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		// assign the new value
		Target = Value;
	}
};

class USeqAct_SubtractFloat : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SubtractFloat
    FLOAT ValueA;
    FLOAT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_SubtractFloat

    DECLARE_CLASS(USeqAct_SubtractFloat,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA - ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_SubtractInt : public USeqAct_SetSequenceVariable
{
public:
    //## BEGIN PROPS SeqAct_SubtractInt
    INT ValueA;
    INT ValueB;
    FLOAT FloatResult;
    INT IntResult;
    //## END PROPS SeqAct_SubtractInt

    DECLARE_CLASS(USeqAct_SubtractInt,USeqAct_SetSequenceVariable,0,Engine)
	void Activated()
	{
		FloatResult = ValueA - ValueB;
		OutputLinks(0).bHasImpulse = TRUE;
		
		// Round the float result into the integer result
		IntResult = appRound( FloatResult );
	}
};

class USeqAct_SetVectorComponents : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetVectorComponents
    FVector OutVector;
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
    //## END PROPS SeqAct_SetVectorComponents

    DECLARE_CLASS(USeqAct_SetVectorComponents,USequenceAction,0,Engine)
	void Activated()
	{
		OutVector.X = X;
		OutVector.Y = Y;
		OutVector.Z = Z;
		OutputLinks(0).bHasImpulse = TRUE;
	}
};

class USeqAct_SetWorldAttractorParam : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_SetWorldAttractorParam
    TArrayNoInit<class AWorldAttractor*> Attractor;
    BITFIELD bEnabledField:1;
    BITFIELD bFalloffTypeField:1;
    BITFIELD bFalloffExponentField:1;
    BITFIELD bRangeField:1;
    BITFIELD bStrengthField:1;
    BITFIELD bEnabled:1;
    SCRIPT_ALIGN;
    BYTE FalloffType;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat FalloffExponent;
    struct FRawDistributionFloat Range;
    struct FRawDistributionFloat Strength;
    //## END PROPS SeqAct_SetWorldAttractorParam

    DECLARE_CLASS(USeqAct_SetWorldAttractorParam,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetWorldAttractorParam)
};

class USeqAct_Switch : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Switch
    INT LinkCount;
    INT IncrementAmount;
    BITFIELD bLooping:1;
    BITFIELD bAutoDisableLinks:1;
    TArrayNoInit<INT> Indices;
    //## END PROPS SeqAct_Switch

    DECLARE_CLASS(USeqAct_Switch,USequenceAction,0,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent)
	{
		// force at least one output link
		if (LinkCount <= 0)
		{
			LinkCount = 1;
		}
		if (OutputLinks.Num() < LinkCount)
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < LinkCount)
			{
				INT idx = OutputLinks.AddZeroed();
				OutputLinks(idx).LinkDesc = FString::Printf(TEXT("Link %d"),idx+1);
			}
		}
		else
		if (OutputLinks.Num() > LinkCount)
		{
			while (OutputLinks.Num() > LinkCount)
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		Super::PostEditChangeProperty(PropertyChangedEvent);
	}

	virtual void Activated()
	{
		USequenceOp::Activated();

		// activate each of the indices
		for (INT Idx = 0; Idx < Indices.Num(); Idx++)
		{
			INT ActiveIdx = Indices(Idx) - 1;
			if (ActiveIdx >= 0 &&
				ActiveIdx < OutputLinks.Num())
			{
				if (!OutputLinks(ActiveIdx).bDisabled && 
					!(OutputLinks(ActiveIdx).bDisabledPIE && GIsEditor))
				{
					OutputLinks(ActiveIdx).bHasImpulse = TRUE;
					if (bAutoDisableLinks)
					{
						OutputLinks(ActiveIdx).bDisabled = TRUE;
					}
				}
			}
			// increment the indices
			if (IncrementAmount != 0)
			{
				if (bLooping)
				{
					Indices(Idx) = 1 + ((Indices(Idx) - 1 + IncrementAmount) % OutputLinks.Num());
				}
				else
				{
					Indices(Idx) += IncrementAmount;
				}
			}
		}
	}

	virtual void UpdateObject()
	{
		// save the output links
		TArray<FSeqOpOutputLink> SavedOutputLinks = OutputLinks;
		Super::UpdateObject();
		OutputLinks.Empty();
		OutputLinks = SavedOutputLinks;
	}

	void DeActivated()
	{
		// do nothing, already activated output links
	}
};

class USeqAct_RandomSwitch : public USeqAct_Switch
{
public:
    //## BEGIN PROPS SeqAct_RandomSwitch
    TArrayNoInit<INT> AutoDisabledIndices;
    //## END PROPS SeqAct_RandomSwitch

    DECLARE_CLASS(USeqAct_RandomSwitch,USeqAct_Switch,0,Engine)
	virtual void Activated();
};

class USeqAct_Timer : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Timer
    FLOAT ActivationTime;
    FLOAT Time;
    //## END PROPS SeqAct_Timer

    DECLARE_CLASS(USeqAct_Timer,USequenceAction,0,Engine)
	void Activated()
	{
		// reset the activation time
		Time = 0.f;
		ActivationTime = GWorld != NULL ? GWorld->GetTimeSeconds() : 0.f;
	}

	UBOOL UpdateOp(FLOAT DeltaTime)
	{
		// check for stop
		if (InputLinks(1).bHasImpulse)
		{
			// record the exact duration
			Time = GWorld != NULL ? GWorld->GetTimeSeconds() - ActivationTime : 0.f;
			// finish the op
			return TRUE;
		}
		else
		{
			// update the current time
			Time += DeltaTime;
			// and force any attached variables to get the new value
			PopulateLinkedVariableValues();
		}
		return FALSE;
	}
};

class USeqAct_Toggle : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Toggle
    //## END PROPS SeqAct_Toggle

    DECLARE_CLASS(USeqAct_Toggle,USequenceAction,0,Engine)
	virtual void PostLoad();
	virtual void Activated();
};

class USeqAct_Trace : public USequenceAction
{
public:
    //## BEGIN PROPS SeqAct_Trace
    BITFIELD bTraceActors:1;
    BITFIELD bTraceWorld:1;
    SCRIPT_ALIGN;
    FVector TraceExtent;
    FVector StartOffset;
    FVector EndOffset;
    class UObject* HitObject;
    FLOAT Distance;
    FVector HitLocation;
    //## END PROPS SeqAct_Trace

    DECLARE_CLASS(USeqAct_Trace,USequenceAction,0,Engine)
	virtual void Activated();
	virtual void DeActivated()
	{
	}
};

class USequenceCondition : public USequenceOp
{
public:
    //## BEGIN PROPS SequenceCondition
    //## END PROPS SequenceCondition

    DECLARE_ABSTRACT_CLASS(USequenceCondition,USequenceOp,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USequenceCondition)
};

class USeqCond_CompareBool : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareBool
    BITFIELD bResult:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqCond_CompareBool

    DECLARE_CLASS(USeqCond_CompareBool,USequenceCondition,0,Engine)
	void Activated();
};

class USeqCond_CompareFloat : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareFloat
    FLOAT ValueA;
    FLOAT ValueB;
    //## END PROPS SeqCond_CompareFloat

    DECLARE_CLASS(USeqCond_CompareFloat,USequenceCondition,0,Engine)
	void Activated()
	{
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_CompareInt : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareInt
    INT ValueA;
    INT ValueB;
    //## END PROPS SeqCond_CompareInt

    DECLARE_CLASS(USeqCond_CompareInt,USequenceCondition,0,Engine)
	void Activated()
	{
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_CompareObject : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_CompareObject
    //## END PROPS SeqCond_CompareObject

    DECLARE_CLASS(USeqCond_CompareObject,USequenceCondition,0,Engine)
	void Activated();
};

class USeqCond_GetServerType : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_GetServerType
    //## END PROPS SeqCond_GetServerType

    DECLARE_CLASS(USeqCond_GetServerType,USequenceCondition,0,Engine)
	virtual void Activated();
};

class USeqCond_Increment : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_Increment
    INT IncrementAmount;
    INT ValueA;
    INT ValueB;
    //## END PROPS SeqCond_Increment

    DECLARE_CLASS(USeqCond_Increment,USequenceCondition,0,Engine)
	void Activated()
	{
		// first increment the value
		ValueA += IncrementAmount;
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IncrementFloat : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IncrementFloat
    FLOAT IncrementAmount;
    FLOAT ValueA;
    FLOAT ValueB;
    //## END PROPS SeqCond_IncrementFloat

    DECLARE_CLASS(USeqCond_IncrementFloat,USequenceCondition,0,Engine)
	void Activated()
	{
		// first increment the value
		ValueA += IncrementAmount;
		// compare the values and set appropriate output impulse
		if (ValueA <= ValueB)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		if (ValueA > ValueB)
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
		if (ValueA == ValueB)
		{
			OutputLinks(2).bHasImpulse = TRUE;
		}
		if (ValueA < ValueB)
		{
			OutputLinks(3).bHasImpulse = TRUE;
		}
		if (ValueA >= ValueB)
		{
			OutputLinks(4).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IsAlive : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsAlive
    //## END PROPS SeqCond_IsAlive

    DECLARE_CLASS(USeqCond_IsAlive,USequenceCondition,0,Engine)
	virtual void Activated();
};

class USeqCond_IsBenchmarking : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsBenchmarking
    //## END PROPS SeqCond_IsBenchmarking

    DECLARE_CLASS(USeqCond_IsBenchmarking,USequenceCondition,0,Engine)
	virtual void Activated();
};

class USeqCond_IsConsole : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsConsole
    //## END PROPS SeqCond_IsConsole

    DECLARE_CLASS(USeqCond_IsConsole,USequenceCondition,0,Engine)
	virtual void Activated()
	{
		USequenceOp::Activated();

		AWorldInfo* WorldInfo = GWorld->GetWorldInfo();

		// Trigger the output based upon meeting the num logged in criteria
		if( WorldInfo && WorldInfo->IsConsoleBuild() )
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		else
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IsInCombat : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsInCombat
    //## END PROPS SeqCond_IsInCombat

    DECLARE_CLASS(USeqCond_IsInCombat,USequenceCondition,0,Engine)
	virtual void Activated();
};

struct SeqCond_IsLoggedIn_eventCheckLogins_Parms
{
    UBOOL ReturnValue;
    SeqCond_IsLoggedIn_eventCheckLogins_Parms(EEventParm)
    {
    }
};
class USeqCond_IsLoggedIn : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsLoggedIn
    INT NumNeededLoggedIn;
    //## END PROPS SeqCond_IsLoggedIn

    UBOOL eventCheckLogins()
    {
        SeqCond_IsLoggedIn_eventCheckLogins_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_CheckLogins),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(USeqCond_IsLoggedIn,USequenceCondition,0,Engine)
	virtual void Activated()
	{
		USequenceOp::Activated();

		// Trigger the output based upon meeting the num logged in criteria
		if (eventCheckLogins() == TRUE)
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		else
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_IsPIE : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsPIE
    //## END PROPS SeqCond_IsPIE

    DECLARE_CLASS(USeqCond_IsPIE,USequenceCondition,0,Engine)
	virtual void Activated();
};

class USeqCond_IsSameTeam : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_IsSameTeam
    //## END PROPS SeqCond_IsSameTeam

    DECLARE_CLASS(USeqCond_IsSameTeam,USequenceCondition,0,Engine)
	virtual void Activated();
};

class USeqCond_MatureLanguage : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_MatureLanguage
    //## END PROPS SeqCond_MatureLanguage

    DECLARE_CLASS(USeqCond_MatureLanguage,USequenceCondition,0,Engine)
	virtual void Activated()
	{
		USequenceOp::Activated();

		if( GEngine && GEngine->bAllowMatureLanguage )
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		else
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
	}
};

class USeqCond_ShowGore : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_ShowGore
    //## END PROPS SeqCond_ShowGore

    DECLARE_CLASS(USeqCond_ShowGore,USequenceCondition,0,Engine)
	virtual void Activated()
	{
		USequenceOp::Activated();

		if( GWorld && GWorld->GetWorldInfo() && GWorld->GetWorldInfo()->GRI && 
			GWorld->GetWorldInfo()->GRI->eventShouldShowGore() )
		{
			OutputLinks(0).bHasImpulse = TRUE;
		}
		else
		{
			OutputLinks(1).bHasImpulse = TRUE;
		}
	}
};

struct SeqCond_SwitchBase_eventRemoveValueEntry_Parms
{
    INT RemoveIndex;
    SeqCond_SwitchBase_eventRemoveValueEntry_Parms(EEventParm)
    {
    }
};
struct SeqCond_SwitchBase_eventInsertValueEntry_Parms
{
    INT InsertIndex;
    SeqCond_SwitchBase_eventInsertValueEntry_Parms(EEventParm)
    {
    }
};
struct SeqCond_SwitchBase_eventIsFallThruEnabled_Parms
{
    INT ValueIndex;
    UBOOL ReturnValue;
    SeqCond_SwitchBase_eventIsFallThruEnabled_Parms(EEventParm)
    {
    }
};
struct SeqCond_SwitchBase_eventVerifyDefaultCaseValue_Parms
{
    SeqCond_SwitchBase_eventVerifyDefaultCaseValue_Parms(EEventParm)
    {
    }
};
class USeqCond_SwitchBase : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_SwitchBase
    //## END PROPS SeqCond_SwitchBase

    void eventRemoveValueEntry(INT RemoveIndex)
    {
        SeqCond_SwitchBase_eventRemoveValueEntry_Parms Parms(EC_EventParm);
        Parms.RemoveIndex=RemoveIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveValueEntry),&Parms);
    }
    void eventInsertValueEntry(INT InsertIndex)
    {
        SeqCond_SwitchBase_eventInsertValueEntry_Parms Parms(EC_EventParm);
        Parms.InsertIndex=InsertIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertValueEntry),&Parms);
    }
    UBOOL eventIsFallThruEnabled(INT ValueIndex)
    {
        SeqCond_SwitchBase_eventIsFallThruEnabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ValueIndex=ValueIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_IsFallThruEnabled),&Parms);
        return Parms.ReturnValue;
    }
    void eventVerifyDefaultCaseValue()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_VerifyDefaultCaseValue),NULL);
    }
    DECLARE_ABSTRACT_CLASS(USeqCond_SwitchBase,USequenceCondition,0,Engine)
	/* === USeqCond_SwitchBase interface === */
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate ) PURE_VIRTUAL(USeqCond_SwitchBase::GetOutputLinksToActivate,return FALSE;);

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const PURE_VIRTUAL(USeqCond_SwitchBase::FindCaseValueIndex,return INDEX_NONE;);

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const PURE_VIRTUAL(USeqCond_SwitchBase::GetSupportedValueCount,return 0;);

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const PURE_VIRTUAL(USeqCond_SwitchBase::GetCaseValueString,return TEXT("NOT IMPLMENTED"););

	/* === USequenceOp interface === */
	/**
	 * Called when this sequence op is activated.  Determines which output link should be activated based on the value
	 * of the linked object var.
	 */
	virtual void Activated();
	virtual void UpdateDynamicLinks();

#if WITH_EDITOR
	/**
	 * Returns the color that should be used for an input, variable, or output link connector in the kismet editor.
	 *
	 * @param	ConnType	the type of connection this represents.  Valid values are:
	 *							LOC_INPUT		(input link)
	 *							LOC_OUTPUT		(output link)
	 *							LOC_VARIABLE	(variable link)
	 *							LOC_EVENT		(event link)
	 * @param	ConnIndex	the index [into the corresponding array (i.e. InputLinks, OutputLinks, etc.)] for the link
	 *						being queried.
	 * @param	MouseOverConnType
	 *						INDEX_NONE if the user is not currently mousing over the specified link connector.  One of the values
	 *						listed for ConnType otherwise.
	 * @param	MouseOverConnIndex
	 *						INDEX_NONE if the user is not currently mousing over the specified link connector.  The index for the
	 *						link being moused over otherwise.
	 */
	virtual FColor GetConnectionColor( INT ConnType, INT ConnIndex, INT MouseOverConnType, INT MouseOverConnIndex );
#endif
};

struct FSwitchClassInfo
{
    FName ClassName;
    BYTE bFallThru;
    SCRIPT_ALIGN;

    /** Constructors */
    FSwitchClassInfo() {}
    FSwitchClassInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSwitchClassInfo));
    }
};

class USeqCond_SwitchClass : public USeqCond_SwitchBase
{
public:
    //## BEGIN PROPS SeqCond_SwitchClass
    TArrayNoInit<struct FSwitchClassInfo> ClassArray;
    //## END PROPS SeqCond_SwitchClass

    DECLARE_CLASS(USeqCond_SwitchClass,USeqCond_SwitchBase,0,Engine)
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate );

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const;

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const;

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const;
};

struct FSwitchObjectCase
{
    class UObject* ObjectValue;
    BITFIELD bFallThru:1;
    BITFIELD bDefaultValue:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FSwitchObjectCase() {}
    FSwitchObjectCase(EEventParm)
    {
        appMemzero(this, sizeof(FSwitchObjectCase));
    }
};

class USeqCond_SwitchObject : public USeqCond_SwitchBase
{
public:
    //## BEGIN PROPS SeqCond_SwitchObject
    TArrayNoInit<struct FSwitchObjectCase> SupportedValues;
    //## END PROPS SeqCond_SwitchObject

    DECLARE_CLASS(USeqCond_SwitchObject,USeqCond_SwitchBase,0,Engine)
	/* === USeqCond_SwitchBase interface === */
	/**
	 * Returns the index of the OutputLink to activate for the specified object.
	 *
	 * @param	out_LinksToActivate
	 *						the indexes [into the OutputLinks array] for the most appropriate OutputLinks to activate
	 *						for the specified object, or INDEX_NONE if none are found.  Should only contain 0 or 1 elements
	 *						unless one of the matching cases is configured to fall through.
	 *
	 * @return	TRUE if at least one match was found, FALSE otherwise.
	 */
	virtual UBOOL GetOutputLinksToActivate( TArray<INT>& out_LinksToActivate );

	/**
	 * Returns the index [into the switch op's array of values] that corresponds to the specified OutputLink.
	 *
	 * @param	OutputLinkIndex		index into [into the OutputLinks array] to find the corresponding value index for
	 *
	 * @return	INDEX_NONE if no value was found which matches the specified output link.
	 */
	virtual INT FindCaseValueIndex( INT OutputLinkIndex ) const;

	/** Returns the number of elements in this switch op's array of values. */
	virtual INT GetSupportedValueCount() const;

	/**
	 * Returns a string representation of the value at the specified index.  Used to populate the LinkDesc for the OutputLinks array.
	 */
	virtual FString GetCaseValueString( INT ValueIndex ) const;
};

class USeqCond_SwitchPlatform : public USequenceCondition
{
public:
    //## BEGIN PROPS SeqCond_SwitchPlatform
    //## END PROPS SeqCond_SwitchPlatform

    DECLARE_CLASS(USeqCond_SwitchPlatform,USequenceCondition,0,Engine)
	virtual void Activated();
};

struct SequenceEvent_eventToggled_Parms
{
    SequenceEvent_eventToggled_Parms(EEventParm)
    {
    }
};
struct SequenceEvent_eventRegisterEvent_Parms
{
    SequenceEvent_eventRegisterEvent_Parms(EEventParm)
    {
    }
};
class USequenceEvent : public USequenceOp
{
public:
    //## BEGIN PROPS SequenceEvent
    TArrayNoInit<class USequenceEvent*> DuplicateEvts;
    class AActor* Originator;
    class AActor* Instigator;
    FLOAT ActivationTime;
    INT TriggerCount;
    INT MaxTriggerCount;
    FLOAT ReTriggerDelay;
    BITFIELD bEnabled:1;
    BITFIELD bPlayerOnly:1;
    BITFIELD bRegistered:1;
    BITFIELD bClientSideOnly:1;
    SCRIPT_ALIGN;
    BYTE Priority;
    INT MaxWidth;
    //## END PROPS SequenceEvent

    DECLARE_FUNCTION(execCheckActivate);
    void eventToggled()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Toggled),NULL);
    }
    void eventRegisterEvent()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RegisterEvent),NULL);
    }
    DECLARE_ABSTRACT_CLASS(USequenceEvent,USequenceOp,0,Engine)
	

	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);

	/**
	 * Adds an error message to the map check dialog if this SequenceEvent's EventActivator is bStatic
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();

	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntRect GetSeqObjBoundingBox();
	FIntPoint GetCenterPoint(FCanvas* Canvas);

	virtual FString GetDisplayTitle() const;
#endif

	/**
	 * This is a debug version of ActivateEvent which can be used by automated testing tools to Activate
	 * an event for testing purposes.
	 **/
	virtual void DebugActivateEvent(AActor *InOriginator, AActor *InInstigator, TArray<INT> *ActivateIndices = NULL);

	virtual UBOOL RegisterEvent();

	/**
	 * Fills in the value of the "Instigator" VariableLink
	 */
	virtual void InitializeLinkedVariableValues();

	virtual void OnExport()
	{
		Super::OnExport();
		Originator = NULL;
		Instigator = NULL;
	}

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }

	virtual void ActivateEvent(AActor *InOriginator, AActor *InInstigator, TArray<INT> *ActivateIndices = NULL, UBOOL bPushTop = FALSE, UBOOL bFromQueued = FALSE);
};

class USeqEvent_AISeeEnemy : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_AISeeEnemy
    FLOAT MaxSightDistance;
    //## END PROPS SeqEvent_AISeeEnemy

    DECLARE_CLASS(USeqEvent_AISeeEnemy,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE)
	{
		if (InOriginator != NULL &&
			InInstigator != NULL &&
			(MaxSightDistance <= 0.f ||
			 (InOriginator->Location-InInstigator->Location).Size() <= MaxSightDistance))
		{
			return Super::CheckActivate(InOriginator,InInstigator,bTest,ActivateIndices, bPushTop);
		}
		else
		{
			return FALSE;
		}
	}
};

class USeqEvent_AnalogInput : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_AnalogInput
    BITFIELD bTrapInput:1;
    INT AllowedPlayerIndex;
    TArrayNoInit<FName> InputNames;
    //## END PROPS SeqEvent_AnalogInput

    DECLARE_CLASS(USeqEvent_AnalogInput,USequenceEvent,0,Engine)
	UBOOL RegisterEvent();

	/**
	 * @return Does this event care about the given input name?
	 */
	UBOOL HasMatchingInput(FName InputName);

	/**
	 * Trigger the event as needed. If this returns TRUE, and bTrapInput is TRUE, then the caller should
	 * stop processing the input.
	 */
	UBOOL CheckInputActivate(INT PlayerIndex, FName InputName, FLOAT Value);

	/**
	 * Trigger the event as needed. If this returns TRUE, and bTrapInput is TRUE, then the caller should
	 * stop processing the input.
	 */
	UBOOL CheckInputActivate(INT PlayerIndex, FName InputName, FVector Value);
};

class USeqEvent_AnimNotify : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_AnimNotify
    FName NotifyName;
    //## END PROPS SeqEvent_AnimNotify

    DECLARE_CLASS(USeqEvent_AnimNotify,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_AnimNotify)
};

class USeqEvent_Console : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Console
    FName ConsoleEventName;
    FStringNoInit EventDesc;
    //## END PROPS SeqEvent_Console

    DECLARE_CLASS(USeqEvent_Console,USequenceEvent,0,Engine)
#if WITH_EDITOR
protected:
	FString GetDisplayTitle() const;
#endif
};

class USeqEvent_ConstraintBroken : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_ConstraintBroken
    //## END PROPS SeqEvent_ConstraintBroken

    DECLARE_CLASS(USeqEvent_ConstraintBroken,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_ConstraintBroken)
};

class USeqEvent_Destroyed : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Destroyed
    //## END PROPS SeqEvent_Destroyed

    DECLARE_CLASS(USeqEvent_Destroyed,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_Destroyed)
};

class USeqEvent_GetInventory : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_GetInventory
    //## END PROPS SeqEvent_GetInventory

    DECLARE_CLASS(USeqEvent_GetInventory,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_Input : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Input
    BITFIELD bTrapInput:1;
    INT AllowedPlayerIndex;
    TArrayNoInit<FName> InputNames;
    //## END PROPS SeqEvent_Input

    DECLARE_CLASS(USeqEvent_Input,USequenceEvent,0,Engine)
	UBOOL RegisterEvent();

	/**
	 * @return Does this event care about the given input name?
	 */
	UBOOL HasMatchingInput(FName InputName);

	/**
	 * Trigger the event as needed. If this returns TRUE, and bTrapInput is TRUE, then the caller should
	 * stop processing the input.
	 */
	UBOOL CheckInputActivate(INT PlayerIndex, FName InputName, EInputEvent Action);
};

class UDEPRECATED_SeqEvent_LevelBeginning : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_LevelBeginning
    //## END PROPS SeqEvent_LevelBeginning

    DECLARE_CLASS(UDEPRECATED_SeqEvent_LevelBeginning,USequenceEvent,0|CLASS_Deprecated,Engine)
	virtual USequenceObject* ConvertObject();
};

class USeqEvent_LevelLoaded : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_LevelLoaded
    //## END PROPS SeqEvent_LevelLoaded

    DECLARE_CLASS(USeqEvent_LevelLoaded,USequenceEvent,0,Engine)
	virtual void UpdateObject();
};

class UDEPRECATED_SeqEvent_LevelStartup : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_LevelStartup
    //## END PROPS SeqEvent_LevelStartup

    DECLARE_CLASS(UDEPRECATED_SeqEvent_LevelStartup,USequenceEvent,0|CLASS_Deprecated,Engine)
	virtual USequenceObject* ConvertObject();
};

class USeqEvent_Mover : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Mover
    FLOAT StayOpenTime;
    //## END PROPS SeqEvent_Mover

    DECLARE_CLASS(USeqEvent_Mover,USequenceEvent,0,Engine)
	virtual void OnCreated();
};

class USeqEvent_ParticleEvent : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_ParticleEvent
    BYTE EventType;
    SCRIPT_ALIGN;
    FVector EventPosition;
    FLOAT EventEmitterTime;
    FVector EventVelocity;
    FLOAT EventParticleTime;
    FVector EventNormal;
    BITFIELD UseRelfectedImpactVector:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqEvent_ParticleEvent

    DECLARE_CLASS(USeqEvent_ParticleEvent,USequenceEvent,0,Engine)
	virtual void OnCreated();
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);

	/** Called via PostEditChange(), lets ops create/remove dynamic links based on data. */
	virtual void UpdateDynamicLinks();

	/** Helper function for filling in the output links according to the assigned emitter. */
	virtual void SetupOutputLinks(UBOOL bPreserveExistingLinks = TRUE);
};

class USeqEvent_ProjectileLanded : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_ProjectileLanded
    FLOAT MaxDistance;
    //## END PROPS SeqEvent_ProjectileLanded

    DECLARE_CLASS(USeqEvent_ProjectileLanded,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_RemoteEvent : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_RemoteEvent
    FName EventName;
    BITFIELD bStatusIsOk:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqEvent_RemoteEvent

    DECLARE_CLASS(USeqEvent_RemoteEvent,USequenceEvent,0,Engine)
public:
	virtual void UpdateStatus();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

#if WITH_EDITOR
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& BoxCenter);
protected:
	FString GetDisplayTitle() const;
#endif
};

class USeqEvent_RigidBodyCollision : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_RigidBodyCollision
    FLOAT MinCollisionVelocity;
    //## END PROPS SeqEvent_RigidBodyCollision

    DECLARE_CLASS(USeqEvent_RigidBodyCollision,USequenceEvent,0,Engine)
	void CheckRBCollisionActivate( const FRigidBodyCollisionInfo& OriginatorInfo, const FRigidBodyCollisionInfo& InstigatorInfo1,
					const TArray<FRigidBodyContactInfo>& ContactInfos, FLOAT VelMag );
};

class USeqEvent_SeeDeath : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_SeeDeath
    //## END PROPS SeqEvent_SeeDeath

    DECLARE_CLASS(USeqEvent_SeeDeath,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USeqEvent_SequenceActivated : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_SequenceActivated
    FStringNoInit InputLabel;
    //## END PROPS SeqEvent_SequenceActivated

    DECLARE_CLASS(USeqEvent_SequenceActivated,USequenceEvent,0,Engine)
#if WITH_EDITOR
protected:
	FString GetDisplayTitle() const;
#endif
public:
	virtual void OnCreated();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	UBOOL CheckActivateSimple();
};

class USeqEvent_TakeDamage : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_TakeDamage
    FLOAT MinDamageAmount;
    FLOAT DamageThreshold;
    TArrayNoInit<class UClass*> DamageTypes;
    TArrayNoInit<class UClass*> IgnoreDamageTypes;
    FLOAT CurrentDamage;
    BITFIELD bResetDamageOnToggle:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqEvent_TakeDamage

    DECLARE_CLASS(USeqEvent_TakeDamage,USequenceEvent,0,Engine)
#if WITH_EDITOR
	// Gives op a chance to add realtime debugging information (when enabled)
	virtual void GetRealtimeComments(TArray<FString> &OutComments);
#endif
};

class USeqEvent_Touch : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Touch
    TArrayNoInit<class UClass*> ClassProximityTypes;
    TArrayNoInit<class UClass*> IgnoredClassProximityTypes;
    BITFIELD bForceOverlapping:1;
    BITFIELD bUseInstigator:1;
    BITFIELD bAllowDeadPawns:1;
    TArrayNoInit<class AActor*> TouchedList;
    //## END PROPS SeqEvent_Touch

    DECLARE_FUNCTION(execCheckTouchActivate);
    DECLARE_FUNCTION(execCheckUnTouchActivate);
    DECLARE_CLASS(USeqEvent_Touch,USequenceEvent,0,Engine)
	virtual UBOOL CheckTouchActivate(AActor *inOriginator, AActor *inInstigator, UBOOL bTest = FALSE);
	virtual UBOOL CheckUnTouchActivate(AActor *inOriginator, AActor *inInstigator, UBOOL bTest = FALSE);

protected:
	// hide the default implementation to force use of CheckTouchActivate/CheckUnTouchActivate
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);

	virtual void DoTouchActivation(AActor *InOriginator, AActor *InInstigator);
	virtual void DoUnTouchActivation(AActor *InOriginator, AActor *InInstigator, INT TouchIdx);
};

class USeqEvent_TouchInput : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_TouchInput
    BITFIELD bTrapInput:1;
    INT AllowedPlayerIndex;
    INT AllowedTouchIndex;
    INT AllowedTouchpadIndex;
    //## END PROPS SeqEvent_TouchInput

    DECLARE_CLASS(USeqEvent_TouchInput,USequenceEvent,0,Engine)
	UBOOL RegisterEvent();

	/**
	 * Trigger the event as needed. If this returns TRUE, and bTrapInput is TRUE, then the caller should
	 * stop processing the input.
	 */
	UBOOL CheckInputActivate(INT PlayerIndex, INT TouchIndex, INT TouchpadIndex, EInputEvent Action, const FVector2D& Location);
};

class USeqEvent_Used : public USequenceEvent
{
public:
    //## BEGIN PROPS SeqEvent_Used
    BITFIELD bAimToInteract:1;
    FLOAT InteractDistance;
    FStringNoInit InteractText;
    class UTexture2D* InteractIcon;
    TArrayNoInit<class UClass*> ClassProximityTypes;
    TArrayNoInit<class UClass*> IgnoredClassProximityTypes;
    //## END PROPS SeqEvent_Used

    DECLARE_CLASS(USeqEvent_Used,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *InOriginator, AActor *InInstigator, UBOOL bTest=FALSE, TArray<INT>* ActivateIndices = NULL, UBOOL bPushTop = FALSE);
};

class USequenceVariable : public USequenceObject
{
public:
    //## BEGIN PROPS SequenceVariable
    FName VarName;
    //## END PROPS SequenceVariable

    DECLARE_ABSTRACT_CLASS(USequenceVariable,USequenceObject,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual UObject** GetObjectRef( INT Idx )
	{
		return NULL;
	}

	virtual FString GetValueStr()
	{
		return FString(TEXT("Undefined"));
	}

	/**
	 * Used for property exposure to variable links, allows variables
	 * to determine what types they can support.
	 */
	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const;

	/**
	 * Copies the value stored by this SequenceVariable to the SequenceOp member variable that it's associated with.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied from this sequence variable
	 * @param	Property	the property in Op that will receive the value of this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink) {}

	/**
	 * Copy the value from the member variable this VariableLink is associated with to this VariableLink's value.
	 *
	 * @param	Op			the sequence op that contains the value that should be copied to this sequence variable
	 * @param	Property	the property in Op that contains the value to copy into this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink) {}

	/**
	 * Allows the sequence variable to execute additional logic after copying values from the SequenceOp's members to the sequence variable.
	 *
	 * @param	SourceOp	the sequence op that contains the value that should be copied to this sequence variable
	 * @param	VarLink		the variable link in Op that this sequence variable is linked to
	 */
	virtual void PostPopulateValue( USequenceOp* SourceOp, FSeqVarLink& VarLink ) {}

protected:
	virtual void ConvertObjectInternal(USequenceObject* NewSeqObj, INT LinkIdx = -1);
public:

#if WITH_EDITOR
	// USequenceObject interface
	virtual void DrawSeqObj(FCanvas* Canvas, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntRect GetSeqObjBoundingBox();
	
	FIntPoint GetVarConnectionLocation();

	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter) {}
#endif
};

struct FAnimSetBakeAndPruneStatus
{
    FStringNoInit AnimSetName;
    BITFIELD bReferencedButUnused:1;
    BITFIELD bSkipBakeAndPrune:1;
    BITFIELD bSkipCooking:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FAnimSetBakeAndPruneStatus() {}
    FAnimSetBakeAndPruneStatus(EEventParm)
    {
        appMemzero(this, sizeof(FAnimSetBakeAndPruneStatus));
    }
};

class UInterpData : public USequenceVariable
{
public:
    //## BEGIN PROPS InterpData
    FLOAT InterpLength;
    FLOAT PathBuildTime;
    TArrayNoInit<class UInterpGroup*> InterpGroups;
    class UInterpCurveEdSetup* CurveEdSetup;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class UInterpFilter*> InterpFilters;
    class UInterpFilter* SelectedFilter;
    TArrayNoInit<class UInterpFilter*> DefaultFilters;
#endif // WITH_EDITORONLY_DATA
    FLOAT EdSectionStart;
    FLOAT EdSectionEnd;
    BITFIELD bShouldBakeAndPrune:1;
    TArrayNoInit<struct FAnimSetBakeAndPruneStatus> BakeAndPruneStatus;
    class UInterpGroupDirector* CachedDirectorGroup;
    //## END PROPS InterpData

    DECLARE_CLASS(UInterpData,USequenceVariable,0,Engine)
	// UObject interface
	/**
	 * This function is being called after all objects referenced by this object have been serialized.
	 */
	virtual void PostLoad(void);

	// SequenceVariable interface
	virtual FString GetValueStr();

	/** Search through all InterpGroups in this InterpData to find a group whose GroupName matches the given name. Returns INDEX_NONE if group not found. */
	INT FindGroupByName( FName GroupName );
	INT FindGroupByName( const FString& InGroupName );

	void FindTracksByClass(UClass* TrackClass, TArray<class UInterpTrack*>& OutputTracks);
	class UInterpGroupDirector* FindDirectorGroup();
	void GetAllEventNames(TArray<FName>& OutEventNames);

#if WITH_EDITOR
	void UpdateBakeAndPruneStatus();
#endif
};

class USeqVar_Bool : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Bool
    INT bValue;
    //## END PROPS SeqVar_Bool

    DECLARE_CLASS(USeqVar_Bool,USequenceVariable,0,Engine)
	virtual UBOOL* GetRef()
	{
		return (UBOOL*)&bValue;
	}

	FString GetValueStr()
	{
		return bValue ? GTrue : GFalse;
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UBoolProperty::StaticClass()));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_External : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_External
    class UClass* ExpectedType;
    FStringNoInit VariableLabel;
    //## END PROPS SeqVar_External

    DECLARE_CLASS(USeqVar_External,USequenceVariable,0,Engine)
    DECLARE_WITHIN(USequence)
	// UObject interface
	virtual void PostLoad();

	// SequenceObject interface
	virtual void OnConnect(USequenceObject* connObj, INT connIdx);

	// SequenceVariable interface
	virtual FString GetValueStr();

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }
};

class USeqVar_Float : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Float
    FLOAT FloatValue;
    //## END PROPS SeqVar_Float

    DECLARE_CLASS(USeqVar_Float,USequenceVariable,0,Engine)
	virtual FLOAT* GetRef()
	{
		return &FloatValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%2.3f"),FloatValue);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UFloatProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UFloatProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_RandomFloat : public USeqVar_Float
{
public:
    //## BEGIN PROPS SeqVar_RandomFloat
    FLOAT Min;
    FLOAT Max;
    //## END PROPS SeqVar_RandomFloat

    DECLARE_CLASS(USeqVar_RandomFloat,USeqVar_Float,0,Engine)
	virtual FLOAT* GetRef()
	{
		FloatValue = Min + appFrand() * (Max - Min);
		return &FloatValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%2.2f..%2.2f"),Min,Max);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_Int : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Int
    INT IntValue;
    //## END PROPS SeqVar_Int

    DECLARE_CLASS(USeqVar_Int,USequenceVariable,0,Engine)
	virtual INT* GetRef()
	{
		return &IntValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%d"),IntValue);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UIntProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UIntProperty::StaticClass())));
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_RandomInt : public USeqVar_Int
{
public:
    //## BEGIN PROPS SeqVar_RandomInt
    INT Min;
    INT Max;
    //## END PROPS SeqVar_RandomInt

    DECLARE_CLASS(USeqVar_RandomInt,USeqVar_Int,0,Engine)
	virtual INT* GetRef()
	{
		if( Min < Max )
		{
			IntValue = Min + (appRand() % (Max - Min + 1));
		}
		else
		{
			IntValue = Max + (appRand() % (Min - Max + 1));
		}
		return &IntValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%d..%d"),Min,Max);
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_Named : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Named
    class UClass* ExpectedType;
    FName FindVarName;
    BITFIELD bStatusIsOk:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqVar_Named

    DECLARE_CLASS(USeqVar_Named,USequenceVariable,0,Engine)
	// UObject interface
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// SequenceObject interface
	virtual void OnConnect(USequenceObject *connObj,INT connIdx);

	/**
	 * Returns whether this SequenceObject can exist in a sequence without being linked to anything else (i.e. does not require
	 * another sequence object to activate it)
	 */
	virtual UBOOL IsStandalone() const { return TRUE; }

	// SequenceVariable interface
	virtual FString GetValueStr();

#if WITH_EDITOR
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);
#endif

	// SeqVar_Named interface
	void UpdateStatus();

	virtual UBOOL ValidateVarLinks();
};

class USeqVar_Object : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Object
    class UObject* ObjValue;
    FVector ActorLocation;
    TArrayNoInit<class UClass*> SupportedClasses;
    //## END PROPS SeqVar_Object

    DECLARE_CLASS(USeqVar_Object,USequenceVariable,0,Engine)
	virtual UObject** GetObjectRef( INT Idx )
	{
		if( Idx != 0 )
		{
			return NULL;
		}
		return &ObjValue;
	}

	virtual FVector* GetRef();

	// Moved to CPP
	virtual FString GetValueStr();

	virtual void OnExport()
	{
		ObjValue = NULL;
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return (Property->IsA(UObjectProperty::StaticClass()) ||
				(Property->IsA(UArrayProperty::StaticClass()) && ((UArrayProperty*)Property)->Inner->IsA(UObjectProperty::StaticClass())));
	}

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);

#if WITH_EDITOR
	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);
#endif
};

class USeqVar_Character : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_Character
    class UClass* PawnClass;
    //## END PROPS SeqVar_Character

    DECLARE_ABSTRACT_CLASS(USeqVar_Character,USeqVar_Object,0,Engine)
	UObject** GetObjectRef( INT Idx );

	virtual FString GetValueStr()
	{
#if WITH_EDITORONLY_DATA
		return ObjName;
#else
		return FString( TEXT( "" ) );
#endif // WITH_EDITORONLY_DATA
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}

#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class UDEPRECATED_SeqVar_Group : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_Group
    FName GroupName;
    BITFIELD bCachedList:1;
    TArrayNoInit<class UObject*> Actors;
    //## END PROPS SeqVar_Group

    DECLARE_CLASS(UDEPRECATED_SeqVar_Group,USeqVar_Object,0|CLASS_Deprecated,Engine)
	virtual FString GetValueStr();
	virtual UObject** GetObjectRef(INT Idx);
};

class USeqVar_ObjectList : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_ObjectList
    TArrayNoInit<class UObject*> ObjList;
    //## END PROPS SeqVar_ObjectList

    DECLARE_CLASS(USeqVar_ObjectList,USeqVar_Object,0,Engine)
	virtual void OnCreated();

	// we need to see how to export arrays here, let's look at inventory
	virtual void OnExport();

	virtual UObject** GetObjectRef( INT Idx );

	virtual FString GetValueStr();

#if WITH_EDITOR
	// USequenceVariable interface
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);
#endif

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}

	virtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent);
};

class USeqVar_ObjectVolume : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_ObjectVolume
    FLOAT LastUpdateTime;
    TArrayNoInit<class UObject*> ContainedObjects;
    TArrayNoInit<class UClass*> ExcludeClassList;
    BITFIELD bCollidingOnly:1;
    SCRIPT_ALIGN;
    //## END PROPS SeqVar_ObjectVolume

    DECLARE_CLASS(USeqVar_ObjectVolume,USeqVar_Object,0,Engine)
	virtual UObject** GetObjectRef(INT Idx);

#if WITH_EDITOR
	virtual void DrawExtraInfo(FCanvas* Canvas, const FVector& CircleCenter);
#endif

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_Player : public USeqVar_Object
{
public:
    //## BEGIN PROPS SeqVar_Player
    TArrayNoInit<class UObject*> Players;
    BITFIELD bAllPlayers:1;
    INT PlayerIdx;
    //## END PROPS SeqVar_Player

    void UpdatePlayersList();
    DECLARE_FUNCTION(execUpdatePlayersList)
    {
        P_FINISH;
        this->UpdatePlayersList();
    }
    DECLARE_CLASS(USeqVar_Player,USeqVar_Object,0,Engine)
	UObject** GetObjectRef( INT Idx );

	virtual FString GetValueStr()
	{
		if (!bAllPlayers)
		{
			return FString::Printf(TEXT("Player %d"),PlayerIdx);
		}
		else
		{
			return FString(TEXT("All Players"));
		}
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		return FALSE;
	}
};

class USeqVar_String : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_String
    FStringNoInit StrValue;
    //## END PROPS SeqVar_String

    DECLARE_CLASS(USeqVar_String,USequenceVariable,0,Engine)
	virtual FString* GetRef()
	{
		return &StrValue;
	}

	FString GetValueStr()
	{
		return StrValue;
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		if (Cast<UStrProperty>(Property))
		{
			return TRUE;
		}

		UArrayProperty* ArrayProp = Cast<UArrayProperty>(Property);
		if (ArrayProp)
		{
			if (Cast<UStrProperty>(ArrayProp->Inner))
			{
				return TRUE;
			}
		}

		return FALSE;
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

class USeqVar_Vector : public USequenceVariable
{
public:
    //## BEGIN PROPS SeqVar_Vector
    FVector VectValue;
    //## END PROPS SeqVar_Vector

    DECLARE_CLASS(USeqVar_Vector,USequenceVariable,0,Engine)
	FVector* GetRef()
	{
		return &VectValue;
	}

	virtual FString GetValueStr()
	{
		return VectValue.ToString();
	}

	virtual UBOOL SupportsProperty(UProperty *Property)
	{
		UStructProperty* StructProp = Cast<UStructProperty>(Property);
		if (StructProp)
		{
			if (StructProp->Struct)
			{
				if (appStricmp(*(StructProp->Struct->GetName()), TEXT("Vector")) == 0)
				{
					return TRUE;
				}
			}
		}

		UArrayProperty* ArrayProp = Cast<UArrayProperty>(Property);
		if (ArrayProp)
		{
			UStructProperty* StructProp = Cast<UStructProperty>(ArrayProp->Inner);
			if (StructProp && StructProp->Struct)
			{
				if (appStricmp(*(StructProp->Struct->GetName()), TEXT("Vector")) == 0)
				{
					return TRUE;
				}
			}
		}

		return FALSE;
	}

	virtual void PublishValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
	virtual void PopulateValue(USequenceOp *Op, UProperty *Property, FSeqVarLink &VarLink);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_SEQUENCE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(USequenceObject,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(USequenceObject,-1,execScriptLog);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execForceActivateOutput);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execForceActivateInput);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execPublishLinkedVariableValues);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execPopulateLinkedVariableValues);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execActivateNamedOutputLink);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execActivateOutputLink);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execLinkedVariables);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetBoolVars);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetInterpDataVars);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetObjectVars);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetLinkedObjects);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execHasLinkedOps);
AUTOGENERATE_FUNCTION(USequence,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(USequence,-1,execFindSeqObjectsByName);
AUTOGENERATE_FUNCTION(USequence,-1,execFindSeqObjectsByClass);
AUTOGENERATE_FUNCTION(UPrefabSequence,-1,execGetOwnerPrefab);
AUTOGENERATE_FUNCTION(UPrefabSequence,-1,execSetOwnerPrefab);
AUTOGENERATE_FUNCTION(USeqAct_Latent,-1,execAbortFor);
AUTOGENERATE_FUNCTION(USeqAct_Delay,-1,execResetDelayActive);
AUTOGENERATE_FUNCTION(USeqAct_Interp,-1,execAddPlayerToDirectorTracks);
AUTOGENERATE_FUNCTION(USeqAct_Interp,-1,execStop);
AUTOGENERATE_FUNCTION(USeqAct_Interp,-1,execSetPosition);
AUTOGENERATE_FUNCTION(USeqAct_WaitForLevelsVisible,-1,execCheckLevelsVisible);
AUTOGENERATE_FUNCTION(USequenceEvent,-1,execCheckActivate);
AUTOGENERATE_FUNCTION(USeqEvent_Touch,-1,execCheckUnTouchActivate);
AUTOGENERATE_FUNCTION(USeqEvent_Touch,-1,execCheckTouchActivate);
AUTOGENERATE_FUNCTION(USeqVar_Player,-1,execUpdatePlayersList);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_SEQUENCE_NATIVE_DEFS
#define ENGINE_SEQUENCE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_SEQUENCE \
	USequenceObject::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SequenceObject"), GEngineUSequenceObjectNatives); \
	USequenceFrame::StaticClass(); \
	USequenceFrameWrapped::StaticClass(); \
	USequenceOp::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SequenceOp"), GEngineUSequenceOpNatives); \
	USequence::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Sequence"), GEngineUSequenceNatives); \
	UPrefabSequence::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PrefabSequence"), GEngineUPrefabSequenceNatives); \
	UPrefabSequenceContainer::StaticClass(); \
	USequenceAction::StaticClass(); \
	USeqAct_ActivateRemoteEvent::StaticClass(); \
	USeqAct_AndGate::StaticClass(); \
	USeqAct_ApplySoundNode::StaticClass(); \
	USeqAct_AttachToEvent::StaticClass(); \
	USeqAct_CameraFade::StaticClass(); \
	USeqAct_CameraLookAt::StaticClass(); \
	USeqAct_CameraShake::StaticClass(); \
	USeqAct_ChangeCollision::StaticClass(); \
	USeqAct_CommitMapChange::StaticClass(); \
	USeqAct_ConvertToString::StaticClass(); \
	USeqAct_DrawText::StaticClass(); \
	USeqAct_FinishSequence::StaticClass(); \
	USeqAct_Gate::StaticClass(); \
	USeqAct_GetDistance::StaticClass(); \
	USeqAct_GetLocationAndRotation::StaticClass(); \
	USeqAct_GetProperty::StaticClass(); \
	USeqAct_GetVectorComponents::StaticClass(); \
	USeqAct_GetVelocity::StaticClass(); \
	USeqAct_HeadTrackingControl::StaticClass(); \
	USeqAct_IsInObjectList::StaticClass(); \
	USeqAct_Latent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SeqAct_Latent"), GEngineUSeqAct_LatentNatives); \
	USeqAct_ActorFactory::StaticClass(); \
	USeqAct_ActorFactoryEx::StaticClass(); \
	USeqAct_ProjectileFactory::StaticClass(); \
	USeqAct_AIMoveToActor::StaticClass(); \
	USeqAct_Delay::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SeqAct_Delay"), GEngineUSeqAct_DelayNatives); \
	UDEPRECATED_SeqAct_DelaySwitch::StaticClass(); \
	USeqAct_ForceGarbageCollection::StaticClass(); \
	USeqAct_Interp::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SeqAct_Interp"), GEngineUSeqAct_InterpNatives); \
	USeqAct_LevelStreamingBase::StaticClass(); \
	USeqAct_LevelStreaming::StaticClass(); \
	USeqAct_MultiLevelStreaming::StaticClass(); \
	USeqAct_LevelVisibility::StaticClass(); \
	USeqAct_PlaySound::StaticClass(); \
	USeqAct_PrepareMapChange::StaticClass(); \
	USeqAct_SetDOFParams::StaticClass(); \
	USeqAct_SetMotionBlurParams::StaticClass(); \
	USeqAct_StreamInTextures::StaticClass(); \
	USeqAct_WaitForLevelsVisible::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SeqAct_WaitForLevelsVisible"), GEngineUSeqAct_WaitForLevelsVisibleNatives); \
	USeqAct_Log::StaticClass(); \
	USeqAct_FeatureTest::StaticClass(); \
	USeqAct_ModifyCover::StaticClass(); \
	USeqAct_ModifyHealth::StaticClass(); \
	USeqAct_ParticleEventGenerator::StaticClass(); \
	USeqAct_PlayCameraAnim::StaticClass(); \
	USeqAct_PlayFaceFXAnim::StaticClass(); \
	USeqAct_PlayMusicTrack::StaticClass(); \
	USeqAct_Possess::StaticClass(); \
	UDEPRECATED_SeqAct_RangeSwitch::StaticClass(); \
	USeqAct_SetActiveAnimChild::StaticClass(); \
	USeqAct_SetApexClothingParam::StaticClass(); \
	USeqAct_SetBlockRigidBody::StaticClass(); \
	USeqAct_SetCameraTarget::StaticClass(); \
	USeqAct_SetMaterial::StaticClass(); \
	USeqAct_SetMatInstScalarParam::StaticClass(); \
	USeqAct_SetMesh::StaticClass(); \
	USeqAct_SetPhysics::StaticClass(); \
	USeqAct_SetRigidBodyIgnoreVehicles::StaticClass(); \
	USeqAct_SetSequenceVariable::StaticClass(); \
	USeqAct_AccessObjectList::StaticClass(); \
	USeqAct_AddFloat::StaticClass(); \
	USeqAct_AddInt::StaticClass(); \
	USeqAct_CastToFloat::StaticClass(); \
	USeqAct_CastToInt::StaticClass(); \
	USeqAct_DivideFloat::StaticClass(); \
	USeqAct_DivideInt::StaticClass(); \
	USeqAct_ModifyObjectList::StaticClass(); \
	USeqAct_MultiplyFloat::StaticClass(); \
	USeqAct_MultiplyInt::StaticClass(); \
	USeqAct_SetBool::StaticClass(); \
	USeqAct_SetFloat::StaticClass(); \
	USeqAct_SetInt::StaticClass(); \
	USeqAct_SetLocation::StaticClass(); \
	USeqAct_SetObject::StaticClass(); \
	USeqAct_SetString::StaticClass(); \
	USeqAct_SubtractFloat::StaticClass(); \
	USeqAct_SubtractInt::StaticClass(); \
	USeqAct_SetVectorComponents::StaticClass(); \
	USeqAct_SetWorldAttractorParam::StaticClass(); \
	USeqAct_Switch::StaticClass(); \
	USeqAct_RandomSwitch::StaticClass(); \
	USeqAct_Timer::StaticClass(); \
	USeqAct_Toggle::StaticClass(); \
	USeqAct_Trace::StaticClass(); \
	USequenceCondition::StaticClass(); \
	USeqCond_CompareBool::StaticClass(); \
	USeqCond_CompareFloat::StaticClass(); \
	USeqCond_CompareInt::StaticClass(); \
	USeqCond_CompareObject::StaticClass(); \
	USeqCond_GetServerType::StaticClass(); \
	USeqCond_Increment::StaticClass(); \
	USeqCond_IncrementFloat::StaticClass(); \
	USeqCond_IsAlive::StaticClass(); \
	USeqCond_IsBenchmarking::StaticClass(); \
	USeqCond_IsConsole::StaticClass(); \
	USeqCond_IsInCombat::StaticClass(); \
	USeqCond_IsLoggedIn::StaticClass(); \
	USeqCond_IsPIE::StaticClass(); \
	USeqCond_IsSameTeam::StaticClass(); \
	USeqCond_MatureLanguage::StaticClass(); \
	USeqCond_ShowGore::StaticClass(); \
	USeqCond_SwitchBase::StaticClass(); \
	USeqCond_SwitchClass::StaticClass(); \
	USeqCond_SwitchObject::StaticClass(); \
	USeqCond_SwitchPlatform::StaticClass(); \
	USequenceEvent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SequenceEvent"), GEngineUSequenceEventNatives); \
	USeqEvent_AISeeEnemy::StaticClass(); \
	USeqEvent_AnalogInput::StaticClass(); \
	USeqEvent_AnimNotify::StaticClass(); \
	USeqEvent_Console::StaticClass(); \
	USeqEvent_ConstraintBroken::StaticClass(); \
	USeqEvent_Destroyed::StaticClass(); \
	USeqEvent_GetInventory::StaticClass(); \
	USeqEvent_Input::StaticClass(); \
	UDEPRECATED_SeqEvent_LevelBeginning::StaticClass(); \
	USeqEvent_LevelLoaded::StaticClass(); \
	UDEPRECATED_SeqEvent_LevelStartup::StaticClass(); \
	USeqEvent_Mover::StaticClass(); \
	USeqEvent_ParticleEvent::StaticClass(); \
	USeqEvent_ProjectileLanded::StaticClass(); \
	USeqEvent_RemoteEvent::StaticClass(); \
	USeqEvent_RigidBodyCollision::StaticClass(); \
	USeqEvent_SeeDeath::StaticClass(); \
	USeqEvent_SequenceActivated::StaticClass(); \
	USeqEvent_TakeDamage::StaticClass(); \
	USeqEvent_Touch::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SeqEvent_Touch"), GEngineUSeqEvent_TouchNatives); \
	USeqEvent_TouchInput::StaticClass(); \
	USeqEvent_Used::StaticClass(); \
	USequenceVariable::StaticClass(); \
	UInterpData::StaticClass(); \
	USeqVar_Bool::StaticClass(); \
	USeqVar_External::StaticClass(); \
	USeqVar_Float::StaticClass(); \
	USeqVar_RandomFloat::StaticClass(); \
	USeqVar_Int::StaticClass(); \
	USeqVar_RandomInt::StaticClass(); \
	USeqVar_Named::StaticClass(); \
	USeqVar_Object::StaticClass(); \
	USeqVar_Character::StaticClass(); \
	UDEPRECATED_SeqVar_Group::StaticClass(); \
	USeqVar_ObjectList::StaticClass(); \
	USeqVar_ObjectVolume::StaticClass(); \
	USeqVar_Player::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SeqVar_Player"), GEngineUSeqVar_PlayerNatives); \
	USeqVar_String::StaticClass(); \
	USeqVar_Vector::StaticClass(); \

#endif // ENGINE_SEQUENCE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineUSequenceObjectNatives[] = 
{ 
	MAP_NATIVE(USequenceObject, execGetWorldInfo)
	MAP_NATIVE(USequenceObject, execScriptLog)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSequenceOpNatives[] = 
{ 
	MAP_NATIVE(USequenceOp, execForceActivateOutput)
	MAP_NATIVE(USequenceOp, execForceActivateInput)
	MAP_NATIVE(USequenceOp, execPublishLinkedVariableValues)
	MAP_NATIVE(USequenceOp, execPopulateLinkedVariableValues)
	MAP_NATIVE(USequenceOp, execActivateNamedOutputLink)
	MAP_NATIVE(USequenceOp, execActivateOutputLink)
	MAP_NATIVE(USequenceOp, execLinkedVariables)
	MAP_NATIVE(USequenceOp, execGetBoolVars)
	MAP_NATIVE(USequenceOp, execGetInterpDataVars)
	MAP_NATIVE(USequenceOp, execGetObjectVars)
	MAP_NATIVE(USequenceOp, execGetLinkedObjects)
	MAP_NATIVE(USequenceOp, execHasLinkedOps)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSequenceNatives[] = 
{ 
	MAP_NATIVE(USequence, execSetEnabled)
	MAP_NATIVE(USequence, execFindSeqObjectsByName)
	MAP_NATIVE(USequence, execFindSeqObjectsByClass)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUPrefabSequenceNatives[] = 
{ 
	MAP_NATIVE(UPrefabSequence, execGetOwnerPrefab)
	MAP_NATIVE(UPrefabSequence, execSetOwnerPrefab)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSeqAct_LatentNatives[] = 
{ 
	MAP_NATIVE(USeqAct_Latent, execAbortFor)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSeqAct_DelayNatives[] = 
{ 
	MAP_NATIVE(USeqAct_Delay, execResetDelayActive)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSeqAct_InterpNatives[] = 
{ 
	MAP_NATIVE(USeqAct_Interp, execAddPlayerToDirectorTracks)
	MAP_NATIVE(USeqAct_Interp, execStop)
	MAP_NATIVE(USeqAct_Interp, execSetPosition)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSeqAct_WaitForLevelsVisibleNatives[] = 
{ 
	MAP_NATIVE(USeqAct_WaitForLevelsVisible, execCheckLevelsVisible)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSequenceEventNatives[] = 
{ 
	MAP_NATIVE(USequenceEvent, execCheckActivate)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSeqEvent_TouchNatives[] = 
{ 
	MAP_NATIVE(USeqEvent_Touch, execCheckUnTouchActivate)
	MAP_NATIVE(USeqEvent_Touch, execCheckTouchActivate)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSeqVar_PlayerNatives[] = 
{ 
	MAP_NATIVE(USeqVar_Player, execUpdatePlayersList)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(USequenceObject,SequenceObject,ObjInstanceVersion)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(USequenceObject,SequenceObject,PIESequenceObject)
#else
VERIFY_CLASS_OFFSET_NODIE(USequenceObject,SequenceObject,DrawHeight)
#endif
VERIFY_CLASS_SIZE_NODIE(USequenceObject)
VERIFY_CLASS_OFFSET_NODIE(USequenceFrame,SequenceFrame,SizeX)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(USequenceFrame,SequenceFrame,FillMaterial)
#else
VERIFY_CLASS_OFFSET_NODIE(USequenceFrame,SequenceFrame,FillColor)
#endif
VERIFY_CLASS_SIZE_NODIE(USequenceFrame)
VERIFY_CLASS_SIZE_NODIE(USequenceFrameWrapped)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(USequenceOp,SequenceOp,PIEActivationTime)
#else
VERIFY_CLASS_OFFSET_NODIE(USequenceOp,SequenceOp,InputLinks)
#endif
VERIFY_CLASS_OFFSET_NODIE(USequenceOp,SequenceOp,SearchTag)
VERIFY_CLASS_SIZE_NODIE(USequenceOp)
VERIFY_CLASS_OFFSET_NODIE(USequence,Sequence,LogFile)
VERIFY_CLASS_OFFSET_NODIE(USequence,Sequence,DefaultViewZoom)
VERIFY_CLASS_SIZE_NODIE(USequence)
VERIFY_CLASS_OFFSET_NODIE(UPrefabSequence,PrefabSequence,OwnerPrefab)
VERIFY_CLASS_SIZE_NODIE(UPrefabSequence)
VERIFY_CLASS_SIZE_NODIE(UPrefabSequenceContainer)
VERIFY_CLASS_OFFSET_NODIE(USequenceAction,SequenceAction,HandlerName)
VERIFY_CLASS_OFFSET_NODIE(USequenceAction,SequenceAction,Targets)
VERIFY_CLASS_SIZE_NODIE(USequenceAction)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ActivateRemoteEvent,SeqAct_ActivateRemoteEvent,Instigator)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ActivateRemoteEvent,SeqAct_ActivateRemoteEvent,EventName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActivateRemoteEvent)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AndGate,SeqAct_AndGate,LinkedOutputFiredStatus)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AndGate,SeqAct_AndGate,LinkedOutputs)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AndGate)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ApplySoundNode,SeqAct_ApplySoundNode,PlaySound)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ApplySoundNode,SeqAct_ApplySoundNode,ApplyNode)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ApplySoundNode)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AttachToEvent)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CameraFade,SeqAct_CameraFade,FadeColor)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CameraFade,SeqAct_CameraFade,CachedPCs)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CameraFade)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CameraLookAt,SeqAct_CameraLookAt,InterpSpeedRange)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CameraLookAt,SeqAct_CameraLookAt,RemainingTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CameraLookAt)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CameraShake,SeqAct_CameraShake,Shake)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CameraShake,SeqAct_CameraShake,LocationActor)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CameraShake)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ChangeCollision,SeqAct_ChangeCollision,CollisionType)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ChangeCollision)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CommitMapChange)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ConvertToString,SeqAct_ConvertToString,VarSeparator)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ConvertToString,SeqAct_ConvertToString,NumberOfInputs)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ConvertToString)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_DrawText,SeqAct_DrawText,DisplayTimeSeconds)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_DrawText,SeqAct_DrawText,DrawTextInfo)
VERIFY_CLASS_SIZE_NODIE(USeqAct_DrawText)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_FinishSequence,SeqAct_FinishSequence,OutputLabel)
VERIFY_CLASS_SIZE_NODIE(USeqAct_FinishSequence)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Gate,SeqAct_Gate,AutoCloseCount)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Gate,SeqAct_Gate,CurrentCloseCount)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Gate)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GetDistance,SeqAct_GetDistance,Distance)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetDistance)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GetLocationAndRotation,SeqAct_GetLocationAndRotation,Location)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GetLocationAndRotation,SeqAct_GetLocationAndRotation,SocketOrBoneName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetLocationAndRotation)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GetProperty,SeqAct_GetProperty,PropertyName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetProperty)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GetVectorComponents,SeqAct_GetVectorComponents,InVector)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GetVectorComponents,SeqAct_GetVectorComponents,Z)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetVectorComponents)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GetVelocity,SeqAct_GetVelocity,VelocityMag)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_GetVelocity,SeqAct_GetVelocity,VelocityVect)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetVelocity)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_HeadTrackingControl,SeqAct_HeadTrackingControl,TrackControllerName)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_HeadTrackingControl,SeqAct_HeadTrackingControl,ActorToComponentMap)
VERIFY_CLASS_SIZE_NODIE(USeqAct_HeadTrackingControl)
VERIFY_CLASS_SIZE_NODIE(USeqAct_IsInObjectList)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Latent,SeqAct_Latent,LatentActors)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Latent,SeqAct_Latent,LatentActivationTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Latent)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ActorFactory,SeqAct_ActorFactory,Factory)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ActorFactory,SeqAct_ActorFactory,RemainingDelay)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActorFactory)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActorFactoryEx)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ProjectileFactory,SeqAct_ProjectileFactory,PSTemplate)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ProjectileFactory,SeqAct_ProjectileFactory,BoneName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ProjectileFactory)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AIMoveToActor,SeqAct_AIMoveToActor,Destination)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AIMoveToActor,SeqAct_AIMoveToActor,LastDestinationChoice)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AIMoveToActor)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Delay,SeqAct_Delay,DefaultDuration)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Delay,SeqAct_Delay,RemainingTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Delay)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_SeqAct_DelaySwitch,SeqAct_DelaySwitch,LinkCount)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_SeqAct_DelaySwitch,SeqAct_DelaySwitch,NextLinkTime)
VERIFY_CLASS_SIZE_NODIE(UDEPRECATED_SeqAct_DelaySwitch)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ForceGarbageCollection)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Interp,SeqAct_Interp,SavedActorTransforms)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Interp,SeqAct_Interp,ConstantCameraAnimRate)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Interp)
VERIFY_CLASS_SIZE_NODIE(USeqAct_LevelStreamingBase)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_LevelStreaming,SeqAct_LevelStreaming,Level)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_LevelStreaming,SeqAct_LevelStreaming,LevelName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_LevelStreaming)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_MultiLevelStreaming,SeqAct_MultiLevelStreaming,Levels)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MultiLevelStreaming)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_LevelVisibility,SeqAct_LevelVisibility,Level)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_LevelVisibility,SeqAct_LevelVisibility,LevelName)
VERIFY_CLASS_SIZE_NODIE(USeqAct_LevelVisibility)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PlaySound,SeqAct_PlaySound,PlaySound)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PlaySound,SeqAct_PlaySound,BeforeEndTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlaySound)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PrepareMapChange,SeqAct_PrepareMapChange,MainLevelName)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PrepareMapChange,SeqAct_PrepareMapChange,InitiallyLoadedSecondaryLevelNames)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PrepareMapChange)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetDOFParams,SeqAct_SetDOFParams,FalloffExponent)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetDOFParams,SeqAct_SetDOFParams,OldFocusPosition)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetDOFParams)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetMotionBlurParams,SeqAct_SetMotionBlurParams,MotionBlurAmount)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetMotionBlurParams,SeqAct_SetMotionBlurParams,OldMotionBlurAmount)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMotionBlurParams)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_StreamInTextures,SeqAct_StreamInTextures,Seconds)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_StreamInTextures,SeqAct_StreamInTextures,SelectedCinematicTextureGroups)
VERIFY_CLASS_SIZE_NODIE(USeqAct_StreamInTextures)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_WaitForLevelsVisible,SeqAct_WaitForLevelsVisible,LevelNames)
VERIFY_CLASS_SIZE_NODIE(USeqAct_WaitForLevelsVisible)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Log,SeqAct_Log,TargetDuration)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Log,SeqAct_Log,LogMessage)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Log)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_FeatureTest,SeqAct_FeatureTest,FreezeAtParameters)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_FeatureTest,SeqAct_FeatureTest,RemainingScreenShotDelay)
VERIFY_CLASS_SIZE_NODIE(USeqAct_FeatureTest)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ModifyCover,SeqAct_ModifyCover,Slots)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ModifyCover,SeqAct_ModifyCover,ManualCoverType)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ModifyCover)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ModifyHealth,SeqAct_ModifyHealth,DamageType)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ModifyHealth,SeqAct_ModifyHealth,Instigator)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ModifyHealth)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ParticleEventGenerator,SeqAct_ParticleEventGenerator,Instigator)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ParticleEventGenerator,SeqAct_ParticleEventGenerator,EventNormal)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ParticleEventGenerator)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PlayCameraAnim,SeqAct_PlayCameraAnim,CameraAnim)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PlayCameraAnim,SeqAct_PlayCameraAnim,UserDefinedSpaceActor)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlayCameraAnim)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PlayFaceFXAnim,SeqAct_PlayFaceFXAnim,FaceFXAnimSetRef)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PlayFaceFXAnim,SeqAct_PlayFaceFXAnim,SoundCueToPlay)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlayFaceFXAnim)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_PlayMusicTrack,SeqAct_PlayMusicTrack,MusicTrack)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlayMusicTrack)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Possess,SeqAct_Possess,PawnToPossess)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Possess)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_SeqAct_RangeSwitch,SeqAct_RangeSwitch,Ranges)
VERIFY_CLASS_SIZE_NODIE(UDEPRECATED_SeqAct_RangeSwitch)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetActiveAnimChild,SeqAct_SetActiveAnimChild,NodeName)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetActiveAnimChild,SeqAct_SetActiveAnimChild,BlendTime)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetActiveAnimChild)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetApexClothingParam)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetBlockRigidBody)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetCameraTarget,SeqAct_SetCameraTarget,CameraTarget)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetCameraTarget,SeqAct_SetCameraTarget,TransitionParams)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetCameraTarget)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetMaterial,SeqAct_SetMaterial,NewMaterial)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetMaterial,SeqAct_SetMaterial,MaterialIndex)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMaterial)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetMatInstScalarParam,SeqAct_SetMatInstScalarParam,MatInst)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetMatInstScalarParam,SeqAct_SetMatInstScalarParam,ScalarValue)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMatInstScalarParam)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetMesh,SeqAct_SetMesh,NewSkeletalMesh)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetMesh,SeqAct_SetMesh,MeshType)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetMesh)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetPhysics,SeqAct_SetPhysics,newPhysics)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetPhysics)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetRigidBodyIgnoreVehicles)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetSequenceVariable)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AccessObjectList,SeqAct_AccessObjectList,OutputObject)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AccessObjectList,SeqAct_AccessObjectList,ObjectIndex)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AccessObjectList)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AddFloat,SeqAct_AddFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AddFloat,SeqAct_AddFloat,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AddFloat)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AddInt,SeqAct_AddInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_AddInt,SeqAct_AddInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AddInt)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CastToFloat,SeqAct_CastToFloat,Value)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CastToFloat,SeqAct_CastToFloat,FloatResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CastToFloat)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CastToInt,SeqAct_CastToInt,Value)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_CastToInt,SeqAct_CastToInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CastToInt)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_DivideFloat,SeqAct_DivideFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_DivideFloat,SeqAct_DivideFloat,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_DivideFloat)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_DivideInt,SeqAct_DivideInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_DivideInt,SeqAct_DivideInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_DivideInt)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_ModifyObjectList,SeqAct_ModifyObjectList,ListEntriesCount)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ModifyObjectList)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_MultiplyFloat,SeqAct_MultiplyFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_MultiplyFloat,SeqAct_MultiplyFloat,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MultiplyFloat)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_MultiplyInt,SeqAct_MultiplyInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_MultiplyInt,SeqAct_MultiplyInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_MultiplyInt)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetBool)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetFloat,SeqAct_SetFloat,Target)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetFloat,SeqAct_SetFloat,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetFloat)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetInt,SeqAct_SetInt,Target)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetInt,SeqAct_SetInt,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetInt)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetLocation,SeqAct_SetLocation,LocationValue)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetLocation,SeqAct_SetLocation,Target)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetLocation)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetObject,SeqAct_SetObject,DefaultValue)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetObject,SeqAct_SetObject,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetObject)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetString,SeqAct_SetString,Target)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetString,SeqAct_SetString,Value)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetString)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SubtractFloat,SeqAct_SubtractFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SubtractFloat,SeqAct_SubtractFloat,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SubtractFloat)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SubtractInt,SeqAct_SubtractInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SubtractInt,SeqAct_SubtractInt,IntResult)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SubtractInt)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetVectorComponents,SeqAct_SetVectorComponents,OutVector)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetVectorComponents,SeqAct_SetVectorComponents,Z)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetVectorComponents)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetWorldAttractorParam,SeqAct_SetWorldAttractorParam,Attractor)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_SetWorldAttractorParam,SeqAct_SetWorldAttractorParam,Strength)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetWorldAttractorParam)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Switch,SeqAct_Switch,LinkCount)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Switch,SeqAct_Switch,Indices)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Switch)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_RandomSwitch,SeqAct_RandomSwitch,AutoDisabledIndices)
VERIFY_CLASS_SIZE_NODIE(USeqAct_RandomSwitch)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Timer,SeqAct_Timer,ActivationTime)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Timer,SeqAct_Timer,Time)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Timer)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Toggle)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Trace,SeqAct_Trace,TraceExtent)
VERIFY_CLASS_OFFSET_NODIE(USeqAct_Trace,SeqAct_Trace,HitLocation)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Trace)
VERIFY_CLASS_SIZE_NODIE(USequenceCondition)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareBool)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_CompareFloat,SeqCond_CompareFloat,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_CompareFloat,SeqCond_CompareFloat,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareFloat)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_CompareInt,SeqCond_CompareInt,ValueA)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_CompareInt,SeqCond_CompareInt,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareInt)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareObject)
VERIFY_CLASS_SIZE_NODIE(USeqCond_GetServerType)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_Increment,SeqCond_Increment,IncrementAmount)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_Increment,SeqCond_Increment,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_Increment)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_IncrementFloat,SeqCond_IncrementFloat,IncrementAmount)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_IncrementFloat,SeqCond_IncrementFloat,ValueB)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IncrementFloat)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsAlive)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsBenchmarking)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsConsole)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsInCombat)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_IsLoggedIn,SeqCond_IsLoggedIn,NumNeededLoggedIn)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsLoggedIn)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsPIE)
VERIFY_CLASS_SIZE_NODIE(USeqCond_IsSameTeam)
VERIFY_CLASS_SIZE_NODIE(USeqCond_MatureLanguage)
VERIFY_CLASS_SIZE_NODIE(USeqCond_ShowGore)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchBase)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_SwitchClass,SeqCond_SwitchClass,ClassArray)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchClass)
VERIFY_CLASS_OFFSET_NODIE(USeqCond_SwitchObject,SeqCond_SwitchObject,SupportedValues)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchObject)
VERIFY_CLASS_SIZE_NODIE(USeqCond_SwitchPlatform)
VERIFY_CLASS_OFFSET_NODIE(USequenceEvent,SequenceEvent,DuplicateEvts)
VERIFY_CLASS_OFFSET_NODIE(USequenceEvent,SequenceEvent,MaxWidth)
VERIFY_CLASS_SIZE_NODIE(USequenceEvent)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_AISeeEnemy,SeqEvent_AISeeEnemy,MaxSightDistance)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_AISeeEnemy)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_AnalogInput,SeqEvent_AnalogInput,AllowedPlayerIndex)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_AnalogInput,SeqEvent_AnalogInput,InputNames)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_AnalogInput)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_AnimNotify,SeqEvent_AnimNotify,NotifyName)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_AnimNotify)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_Console,SeqEvent_Console,ConsoleEventName)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_Console,SeqEvent_Console,EventDesc)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Console)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ConstraintBroken)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Destroyed)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_GetInventory)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_Input,SeqEvent_Input,AllowedPlayerIndex)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_Input,SeqEvent_Input,InputNames)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Input)
VERIFY_CLASS_SIZE_NODIE(UDEPRECATED_SeqEvent_LevelBeginning)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_LevelLoaded)
VERIFY_CLASS_SIZE_NODIE(UDEPRECATED_SeqEvent_LevelStartup)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_Mover,SeqEvent_Mover,StayOpenTime)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Mover)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_ParticleEvent,SeqEvent_ParticleEvent,EventType)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_ParticleEvent,SeqEvent_ParticleEvent,EventNormal)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ParticleEvent)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_ProjectileLanded,SeqEvent_ProjectileLanded,MaxDistance)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ProjectileLanded)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_RemoteEvent,SeqEvent_RemoteEvent,EventName)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_RemoteEvent)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_RigidBodyCollision,SeqEvent_RigidBodyCollision,MinCollisionVelocity)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_RigidBodyCollision)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_SeeDeath)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_SequenceActivated,SeqEvent_SequenceActivated,InputLabel)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_SequenceActivated)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_TakeDamage,SeqEvent_TakeDamage,MinDamageAmount)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_TakeDamage,SeqEvent_TakeDamage,CurrentDamage)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_TakeDamage)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_Touch,SeqEvent_Touch,ClassProximityTypes)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_Touch,SeqEvent_Touch,TouchedList)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Touch)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_TouchInput,SeqEvent_TouchInput,AllowedPlayerIndex)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_TouchInput,SeqEvent_TouchInput,AllowedTouchpadIndex)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_TouchInput)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_Used,SeqEvent_Used,InteractDistance)
VERIFY_CLASS_OFFSET_NODIE(USeqEvent_Used,SeqEvent_Used,IgnoredClassProximityTypes)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Used)
VERIFY_CLASS_OFFSET_NODIE(USequenceVariable,SequenceVariable,VarName)
VERIFY_CLASS_SIZE_NODIE(USequenceVariable)
VERIFY_CLASS_OFFSET_NODIE(UInterpData,InterpData,InterpLength)
VERIFY_CLASS_OFFSET_NODIE(UInterpData,InterpData,CachedDirectorGroup)
VERIFY_CLASS_SIZE_NODIE(UInterpData)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Bool,SeqVar_Bool,bValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Bool)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_External,SeqVar_External,ExpectedType)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_External,SeqVar_External,VariableLabel)
VERIFY_CLASS_SIZE_NODIE(USeqVar_External)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Float,SeqVar_Float,FloatValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Float)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_RandomFloat,SeqVar_RandomFloat,Min)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_RandomFloat,SeqVar_RandomFloat,Max)
VERIFY_CLASS_SIZE_NODIE(USeqVar_RandomFloat)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Int,SeqVar_Int,IntValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Int)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_RandomInt,SeqVar_RandomInt,Min)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_RandomInt,SeqVar_RandomInt,Max)
VERIFY_CLASS_SIZE_NODIE(USeqVar_RandomInt)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Named,SeqVar_Named,ExpectedType)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Named,SeqVar_Named,FindVarName)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Named)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Object,SeqVar_Object,ObjValue)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Object,SeqVar_Object,SupportedClasses)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Object)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Character,SeqVar_Character,PawnClass)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Character)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_SeqVar_Group,SeqVar_Group,GroupName)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_SeqVar_Group,SeqVar_Group,Actors)
VERIFY_CLASS_SIZE_NODIE(UDEPRECATED_SeqVar_Group)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_ObjectList,SeqVar_ObjectList,ObjList)
VERIFY_CLASS_SIZE_NODIE(USeqVar_ObjectList)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_ObjectVolume,SeqVar_ObjectVolume,LastUpdateTime)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_ObjectVolume,SeqVar_ObjectVolume,ExcludeClassList)
VERIFY_CLASS_SIZE_NODIE(USeqVar_ObjectVolume)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Player,SeqVar_Player,Players)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Player,SeqVar_Player,PlayerIdx)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Player)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_String,SeqVar_String,StrValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_String)
VERIFY_CLASS_OFFSET_NODIE(USeqVar_Vector,SeqVar_Vector,VectValue)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Vector)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
