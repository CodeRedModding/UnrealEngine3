/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY


class USequenceObject : public UObject
{
public:
    INT ObjPosX;
    INT ObjPosY;
    FStringNoInit ObjName;
    FColor ObjColor;
    FStringNoInit ObjComment;
    BITFIELD bDrawFirst:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bDrawLast:1;
    INT DrawWidth GCC_PACK(PROPERTY_ALIGNMENT);
    INT DrawHeight;
    DECLARE_FUNCTION(execScriptLog);
    DECLARE_CLASS(USequenceObject,UObject,0,Engine)
	virtual void CheckForErrors() {};
	ULevel* GetLevel();

	virtual void OnExport();
	virtual void OnConnect(USequenceObject *connObj,INT connIdx) {}

	virtual void ScriptLog(const FString &outText);

	// USequenceObject interface
	virtual void DrawSeqObj(FRenderInterface* RI, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime) {};
	virtual void DrawLogicLinks(FRenderInterface *RI, UBOOL bCurves) {};
	virtual void DrawVariableLinks(FRenderInterface *RI, UBOOL bCurves) {};
	virtual void OnCreated() {};
	virtual void OnSelected() {};
	virtual FIntRect GetSeqObjBoundingBox();
	void SnapPosition(INT Gridsize);
	FString GetSeqObjFullName();
	USequence* GetRootSequence();

	FIntPoint GetTitleBarSize(FRenderInterface* RI);
	FColor GetBorderColor(UBOOL bSelected, UBOOL bMouseOver);

	void DrawTitleBar(FRenderInterface* RI, UBOOL bSelected, UBOOL bMouseOver, const FIntPoint& Pos, const FIntPoint& Size);
};


class USequenceFrame : public USequenceObject
{
public:
    INT SizeX;
    INT SizeY;
    INT BorderWidth;
    BITFIELD bDrawBox:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bFilled:1;
    BITFIELD bTileFill:1;
    FColor BorderColor GCC_PACK(PROPERTY_ALIGNMENT);
    FColor FillColor;
    class UTexture2D* FillTexture;
    class UMaterial* FillMaterial;
    DECLARE_CLASS(USequenceFrame,USequenceObject,0,Engine)
	virtual void DrawSeqObj(FRenderInterface* RI, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
};

struct FSeqOpInputLink
{
    FStringNoInit LinkDesc;
    BITFIELD bHasImpulse:1 GCC_PACK(PROPERTY_ALIGNMENT);
    FName LinkAction GCC_PACK(PROPERTY_ALIGNMENT);
    INT DrawY;
    BITFIELD bHidden:1 GCC_PACK(PROPERTY_ALIGNMENT);
};

struct FSeqOpOutputInputLink
{
    class USequenceOp* LinkedOp;
    INT InputLinkIdx;
};

struct FSeqOpOutputLink
{
    TArrayNoInit<FSeqOpOutputInputLink> Links;
    FStringNoInit LinkDesc;
    BITFIELD bHasImpulse:1 GCC_PACK(PROPERTY_ALIGNMENT);
    FName LinkAction GCC_PACK(PROPERTY_ALIGNMENT);
    INT DrawY;
    BITFIELD bHidden:1 GCC_PACK(PROPERTY_ALIGNMENT);
};

struct FSeqVarLink
{
    class UClass* ExpectedType;
    TArrayNoInit<class USequenceVariable*> LinkedVariables;
    FStringNoInit LinkDesc;
    FName LinkVar;
    BITFIELD bWriteable:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bHidden:1;
    INT MinVars GCC_PACK(PROPERTY_ALIGNMENT);
    INT MaxVars;
    INT DrawX;
};

struct FSeqEventLink
{
    class UClass* ExpectedType;
    TArrayNoInit<class USequenceEvent*> LinkedEvents;
    FStringNoInit LinkDesc;
    INT DrawX;
    BITFIELD bHidden:1 GCC_PACK(PROPERTY_ALIGNMENT);
};


class USequenceOp : public USequenceObject
{
public:
    BITFIELD bActive:1 GCC_PACK(PROPERTY_ALIGNMENT);
    TArrayNoInit<FSeqOpInputLink> InputLinks GCC_PACK(PROPERTY_ALIGNMENT);
    TArrayNoInit<FSeqOpOutputLink> OutputLinks;
    TArrayNoInit<FSeqVarLink> VariableLinks;
    TArrayNoInit<FSeqEventLink> EventLinks;
    DECLARE_FUNCTION(execGetObjectVars);
    DECLARE_CLASS(USequenceOp,USequenceObject,0,Engine)
	virtual void CheckForErrors();

	// USequenceOp interface
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void Activated();
	virtual void DeActivated();

	// helper functions
	void GetBoolVars(TArray<UBOOL*> &outBools, const TCHAR *inDesc = NULL);
	void GetIntVars(TArray<INT*> &outInts, const TCHAR *inDesc = NULL);
	void GetFloatVars(TArray<FLOAT*> &outFloats, const TCHAR *inDesc = NULL);
	void GetObjectVars(TArray<UObject**> &outObjects, const TCHAR *inDesc = NULL);
	void GetStringVars(TArray<FString*> &outStrings, const TCHAR *inDesc = NULL);

	INT FindConnectorIndex(const FString& ConnName, INT ConnType);
	void CleanupConnections();

	// USequenceObject interface
	virtual void DrawSeqObj(FRenderInterface* RI, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);

	FIntPoint GetLogicConnectorsSize(FRenderInterface* RI, INT* InputY=0, INT* OutputY=0);
	FIntPoint GetVariableConnectorsSize(FRenderInterface* RI);
	FColor GetVarConnectorColor(INT LinkIndex);

	void DrawLogicConnectors(FRenderInterface* RI, const FIntPoint& Pos, const FIntPoint& Size, INT MouseOverConnType, INT MouseOverConnIndex);
	void DrawVariableConnectors(FRenderInterface* RI, const FIntPoint& Pos, const FIntPoint& Size, INT MouseOverConnType, INT MouseOverConnIndex);

	virtual void DrawLogicLinks(FRenderInterface* RI, UBOOL bCurves);
	virtual void DrawVariableLinks(FRenderInterface* RI, UBOOL bCurves);

	void MakeLinkedObjDrawInfo(struct FLinkedObjDrawInfo& ObjInfo, INT MouseOverConnType = -1, INT MouseOverConnIndex = INDEX_NONE);
};


class USequence : public USequenceOp
{
public:
    Fpointer LogFile;
    TArrayNoInit<class USequenceObject*> SequenceObjects;
    INT DefaultViewX;
    INT DefaultViewY;
    FLOAT DefaultViewZoom;
    DECLARE_FUNCTION(execFindSeqObjectsByClass);
    DECLARE_CLASS(USequence,USequenceOp,0,Engine)
	void CheckForErrors();

	void BuildOpStack(TArray<USequenceOp*> &opStack);
	UBOOL ExecuteOpStack(FLOAT deltaTime, TArray<USequenceOp*> &opStack,INT maxSteps = 0);
	UBOOL UpdateOp(FLOAT deltaTime);

	virtual void ScriptLog(const FString &outText);

	virtual void Activated();

	virtual void OnCreated()
	{
		Super::OnCreated();
		// update our connectors
		UpdateConnectors();
	}

	virtual void OnExport()
	{
		Super::OnExport();
		for (INT idx = 0; idx < SequenceObjects.Num(); idx++)
		{
			SequenceObjects(idx)->OnExport();
		}
		for (INT idx = 0; idx < OutputLinks.Num(); idx++)
		{
			OutputLinks(idx).Links.Empty();
		}
		for (INT idx = 0; idx < VariableLinks.Num(); idx++)
		{
			VariableLinks(idx).LinkedVariables.Empty();
		}
		for (INT idx = 0; idx < EventLinks.Num(); idx++)
		{
			EventLinks(idx).LinkedEvents.Empty();
		}
	}

	virtual void UpdateConnectors();
	void UpdateNamedVarStatus();
	void UpdateInterpActionConnectors();

	virtual void BeginPlay();
	virtual void Destroy();
	
	void FindSeqObjectsByClass(UClass* DesiredClass, TArray<USequenceObject*>& OutputObjects);
	void FindSeqObjectsByName(const FString& Name, UBOOL bCheckComment, TArray<USequenceObject*>& OutputObjects);
	void FindSeqObjectsByObjectName(FName Name, TArray<USequenceObject*>& OutputObjects);
	void FindNamedVariables(FName VarName, UBOOL bFindUses, TArray<USequenceVariable*>& OutputVars);

	UBOOL ReferencesObject(UObject* InObject);

	void DrawSequence(FRenderInterface* RI, TArray<USequenceObject*>& SelectedSeqObjs, USequenceObject* MouseOverSeqObj, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime, UBOOL bCurves);

	// for generic browser
	void DrawThumbnail( EThumbnailPrimType InPrimType, INT InX, INT InY, struct FChildViewport* InViewport, struct FRenderInterface* InRI, FLOAT InZoom, UBOOL InShowBackground, FLOAT InZoomPct, INT InFixedSz );
	FThumbnailDesc GetThumbnailDesc( FRenderInterface* InRI, FLOAT InZoom, INT InFixedSz );
	INT GetThumbnailLabels( TArray<FString>* InLabels );
};


class USequenceAction : public USequenceOp
{
public:
    DECLARE_CLASS(USequenceAction,USequenceOp,0,Engine)
	virtual void Activated();
	virtual void PreActorHandle(AActor *inActor) {}
};


class USeqAct_AttachToEvent : public USequenceAction
{
public:
    DECLARE_CLASS(USeqAct_AttachToEvent,USequenceAction,0,Engine)
	void Activated();
};


class USeqAct_CauseDamage : public USequenceAction
{
public:
    class UClass* DamageType;
    FLOAT DamageAmount;
    DECLARE_CLASS(USeqAct_CauseDamage,USequenceAction,0,Engine)
	void Activated();
};


class USeqAct_FinishSequence : public USequenceAction
{
public:
    FStringNoInit OutputLabel;
    DECLARE_CLASS(USeqAct_FinishSequence,USequenceAction,0,Engine)
	virtual void Activated();
	virtual void OnCreated();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};


class USeqAct_GetDistance : public USequenceAction
{
public:
    DECLARE_CLASS(USeqAct_GetDistance,USequenceAction,0,Engine)
	void Activated();
};


class USeqAct_GetVelocity : public USequenceAction
{
public:
    DECLARE_CLASS(USeqAct_GetVelocity,USequenceAction,0,Engine)
	void Activated();
};


class USeqAct_Latent : public USequenceAction
{
public:
    TArrayNoInit<class AActor*> LatentActors;
    BITFIELD bAborted:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_FUNCTION(execAbortFor);
    DECLARE_CLASS(USeqAct_Latent,USequenceAction,0,Engine)
	virtual void PreActorHandle(AActor *inActor);
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void DeActivated();
};

enum EPointSelection
{
    PS_Normal               =0,
    PS_Random               =1,
    PS_MAX                  =2,
};

class USeqAct_ActorFactory : public USeqAct_Latent
{
public:
    class UActorFactory* Factory;
    BYTE PointSelection;
    INT SpawnCount GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT SpawnDelay;
    INT SpawnedCount;
    FLOAT RemainingDelay;
    DECLARE_CLASS(USeqAct_ActorFactory,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
	void DeActivated();
};


class USeqAct_AIMoveToActor : public USeqAct_Latent
{
public:
    BITFIELD bInterruptable:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(USeqAct_AIMoveToActor,USeqAct_Latent,0,Engine)
	virtual UBOOL UpdateOp(FLOAT deltaTime);
};


class USeqAct_Delay : public USeqAct_Latent
{
public:
    FLOAT DefaultDuration;
    FLOAT RemainingTime;
    DECLARE_CLASS(USeqAct_Delay,USeqAct_Latent,0,Engine)
	void Activated();
	UBOOL UpdateOp(FLOAT deltaTime);
};


class USeqAct_DelaySwitch : public USeqAct_Latent
{
public:
    INT LinkCount;
    INT CurrentIdx;
    FLOAT SwitchDelay;
    FLOAT NextLinkTime;
    DECLARE_CLASS(USeqAct_DelaySwitch,USeqAct_Latent,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged)
	{
		Super::PostEditChange(PropertyThatChanged);
		// force at least one output link
		if (LinkCount <= 0)
		{
			LinkCount = 1;
		}
		if (OutputLinks.Num() < LinkCount)
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < LinkCount)
			{
				INT idx = OutputLinks.AddZeroed();
				OutputLinks(idx).LinkDesc = FString::Printf(TEXT("Link %d"),idx+1);
			}
		}
		else
		if (OutputLinks.Num() > LinkCount)
		{
			while (OutputLinks.Num() > LinkCount)
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
	}

	void Activated()
	{
		// reset the link index
		CurrentIdx = 0;
		// figure out the total delay
		TArray<FLOAT*> floatVars;
		GetFloatVars(floatVars,TEXT("Delay"));
		SwitchDelay = 0.f;
		for (INT idx = 0; idx < floatVars.Num(); idx++)
		{
			SwitchDelay += *(floatVars(idx));
		}
		NextLinkTime = SwitchDelay;
	}

	UBOOL UpdateOp(FLOAT deltaTime)
	{
		if (NextLinkTime <= 0.f)
		{
			if (CurrentIdx < OutputLinks.Num())
			{
				// activate the new link
				OutputLinks(CurrentIdx).bHasImpulse = 1;
				// fill any variables attached
				TArray<INT*> intVars;
				GetIntVars(intVars,TEXT("Active Link"));
				for (INT idx = 0; idx < intVars.Num(); idx++)
				{
					// offset by 1 for non-programmer friendliness
					*(intVars(idx)) = CurrentIdx + 1;
				}
				// and increment the link index
				CurrentIdx++;
			}
			NextLinkTime = SwitchDelay;
		}
		else
		{
			NextLinkTime -= deltaTime;
		}
		return (CurrentIdx >= OutputLinks.Num());
	}

	void DeActivated()
	{
	}
};


class USeqAct_Interp : public USeqAct_Latent
{
public:
    FLOAT PlayRate;
    FLOAT Position;
    BITFIELD bIsPlaying:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bLooping:1;
    BITFIELD bRewindOnPlay:1;
    BITFIELD bRewindIfAlreadyPlaying:1;
    BITFIELD bReversePlayback:1;
    BITFIELD bInterpForPathBuilding:1;
    class UInterpData* InterpData GCC_PACK(PROPERTY_ALIGNMENT);
    TArrayNoInit<class UInterpGroupInst*> GroupInst;
    DECLARE_CLASS(USeqAct_Interp,USeqAct_Latent,0,Engine)
	// UObject interface
	virtual void Serialize( FArchive& Ar );

	// USequenceAction interface

	virtual void Activated();
	virtual UBOOL UpdateOp(FLOAT deltaTime);
	virtual void DeActivated();
	virtual void OnCreated();

	// USeqAct_Interp interface

	/** 
	 * Begin playback of this sequence. Only called in game. 
	 * Will then advance Position by (PlayRate * Deltatime) each time the SeqAct_Interp is ticked.
	 */
	void Play();

	/** Stop playback at current position. */
	void Stop();

	/** Similar to play, but the playback will go backwards until the beginning of the sequence is reached. */
	void Reverse();

	/** Increment track forwards by given timestep and iterate over each track updating any properties. */
	void StepInterp(FLOAT DeltaTime, UBOOL bPreview=false);

	/** Move interpolation to new position and iterate over each track updating any properties. */
	void UpdateInterp(FLOAT NewPosition, UBOOL bPreview=false, UBOOL bJump=false);

	/** For each InterGroup/Actor combination, create a InterpGroupInst, assign Actor and initialise each track. */
	void InitInterp();

	/** Destroy all InterpGroupInst. */
	void TermInterp();

	/** See if there is an instance referring to the supplied Actor. Returns NULL if not. */
	class UInterpGroupInst* FindGroupInst(AActor* Actor);

	/** Find the first group instance based on the given InterpGroup. */
	class UInterpGroupInst* FindFirstGroupInst(class UInterpGroup* InGroup);

	/** Find the first group instance based on the InterpGroup with the given name. */
	class UInterpGroupInst* FindFirstGroupInstByName(FName InGroupName);

	/** Find the InterpData connected to the first Variable connector. Returns NULL if none attached. */
	class UInterpData* FindInterpDataFromVariable();

	/** Synchronise the variable connectors with the currently attached InterpData. */
	void UpdateConnectorsFromData();

	/** Use any existing DirectorGroup to see which Actor we currently want to view through. */
	class AActor* FindViewedActor();
};


class USeqAct_Log : public USequenceAction
{
public:
    BITFIELD bOutputToScreen:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(USeqAct_Log,USequenceAction,0,Engine)
	void Activated();
};

struct FPropertyInfo
{
    FName PropertyName;
    BITFIELD bModifyProperty:1 GCC_PACK(PROPERTY_ALIGNMENT);
    FStringNoInit PropertyValue GCC_PACK(PROPERTY_ALIGNMENT);
};


class USeqAct_ModifyProperty : public USequenceAction
{
public:
    class UClass* ObjectClass;
    class UClass* PrevObjectClass;
    BITFIELD bAutoFill:1 GCC_PACK(PROPERTY_ALIGNMENT);
    TArrayNoInit<FPropertyInfo> Properties GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(USeqAct_ModifyProperty,USequenceAction,0,Engine)
	virtual void Activated();
	virtual void PostEditChange(UProperty *PropertyThatChanged);
};


class USeqAct_PlaySound : public USequenceAction
{
public:
    class USoundCue* PlaySound;
    DECLARE_CLASS(USeqAct_PlaySound,USequenceAction,0,Engine)
	void Activated();
};


class USeqAct_Possess : public USequenceAction
{
public:
    class APawn* PawnToPossess;
    DECLARE_CLASS(USeqAct_Possess,USequenceAction,0,Engine)
	void Activated();
};

struct FSwitchRange
{
    INT Min;
    INT Max;
};


class USeqAct_RangeSwitch : public USequenceAction
{
public:
    TArrayNoInit<FSwitchRange> Ranges;
    DECLARE_CLASS(USeqAct_RangeSwitch,USequenceAction,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged)
	{
		Super::PostEditChange(PropertyThatChanged);
		if (OutputLinks.Num() < Ranges.Num())
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < Ranges.Num())
			{
				OutputLinks.AddZeroed();
			}
		}
		else
		if (OutputLinks.Num() > Ranges.Num())
		{
			while (OutputLinks.Num() > Ranges.Num())
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
		// match all the link descriptions to the range values
		for (INT idx = 0; idx < Ranges.Num(); idx++)
		{
			OutputLinks(idx).LinkDesc = FString::Printf(TEXT("%d - %d"),Ranges(idx).Min,Ranges(idx).Max);
		}
	}

	virtual void Activated()
	{
		// get all of the attached int vars
		TArray<INT*> intVars;
		GetIntVars(intVars,TEXT("Index"));
		// and activate the matching outputs
		for (INT idx = 0; idx < intVars.Num(); idx++)
		{
			INT activeIdx = *(intVars(idx)) - 1;
			for (INT rangeIdx = 0; rangeIdx < Ranges.Num(); rangeIdx++)
			{
				if (activeIdx >= Ranges(rangeIdx).Min &&
					activeIdx <= Ranges(rangeIdx).Max)
				{
					OutputLinks(rangeIdx).bHasImpulse = 1;
				}
			}
		}
	}

	void DeActivated()
	{
		// do nothing, already activated output links
	}
};


class USeqAct_SetBlockRigidBody : public USequenceAction
{
public:
    DECLARE_CLASS(USeqAct_SetBlockRigidBody,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetBlockRigidBody)
};


class USeqAct_SetBool : public USequenceAction
{
public:
    BITFIELD DefaultValue:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(USeqAct_SetBool,USequenceAction,0,Engine)
	void Activated();
};


class USeqAct_SetCameraTarget : public USequenceAction
{
public:
    class AActor* CameraTarget;
    DECLARE_CLASS(USeqAct_SetCameraTarget,USequenceAction,0,Engine)
	void Activated();
};


class USeqAct_SetFloat : public USequenceAction
{
public:
    FLOAT DefaultValue;
    DECLARE_CLASS(USeqAct_SetFloat,USequenceAction,0,Engine)
	virtual void Activated();
};


class USeqAct_SetInt : public USequenceAction
{
public:
    INT DefaultValue;
    DECLARE_CLASS(USeqAct_SetInt,USequenceAction,0,Engine)
	virtual void Activated();
};


class USeqAct_SetObject : public USequenceAction
{
public:
    class UObject* DefaultValue;
    DECLARE_CLASS(USeqAct_SetObject,USequenceAction,0,Engine)
	virtual void Activated();
};


class USeqAct_SetPhysics : public USequenceAction
{
public:
    BYTE newPhysics;
    DECLARE_CLASS(USeqAct_SetPhysics,USequenceAction,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqAct_SetPhysics)
};


class USeqAct_Switch : public USequenceAction
{
public:
    INT LinkCount;
    INT IncrementAmount;
    DECLARE_CLASS(USeqAct_Switch,USequenceAction,0,Engine)
	virtual void PostEditChange(UProperty* PropertyThatChanged)
	{
		Super::PostEditChange(PropertyThatChanged);
		// force at least one output link
		if (LinkCount <= 0)
		{
			LinkCount = 1;
		}
		if (OutputLinks.Num() < LinkCount)
		{
			// keep adding, updating the description
			while (OutputLinks.Num() < LinkCount)
			{
				INT idx = OutputLinks.AddZeroed();
				OutputLinks(idx).LinkDesc = FString::Printf(TEXT("Link %d"),idx+1);
			}
		}
		else
		if (OutputLinks.Num() > LinkCount)
		{
			while (OutputLinks.Num() > LinkCount)
			{
				//FIXME: any cleanup needed for each link, or can we just mass delete?
				OutputLinks.Remove(OutputLinks.Num()-1);
			}
		}
	}

	virtual void Activated()
	{
		// get all of the attached int vars
		TArray<INT*> intVars;
		GetIntVars(intVars,TEXT("Index"));
		// and activate the matching output
		for (INT idx = 0; idx < intVars.Num(); idx++)
		{
			INT activeIdx = *(intVars(idx)) - 1;
			if (activeIdx >= 0 &&
				activeIdx < OutputLinks.Num())
			{
				OutputLinks(activeIdx).bHasImpulse = 1;
			}
			// increment the int vars
			*(intVars(idx)) += IncrementAmount;
		}
	}

	void DeActivated()
	{
		// do nothing, already activated output links
	}
};


class USeqAct_RandomSwitch : public USeqAct_Switch
{
public:
    DECLARE_CLASS(USeqAct_RandomSwitch,USeqAct_Switch,0,Engine)
	virtual void Activated()
	{
		// pick a random link to activate
		INT outIdx = appRand() % OutputLinks.Num();
		OutputLinks(outIdx).bHasImpulse = 1;
		// fill any variables attached
		TArray<INT*> intVars;
		GetIntVars(intVars,TEXT("Active Link"));
		for (INT idx = 0; idx < intVars.Num(); idx++)
		{
			// offset by 1 for non-programmer friendliness
			*(intVars(idx)) = outIdx + 1;
		}
	}
};


class USeqAct_Toggle : public USequenceAction
{
public:
    DECLARE_CLASS(USeqAct_Toggle,USequenceAction,0,Engine)
	void Activated();
};


class USequenceCondition : public USequenceOp
{
public:
    DECLARE_CLASS(USequenceCondition,USequenceOp,0,Engine)
	virtual void DeActivated()
	{
		// don't do anything, conditions handle their inputs
		// depending on the operation result
	}
};


class USeqCond_CompareBool : public USequenceCondition
{
public:
    DECLARE_CLASS(USeqCond_CompareBool,USequenceCondition,0,Engine)
	void Activated();
};


class USeqCond_CompareFloat : public USequenceCondition
{
public:
    FLOAT DefaultA;
    FLOAT DefaultB;
    DECLARE_CLASS(USeqCond_CompareFloat,USequenceCondition,0,Engine)
	void Activated();
};


class USeqCond_CompareInt : public USequenceCondition
{
public:
    INT DefaultA;
    INT DefaultB;
    DECLARE_CLASS(USeqCond_CompareInt,USequenceCondition,0,Engine)
	void Activated();
};


class USeqCond_Increment : public USequenceCondition
{
public:
    INT IncrementAmount;
    INT DefaultA;
    INT DefaultB;
    DECLARE_CLASS(USeqCond_Increment,USequenceCondition,0,Engine)
	void Activated();
};


class USequenceEvent : public USequenceOp
{
public:
    class AActor* Originator;
    class AActor* Instigator;
    FLOAT ActivationTime;
    INT TriggerCount;
    INT MaxTriggerCount;
    FLOAT ReTriggerDelay;
    BITFIELD bEnabled:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bPlayerOnly:1;
    INT MaxWidth GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_FUNCTION(execCheckActivate);
    DECLARE_CLASS(USequenceEvent,USequenceOp,0,Engine)
	// USequenceObject interface
	virtual void DrawSeqObj(FRenderInterface* RI, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntRect GetSeqObjBoundingBox();
	FIntPoint GetCenterPoint(FRenderInterface* RI);

	virtual UBOOL CheckActivate(AActor *inOriginator, AActor *inInstigator,UBOOL bTest=0);

	virtual void OnExport()
	{
		Super::OnExport();
		Originator = NULL;
		Instigator = NULL;
	}
};


class USeqEvent_AISeeEnemy : public USequenceEvent
{
public:
    FLOAT MaxSightDistance;
    DECLARE_CLASS(USeqEvent_AISeeEnemy,USequenceEvent,0,Engine)
	UBOOL CheckActivate(AActor *inOriginator, AActor *inInstigator, UBOOL bTest = 0)
	{
		if (inOriginator != NULL &&
			inInstigator != NULL &&
			(MaxSightDistance <= 0.f ||
			 (inOriginator->Location-inInstigator->Location).Size() <= MaxSightDistance))
		{
			return Super::CheckActivate(inOriginator,inInstigator,bTest);
		}
		else
		{
			return 0;
		}
	}
};


class USeqEvent_ConstraintBroken : public USequenceEvent
{
public:
    DECLARE_CLASS(USeqEvent_ConstraintBroken,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_ConstraintBroken)
};


class USeqEvent_Destroyed : public USequenceEvent
{
public:
    DECLARE_CLASS(USeqEvent_Destroyed,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_Destroyed)
};


class USeqEvent_LevelStartup : public USequenceEvent
{
public:
    DECLARE_CLASS(USeqEvent_LevelStartup,USequenceEvent,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USeqEvent_LevelStartup)
};


class USeqEvent_SequenceActivated : public USequenceEvent
{
public:
    FStringNoInit InputLabel;
    DECLARE_CLASS(USeqEvent_SequenceActivated,USequenceEvent,0,Engine)
	virtual void OnCreated();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};


class USeqEvent_Touch : public USequenceEvent
{
public:
    TArrayNoInit<class UClass*> ClassProximityTypes;
    DECLARE_CLASS(USeqEvent_Touch,USequenceEvent,0,Engine)
	UBOOL CheckActivate(AActor *inOriginator, AActor *inInstigator, UBOOL bTest = 0);
};


class USeqEvent_UnTouch : public USequenceEvent
{
public:
    TArrayNoInit<class UClass*> ClassProximityTypes;
    DECLARE_CLASS(USeqEvent_UnTouch,USequenceEvent,0,Engine)
	UBOOL CheckActivate(AActor *inOriginator, AActor *inInstigator, UBOOL bTest = 0);
};


class USeqEvent_Used : public USequenceEvent
{
public:
    BITFIELD bAimToInteract:1 GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT InteractDistance GCC_PACK(PROPERTY_ALIGNMENT);
    FStringNoInit InteractText;
    class UTexture2D* InteractIcon;
    DECLARE_CLASS(USeqEvent_Used,USequenceEvent,0,Engine)
	virtual UBOOL CheckActivate(AActor *inOriginator,AActor *inInstigator,UBOOL bTest=0);
};


class USequenceVariable : public USequenceObject
{
public:
    FName VarName;
    DECLARE_CLASS(USequenceVariable,USequenceObject,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// USequenceObject interface
	virtual void DrawSeqObj(FRenderInterface* RI, UBOOL bSelected, UBOOL bMouseOver, INT MouseOverConnType, INT MouseOverConnIndex, FLOAT MouseOverTime);
	virtual FIntRect GetSeqObjBoundingBox();

	//NOTE: yes this sucks, and is tedious, but works as an interim solution
	virtual INT* GetIntRef()
	{
		return NULL;
	}

	virtual UBOOL* GetBoolRef()
	{
		return NULL;
	}

	virtual FLOAT* GetFloatRef()
	{
		return NULL;
	}

	virtual FString* GetStringRef()
	{
		return NULL;
	}

	virtual UObject** GetObjectRef()
	{
		return NULL;
	}

	virtual FString GetValueStr()
	{
		return FString(TEXT("Undefined"));
	}

	// USequenceVariable interface
	virtual void DrawExtraInfo(FRenderInterface* RI, const FVector& CircleCenter) {}

	FIntPoint GetVarConnectionLocation();
};


class UInterpData : public USequenceVariable
{
public:
    FLOAT InterpLength;
    FLOAT PathBuildTime;
    TArrayNoInit<class UInterpGroup*> InterpGroups;
    class UInterpCurveEdSetup* CurveEdSetup;
    FLOAT EdSectionStart;
    FLOAT EdSectionEnd;
    DECLARE_CLASS(UInterpData,USequenceVariable,0,Engine)
	// SequenceVariable interface
	virtual FString GetValueStr();

	// InterpData interface
	INT FindGroupByName(FName GroupName);
	void FindTracksByClass(UClass* TrackClass, TArray<class UInterpTrack*>& OutputTracks);
	class UInterpGroupDirector* FindDirectorGroup();
	void GetAllEventNames(TArray<FName>& OutEventNames);
};


class USeqVar_Bool : public USequenceVariable
{
public:
    INT bValue;
    DECLARE_CLASS(USeqVar_Bool,USequenceVariable,0,Engine)
	UBOOL* GetBoolRef()
	{
		return &((UBOOL)bValue);
	}

	FString GetValueStr()
	{
		return FString::Printf(TEXT("%s"),bValue?TEXT("True"):TEXT("False"));
	}
};


class USeqVar_External : public USequenceVariable
{
public:
    class UClass* ExpectedType;
    FStringNoInit VariableLabel;
    DECLARE_CLASS(USeqVar_External,USequenceVariable,0,Engine)
	// UObject interface
	virtual void PostLoad();

	// SequenceObject interface
	virtual void OnConnect(USequenceObject *connObj,INT connIdx);

	// SequenceVariable interface
	virtual FString GetValueStr();
};


class USeqVar_Float : public USequenceVariable
{
public:
    FLOAT FloatValue;
    DECLARE_CLASS(USeqVar_Float,USequenceVariable,0,Engine)
	virtual FLOAT* GetFloatRef()
	{
		return &FloatValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%2.3f"),FloatValue);
	}
};


class USeqVar_RandomFloat : public USeqVar_Float
{
public:
    FLOAT Min;
    FLOAT Max;
    DECLARE_CLASS(USeqVar_RandomFloat,USeqVar_Float,0,Engine)
	virtual FLOAT* GetFloatRef()
	{
		FloatValue = Min + appFrand() * Max;
		return &FloatValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%2.1f..%2.1f"),Min,Max);
	}
};


class USeqVar_Int : public USequenceVariable
{
public:
    INT IntValue;
    DECLARE_CLASS(USeqVar_Int,USequenceVariable,0,Engine)
	virtual INT* GetIntRef()
	{
		return &IntValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%d"),IntValue);
	}
};


class USeqVar_RandomInt : public USeqVar_Int
{
public:
    INT Min;
    INT Max;
    DECLARE_CLASS(USeqVar_RandomInt,USeqVar_Int,0,Engine)
	virtual INT* GetIntRef()
	{
		IntValue = Min + (appRand() % (Max - Min));
		return &IntValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%d..%d"),Min,Max);
	}
};


class USeqVar_Named : public USequenceVariable
{
public:
    class UClass* ExpectedType;
    FName FindVarName;
    BITFIELD bStatusIsOk:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(USeqVar_Named,USequenceVariable,0,Engine)
	// UObject interface
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// SequenceObject interface
	virtual void OnConnect(USequenceObject *connObj,INT connIdx);

	// SequenceVariable interface
	virtual FString GetValueStr();
	virtual void DrawExtraInfo(FRenderInterface* RI, const FVector& CircleCenter);

	// SeqVar_Named interface
	void UpdateStatus(FString* StatusMsg = NULL);
};


class USeqVar_Object : public USequenceVariable
{
public:
    class UObject* ObjValue;
    DECLARE_CLASS(USeqVar_Object,USequenceVariable,0,Engine)
	virtual UObject** GetObjectRef()
	{
		return &ObjValue;
	}

	virtual FString GetValueStr()
	{
		return FString::Printf(TEXT("%s"),ObjValue!=NULL?ObjValue->GetName():TEXT("???"));
	}

	virtual void OnCreated();

	virtual void OnExport()
	{
		ObjValue = NULL;
	}

	// USequenceVariable interface
	virtual void DrawExtraInfo(FRenderInterface* RI, const FVector& CircleCenter);
};


class USeqVar_Player : public USeqVar_Object
{
public:
    INT PlayerIdx;
    DECLARE_CLASS(USeqVar_Player,USeqVar_Object,0,Engine)
	UObject** GetObjectRef();

	virtual FString GetValueStr()
	{
		return FString(TEXT("Player"));
	}

	void OnCreated()
	{
		// do nothing
	}
};


class USeqVar_String : public USequenceVariable
{
public:
    FStringNoInit StrValue;
    DECLARE_CLASS(USeqVar_String,USequenceVariable,0,Engine)
	FString* GetStringRef()
	{
		return &StrValue;
	}
	
	FString GetValueStr()
	{
		return StrValue;
	}
};

#endif

AUTOGENERATE_FUNCTION(USeqAct_Latent,-1,execAbortFor);
AUTOGENERATE_FUNCTION(USequence,-1,execFindSeqObjectsByClass);
AUTOGENERATE_FUNCTION(USequenceEvent,-1,execCheckActivate);
AUTOGENERATE_FUNCTION(USequenceObject,-1,execScriptLog);
AUTOGENERATE_FUNCTION(USequenceOp,-1,execGetObjectVars);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif

