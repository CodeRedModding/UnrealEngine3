/*=============================================================================
	AnimationUtils.h: Skeletal mesh animation utilities.
	Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
=============================================================================*/ 

#ifndef __ANIMATIONUTILS_H__
#define __ANIMATIONUTILS_H__

// Forward declarations.
class UAnimationCompressionAlgorithm;
class UAnimSequence;
class UAnimSet;
class USkeletalMesh;
struct FAnimSetMeshLinkup;
class FBoneAtom;
struct FMeshBone;
struct FRotationTrack;
struct FTranslationTrack;

/**
 * Encapsulates commonly useful data about bones.
 */
class FBoneData
{
public:
	FQuat		Orientation;
	FVector		Position;
	/** Bone name. */
	FName		Name;
	/** Direct descendants.  Empty for end effectors. */
	TArray<INT> Children;
	/** List of bone indices from parent up to root. */
	TArray<INT>	BonesToRoot;
	/** List of end effectors for which this bone is an ancestor.  End effectors have only one element in this list, themselves. */
	TArray<INT>	EndEffectors;
	/** If a Socket is attached to that bone */
	UBOOL		bHasSocket;
	/** If matched as a Key end effector */
	UBOOL		bKeyEndEffector;

	/**	@return		Index of parent bone; -1 for the root. */
	INT GetParent() const
	{
		return GetDepth() ? BonesToRoot(0) : -1;
	}
	/**	@return		Distance to root; 0 for the root. */
	INT GetDepth() const
	{
		return BonesToRoot.Num();
	}
	/** @return		TRUE if this bone is an end effector (has no children). */
	UBOOL IsEndEffector() const
	{
		return Children.Num() == 0;
	}
};

/**
 * Error statistics for an animation generated by TallyErrorsFromPerturbation, representing errors in translation or rotation due to a small incremental translation or rotation
 */
struct FAnimPerturbationError
{
	FLOAT MaxErrorInTransDueToTrans;
	FLOAT MaxErrorInRotDueToTrans;
	FLOAT MaxErrorInTransDueToRot;
	FLOAT MaxErrorInRotDueToRot;
};

/**
 * A set of error statistics for an animation, gathered by FAnimationUtils::ComputeCompressionError
 */
struct AnimationErrorStats
{
	/** Average world-space translation error across all end-effectors **/
	FLOAT AverageError;
	/** The worst error encountered across all end effectors **/
	FLOAT MaxError;
	/** Time at which the worst error occurred */
	FLOAT MaxErrorTime;
	/** Bone on which the worst error occurred */
	INT MaxErrorBone;
};

/** Different ways to create an additive animation */
enum EConvertToAdditive
{
	/** Delta against SkelMesh Reference pose */
	CTA_RefPose,
	/** Delta against the first frame of another animation */
	CTA_AnimFirstFrame,
	/** Delta against another animation. Other animation scaled to match first anim's length */
	CTA_AnimScaled,
	CTA_MAX	// Always last one
};

struct AdditiveAnimRebuildInfo
{
	UAnimSequence*		AdditivePose;
	UAnimSequence*		BasePose;
	UAnimSequence*		TargetPose;
	USkeletalMesh*		SkelMesh;
	EConvertToAdditive	BuildMethod;
};

/** Control animation recompression upon load. */
extern UBOOL GDisableAnimationRecompression;

/**
 * A collection of useful functions for skeletal mesh animation.
 */
class FAnimationUtils
{
public:


	/**
	 * Builds the local-to-component transformation for all bones.
	 */
	static void BuildComponentSpaceTransforms(TArray<FBoneAtom>& OutTransforms,
												const TArray<FBoneAtom>& LocalAtoms,
												const TArray<BYTE>& RequiredBones,
												const TArray<FMeshBone>& BoneData);

	/**
	* Builds the local-to-component matrix for the specified bone.
	*/
	static void BuildComponentSpaceTransform(FBoneAtom& OutTransform,
												INT BoneIndex,
												const TArray<FBoneAtom>& LocalAtoms,
												const TArray<FBoneData>& BoneData);

	static void BuildSkeletonMetaData(USkeletalMesh* SkelMesh, TArray<FBoneData>& OutBoneData);


	/**
	 * Utility function to measure the accuracy of a compressed animation. Each end-effector is checked for 
	 * world-space movement as a result of compression.
	 *
	 * @param	AnimSet		The animset to calculate compression error for.
	 * @param	SkelMesh	The skeletal mesh to use to check for world-space error (required)
	 * @param	BoneData	BoneData array describing the hierarchy of the animated skeleton
	 * @param	ErrorStats	Output structure containing the final compression error values
	 * @return				None.
	 */
	static void ComputeCompressionError(const UAnimSequence* AnimSeq, USkeletalMesh* SkelMesh, const TArray<FBoneData>& BoneData, AnimationErrorStats& ErrorStats);

	/**
	 * Utility function to compress an animation. If the animation is currently associated with a codec, it will be used to 
	 * compress the animation. Otherwise, the default codec will be used. If AllowAlternateCompressor is TRUE, an
	 * alternative compression codec will also be tested. If the alternative codec produces better compression and 
	 * the accuracy of the compressed animation remains within tolerances, the alternative codec will be used. 
	 * See GetAlternativeCompressionThreshold for information on the tolerance value used.
	 *
	 * @param	AnimSeq		The anim sequence to compress.
	 * @param	SkelMesh	The skeletal mesh against which to compress the animation.  Not needed by all compression schemes.
	 * @param	AllowAlternateCompressor	TRUE if an alternative compressor is permitted.
	 * @param	bOutput		If FALSE don't generate output or compute memory savings.
	 * @return				None.
	 */
	static void CompressAnimSequence(UAnimSequence* AnimSeq, USkeletalMesh* SkelMesh = NULL, UBOOL AllowAlternateCompressor = FALSE, UBOOL bOutput = FALSE);

	/**
	 * Utility function to compress an animation. If the animation is currently associated with a codec, it will be used to 
	 * compress the animation. Otherwise, the default codec will be used. If AllowAlternateCompressor is TRUE, an
	 * alternative compression codec will also be tested. If the alternative codec produces better compression and 
	 * the accuracy of the compressed animation remains within tolerances, the alternative codec will be used. 
	 * See GetAlternativeCompressionThreshold for information on the tolerance value used.
	 *
	 * @param	AnimSeq		The anim sequence to compress.
	 * @param	SkelMesh	The skeletal mesh against which to compress the animation.  Not needed by all compression schemes.
	 * @param	MasterTolerance	The alternate error threshold (0.0 means don't try anything other than the current / default scheme)
	 * @param	bOutput		If FALSE don't generate output or compute memory savings.
	 * @param	bFirstRecompressUsingCurrentOrDefault	If TRUE, then the animation will be first recompressed with it's current compressor if non-NULL, or with the global default compressor (specified in the engine ini)
	 * @param	bForceBelowThreshold					If TRUE and the existing compression error is greater than MasterTolerance, then any compression technique (even one that increases the size) with a lower error will be used until it falls below the threshold
	 * @param	bRaiseMaxErrorToExisting				If TRUE and the existing compression error is greater than MasterTolerance, then MasterTolerance will be effectively raised to the existing error level
	 * @param	bTryFixedBitwiseCompression				If TRUE, the uniform bitwise techniques will be tried
	 * @param	bTryPerTrackBitwiseCompression			If TRUE, the per-track compressor techniques will be tried
	 * @param	bTryLinearKeyRemovalCompression			If TRUE, the linear key removal techniques will be tried
	 * @param	bTryIntervalKeyRemoval					If TRUE, the resampling techniques will be tried
	 *
	 * @return	None.
	 */
	static void CompressAnimSequenceExplicit(
		UAnimSequence* AnimSeq,
		USkeletalMesh* SkelMesh,
		FLOAT MasterTolerance,
		UBOOL bOutput,
		UBOOL bFirstRecompressUsingCurrentOrDefault,
		UBOOL bForceBelowThreshold,
		UBOOL bRaiseMaxErrorToExisting,
		UBOOL bTryFixedBitwiseCompression,
		UBOOL bTryPerTrackBitwiseCompression,
		UBOOL bTryLinearKeyRemovalCompression,
		UBOOL bTryIntervalKeyRemoval);

	/**
	 * Tests for a missing or invalid mesh on the animation sequence, warning if one or more were found
	 *
	 * @param AnimSeq	The anim sequence to check.
	 * @param SkelMesh	The mesh to check with AnimSeq.  If NULL, the default for the anim seq is checked instead.
	 *
	 * @return	None.
	 */
	static void TestForMissingMeshes(UAnimSequence* AnimSeq, USkeletalMesh* SkelMesh);

	/**
	 * Determines the current setting for world-space error tolerance in the animation compressor.
	 * When requested, animation being compressed will also consider an alternative compression
	 * method if the end result of that method produces less error than the AlternativeCompressionThreshold.
	 * The default tolerance value is 0.0f (no alternatives allowed) but may be overriden using a field in the base engine INI file.
	 *
	 * @return				World-space error tolerance for considering an alternative compression method
	 */
	static FLOAT GetAlternativeCompressionThreshold();
	
	/**
	 * Determines the current setting for recompressing all animations upon load. The default value 
	 * is False, but may be overridden by an optional field in the base engine INI file. 
	 *
	 * @return				TRUE if the engine settings request that all animations be recompiled
	 */
	static UBOOL GetForcedRecompressionSetting();

	static void InternalSetAnimRebuildInfoForAdditiveAnim(UAnimSequence* AdditiveAnimSeq, TArray<AdditiveAnimRebuildInfo> &AdditiveAnimRebuildList);
	static void GetAdditiveAnimRebuildList(UAnimSequence *AnimSeq, TArray<AdditiveAnimRebuildInfo> &AdditiveAnimRebuildList);
	static void RebuildAdditiveAnimations(TArray<AdditiveAnimRebuildInfo> &AdditiveAnimRebuildList);
	static UBOOL ConvertAnimSeqToAdditive(UAnimSequence* SourceAnimSeq, UAnimSequence* DestAnimSeq, UAnimSequence* RefAnimSeq, USkeletalMesh* SkelMesh, EConvertToAdditive BuildMethod, UBOOL bIsLoopingAnim, UBOOL bRebuildExisting=FALSE);

	/**
	 * Converts an animation codec format into a human readable string
	 *
	 * @param	InFormat	The format to convert into a string
	 * @return				The format as a string
	 */
	static FString GetAnimationKeyFormatString(AnimationKeyFormat InFormat);

	/**
	 * Converts an animation compression type into a human readable string
	 *
	 * @param	InFormat	The compression format to convert into a string
	 * @return				The format as a string
	 */
	static FString GetAnimationCompressionFormatString(AnimationCompressionFormat InFormat);

	/**
	 * Computes the 'height' of each track, relative to a given animation linkup.
	 *
	 * The track height is defined as the minimal number of bones away from an end effector (end effectors are 0, their parents are 1, etc...)
	 *
	 * @param AnimLinkup			The animation linkup
	 * @param BoneData				The bone data to check
	 * @param NumTracks				The number of tracks
	 * @param TrackHeights [OUT]	The computed track heights
	 *
	 */
	static void CalculateTrackHeights(const FAnimSetMeshLinkup& AnimLinkup, const TArray<FBoneData>& BoneData, int NumTracks, TArray<INT>& TrackHeights);

	/**
	 * Checks a set of key times to see if the spacing is uniform or non-uniform.
	 * Note: If there are as many times as frames, they are automatically assumed to be uniformly spaced.
	 * Note: If there are two or fewer times, they are automatically assumed to be uniformly spaced.
	 *
	 * @param AnimSeq		The animation sequence the Times array is associated with
	 * @param Times			The array of key times
	 *
	 * @return				TRUE if the keys are uniformly spaced (or one of the trivial conditions is detected).  FALSE if any key spacing is greater than 1e-4 off.
	 */
	static UBOOL HasUniformKeySpacing(UAnimSequence* AnimSeq, const TArrayNoInit<FLOAT>& Times);

	/**
	 * Perturbs the bone(s) associated with each track in turn, measuring the maximum error introduced in end effectors as a result
	 */
	static void TallyErrorsFromPerturbation(
		const UAnimSequence* AnimSeq,
		INT NumTracks,
		USkeletalMesh* SkelMesh,
		const FAnimSetMeshLinkup& AnimLinkup,
		const TArray<FBoneData>& BoneData,
		const FVector& PositionNudge,
		const FQuat& RotationNudge,
		TArray<FAnimPerturbationError>& InducedErrors);
private:
	/**
	 * @return		The default animation compression algorithm singleton, instantiating it if necessary.
	 */
	static UAnimationCompressionAlgorithm* GetDefaultAnimationCompressionAlgorithm();

};


#endif // __ANIMATIONUTILS_H__
