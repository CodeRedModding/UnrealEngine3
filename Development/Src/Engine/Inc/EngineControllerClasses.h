/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_CONTROLLER_ENUMS
#define INCLUDED_ENGINE_CONTROLLER_ENUMS 1

enum EProgressMessageType
{
    PMT_Clear               =0,
    PMT_Information         =1,
    PMT_AdminMessage        =2,
    PMT_DownloadProgress    =3,
    PMT_ConnectionFailure   =4,
    PMT_PeerConnectionFailure=5,
    PMT_PeerHostMigrationFailure=6,
    PMT_SocketFailure       =7,
    PMT_MAX                 =8,
};
#define FOREACH_ENUM_EPROGRESSMESSAGETYPE(op) \
    op(PMT_Clear) \
    op(PMT_Information) \
    op(PMT_AdminMessage) \
    op(PMT_DownloadProgress) \
    op(PMT_ConnectionFailure) \
    op(PMT_PeerConnectionFailure) \
    op(PMT_PeerHostMigrationFailure) \
    op(PMT_SocketFailure) 
enum EInputMatchAction
{
    IMA_GreaterThan         =0,
    IMA_LessThan            =1,
    IMA_MAX                 =2,
};
#define FOREACH_ENUM_EINPUTMATCHACTION(op) \
    op(IMA_GreaterThan) \
    op(IMA_LessThan) 
enum EInputTypes
{
    IT_XAxis                =0,
    IT_YAxis                =1,
    IT_MAX                  =2,
};
#define FOREACH_ENUM_EINPUTTYPES(op) \
    op(IT_XAxis) \
    op(IT_YAxis) 

#endif // !INCLUDED_ENGINE_CONTROLLER_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_CONTROLLER_CLASSES
#define INCLUDED_ENGINE_CONTROLLER_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

#define UCONST_LATENT_MOVETOWARD 503

struct FVisiblePortalInfo
{
    class AActor* Source;
    class AActor* Destination;

		FVisiblePortalInfo()
		{}
		FVisiblePortalInfo(EEventParm)
		{
			appMemzero(this, sizeof(FVisiblePortalInfo));
		}
		FVisiblePortalInfo(AActor* InSource, AActor* InDest)
		: Source(InSource), Destination(InDest)
		{}

		UBOOL operator==(const FVisiblePortalInfo& Other)
		{
			return Other.Source == Source && Other.Destination == Destination;
		}
	
};

struct Controller_eventGeneratePathToLocation_Parms
{
    FVector Goal;
    FLOAT WithinDistance;
    UBOOL bAllowPartialPath;
    UBOOL ReturnValue;
    Controller_eventGeneratePathToLocation_Parms(EEventParm)
    {
    }
};
struct Controller_eventGeneratePathToActor_Parms
{
    class AActor* Goal;
    FLOAT WithinDistance;
    UBOOL bAllowPartialPath;
    UBOOL ReturnValue;
    Controller_eventGeneratePathToActor_Parms(EEventParm)
    {
    }
};
struct Controller_eventCurrentLevelUnloaded_Parms
{
    Controller_eventCurrentLevelUnloaded_Parms(EEventParm)
    {
    }
};
struct Controller_eventIsInCombat_Parms
{
    UBOOL bForceCheck;
    UBOOL ReturnValue;
    Controller_eventIsInCombat_Parms(EEventParm)
    {
    }
};
struct Controller_eventIsSpectating_Parms
{
    UBOOL ReturnValue;
    Controller_eventIsSpectating_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyCoverAdjusted_Parms
{
    Controller_eventNotifyCoverAdjusted_Parms(EEventParm)
    {
    }
};
struct Controller_eventReachedPreciseDestination_Parms
{
    Controller_eventReachedPreciseDestination_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyMissedJump_Parms
{
    Controller_eventNotifyMissedJump_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyJumpApex_Parms
{
    Controller_eventNotifyJumpApex_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyBump_Parms
{
    class AActor* Other;
    FVector HitNormal;
    UBOOL ReturnValue;
    Controller_eventNotifyBump_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyFallingHitWall_Parms
{
    FVector HitNormal;
    class AActor* Wall;
    Controller_eventNotifyFallingHitWall_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyHitWall_Parms
{
    FVector HitNormal;
    class AActor* Wall;
    UBOOL ReturnValue;
    Controller_eventNotifyHitWall_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyLanded_Parms
{
    FVector HitNormal;
    class AActor* FloorActor;
    UBOOL ReturnValue;
    Controller_eventNotifyLanded_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyHeadVolumeChange_Parms
{
    class APhysicsVolume* NewVolume;
    UBOOL ReturnValue;
    Controller_eventNotifyHeadVolumeChange_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyPhysicsVolumeChange_Parms
{
    class APhysicsVolume* NewVolume;
    Controller_eventNotifyPhysicsVolumeChange_Parms(EEventParm)
    {
    }
};
struct Controller_eventGetPlayerViewPoint_Parms
{
    FVector out_Location;
    FRotator out_Rotation;
    Controller_eventGetPlayerViewPoint_Parms(EEventParm)
    {
    }
};
struct Controller_eventHandlePathObstruction_Parms
{
    class AActor* BlockedBy;
    UBOOL ReturnValue;
    Controller_eventHandlePathObstruction_Parms(EEventParm)
    {
    }
};
struct Controller_eventMoverFinished_Parms
{
    UBOOL ReturnValue;
    Controller_eventMoverFinished_Parms(EEventParm)
    {
    }
};
struct Controller_eventAllowDetourTo_Parms
{
    class ANavigationPoint* N;
    UBOOL ReturnValue;
    Controller_eventAllowDetourTo_Parms(EEventParm)
    {
    }
};
struct Controller_eventMayFall_Parms
{
    UBOOL bFloor;
    FVector FloorNormal;
    Controller_eventMayFall_Parms(EEventParm)
    {
    }
};
struct Controller_eventLongFall_Parms
{
    Controller_eventLongFall_Parms(EEventParm)
    {
    }
};
struct Controller_eventMoveUnreachable_Parms
{
    FVector AttemptedDest;
    class AActor* AttemptedTarget;
    Controller_eventMoveUnreachable_Parms(EEventParm)
    {
    }
};
struct Controller_eventSetupSpecialPathAbilities_Parms
{
    Controller_eventSetupSpecialPathAbilities_Parms(EEventParm)
    {
    }
};
struct Controller_eventEnemyNotVisible_Parms
{
    Controller_eventEnemyNotVisible_Parms(EEventParm)
    {
    }
};
struct Controller_eventSeeMonster_Parms
{
    class APawn* Seen;
    Controller_eventSeeMonster_Parms(EEventParm)
    {
    }
};
struct Controller_eventSeePlayer_Parms
{
    class APawn* Seen;
    Controller_eventSeePlayer_Parms(EEventParm)
    {
    }
};
struct Controller_eventHearNoise_Parms
{
    FLOAT Loudness;
    class AActor* NoiseMaker;
    FName NoiseType;
    Controller_eventHearNoise_Parms(EEventParm)
    {
    }
};
struct Controller_eventStopFiring_Parms
{
    Controller_eventStopFiring_Parms(EEventParm)
    {
    }
};
struct Controller_eventRatePickup_Parms
{
    class AActor* PickupHolder;
    class UClass* inPickup;
    FLOAT ReturnValue;
    Controller_eventRatePickup_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyPostLanded_Parms
{
    Controller_eventNotifyPostLanded_Parms(EEventParm)
    {
    }
};
struct Controller_eventUnPossess_Parms
{
    Controller_eventUnPossess_Parms(EEventParm)
    {
    }
};
struct Controller_eventPossess_Parms
{
    class APawn* inPawn;
    UBOOL bVehicleTransition;
    Controller_eventPossess_Parms(EEventParm)
    {
    }
};
struct Controller_eventNotifyPathChanged_Parms
{
    Controller_eventNotifyPathChanged_Parms(EEventParm)
    {
    }
};
class AController : public AActor, public IInterface_NavigationHandle
{
public:
    //## BEGIN PROPS Controller
    class APawn* Pawn;
    class APlayerReplicationInfo* PlayerReplicationInfo;
    INT PlayerNum;
    class AController* NextController;
    BITFIELD bIsPlayer:1;
    BITFIELD bGodMode:1;
    BITFIELD bSoaking:1;
    BITFIELD bSlowerZAcquire:1;
    BITFIELD bNotifyPostLanded:1;
    BITFIELD bNotifyApex:1;
    BITFIELD bOverrideSearchStart:1;
    BITFIELD bAdvancedTactics:1;
    BITFIELD bCanDoSpecial:1;
    BITFIELD bAdjusting:1;
    BITFIELD bPreparingMove:1;
    BITFIELD bForceStrafe:1;
    BITFIELD bLOSflag:1;
    BITFIELD bSkipExtraLOSChecks:1;
    BITFIELD bNotifyFallingHitWall:1;
    BITFIELD bEarlyOutOfSighTestsForSameType:1;
    BITFIELD bPreciseDestination:1;
    BITFIELD bSeeFriendly:1;
    BITFIELD bUsingPathLanes:1;
    SCRIPT_ALIGN;
    BYTE bFire;
    BYTE bAltFire;
    FLOAT MinHitWall;
    class UClass* NavigationHandleClass;
    class UNavigationHandle* NavigationHandle;
    FVector OverrideSearchStart;
    FLOAT MoveTimer;
    class AActor* MoveTarget;
    struct FBasedPosition DestinationPosition;
    struct FBasedPosition FocalPosition;
    class AActor* Focus;
    class AActor* GoalList[4];
    struct FBasedPosition AdjustPosition;
    class ANavigationPoint* StartSpot;
    TArrayNoInit<class ANavigationPoint*> RouteCache;
    class UReachSpec* CurrentPath;
    class UReachSpec* NextRoutePath;
    FVector CurrentPathDir;
    class AActor* RouteGoal;
    FLOAT RouteDist;
    FLOAT LastRouteFind;
    class AInterpActor* PendingMover;
    class AActor* FailedMoveTarget;
    INT MoveFailureCount;
    FLOAT GroundPitchTime;
    class APawn* ShotTarget;
    class AActor* LastFailedReach;
    FLOAT FailedReachTime;
    FVector FailedReachLocation;
    FLOAT SightCounter;
    FLOAT SightCounterInterval;
    FLOAT InUseNodeCostMultiplier;
    INT HighJumpNodeCostModifier;
    FLOAT MaxMoveTowardPawnTargetTime;
    class APawn* Enemy;
    TArrayNoInit<struct FVisiblePortalInfo> VisiblePortals;
    FLOAT LaneOffset;
    FRotator OldBasedRotation;
    FVector NavMeshPath_SearchExtent_Modifier;
    //## END PROPS Controller

    virtual UBOOL IsLocalPlayerController();
    virtual UBOOL IsLocalController();
    virtual void RouteCache_Empty();
    virtual void RouteCache_AddItem(class ANavigationPoint* Nav);
    virtual void RouteCache_InsertItem(class ANavigationPoint* Nav,INT Idx=0);
    virtual void RouteCache_RemoveItem(class ANavigationPoint* Nav);
    virtual void RouteCache_RemoveIndex(INT InIndex,INT Count=1);
    void SetFocalPoint(FVector FP,UBOOL bOffsetFromBase=FALSE);
    FVector GetFocalPoint();
    void SetDestinationPosition(FVector Dest,UBOOL bOffsetFromBase=FALSE);
    FVector GetDestinationPosition();
    virtual void SetAdjustLocation(FVector NewLoc,UBOOL bAdjust,UBOOL bOffsetFromBase=FALSE);
    FVector GetAdjustLocation();
    UBOOL BeyondFogDistance(FVector ViewPoint,FVector OtherPoint);
    virtual BYTE GetTeamNum();
    UBOOL CanSee(class APawn* Other);
    UBOOL CanSeeByPoints(FVector ViewLocation,FVector TestLocation,FRotator ViewRotation);
    class APawn* PickTarget(class UClass* TargetClass,FLOAT& bestAim,FLOAT& bestDist,FVector FireDir,FVector projStart,FLOAT MaxRange);
    void FinishRotation();
    class AActor* FindPathTo(FVector aPoint,INT MaxPathLength=0,UBOOL bReturnPartial=FALSE);
    class AActor* FindPathToward(class AActor* anActor,UBOOL bWeightDetours=FALSE,INT MaxPathLength=0,UBOOL bReturnPartial=FALSE);
    class AActor* FindPathTowardNearest(class UClass* GoalClass,UBOOL bWeightDetours=FALSE,INT MaxPathLength=0,UBOOL bReturnPartial=FALSE);
    class ANavigationPoint* FindRandomDest();
    class AActor* FindPathToIntercept(class APawn* P,class AActor* InRouteGoal,UBOOL bWeightDetours=FALSE,INT MaxPathLength=0,UBOOL bReturnPartial=FALSE);
    UBOOL PointReachable(FVector aPoint);
    UBOOL ActorReachable(class AActor* anActor);
    UBOOL PickWallAdjust(FVector HitNormal);
    virtual void EndClimbLadder();
    UBOOL InLatentExecution(INT LatentActionNumber);
    void StopLatentExecution();
    DECLARE_FUNCTION(execIsLocalPlayerController)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsLocalPlayerController();
    }
    DECLARE_FUNCTION(execIsLocalController)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsLocalController();
    }
    DECLARE_FUNCTION(execRouteCache_Empty)
    {
        P_FINISH;
        this->RouteCache_Empty();
    }
    DECLARE_FUNCTION(execRouteCache_AddItem)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_FINISH;
        this->RouteCache_AddItem(Nav);
    }
    DECLARE_FUNCTION(execRouteCache_InsertItem)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_GET_INT_OPTX(Idx,0);
        P_FINISH;
        this->RouteCache_InsertItem(Nav,Idx);
    }
    DECLARE_FUNCTION(execRouteCache_RemoveItem)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_FINISH;
        this->RouteCache_RemoveItem(Nav);
    }
    DECLARE_FUNCTION(execRouteCache_RemoveIndex)
    {
        P_GET_INT(InIndex);
        P_GET_INT_OPTX(Count,1);
        P_FINISH;
        this->RouteCache_RemoveIndex(InIndex,Count);
    }
    DECLARE_FUNCTION(execSetFocalPoint)
    {
        P_GET_STRUCT(FVector,FP);
        P_GET_UBOOL_OPTX(bOffsetFromBase,FALSE);
        P_FINISH;
        this->SetFocalPoint(FP,bOffsetFromBase);
    }
    DECLARE_FUNCTION(execGetFocalPoint)
    {
        P_FINISH;
        *(FVector*)Result=this->GetFocalPoint();
    }
    DECLARE_FUNCTION(execSetDestinationPosition)
    {
        P_GET_STRUCT(FVector,Dest);
        P_GET_UBOOL_OPTX(bOffsetFromBase,FALSE);
        P_FINISH;
        this->SetDestinationPosition(Dest,bOffsetFromBase);
    }
    DECLARE_FUNCTION(execGetDestinationPosition)
    {
        P_FINISH;
        *(FVector*)Result=this->GetDestinationPosition();
    }
    DECLARE_FUNCTION(execSetAdjustLocation)
    {
        P_GET_STRUCT(FVector,NewLoc);
        P_GET_UBOOL(bAdjust);
        P_GET_UBOOL_OPTX(bOffsetFromBase,FALSE);
        P_FINISH;
        this->SetAdjustLocation(NewLoc,bAdjust,bOffsetFromBase);
    }
    DECLARE_FUNCTION(execGetAdjustLocation)
    {
        P_FINISH;
        *(FVector*)Result=this->GetAdjustLocation();
    }
    DECLARE_FUNCTION(execBeyondFogDistance)
    {
        P_GET_STRUCT(FVector,ViewPoint);
        P_GET_STRUCT(FVector,OtherPoint);
        P_FINISH;
        *(UBOOL*)Result=this->BeyondFogDistance(ViewPoint,OtherPoint);
    }
    DECLARE_FUNCTION(execLineOfSightTo);
    DECLARE_FUNCTION(execCanSee)
    {
        P_GET_OBJECT(APawn,Other);
        P_FINISH;
        *(UBOOL*)Result=this->CanSee(Other);
    }
    DECLARE_FUNCTION(execCanSeeByPoints)
    {
        P_GET_STRUCT(FVector,ViewLocation);
        P_GET_STRUCT(FVector,TestLocation);
        P_GET_STRUCT(FRotator,ViewRotation);
        P_FINISH;
        *(UBOOL*)Result=this->CanSeeByPoints(ViewLocation,TestLocation,ViewRotation);
    }
    DECLARE_FUNCTION(execPickTarget)
    {
        P_GET_OBJECT(UClass,TargetClass);
        P_GET_FLOAT_REF(bestAim);
        P_GET_FLOAT_REF(bestDist);
        P_GET_STRUCT(FVector,FireDir);
        P_GET_STRUCT(FVector,projStart);
        P_GET_FLOAT(MaxRange);
        P_FINISH;
        *(class APawn**)Result=this->PickTarget(TargetClass,bestAim,bestDist,FireDir,projStart,MaxRange);
    }
    DECLARE_FUNCTION(execMoveTo);
    DECLARE_FUNCTION(execMoveToDirectNonPathPos);
    DECLARE_FUNCTION(execMoveToward);
    DECLARE_FUNCTION(execFinishRotation)
    {
        P_FINISH;
        this->FinishRotation();
    }
    DECLARE_FUNCTION(execFindPathTo)
    {
        P_GET_STRUCT(FVector,aPoint);
        P_GET_INT_OPTX(MaxPathLength,0);
        P_GET_UBOOL_OPTX(bReturnPartial,FALSE);
        P_FINISH;
        *(class AActor**)Result=this->FindPathTo(aPoint,MaxPathLength,bReturnPartial);
    }
    DECLARE_FUNCTION(execFindPathToward)
    {
        P_GET_OBJECT(AActor,anActor);
        P_GET_UBOOL_OPTX(bWeightDetours,FALSE);
        P_GET_INT_OPTX(MaxPathLength,0);
        P_GET_UBOOL_OPTX(bReturnPartial,FALSE);
        P_FINISH;
        *(class AActor**)Result=this->FindPathToward(anActor,bWeightDetours,MaxPathLength,bReturnPartial);
    }
    DECLARE_FUNCTION(execFindPathTowardNearest)
    {
        P_GET_OBJECT(UClass,GoalClass);
        P_GET_UBOOL_OPTX(bWeightDetours,FALSE);
        P_GET_INT_OPTX(MaxPathLength,0);
        P_GET_UBOOL_OPTX(bReturnPartial,FALSE);
        P_FINISH;
        *(class AActor**)Result=this->FindPathTowardNearest(GoalClass,bWeightDetours,MaxPathLength,bReturnPartial);
    }
    DECLARE_FUNCTION(execFindRandomDest)
    {
        P_FINISH;
        *(class ANavigationPoint**)Result=this->FindRandomDest();
    }
    DECLARE_FUNCTION(execFindPathToIntercept)
    {
        P_GET_OBJECT(APawn,P);
        P_GET_OBJECT(AActor,InRouteGoal);
        P_GET_UBOOL_OPTX(bWeightDetours,FALSE);
        P_GET_INT_OPTX(MaxPathLength,0);
        P_GET_UBOOL_OPTX(bReturnPartial,FALSE);
        P_FINISH;
        *(class AActor**)Result=this->FindPathToIntercept(P,InRouteGoal,bWeightDetours,MaxPathLength,bReturnPartial);
    }
    DECLARE_FUNCTION(execPointReachable)
    {
        P_GET_STRUCT(FVector,aPoint);
        P_FINISH;
        *(UBOOL*)Result=this->PointReachable(aPoint);
    }
    DECLARE_FUNCTION(execActorReachable)
    {
        P_GET_OBJECT(AActor,anActor);
        P_FINISH;
        *(UBOOL*)Result=this->ActorReachable(anActor);
    }
    DECLARE_FUNCTION(execPickWallAdjust)
    {
        P_GET_STRUCT(FVector,HitNormal);
        P_FINISH;
        *(UBOOL*)Result=this->PickWallAdjust(HitNormal);
    }
    DECLARE_FUNCTION(execWaitForLanding);
    DECLARE_FUNCTION(execEndClimbLadder)
    {
        P_FINISH;
        this->EndClimbLadder();
    }
    DECLARE_FUNCTION(execInLatentExecution)
    {
        P_GET_INT(LatentActionNumber);
        P_FINISH;
        *(UBOOL*)Result=this->InLatentExecution(LatentActionNumber);
    }
    DECLARE_FUNCTION(execStopLatentExecution)
    {
        P_FINISH;
        this->StopLatentExecution();
    }
    UBOOL eventGeneratePathToLocation(FVector Goal,FLOAT WithinDistance=0,UBOOL bAllowPartialPath=FALSE)
    {
        Controller_eventGeneratePathToLocation_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Goal=Goal;
        Parms.WithinDistance=WithinDistance;
        Parms.bAllowPartialPath=bAllowPartialPath ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_GeneratePathToLocation),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventGeneratePathToActor(class AActor* Goal,FLOAT WithinDistance=0,UBOOL bAllowPartialPath=FALSE)
    {
        Controller_eventGeneratePathToActor_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Goal=Goal;
        Parms.WithinDistance=WithinDistance;
        Parms.bAllowPartialPath=bAllowPartialPath ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_GeneratePathToActor),&Parms);
        return Parms.ReturnValue;
    }
    void eventCurrentLevelUnloaded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_CurrentLevelUnloaded),NULL);
    }
    UBOOL eventIsInCombat(UBOOL bForceCheck=FALSE)
    {
        Controller_eventIsInCombat_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.bForceCheck=bForceCheck ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsInCombat),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsSpectating()
    {
        Controller_eventIsSpectating_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsSpectating),&Parms);
        return Parms.ReturnValue;
    }
    void eventNotifyCoverAdjusted()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyCoverAdjusted),NULL);
    }
    void eventReachedPreciseDestination()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ReachedPreciseDestination),NULL);
    }
    void eventNotifyMissedJump()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyMissedJump),NULL);
    }
    void eventNotifyJumpApex()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyJumpApex),NULL);
    }
    UBOOL eventNotifyBump(class AActor* Other,FVector HitNormal)
    {
        Controller_eventNotifyBump_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        if(IsProbing(NAME_NotifyBump)) {
        Parms.Other=Other;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyBump),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventNotifyFallingHitWall(FVector HitNormal,class AActor* Wall)
    {
        Controller_eventNotifyFallingHitWall_Parms Parms(EC_EventParm);
        Parms.HitNormal=HitNormal;
        Parms.Wall=Wall;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyFallingHitWall),&Parms);
    }
    UBOOL eventNotifyHitWall(FVector HitNormal,class AActor* Wall)
    {
        Controller_eventNotifyHitWall_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        if(IsProbing(NAME_NotifyHitWall)) {
        Parms.HitNormal=HitNormal;
        Parms.Wall=Wall;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyHitWall),&Parms);
        }
        return Parms.ReturnValue;
    }
    UBOOL eventNotifyLanded(FVector HitNormal,class AActor* FloorActor)
    {
        Controller_eventNotifyLanded_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        if(IsProbing(NAME_NotifyLanded)) {
        Parms.HitNormal=HitNormal;
        Parms.FloorActor=FloorActor;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyLanded),&Parms);
        }
        return Parms.ReturnValue;
    }
    UBOOL eventNotifyHeadVolumeChange(class APhysicsVolume* NewVolume)
    {
        Controller_eventNotifyHeadVolumeChange_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyHeadVolumeChange),&Parms);
        return Parms.ReturnValue;
    }
    void eventNotifyPhysicsVolumeChange(class APhysicsVolume* NewVolume)
    {
        Controller_eventNotifyPhysicsVolumeChange_Parms Parms(EC_EventParm);
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPhysicsVolumeChange),&Parms);
    }
    void eventGetPlayerViewPoint(FVector& out_Location,FRotator& out_Rotation)
    {
        Controller_eventGetPlayerViewPoint_Parms Parms(EC_EventParm);
        Parms.out_Location=out_Location;
        Parms.out_Rotation=out_Rotation;
        ProcessEvent(FindFunctionChecked(ENGINE_GetPlayerViewPoint),&Parms);
        out_Location=Parms.out_Location;
        out_Rotation=Parms.out_Rotation;
    }
    UBOOL eventHandlePathObstruction(class AActor* BlockedBy)
    {
        Controller_eventHandlePathObstruction_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.BlockedBy=BlockedBy;
        ProcessEvent(FindFunctionChecked(ENGINE_HandlePathObstruction),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventMoverFinished()
    {
        Controller_eventMoverFinished_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_MoverFinished),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventAllowDetourTo(class ANavigationPoint* N)
    {
        Controller_eventAllowDetourTo_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.N=N;
        ProcessEvent(FindFunctionChecked(ENGINE_AllowDetourTo),&Parms);
        return Parms.ReturnValue;
    }
    void eventMayFall(UBOOL bFloor,FVector FloorNormal)
    {
        Controller_eventMayFall_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_MayFall)) {
        Parms.bFloor=bFloor ? FIRST_BITFIELD : FALSE;
        Parms.FloorNormal=FloorNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_MayFall),&Parms);
        }
    }
    void eventLongFall()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_LongFall),NULL);
    }
    void eventMoveUnreachable(FVector AttemptedDest,class AActor* AttemptedTarget)
    {
        Controller_eventMoveUnreachable_Parms Parms(EC_EventParm);
        Parms.AttemptedDest=AttemptedDest;
        Parms.AttemptedTarget=AttemptedTarget;
        ProcessEvent(FindFunctionChecked(ENGINE_MoveUnreachable),&Parms);
    }
    void eventSetupSpecialPathAbilities()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SetupSpecialPathAbilities),NULL);
    }
    void eventEnemyNotVisible()
    {
        if(IsProbing(NAME_EnemyNotVisible)) {
        ProcessEvent(FindFunctionChecked(ENGINE_EnemyNotVisible),NULL);
        }
    }
    void eventSeeMonster(class APawn* Seen)
    {
        Controller_eventSeeMonster_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_SeeMonster)) {
        Parms.Seen=Seen;
        ProcessEvent(FindFunctionChecked(ENGINE_SeeMonster),&Parms);
        }
    }
    void eventSeePlayer(class APawn* Seen)
    {
        Controller_eventSeePlayer_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_SeePlayer)) {
        Parms.Seen=Seen;
        ProcessEvent(FindFunctionChecked(ENGINE_SeePlayer),&Parms);
        }
    }
    void eventHearNoise(FLOAT Loudness,class AActor* NoiseMaker,FName NoiseType=NAME_None)
    {
        Controller_eventHearNoise_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_HearNoise)) {
        Parms.Loudness=Loudness;
        Parms.NoiseMaker=NoiseMaker;
        Parms.NoiseType=NoiseType;
        ProcessEvent(FindFunctionChecked(ENGINE_HearNoise),&Parms);
        }
    }
    void eventStopFiring()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StopFiring),NULL);
    }
    FLOAT eventRatePickup(class AActor* PickupHolder,class UClass* inPickup)
    {
        Controller_eventRatePickup_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.PickupHolder=PickupHolder;
        Parms.inPickup=inPickup;
        ProcessEvent(FindFunctionChecked(ENGINE_RatePickup),&Parms);
        return Parms.ReturnValue;
    }
    void eventNotifyPostLanded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPostLanded),NULL);
    }
    void eventUnPossess()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_UnPossess),NULL);
    }
    void eventPossess(class APawn* inPawn,UBOOL bVehicleTransition)
    {
        Controller_eventPossess_Parms Parms(EC_EventParm);
        Parms.inPawn=inPawn;
        Parms.bVehicleTransition=bVehicleTransition ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_Possess),&Parms);
    }
    void eventNotifyPathChanged()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPathChanged),NULL);
    }
    DECLARE_ABSTRACT_CLASS(AController,AActor,0|CLASS_NativeReplication,Engine)
    virtual UObject* GetUObjectInterfaceInterface_NavigationHandle(){return this;}
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	virtual void Spawned();
	virtual void BeginDestroy();

	virtual UBOOL IsPlayerOwned()
	{
		return IsPlayerOwner();
	}

	virtual UBOOL IsPlayerOwner()
	{
		return bIsPlayer;
	}
	virtual AController* GetAController() { return this; }

	// Seeing and hearing checks
	virtual UBOOL CanHear(const FVector& NoiseLoc, FLOAT Loudness, AActor *Other);
	virtual void ShowSelf();
	virtual UBOOL ShouldCheckVisibilityOf(AController* C);
	virtual DWORD SeePawn(APawn *Other, UBOOL bMaySkipChecks = TRUE);
	virtual DWORD LineOfSightTo(const AActor* Other, INT bUseLOSFlag=0, const FVector* chkLocation = NULL, UBOOL bTryAlternateTargetLoc = FALSE);
	void CheckEnemyVisible();
	virtual void HearNoise(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType);

	AActor* HandleSpecial(AActor *bestPath);
	virtual INT AcceptNearbyPath(AActor* goal);
	virtual UReachSpec* PrepareForMove( ANavigationPoint *NavGoal, UReachSpec* Path );
	UReachSpec* GetNextRoutePath( ANavigationPoint *NavGoal );
	virtual void AdjustFromWall(FVector HitNormal, AActor* HitActor);
	void SetRouteCache( ANavigationPoint *EndPath, FLOAT StartDist, FLOAT EndDist );
	AActor* FindPath(const FVector& Point, AActor* Goal, UBOOL bWeightDetours, INT MaxPathLength, UBOOL bReturnPartial);
	/** given the passed in goal for pathfinding, set bTransientEndPoint on all NavigationPoints that are acceptable
	 * destinations on the path network
	 * @param EndAnchor the Anchor for the goal on the navigation network
	 * @param Goal the goal actor we're pathfinding toward (may be NULL)
	 * @param GoalLocation the goal world location we're pathfinding toward
	 */
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
	/** gives the Controller a chance to pre-empt pathfinding with its own result (if a cached path is still valid, for example)
	 * called just before navigation network traversal, after Anchor determination and NavigationPoint transient properties are set up
	 * only called when using the 'FindEndPoint' node evaluator
	 * @param EndAnchor - Anchor for Goal on the path network
	 * @param Goal - Destination Actor we're trying to path to (may be NULL)
	 * @param GoalLocation - the goal world location we're pathfinding toward
	 * @param bWeightDetours - whether we should consider short detours for pickups and such
	 * @param BestWeight - weighting value for best node on path - if this function returns true, findPathToward() will return this value
	 * @return whether the normal pathfinding should be skipped
	 */
	virtual UBOOL OverridePathTo(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation, UBOOL bWeightDetours, FLOAT& BestWeight)
	{
		return FALSE;
	}
	AActor* SetPath(INT bInitialPath=1);
	virtual UBOOL WantsLedgeCheck();
	virtual UBOOL StopAtLedge();
	virtual void PrePollMove()
	{}
	virtual void PostPollMove()
	{}
	virtual void PollMoveComplete();
	virtual AActor* GetViewTarget();
	virtual void UpdateEnemyInfo(APawn* AcquiredEnemy) {};
	virtual void JumpOverWall(FVector WallNormal);
	virtual void UpdatePawnRotation();
	virtual UBOOL ForceReached(ANavigationPoint *Nav, const FVector& TestPosition);
	virtual FRotator SetRotationRate(FLOAT deltaTime);
	virtual FVector DesiredDirection();
	/** activates path lanes for this Controller's current movement and adjusts its destination accordingly
	 * @param DesiredLaneOffset the offset from the center of the Controller's CurrentPath that is desired
	 * 				the Controller sets its LaneOffset as close as it can get to it without
	 *				allowing any part of the Pawn's cylinder outside of the CurrentPath
	 */
	void SetPathLane(FLOAT InPathOffset);
	virtual void FailMove();

	// falling physics AI hooks
	virtual void PreAirSteering(FLOAT DeltaTime) {};
	virtual void PostAirSteering(FLOAT DeltaTime) {};
	virtual void PostPhysFalling(FLOAT DeltaTime) {};
	virtual void PostPhysWalking(FLOAT DeltaTime) {};
	virtual void PostPhysSpider(FLOAT DeltaTime) {};
	virtual UBOOL AirControlFromWall(float DeltaTime, FVector& RealAcceleration) { return FALSE; };
	virtual void NotifyJumpApex();

	virtual void PostBeginPlay();
	virtual void PostScriptDestroyed();

	virtual void ClearCrossLevelPaths(ULevel *Level);

	// Natives.
	DECLARE_FUNCTION(execPollWaitForLanding);
	virtual DECLARE_FUNCTION(execPollMoveTo);
	virtual DECLARE_FUNCTION(execPollMoveToward);
	DECLARE_FUNCTION(execPollFinishRotation);

	virtual UBOOL ShouldOffsetCorners() { return TRUE; }
	virtual UBOOL ShouldUsePathLanes() { return TRUE; }
	virtual UBOOL ShouldIgnoreNavigationBlockingFor(const AActor* Other){ return !Other->bBlocksNavigation; }

	// AnimControl Matinee Track support

	/** Used to provide information on the slots that this Actor provides for animation to Matinee. */
	virtual void GetAnimControlSlotDesc(TArray<struct FAnimSlotDesc>& OutSlotDescs);

	/**
	 *	Called by Matinee when we open it to start controlling animation on this Actor.
	 *	Is also called again when the GroupAnimSets array changes in Matinee, so must support multiple calls.
	 */
	virtual void PreviewBeginAnimControl(class UInterpGroup* InInterpGroup);

	/** Called each frame by Matinee to update the desired sequence by name and position within it. */
	virtual void PreviewSetAnimPosition(FName SlotName, INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bLooping, UBOOL bFireNotifies, UBOOL bEnableRootMotion, FLOAT DeltaTime);

	/** Called each frame by Matinee to update the desired animation channel weights for this Actor. */
	virtual void PreviewSetAnimWeights(TArray<FAnimSlotInfo>& SlotInfos);

	/** Called by Matinee when we close it after we have been controlling animation on this Actor. */
	virtual void PreviewFinishAnimControl(class UInterpGroup* InInterpGroup);

	/** Function used to control FaceFX animation in the editor (Matinee). */
	virtual void PreviewUpdateFaceFX(UBOOL bForceAnim, const FString& GroupName, const FString& SeqName, FLOAT InPosition);

	/** Used by Matinee playback to start a FaceFX animation playing. */
	virtual void PreviewActorPlayFaceFX(const FString& GroupName, const FString& SeqName, USoundCue* InSoundCue);

	/** Used by Matinee to stop current FaceFX animation playing. */
	virtual void PreviewActorStopFaceFX();

	/** Used in Matinee to get the AudioComponent we should play facial animation audio on. */
	virtual UAudioComponent* PreviewGetFaceFXAudioComponent();

	/** Get the UFaceFXAsset that is currently being used by this Actor when playing facial animations. */
	virtual class UFaceFXAsset* PreviewGetActorFaceFXAsset();

	/** Called each frame by Matinee to update the weight of a particular MorphNodeWeight. */
	virtual void PreviewSetMorphWeight(FName MorphNodeName, FLOAT MorphWeight);

	/** Called each frame by Matinee to update the scaling on a SkelControl. */
	virtual void PreviewSetSkelControlScale(FName SkelControlName, FLOAT Scale);

	/** Called each frame by Matinee to update the controlstrength on a SkelControl. */
	virtual void SetSkelControlStrength(FName SkelControlName, FLOAT ControlStrength);

	/** Called each from while the Matinee action is running, to set the animation weights for the actor. */
	virtual void SetAnimWeights( const TArray<struct FAnimSlotInfo>& SlotInfos );

	/** base function called to kick off moveto latent action (called from execMoveTo and execMoveToDirectNonPathPos) */
	virtual void MoveTo(const FVector& Dest, AActor* ViewFocus, FLOAT DesiredOffset, UBOOL bShouldWalk);

	/** base function called to kick off movetoward latent action (called from execMoveToward) */
	virtual void MoveToward(AActor* goal, AActor* viewfocus, FLOAT DesiredOffset, UBOOL bStrafe, UBOOL bShouldWalk);


	/** IMPLEMENT Interface_NavigationHandle */
	virtual UBOOL	CanCoverSlip(ACoverLink* Link, INT SlotIdx);
	virtual void SetupPathfindingParams( FNavMeshPathParams& out_ParamCache );
	virtual void InitForPathfinding() {}
	virtual INT ExtraEdgeCostToAddWhenActive(FNavMeshEdgeBase* Edge) { return 0; }
	virtual FVector GetEdgeZAdjust(FNavMeshEdgeBase* Edge);
	/** END */

	virtual FLOAT GetMaxDropHeight();
};

#define UCONST_MAXCLIENTUPDATEINTERVAL 0.25
#define UCONST_CLIENTADJUSTUPDATECOST 180.0
#define UCONST_MAXVEHICLEPOSITIONERRORSQUARED 900.0
#define UCONST_MAXNEARZEROVELOCITYSQUARED 9.0
#define UCONST_MAXPOSITIONERRORSQUARED 3.0

struct FClientAdjustment
{
    FLOAT TimeStamp;
    BYTE newPhysics;
    SCRIPT_ALIGN;
    FVector NewLoc;
    FVector NewVel;
    class AActor* NewBase;
    FVector NewFloor;
    BYTE bAckGoodMove;
    SCRIPT_ALIGN;

    /** Constructors */
    FClientAdjustment() {}
    FClientAdjustment(EEventParm)
    {
        appMemzero(this, sizeof(FClientAdjustment));
    }
};

struct FConnectedPeerInfo
{
    struct FUniqueNetId PlayerID;
    BYTE NatType;
    SCRIPT_ALIGN;
    BITFIELD bLostConnectionToHost:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FConnectedPeerInfo() {}
    FConnectedPeerInfo(EEventParm)
    {
        appMemzero(this, sizeof(FConnectedPeerInfo));
    }
};

struct FInputEntry
{
    BYTE Type;
    FLOAT Value;
    FLOAT TimeDelta;
    BYTE Action;
    SCRIPT_ALIGN;

    /** Constructors */
    FInputEntry() {}
    FInputEntry(EEventParm)
    {
        appMemzero(this, sizeof(FInputEntry));
    }
};

struct FInputMatchRequest
{
    TArrayNoInit<struct FInputEntry> Inputs;
    class AActor* MatchActor;
    FName MatchFuncName;
    FScriptDelegate MatchDelegate;
    FName FailedFuncName;
    FName RequestName;
    INT MatchIdx;
    FLOAT LastMatchTime;

    /** Constructors */
    FInputMatchRequest() {}
    FInputMatchRequest(EEventParm)
    {
        appMemzero(this, sizeof(FInputMatchRequest));
    }
};

struct FDebugTextInfo
{
    class AActor* SrcActor;
    FVector SrcActorOffset;
    FVector SrcActorDesiredOffset;
    FStringNoInit DebugText;
    FLOAT TimeRemaining;
    FLOAT Duration;
    FColor TextColor;
    BITFIELD bAbsoluteLocation:1;
    BITFIELD bKeepAttachedToActor:1;
    SCRIPT_ALIGN;
    FVector OrigActorLocation;
    class UFont* Font;

    /** Constructors */
    FDebugTextInfo() {}
    FDebugTextInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDebugTextInfo));
    }
};

struct PlayerController_eventSetMatineeConstantCameraAnim_Parms
{
    UBOOL bOn;
    BYTE Type;
    FLOAT Rate;
    PlayerController_eventSetMatineeConstantCameraAnim_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventNotifyDisconnect_Parms
{
    FString Command;
    UBOOL ReturnValue;
    PlayerController_eventNotifyDisconnect_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventOnEngineInitialTick_Parms
{
    PlayerController_eventOnEngineInitialTick_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventBugItStringCreator_Parms
{
    FVector ViewLocation;
    FRotator ViewRotation;
    FString GoString;
    FString LocString;
    PlayerController_eventBugItStringCreator_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventBugItAI_Parms
{
    FString ScreenShotDescription;
    PlayerController_eventBugItAI_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventBugIt_Parms
{
    FString ScreenShotDescription;
    PlayerController_eventBugIt_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSpawnCameraLensEffect_Parms
{
    class UClass* LensEffectEmitterClass;
    PlayerController_eventClientSpawnCameraLensEffect_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientStopCameraAnim_Parms
{
    class UCameraAnim* AnimToStop;
    UBOOL bImmediate;
    PlayerController_eventClientStopCameraAnim_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientPlayCameraAnim_Parms
{
    class UCameraAnim* AnimToPlay;
    FLOAT Scale;
    FLOAT Rate;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    UBOOL bLoop;
    UBOOL bRandomStartTime;
    BYTE Space;
    FRotator CustomPlaySpace;
    PlayerController_eventClientPlayCameraAnim_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventInputMatchDelegate_Parms
{
    PlayerController_eventInputMatchDelegate_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventGetAchievementProgression_Parms
{
    INT AchievementId;
    FLOAT CurrentValue;
    FLOAT MaxValue;
    UBOOL ReturnValue;
    PlayerController_eventGetAchievementProgression_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientAddTextureStreamingLoc_Parms
{
    FVector InLoc;
    FLOAT Duration;
    UBOOL bOverrideLocation;
    PlayerController_eventClientAddTextureStreamingLoc_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientPrestreamTextures_Parms
{
    class AActor* ForcedActor;
    FLOAT ForceDuration;
    UBOOL bEnableStreaming;
    INT CinematicTextureGroups;
    PlayerController_eventClientPrestreamTextures_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSetForceMipLevelsToBeResident_Parms
{
    class UMaterialInterface* Material;
    FLOAT ForceDuration;
    INT CinematicTextureGroups;
    PlayerController_eventClientSetForceMipLevelsToBeResident_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventSoakPause_Parms
{
    class APawn* P;
    PlayerController_eventSoakPause_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventRemoveAllDebugStrings_Parms
{
    PlayerController_eventRemoveAllDebugStrings_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventRemoveDebugText_Parms
{
    class AActor* SrcActor;
    PlayerController_eventRemoveDebugText_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventAddDebugText_Parms
{
    FString DebugText;
    class AActor* SrcActor;
    FLOAT Duration;
    FVector Offset;
    FVector DesiredOffset;
    FColor TextColor;
    UBOOL bSkipOverwriteCheck;
    UBOOL bAbsoluteLocation;
    UBOOL bKeepAttachedToActor;
    class UFont* InFont;
    PlayerController_eventAddDebugText_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientWasKicked_Parms
{
    PlayerController_eventClientWasKicked_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventNotifyDirectorControl_Parms
{
    UBOOL bNowControlling;
    class USeqAct_Interp* CurrentMatinee;
    PlayerController_eventNotifyDirectorControl_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerUnmutePlayer_Parms
{
    struct FUniqueNetId PlayerNetId;
    PlayerController_eventServerUnmutePlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerMutePlayer_Parms
{
    struct FUniqueNetId PlayerNetId;
    PlayerController_eventServerMutePlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientUnmutePlayer_Parms
{
    struct FUniqueNetId PlayerNetId;
    PlayerController_eventClientUnmutePlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientMutePlayer_Parms
{
    struct FUniqueNetId PlayerNetId;
    PlayerController_eventClientMutePlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventGetSeamlessTravelActorList_Parms
{
    UBOOL bToEntry;
    TArray<class AActor*> ActorList;
    PlayerController_eventGetSeamlessTravelActorList_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSetBlockOnAsyncLoading_Parms
{
    PlayerController_eventClientSetBlockOnAsyncLoading_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientFlushLevelStreaming_Parms
{
    PlayerController_eventClientFlushLevelStreaming_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientCancelPendingMapChange_Parms
{
    PlayerController_eventClientCancelPendingMapChange_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientCommitMapChange_Parms
{
    PlayerController_eventClientCommitMapChange_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientPrepareMapChange_Parms
{
    FName LevelName;
    UBOOL bFirst;
    UBOOL bLast;
    PlayerController_eventClientPrepareMapChange_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerUpdateLevelVisibility_Parms
{
    FName PackageName;
    UBOOL bIsVisible;
    PlayerController_eventServerUpdateLevelVisibility_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventLevelStreamingStatusChanged_Parms
{
    class ULevelStreaming* LevelObject;
    UBOOL bNewShouldBeLoaded;
    UBOOL bNewShouldBeVisible;
    UBOOL bNewShouldBlockOnLoad;
    PlayerController_eventLevelStreamingStatusChanged_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientForceGarbageCollection_Parms
{
    PlayerController_eventClientForceGarbageCollection_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventIsLookInputIgnored_Parms
{
    UBOOL ReturnValue;
    PlayerController_eventIsLookInputIgnored_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventIsMoveInputIgnored_Parms
{
    UBOOL ReturnValue;
    PlayerController_eventIsMoveInputIgnored_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientStopForceFeedbackWaveform_Parms
{
    class UForceFeedbackWaveform* FFWaveform;
    PlayerController_eventClientStopForceFeedbackWaveform_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientPlayForceFeedbackWaveform_Parms
{
    class UForceFeedbackWaveform* FFWaveform;
    class AActor* FFWaveformInstigator;
    PlayerController_eventClientPlayForceFeedbackWaveform_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventPlayRumble_Parms
{
    const class UAnimNotify_Rumble* TheAnimNotify;
    PlayerController_eventPlayRumble_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventAdjustHUDRenderSize_Parms
{
    INT X;
    INT Y;
    INT SizeX;
    INT SizeY;
    INT FullScreenSizeX;
    INT FullScreenSizeY;
    PlayerController_eventAdjustHUDRenderSize_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventLimitViewRotation_Parms
{
    FRotator ViewRotation;
    FLOAT ViewPitchMin;
    FLOAT ViewPitchMax;
    FRotator ReturnValue;
    PlayerController_eventLimitViewRotation_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventSpawnPlayerCamera_Parms
{
    PlayerController_eventSpawnPlayerCamera_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSetViewTarget_Parms
{
    class AActor* A;
    struct FViewTargetTransitionParams TransitionParams;
    PlayerController_eventClientSetViewTarget_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventGetFOVAngle_Parms
{
    FLOAT ReturnValue;
    PlayerController_eventGetFOVAngle_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventCameraLookAtFinished_Parms
{
    class USeqAct_CameraLookAt* Action;
    PlayerController_eventCameraLookAtFinished_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventPlayerTick_Parms
{
    FLOAT DeltaTime;
    PlayerController_eventPlayerTick_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventNotifyLoadedWorld_Parms
{
    FName WorldPackageName;
    UBOOL bFinalDest;
    PlayerController_eventNotifyLoadedWorld_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerNotifyLoadedWorld_Parms
{
    FName WorldPackageName;
    PlayerController_eventServerNotifyLoadedWorld_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSetProgressMessage_Parms
{
    BYTE MessageType;
    FString Message;
    FString Title;
    UBOOL bIgnoreFutureNetworkMessages;
    PlayerController_eventClientSetProgressMessage_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventConditionalPause_Parms
{
    UBOOL bDesiredPauseState;
    PlayerController_eventConditionalPause_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventCanUnpause_Parms
{
    UBOOL ReturnValue;
    PlayerController_eventCanUnpause_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventSendClientAdjustment_Parms
{
    PlayerController_eventSendClientAdjustment_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientSetCameraFade_Parms
{
    UBOOL bEnableFading;
    FColor FadeColor;
    FVector2D FadeAlpha;
    FLOAT FadeTime;
    UBOOL bFadeAudio;
    PlayerController_eventClientSetCameraFade_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventResetCameraMode_Parms
{
    PlayerController_eventResetCameraMode_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventPreClientTravel_Parms
{
    FString PendingURL;
    BYTE TravelType;
    UBOOL bIsSeamlessTravel;
    PlayerController_eventPreClientTravel_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClearOnlineDelegates_Parms
{
    PlayerController_eventClearOnlineDelegates_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventTeamMessage_Parms
{
    class APlayerReplicationInfo* PRI;
    FString S;
    FName Type;
    FLOAT MsgLifeTime;
    PlayerController_eventTeamMessage_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientMessage_Parms
{
    FString S;
    FName Type;
    FLOAT MsgLifeTime;
    PlayerController_eventClientMessage_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventKismet_ClientStopSound_Parms
{
    class USoundCue* ASound;
    class AActor* SourceActor;
    FLOAT FadeOutTime;
    PlayerController_eventKismet_ClientStopSound_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventKismet_ClientPlaySound_Parms
{
    class USoundCue* ASound;
    class AActor* SourceActor;
    FLOAT VolumeMultiplier;
    FLOAT PitchMultiplier;
    FLOAT FadeInTime;
    UBOOL bSuppressSubtitles;
    UBOOL bSuppressSpatialization;
    PlayerController_eventKismet_ClientPlaySound_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientHearSound_Parms
{
    class USoundCue* ASound;
    class AActor* SourceActor;
    FVector SourceLocation;
    UBOOL bStopWhenOwnerDestroyed;
    UBOOL bIsOccluded;
    PlayerController_eventClientHearSound_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientPlaySound_Parms
{
    class USoundCue* ASound;
    PlayerController_eventClientPlaySound_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventReceiveLocalizedMessage_Parms
{
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    PlayerController_eventReceiveLocalizedMessage_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventInitInputSystem_Parms
{
    PlayerController_eventInitInputSystem_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventKickWarning_Parms
{
    PlayerController_eventKickWarning_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventPreRender_Parms
{
    class UCanvas* Canvas;
    PlayerController_eventPreRender_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventPeerReceivedMigratedSession_Parms
{
    struct FUniqueNetId FromPeerNetId;
    FName SessionName;
    class UClass* SearchClass;
    BYTE PlatformSpecificInfo[80];
    PlayerController_eventPeerReceivedMigratedSession_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventOnMissingPeersUnregistered_Parms
{
    FName SessionName;
    struct FUniqueNetId PlayerID;
    UBOOL bWasSuccessful;
    PlayerController_eventOnMissingPeersUnregistered_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventMigrateNewHost_Parms
{
    UBOOL ReturnValue;
    PlayerController_eventMigrateNewHost_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventNotifyPeerDisconnectHost_Parms
{
    struct FUniqueNetId PeerNetId;
    PlayerController_eventNotifyPeerDisconnectHost_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventRemovePeer_Parms
{
    struct FUniqueNetId PeerNetId;
    PlayerController_eventRemovePeer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventAddPeer_Parms
{
    struct FUniqueNetId PeerNetId;
    BYTE NatType;
    PlayerController_eventAddPeer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventReceivedPlayer_Parms
{
    PlayerController_eventReceivedPlayer_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventServerProcessConvolve_Parms
{
    FString C;
    INT H;
    PlayerController_eventServerProcessConvolve_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientConvolve_Parms
{
    FString C;
    INT H;
    PlayerController_eventClientConvolve_Parms(EEventParm)
    {
    }
};
struct PlayerController_eventClientTravel_Parms
{
    FString URL;
    BYTE TravelType;
    UBOOL bSeamless;
    FGuid MapPackageGuid;
    PlayerController_eventClientTravel_Parms(EEventParm)
    {
    }
};
class APlayerController : public AController
{
public:
    //## BEGIN PROPS PlayerController
    class UPlayer* Player;
    class ACamera* PlayerCamera;
    class UClass* CameraClass;
    BITFIELD bFrozen:1;
    BITFIELD bPressedJump:1;
    BITFIELD bDoubleJump:1;
    BITFIELD bUpdatePosition:1;
    BITFIELD bUpdating:1;
    BITFIELD bNeverSwitchOnPickup:1;
    BITFIELD bCheatFlying:1;
    BITFIELD bCameraPositionLocked:1;
    BITFIELD bShortConnectTimeOut:1;
    BITFIELD bPendingDestroy:1;
    BITFIELD bWasSpeedHack:1;
    BITFIELD bWasSaturated:1;
    BITFIELD bAimingHelp:1;
    BITFIELD bCameraCut:1;
    BITFIELD bClientSimulatingViewTarget:1;
    BITFIELD bHasVoiceHandshakeCompleted:1;
    BITFIELD bCinematicMode:1;
    BITFIELD bInteractiveMode:1;
    BITFIELD bCinemaDisableInputMove:1;
    BITFIELD bCinemaDisableInputLook:1;
    BITFIELD bIgnoreNetworkMessages:1;
    BITFIELD bShowKismetDrawText:1;
    BITFIELD bReplicateAllPawns:1;
    BITFIELD bIsUsingStreamingVolumes:1;
    BITFIELD bIsExternalUIOpen:1;
    BITFIELD bIsControllerConnected:1;
    BITFIELD bCheckSoundOcclusion:1;
    BITFIELD bDebugCameraAnims:1;
    BITFIELD bBlockCameraAnimsFromOverridingPostProcess:1;
    BITFIELD bLogHearSoundOverflow:1;
    BITFIELD bCheckRelevancyThroughPortals:1;
    BITFIELD bDebugClientAdjustPosition:1;
    FLOAT MaxResponseTime;
    FLOAT WaitDelay;
    class APawn* AcknowledgedPawn;
    BYTE DoubleClickDir;
    BYTE bIgnoreMoveInput;
    BYTE bIgnoreLookInput;
    BYTE bRun;
    BYTE bDuck;
    BYTE NetPlayerIndex;
    class AActor* ViewTarget;
    class APlayerReplicationInfo* RealViewTarget;
    class UInterpTrackInstDirector* ControllingDirTrackInst;
    FLOAT FOVAngle;
    FLOAT DesiredFOV;
    FLOAT DefaultFOV;
    FLOAT LODDistanceFactor;
    FRotator TargetViewRotation;
    FLOAT TargetEyeHeight;
    FRotator BlendedTargetViewRotation;
    class AHUD* myHUD;
    class AHUD* mySecondaryHUD;
    class UClass* SavedMoveClass;
    class USavedMove* SavedMoves;
    class USavedMove* FreeMoves;
    class USavedMove* PendingMove;
    FVector LastAckedAccel;
    FLOAT CurrentTimeStamp;
    FLOAT LastUpdateTime;
    FLOAT ServerTimeStamp;
    FLOAT TimeMargin;
    FLOAT ClientUpdateTime;
    FLOAT MaxTimeMargin;
    FLOAT LastActiveTime;
    INT ClientCap;
    FLOAT DynamicPingThreshold_DEPRECATED;
    FLOAT LastPingUpdate;
    FLOAT LastSpeedHackLog;
    struct FClientAdjustment PendingAdjustment;
    INT GroundPitch;
    class UCheatManager* CheatManager;
    class UClass* CheatClass;
    class UPlayerInput* PlayerInput;
    class UClass* InputClass;
    FVector FailedPathStart;
    class UCylinderComponent* CylinderComponent;
    FStringNoInit ForceFeedbackManagerClassName;
    class UForceFeedbackManager* ForceFeedbackManager;
    TArrayNoInit<class UInteraction*> Interactions;
    TArrayNoInit<struct FUniqueNetId> VoiceMuteList;
    TArrayNoInit<struct FUniqueNetId> GameplayVoiceMuteList;
    TArrayNoInit<struct FUniqueNetId> VoicePacketFilter;
    TArrayNoInit<struct FConnectedPeerInfo> ConnectedPeers;
    TArrayNoInit<struct FUniqueNetId> BestNextHostPeers;
    class UOnlineGameSearch* MigratedSearchToJoin;
    class UOnlineSubsystem* OnlineSub;
    TScriptInterface<class IInterface> VoiceInterface;
    class UUIDataStore_OnlinePlayerData* OnlinePlayerData;
    FLOAT InteractDistance;
    FName DelayedJoinSessionName;
    TArrayNoInit<struct FInputMatchRequest> InputRequests;
    FLOAT LastBroadcastTime;
    FStringNoInit LastBroadcastString[4];
    TArrayNoInit<FName> PendingMapChangeLevelNames;
    class ACoverReplicator* MyCoverReplicator;
    TArrayNoInit<struct FDebugTextInfo> DebugTextList;
    FLOAT SpectatorCameraSpeed;
    class UNetConnection* PendingSwapConnection;
    FLOAT MinRespawnDelay;
    INT MaxConcurrentHearSounds;
    TArrayNoInit<class UAudioComponent*> HearSoundActiveComponents;
    TArrayNoInit<class UAudioComponent*> HearSoundPoolComponents;
    TArrayNoInit<class AActor*> HiddenActors;
    FLOAT LastSpectatorStateSynchTime;
    FScriptDelegate __OnMissingPeersUnregistered__Delegate;
    FScriptDelegate __CanUnpause__Delegate;
    FScriptDelegate __InputMatchDelegate__Delegate;
    //## END PROPS PlayerController

    void SetNetSpeed(INT NewSpeed);
    FString GetPlayerNetworkAddress();
    FString GetServerNetworkAddress();
    virtual FString ConsoleCommand(const FString& Command,UBOOL bWriteToLog=TRUE);
    virtual void ClientTravel(const FString& URL,BYTE TravelType,UBOOL bSeamless=FALSE,FGuid MapPackageGuid=FGuid(EC_EventParm));
    void UpdateURL(const FString& NewOption,const FString& NewValue,UBOOL bSave1Default);
    FString GetDefaultURL(const FString& Option);
    virtual void CopyToClipboard(const FString& Text);
    virtual FString PasteFromClipboard();
    virtual void SetAllowMatureLanguage(UBOOL bAllowMatureLanguge);
    virtual void SetAudioGroupVolume(FName GroupName,FLOAT Volume);
    void ClientConvolve(const FString& C,INT H);
    void ServerProcessConvolve(const FString& C,INT H);
    UBOOL CheckSpeedHack(FLOAT DeltaTime);
    INT FindStairRotation(FLOAT DeltaTime);
    virtual void CleanUpAudioComponents();
    virtual void PeerTravelAsHost(FLOAT TravelCountdownTimer,const FString& URL);
    virtual void TellPeerToTravel(struct FUniqueNetId ToPeerNetId);
    virtual void TellPeerToTravelToSession(struct FUniqueNetId ToPeerNetId,FName SessionName,class UClass* SearchClass,BYTE* PlatformSpecificInfo,INT PlatformSpecificInfoSize);
    virtual UBOOL IsControllerTiltActive() const;
    virtual void SetControllerTiltActive(UBOOL bActive);
    virtual void SetOnlyUseControllerTiltInput(UBOOL bActive);
    virtual void SetUseTiltForwardAndBack(UBOOL bActive);
    virtual UBOOL IsKeyboardAvailable() const;
    virtual UBOOL IsMouseAvailable() const;
    virtual class UAudioComponent* GetPooledAudioComponent(class USoundCue* ASound,class AActor* SourceActor,UBOOL bStopWhenOwnerDestroyed,UBOOL bUseLocation=FALSE,FVector SourceLocation=FVector(EC_EventParm));
    virtual class USoundCue* CreateTTSSoundCue(const FString& StrToSpeak,class APlayerReplicationInfo* PRI);
    void ServerNotifyLoadedWorld(FName WorldPackageName);
    UBOOL HasClientLoadedCurrentWorld();
    void ForceSingleNetUpdateFor(class AActor* Target);
    virtual UBOOL IsLocalPlayerController();
    virtual UBOOL IsLocalController();
    virtual void SetViewTarget(class AActor* NewViewTarget,struct FViewTargetTransitionParams TransitionParams=FViewTargetTransitionParams(EC_EventParm));
    virtual class AActor* GetViewTarget();
    virtual void ClientUpdateLevelStreamingStatus(FName PackageName,UBOOL bNewShouldBeLoaded,UBOOL bNewShouldBeVisible,UBOOL bNewShouldBlockOnLoad);
    void ServerUpdateLevelVisibility(FName PackageName,UBOOL bIsVisible);
    void ClientFlushLevelStreaming();
    UBOOL IsPlayerMuted(const struct FUniqueNetId& Sender);
    class APlayerController* GetPlayerControllerFromNetId(struct FUniqueNetId PlayerNetId);
    virtual void SetShowSubtitles(UBOOL bValue);
    virtual UBOOL IsShowingSubtitles();
    void ClientAddTextureStreamingLoc(FVector InLoc,FLOAT Duration,UBOOL bOverrideLocation);
    virtual UBOOL HasPeerConnection(const struct FUniqueNetId& PeerNetId) const;
    virtual void LogOutBugItGoToLogFile(const FString& InScreenShotDesc,const FString& InGoString,const FString& InLocString);
    virtual void LogOutBugItAIGoToLogFile(const FString& InScreenShotDesc,const FString& InGoString,const FString& InLocString);
    DECLARE_FUNCTION(execSetNetSpeed)
    {
        P_GET_INT(NewSpeed);
        P_FINISH;
        this->SetNetSpeed(NewSpeed);
    }
    DECLARE_FUNCTION(execGetPlayerNetworkAddress)
    {
        P_FINISH;
        *(FString*)Result=this->GetPlayerNetworkAddress();
    }
    DECLARE_FUNCTION(execGetServerNetworkAddress)
    {
        P_FINISH;
        *(FString*)Result=this->GetServerNetworkAddress();
    }
    DECLARE_FUNCTION(execClientTravel)
    {
        P_GET_STR(URL);
        P_GET_BYTE(TravelType);
        P_GET_UBOOL_OPTX(bSeamless,FALSE);
        P_GET_STRUCT_OPTX(FGuid,MapPackageGuid,FGuid(EC_EventParm));
        P_FINISH;
        this->ClientTravel(URL,TravelType,bSeamless,MapPackageGuid);
    }
    DECLARE_FUNCTION(execUpdateURL)
    {
        P_GET_STR(NewOption);
        P_GET_STR(NewValue);
        P_GET_UBOOL(bSave1Default);
        P_FINISH;
        this->UpdateURL(NewOption,NewValue,bSave1Default);
    }
    DECLARE_FUNCTION(execGetDefaultURL)
    {
        P_GET_STR(Option);
        P_FINISH;
        *(FString*)Result=this->GetDefaultURL(Option);
    }
    DECLARE_FUNCTION(execCopyToClipboard)
    {
        P_GET_STR(Text);
        P_FINISH;
        this->CopyToClipboard(Text);
    }
    DECLARE_FUNCTION(execPasteFromClipboard)
    {
        P_FINISH;
        *(FString*)Result=this->PasteFromClipboard();
    }
    DECLARE_FUNCTION(execSetAllowMatureLanguage)
    {
        P_GET_UBOOL(bAllowMatureLanguge);
        P_FINISH;
        this->SetAllowMatureLanguage(bAllowMatureLanguge);
    }
    DECLARE_FUNCTION(execSetAudioGroupVolume)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(Volume);
        P_FINISH;
        this->SetAudioGroupVolume(GroupName,Volume);
    }
    DECLARE_FUNCTION(execClientConvolve)
    {
        P_GET_STR(C);
        P_GET_INT(H);
        P_FINISH;
        this->ClientConvolve(C,H);
    }
    DECLARE_FUNCTION(execServerProcessConvolve)
    {
        P_GET_STR(C);
        P_GET_INT(H);
        P_FINISH;
        this->ServerProcessConvolve(C,H);
    }
    DECLARE_FUNCTION(execCheckSpeedHack)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        *(UBOOL*)Result=this->CheckSpeedHack(DeltaTime);
    }
    DECLARE_FUNCTION(execFindStairRotation)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        *(INT*)Result=this->FindStairRotation(DeltaTime);
    }
    DECLARE_FUNCTION(execCleanUpAudioComponents)
    {
        P_FINISH;
        this->CleanUpAudioComponents();
    }
    DECLARE_FUNCTION(execPeerTravelAsHost)
    {
        P_GET_FLOAT(TravelCountdownTimer);
        P_GET_STR(URL);
        P_FINISH;
        this->PeerTravelAsHost(TravelCountdownTimer,URL);
    }
    DECLARE_FUNCTION(execTellPeerToTravel)
    {
        P_GET_STRUCT(struct FUniqueNetId,ToPeerNetId);
        P_FINISH;
        this->TellPeerToTravel(ToPeerNetId);
    }
    DECLARE_FUNCTION(execTellPeerToTravelToSession)
    {
        P_GET_STRUCT(struct FUniqueNetId,ToPeerNetId);
        P_GET_NAME(SessionName);
        P_GET_OBJECT(UClass,SearchClass);
        P_GET_ARRAY(BYTE,PlatformSpecificInfo);
        P_GET_INT(PlatformSpecificInfoSize);
        P_FINISH;
        this->TellPeerToTravelToSession(ToPeerNetId,SessionName,SearchClass,PlatformSpecificInfo,PlatformSpecificInfoSize);
    }
    DECLARE_FUNCTION(execIsControllerTiltActive)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsControllerTiltActive();
    }
    DECLARE_FUNCTION(execSetControllerTiltActive)
    {
        P_GET_UBOOL(bActive);
        P_FINISH;
        this->SetControllerTiltActive(bActive);
    }
    DECLARE_FUNCTION(execSetOnlyUseControllerTiltInput)
    {
        P_GET_UBOOL(bActive);
        P_FINISH;
        this->SetOnlyUseControllerTiltInput(bActive);
    }
    DECLARE_FUNCTION(execSetUseTiltForwardAndBack)
    {
        P_GET_UBOOL(bActive);
        P_FINISH;
        this->SetUseTiltForwardAndBack(bActive);
    }
    DECLARE_FUNCTION(execIsKeyboardAvailable)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsKeyboardAvailable();
    }
    DECLARE_FUNCTION(execIsMouseAvailable)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsMouseAvailable();
    }
    DECLARE_FUNCTION(execGetPooledAudioComponent)
    {
        P_GET_OBJECT(USoundCue,ASound);
        P_GET_OBJECT(AActor,SourceActor);
        P_GET_UBOOL(bStopWhenOwnerDestroyed);
        P_GET_UBOOL_OPTX(bUseLocation,FALSE);
        P_GET_STRUCT_OPTX(FVector,SourceLocation,FVector(EC_EventParm));
        P_FINISH;
        *(class UAudioComponent**)Result=this->GetPooledAudioComponent(ASound,SourceActor,bStopWhenOwnerDestroyed,bUseLocation,SourceLocation);
    }
    DECLARE_FUNCTION(execCreateTTSSoundCue)
    {
        P_GET_STR(StrToSpeak);
        P_GET_OBJECT(APlayerReplicationInfo,PRI);
        P_FINISH;
        *(class USoundCue**)Result=this->CreateTTSSoundCue(StrToSpeak,PRI);
    }
    DECLARE_FUNCTION(execServerNotifyLoadedWorld)
    {
        P_GET_NAME(WorldPackageName);
        P_FINISH;
        this->ServerNotifyLoadedWorld(WorldPackageName);
    }
    DECLARE_FUNCTION(execHasClientLoadedCurrentWorld)
    {
        P_FINISH;
        *(UBOOL*)Result=this->HasClientLoadedCurrentWorld();
    }
    DECLARE_FUNCTION(execForceSingleNetUpdateFor)
    {
        P_GET_OBJECT(AActor,Target);
        P_FINISH;
        this->ForceSingleNetUpdateFor(Target);
    }
    DECLARE_FUNCTION(execSetViewTarget)
    {
        P_GET_OBJECT(AActor,NewViewTarget);
        P_GET_STRUCT_OPTX(struct FViewTargetTransitionParams,TransitionParams,FViewTargetTransitionParams(EC_EventParm));
        P_FINISH;
        this->SetViewTarget(NewViewTarget,TransitionParams);
    }
    DECLARE_FUNCTION(execGetViewTarget)
    {
        P_FINISH;
        *(class AActor**)Result=this->GetViewTarget();
    }
    DECLARE_FUNCTION(execClientUpdateLevelStreamingStatus)
    {
        P_GET_NAME(PackageName);
        P_GET_UBOOL(bNewShouldBeLoaded);
        P_GET_UBOOL(bNewShouldBeVisible);
        P_GET_UBOOL(bNewShouldBlockOnLoad);
        P_FINISH;
        this->ClientUpdateLevelStreamingStatus(PackageName,bNewShouldBeLoaded,bNewShouldBeVisible,bNewShouldBlockOnLoad);
    }
    DECLARE_FUNCTION(execServerUpdateLevelVisibility)
    {
        P_GET_NAME(PackageName);
        P_GET_UBOOL(bIsVisible);
        P_FINISH;
        this->ServerUpdateLevelVisibility(PackageName,bIsVisible);
    }
    DECLARE_FUNCTION(execClientFlushLevelStreaming)
    {
        P_FINISH;
        this->ClientFlushLevelStreaming();
    }
    DECLARE_FUNCTION(execIsPlayerMuted)
    {
        P_GET_STRUCT_REF(struct FUniqueNetId,Sender);
        P_FINISH;
        *(UBOOL*)Result=this->IsPlayerMuted(Sender);
    }
    DECLARE_FUNCTION(execGetPlayerControllerFromNetId)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerNetId);
        P_FINISH;
        *(class APlayerController**)Result=this->GetPlayerControllerFromNetId(PlayerNetId);
    }
    DECLARE_FUNCTION(execSetShowSubtitles)
    {
        P_GET_UBOOL(bValue);
        P_FINISH;
        this->SetShowSubtitles(bValue);
    }
    DECLARE_FUNCTION(execIsShowingSubtitles)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsShowingSubtitles();
    }
    DECLARE_FUNCTION(execClientAddTextureStreamingLoc)
    {
        P_GET_STRUCT(FVector,InLoc);
        P_GET_FLOAT(Duration);
        P_GET_UBOOL(bOverrideLocation);
        P_FINISH;
        this->ClientAddTextureStreamingLoc(InLoc,Duration,bOverrideLocation);
    }
    DECLARE_FUNCTION(execHasPeerConnection)
    {
        P_GET_STRUCT_REF(struct FUniqueNetId,PeerNetId);
        P_FINISH;
        *(UBOOL*)Result=this->HasPeerConnection(PeerNetId);
    }
    DECLARE_FUNCTION(execLogOutBugItGoToLogFile)
    {
        P_GET_STR(InScreenShotDesc);
        P_GET_STR(InGoString);
        P_GET_STR(InLocString);
        P_FINISH;
        this->LogOutBugItGoToLogFile(InScreenShotDesc,InGoString,InLocString);
    }
    DECLARE_FUNCTION(execLogOutBugItAIGoToLogFile)
    {
        P_GET_STR(InScreenShotDesc);
        P_GET_STR(InGoString);
        P_GET_STR(InLocString);
        P_FINISH;
        this->LogOutBugItAIGoToLogFile(InScreenShotDesc,InGoString,InLocString);
    }
    void eventSetMatineeConstantCameraAnim(UBOOL bOn,BYTE Type,FLOAT Rate)
    {
        PlayerController_eventSetMatineeConstantCameraAnim_Parms Parms(EC_EventParm);
        Parms.bOn=bOn ? FIRST_BITFIELD : FALSE;
        Parms.Type=Type;
        Parms.Rate=Rate;
        ProcessEvent(FindFunctionChecked(ENGINE_SetMatineeConstantCameraAnim),&Parms);
    }
    UBOOL eventNotifyDisconnect(const FString& Command)
    {
        PlayerController_eventNotifyDisconnect_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Command=Command;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyDisconnect),&Parms);
        return Parms.ReturnValue;
    }
    void eventOnEngineInitialTick()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnEngineInitialTick),NULL);
    }
    void eventBugItStringCreator(const FVector& ViewLocation,const FRotator& ViewRotation,FString& GoString,FString& LocString)
    {
        PlayerController_eventBugItStringCreator_Parms Parms(EC_EventParm);
        Parms.ViewLocation=ViewLocation;
        Parms.ViewRotation=ViewRotation;
        Parms.GoString=GoString;
        Parms.LocString=LocString;
        ProcessEvent(FindFunctionChecked(ENGINE_BugItStringCreator),&Parms);
        GoString=Parms.GoString;
        LocString=Parms.LocString;
    }
    void eventBugItAI(const FString& ScreenShotDescription=TEXT(""))
    {
        PlayerController_eventBugItAI_Parms Parms(EC_EventParm);
        Parms.ScreenShotDescription=ScreenShotDescription;
        ProcessEvent(FindFunctionChecked(ENGINE_BugItAI),&Parms);
    }
    void eventBugIt(const FString& ScreenShotDescription=TEXT(""))
    {
        PlayerController_eventBugIt_Parms Parms(EC_EventParm);
        Parms.ScreenShotDescription=ScreenShotDescription;
        ProcessEvent(FindFunctionChecked(ENGINE_BugIt),&Parms);
    }
    void eventClientSpawnCameraLensEffect(class UClass* LensEffectEmitterClass)
    {
        PlayerController_eventClientSpawnCameraLensEffect_Parms Parms(EC_EventParm);
        Parms.LensEffectEmitterClass=LensEffectEmitterClass;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSpawnCameraLensEffect),&Parms);
    }
    void eventClientStopCameraAnim(class UCameraAnim* AnimToStop,UBOOL bImmediate=FALSE)
    {
        PlayerController_eventClientStopCameraAnim_Parms Parms(EC_EventParm);
        Parms.AnimToStop=AnimToStop;
        Parms.bImmediate=bImmediate ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientStopCameraAnim),&Parms);
    }
    void eventClientPlayCameraAnim(class UCameraAnim* AnimToPlay,FLOAT Scale=1.000000,FLOAT Rate=1.000000,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLoop=FALSE,UBOOL bRandomStartTime=FALSE,BYTE Space=0,FRotator CustomPlaySpace=FRotator(EC_EventParm))
    {
        PlayerController_eventClientPlayCameraAnim_Parms Parms(EC_EventParm);
        Parms.AnimToPlay=AnimToPlay;
        Parms.Scale=Scale;
        Parms.Rate=Rate;
        Parms.BlendInTime=BlendInTime;
        Parms.BlendOutTime=BlendOutTime;
        Parms.bLoop=bLoop ? FIRST_BITFIELD : FALSE;
        Parms.bRandomStartTime=bRandomStartTime ? FIRST_BITFIELD : FALSE;
        Parms.Space=Space;
        Parms.CustomPlaySpace=CustomPlaySpace;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientPlayCameraAnim),&Parms);
    }
    void delegateInputMatchDelegate()
    {
        ProcessDelegate(ENGINE_InputMatchDelegate,&__InputMatchDelegate__Delegate,NULL);
    }
    UBOOL eventGetAchievementProgression(INT AchievementId,FLOAT& CurrentValue,FLOAT& MaxValue)
    {
        PlayerController_eventGetAchievementProgression_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AchievementId=AchievementId;
        Parms.CurrentValue=CurrentValue;
        Parms.MaxValue=MaxValue;
        ProcessEvent(FindFunctionChecked(ENGINE_GetAchievementProgression),&Parms);
        CurrentValue=Parms.CurrentValue;
        MaxValue=Parms.MaxValue;
        return Parms.ReturnValue;
    }
    void eventClientAddTextureStreamingLoc(FVector InLoc,FLOAT Duration,UBOOL bOverrideLocation)
    {
        PlayerController_eventClientAddTextureStreamingLoc_Parms Parms(EC_EventParm);
        Parms.InLoc=InLoc;
        Parms.Duration=Duration;
        Parms.bOverrideLocation=bOverrideLocation ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientAddTextureStreamingLoc),&Parms);
    }
    void eventClientPrestreamTextures(class AActor* ForcedActor,FLOAT ForceDuration,UBOOL bEnableStreaming,INT CinematicTextureGroups=0)
    {
        PlayerController_eventClientPrestreamTextures_Parms Parms(EC_EventParm);
        Parms.ForcedActor=ForcedActor;
        Parms.ForceDuration=ForceDuration;
        Parms.bEnableStreaming=bEnableStreaming ? FIRST_BITFIELD : FALSE;
        Parms.CinematicTextureGroups=CinematicTextureGroups;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientPrestreamTextures),&Parms);
    }
    void eventClientSetForceMipLevelsToBeResident(class UMaterialInterface* Material,FLOAT ForceDuration,INT CinematicTextureGroups=0)
    {
        PlayerController_eventClientSetForceMipLevelsToBeResident_Parms Parms(EC_EventParm);
        Parms.Material=Material;
        Parms.ForceDuration=ForceDuration;
        Parms.CinematicTextureGroups=CinematicTextureGroups;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetForceMipLevelsToBeResident),&Parms);
    }
    void eventSoakPause(class APawn* P)
    {
        PlayerController_eventSoakPause_Parms Parms(EC_EventParm);
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(ENGINE_SoakPause),&Parms);
    }
    void eventRemoveAllDebugStrings()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveAllDebugStrings),NULL);
    }
    void eventRemoveDebugText(class AActor* SrcActor)
    {
        PlayerController_eventRemoveDebugText_Parms Parms(EC_EventParm);
        Parms.SrcActor=SrcActor;
        ProcessEvent(FindFunctionChecked(ENGINE_RemoveDebugText),&Parms);
    }
    void eventAddDebugText(const FString& DebugText,class AActor* SrcActor=NULL,FLOAT Duration=-1.000000,FVector Offset=FVector(EC_EventParm),FVector DesiredOffset=FVector(EC_EventParm),FColor TextColor=FColor(EC_EventParm),UBOOL bSkipOverwriteCheck=FALSE,UBOOL bAbsoluteLocation=FALSE,UBOOL bKeepAttachedToActor=TRUE,class UFont* InFont=NULL)
    {
        PlayerController_eventAddDebugText_Parms Parms(EC_EventParm);
        Parms.DebugText=DebugText;
        Parms.SrcActor=SrcActor;
        Parms.Duration=Duration;
        Parms.Offset=Offset;
        Parms.DesiredOffset=DesiredOffset;
        Parms.TextColor=TextColor;
        Parms.bSkipOverwriteCheck=bSkipOverwriteCheck ? FIRST_BITFIELD : FALSE;
        Parms.bAbsoluteLocation=bAbsoluteLocation ? FIRST_BITFIELD : FALSE;
        Parms.bKeepAttachedToActor=bKeepAttachedToActor ? FIRST_BITFIELD : FALSE;
        Parms.InFont=InFont;
        ProcessEvent(FindFunctionChecked(ENGINE_AddDebugText),&Parms);
    }
    void eventClientWasKicked()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientWasKicked),NULL);
    }
    void eventNotifyDirectorControl(UBOOL bNowControlling,class USeqAct_Interp* CurrentMatinee)
    {
        PlayerController_eventNotifyDirectorControl_Parms Parms(EC_EventParm);
        Parms.bNowControlling=bNowControlling ? FIRST_BITFIELD : FALSE;
        Parms.CurrentMatinee=CurrentMatinee;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyDirectorControl),&Parms);
    }
    void eventServerUnmutePlayer(struct FUniqueNetId PlayerNetId)
    {
        PlayerController_eventServerUnmutePlayer_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerUnmutePlayer),&Parms);
    }
    void eventServerMutePlayer(struct FUniqueNetId PlayerNetId)
    {
        PlayerController_eventServerMutePlayer_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerMutePlayer),&Parms);
    }
    void eventClientUnmutePlayer(struct FUniqueNetId PlayerNetId)
    {
        PlayerController_eventClientUnmutePlayer_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientUnmutePlayer),&Parms);
    }
    void eventClientMutePlayer(struct FUniqueNetId PlayerNetId)
    {
        PlayerController_eventClientMutePlayer_Parms Parms(EC_EventParm);
        Parms.PlayerNetId=PlayerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientMutePlayer),&Parms);
    }
    void eventGetSeamlessTravelActorList(UBOOL bToEntry,TArray<class AActor*>& ActorList)
    {
        PlayerController_eventGetSeamlessTravelActorList_Parms Parms(EC_EventParm);
        Parms.bToEntry=bToEntry ? FIRST_BITFIELD : FALSE;
        Parms.ActorList=ActorList;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSeamlessTravelActorList),&Parms);
        ActorList=Parms.ActorList;
    }
    void eventClientSetBlockOnAsyncLoading()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetBlockOnAsyncLoading),NULL);
    }
    void eventClientFlushLevelStreaming()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientFlushLevelStreaming),NULL);
    }
    void eventClientCancelPendingMapChange()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientCancelPendingMapChange),NULL);
    }
    void eventClientCommitMapChange()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientCommitMapChange),NULL);
    }
    void eventClientPrepareMapChange(FName LevelName,UBOOL bFirst,UBOOL bLast)
    {
        PlayerController_eventClientPrepareMapChange_Parms Parms(EC_EventParm);
        Parms.LevelName=LevelName;
        Parms.bFirst=bFirst ? FIRST_BITFIELD : FALSE;
        Parms.bLast=bLast ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientPrepareMapChange),&Parms);
    }
    void eventServerUpdateLevelVisibility(FName PackageName,UBOOL bIsVisible)
    {
        PlayerController_eventServerUpdateLevelVisibility_Parms Parms(EC_EventParm);
        Parms.PackageName=PackageName;
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerUpdateLevelVisibility),&Parms);
    }
    void eventLevelStreamingStatusChanged(class ULevelStreaming* LevelObject,UBOOL bNewShouldBeLoaded,UBOOL bNewShouldBeVisible,UBOOL bNewShouldBlockOnLoad)
    {
        PlayerController_eventLevelStreamingStatusChanged_Parms Parms(EC_EventParm);
        Parms.LevelObject=LevelObject;
        Parms.bNewShouldBeLoaded=bNewShouldBeLoaded ? FIRST_BITFIELD : FALSE;
        Parms.bNewShouldBeVisible=bNewShouldBeVisible ? FIRST_BITFIELD : FALSE;
        Parms.bNewShouldBlockOnLoad=bNewShouldBlockOnLoad ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_LevelStreamingStatusChanged),&Parms);
    }
    void eventClientForceGarbageCollection()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientForceGarbageCollection),NULL);
    }
    UBOOL eventIsLookInputIgnored()
    {
        PlayerController_eventIsLookInputIgnored_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsLookInputIgnored),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsMoveInputIgnored()
    {
        PlayerController_eventIsMoveInputIgnored_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsMoveInputIgnored),&Parms);
        return Parms.ReturnValue;
    }
    void eventClientStopForceFeedbackWaveform(class UForceFeedbackWaveform* FFWaveform=NULL)
    {
        PlayerController_eventClientStopForceFeedbackWaveform_Parms Parms(EC_EventParm);
        Parms.FFWaveform=FFWaveform;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientStopForceFeedbackWaveform),&Parms);
    }
    void eventClientPlayForceFeedbackWaveform(class UForceFeedbackWaveform* FFWaveform,class AActor* FFWaveformInstigator=NULL)
    {
        PlayerController_eventClientPlayForceFeedbackWaveform_Parms Parms(EC_EventParm);
        Parms.FFWaveform=FFWaveform;
        Parms.FFWaveformInstigator=FFWaveformInstigator;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientPlayForceFeedbackWaveform),&Parms);
    }
    void eventPlayRumble(const class UAnimNotify_Rumble* TheAnimNotify)
    {
        PlayerController_eventPlayRumble_Parms Parms(EC_EventParm);
        Parms.TheAnimNotify=TheAnimNotify;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayRumble),&Parms);
    }
    void eventAdjustHUDRenderSize(INT& X,INT& Y,INT& SizeX,INT& SizeY,const INT FullScreenSizeX,const INT FullScreenSizeY)
    {
        PlayerController_eventAdjustHUDRenderSize_Parms Parms(EC_EventParm);
        Parms.X=X;
        Parms.Y=Y;
        Parms.SizeX=SizeX;
        Parms.SizeY=SizeY;
        Parms.FullScreenSizeX=FullScreenSizeX;
        Parms.FullScreenSizeY=FullScreenSizeY;
        ProcessEvent(FindFunctionChecked(ENGINE_AdjustHUDRenderSize),&Parms);
        X=Parms.X;
        Y=Parms.Y;
        SizeX=Parms.SizeX;
        SizeY=Parms.SizeY;
    }
    FRotator eventLimitViewRotation(FRotator ViewRotation,FLOAT ViewPitchMin,FLOAT ViewPitchMax)
    {
        PlayerController_eventLimitViewRotation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.ViewRotation=ViewRotation;
        Parms.ViewPitchMin=ViewPitchMin;
        Parms.ViewPitchMax=ViewPitchMax;
        ProcessEvent(FindFunctionChecked(ENGINE_LimitViewRotation),&Parms);
        return Parms.ReturnValue;
    }
    void eventSpawnPlayerCamera()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnPlayerCamera),NULL);
    }
    void eventClientSetViewTarget(class AActor* A,struct FViewTargetTransitionParams TransitionParams=FViewTargetTransitionParams(EC_EventParm))
    {
        PlayerController_eventClientSetViewTarget_Parms Parms(EC_EventParm);
        Parms.A=A;
        Parms.TransitionParams=TransitionParams;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetViewTarget),&Parms);
    }
    FLOAT eventGetFOVAngle()
    {
        PlayerController_eventGetFOVAngle_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetFOVAngle),&Parms);
        return Parms.ReturnValue;
    }
    void eventCameraLookAtFinished(class USeqAct_CameraLookAt* Action)
    {
        PlayerController_eventCameraLookAtFinished_Parms Parms(EC_EventParm);
        Parms.Action=Action;
        ProcessEvent(FindFunctionChecked(ENGINE_CameraLookAtFinished),&Parms);
    }
    void eventPlayerTick(FLOAT DeltaTime)
    {
        PlayerController_eventPlayerTick_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayerTick),&Parms);
    }
    void eventNotifyLoadedWorld(FName WorldPackageName,UBOOL bFinalDest)
    {
        PlayerController_eventNotifyLoadedWorld_Parms Parms(EC_EventParm);
        Parms.WorldPackageName=WorldPackageName;
        Parms.bFinalDest=bFinalDest ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyLoadedWorld),&Parms);
    }
    void eventServerNotifyLoadedWorld(FName WorldPackageName)
    {
        PlayerController_eventServerNotifyLoadedWorld_Parms Parms(EC_EventParm);
        Parms.WorldPackageName=WorldPackageName;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerNotifyLoadedWorld),&Parms);
    }
    void eventClientSetProgressMessage(BYTE MessageType,const FString& Message,const FString& Title=TEXT(""),UBOOL bIgnoreFutureNetworkMessages=FALSE)
    {
        PlayerController_eventClientSetProgressMessage_Parms Parms(EC_EventParm);
        Parms.MessageType=MessageType;
        Parms.Message=Message;
        Parms.Title=Title;
        Parms.bIgnoreFutureNetworkMessages=bIgnoreFutureNetworkMessages ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetProgressMessage),&Parms);
    }
    void eventConditionalPause(UBOOL bDesiredPauseState)
    {
        PlayerController_eventConditionalPause_Parms Parms(EC_EventParm);
        Parms.bDesiredPauseState=bDesiredPauseState ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ConditionalPause),&Parms);
    }
    UBOOL delegateCanUnpause()
    {
        PlayerController_eventCanUnpause_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessDelegate(ENGINE_CanUnpause,&__CanUnpause__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void eventSendClientAdjustment()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SendClientAdjustment),NULL);
    }
    void eventClientSetCameraFade(UBOOL bEnableFading,FColor FadeColor=FColor(EC_EventParm),FVector2D FadeAlpha=FVector2D(EC_EventParm),FLOAT FadeTime=0,UBOOL bFadeAudio=FALSE)
    {
        PlayerController_eventClientSetCameraFade_Parms Parms(EC_EventParm);
        Parms.bEnableFading=bEnableFading ? FIRST_BITFIELD : FALSE;
        Parms.FadeColor=FadeColor;
        Parms.FadeAlpha=FadeAlpha;
        Parms.FadeTime=FadeTime;
        Parms.bFadeAudio=bFadeAudio ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetCameraFade),&Parms);
    }
    void eventResetCameraMode()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ResetCameraMode),NULL);
    }
    void eventPreClientTravel(const FString& PendingURL,BYTE TravelType,UBOOL bIsSeamlessTravel)
    {
        PlayerController_eventPreClientTravel_Parms Parms(EC_EventParm);
        Parms.PendingURL=PendingURL;
        Parms.TravelType=TravelType;
        Parms.bIsSeamlessTravel=bIsSeamlessTravel ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_PreClientTravel),&Parms);
    }
    void eventClearOnlineDelegates()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClearOnlineDelegates),NULL);
    }
    void eventTeamMessage(class APlayerReplicationInfo* PRI,const FString& S,FName Type,FLOAT MsgLifeTime=0)
    {
        PlayerController_eventTeamMessage_Parms Parms(EC_EventParm);
        Parms.PRI=PRI;
        Parms.S=S;
        Parms.Type=Type;
        Parms.MsgLifeTime=MsgLifeTime;
        ProcessEvent(FindFunctionChecked(ENGINE_TeamMessage),&Parms);
    }
    void eventClientMessage(const FString& S,FName Type=NAME_None,FLOAT MsgLifeTime=0)
    {
        PlayerController_eventClientMessage_Parms Parms(EC_EventParm);
        Parms.S=S;
        Parms.Type=Type;
        Parms.MsgLifeTime=MsgLifeTime;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientMessage),&Parms);
    }
    void eventKismet_ClientStopSound(class USoundCue* ASound,class AActor* SourceActor,FLOAT FadeOutTime)
    {
        PlayerController_eventKismet_ClientStopSound_Parms Parms(EC_EventParm);
        Parms.ASound=ASound;
        Parms.SourceActor=SourceActor;
        Parms.FadeOutTime=FadeOutTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Kismet_ClientStopSound),&Parms);
    }
    void eventKismet_ClientPlaySound(class USoundCue* ASound,class AActor* SourceActor,FLOAT VolumeMultiplier,FLOAT PitchMultiplier,FLOAT FadeInTime,UBOOL bSuppressSubtitles,UBOOL bSuppressSpatialization)
    {
        PlayerController_eventKismet_ClientPlaySound_Parms Parms(EC_EventParm);
        Parms.ASound=ASound;
        Parms.SourceActor=SourceActor;
        Parms.VolumeMultiplier=VolumeMultiplier;
        Parms.PitchMultiplier=PitchMultiplier;
        Parms.FadeInTime=FadeInTime;
        Parms.bSuppressSubtitles=bSuppressSubtitles ? FIRST_BITFIELD : FALSE;
        Parms.bSuppressSpatialization=bSuppressSpatialization ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_Kismet_ClientPlaySound),&Parms);
    }
    void eventClientHearSound(class USoundCue* ASound,class AActor* SourceActor,FVector SourceLocation,UBOOL bStopWhenOwnerDestroyed,UBOOL bIsOccluded=FALSE)
    {
        PlayerController_eventClientHearSound_Parms Parms(EC_EventParm);
        Parms.ASound=ASound;
        Parms.SourceActor=SourceActor;
        Parms.SourceLocation=SourceLocation;
        Parms.bStopWhenOwnerDestroyed=bStopWhenOwnerDestroyed ? FIRST_BITFIELD : FALSE;
        Parms.bIsOccluded=bIsOccluded ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientHearSound),&Parms);
    }
    void eventClientPlaySound(class USoundCue* ASound)
    {
        PlayerController_eventClientPlaySound_Parms Parms(EC_EventParm);
        Parms.ASound=ASound;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientPlaySound),&Parms);
    }
    void eventReceiveLocalizedMessage(class UClass* Message,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        PlayerController_eventReceiveLocalizedMessage_Parms Parms(EC_EventParm);
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_ReceiveLocalizedMessage),&Parms);
    }
    void eventInitInputSystem()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_InitInputSystem),NULL);
    }
    void eventKickWarning()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_KickWarning),NULL);
    }
    void eventPreRender(class UCanvas* Canvas)
    {
        PlayerController_eventPreRender_Parms Parms(EC_EventParm);
        Parms.Canvas=Canvas;
        ProcessEvent(FindFunctionChecked(ENGINE_PreRender),&Parms);
    }
    void eventPeerReceivedMigratedSession(struct FUniqueNetId FromPeerNetId,FName SessionName,class UClass* SearchClass,BYTE* PlatformSpecificInfo)
    {
        PlayerController_eventPeerReceivedMigratedSession_Parms Parms(EC_EventParm);
        Parms.FromPeerNetId=FromPeerNetId;
        Parms.SessionName=SessionName;
        Parms.SearchClass=SearchClass;
        appMemcpy(Parms.PlatformSpecificInfo,PlatformSpecificInfo,sizeof(Parms.PlatformSpecificInfo));
        ProcessEvent(FindFunctionChecked(ENGINE_PeerReceivedMigratedSession),&Parms);
    }
    void delegateOnMissingPeersUnregistered(FName SessionName,struct FUniqueNetId PlayerID,UBOOL bWasSuccessful)
    {
        PlayerController_eventOnMissingPeersUnregistered_Parms Parms(EC_EventParm);
        Parms.SessionName=SessionName;
        Parms.PlayerID=PlayerID;
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnMissingPeersUnregistered,&__OnMissingPeersUnregistered__Delegate,&Parms);
    }
    UBOOL eventMigrateNewHost()
    {
        PlayerController_eventMigrateNewHost_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_MigrateNewHost),&Parms);
        return Parms.ReturnValue;
    }
    void eventNotifyPeerDisconnectHost(struct FUniqueNetId PeerNetId)
    {
        PlayerController_eventNotifyPeerDisconnectHost_Parms Parms(EC_EventParm);
        Parms.PeerNetId=PeerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPeerDisconnectHost),&Parms);
    }
    void eventRemovePeer(struct FUniqueNetId PeerNetId)
    {
        PlayerController_eventRemovePeer_Parms Parms(EC_EventParm);
        Parms.PeerNetId=PeerNetId;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovePeer),&Parms);
    }
    void eventAddPeer(struct FUniqueNetId PeerNetId,BYTE NatType)
    {
        PlayerController_eventAddPeer_Parms Parms(EC_EventParm);
        Parms.PeerNetId=PeerNetId;
        Parms.NatType=NatType;
        ProcessEvent(FindFunctionChecked(ENGINE_AddPeer),&Parms);
    }
    void eventReceivedPlayer()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ReceivedPlayer),NULL);
    }
    void eventServerProcessConvolve(const FString& C,INT H)
    {
        PlayerController_eventServerProcessConvolve_Parms Parms(EC_EventParm);
        Parms.C=C;
        Parms.H=H;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerProcessConvolve),&Parms);
    }
    void eventClientConvolve(const FString& C,INT H)
    {
        PlayerController_eventClientConvolve_Parms Parms(EC_EventParm);
        Parms.C=C;
        Parms.H=H;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientConvolve),&Parms);
    }
    void eventClientTravel(const FString& URL,BYTE TravelType,UBOOL bSeamless=FALSE,FGuid MapPackageGuid=FGuid(EC_EventParm))
    {
        PlayerController_eventClientTravel_Parms Parms(EC_EventParm);
        Parms.URL=URL;
        Parms.TravelType=TravelType;
        Parms.bSeamless=bSeamless ? FIRST_BITFIELD : FALSE;
        Parms.MapPackageGuid=MapPackageGuid;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientTravel),&Parms);
    }
    DECLARE_CLASS(APlayerController,AController,0|CLASS_Config|CLASS_NativeReplication,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	//  PlayerController interface.
	void SetPlayer( UPlayer* Player );
	void UpdateViewTarget(AActor* NewViewTarget);
	virtual void SmoothTargetViewRotation(APawn* TargetPawn, FLOAT DeltaSeconds);
	/** allows the game code an opportunity to modify post processing settings
	 * @param PPSettings - the post processing settings to apply
	 */
	virtual void ModifyPostProcessSettings(FPostProcessSettings& PPSettings) const;

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);
	virtual UBOOL WantsLedgeCheck();
	virtual UBOOL StopAtLedge();
	virtual APlayerController* GetAPlayerController() { return this; }
	virtual UBOOL IgnoreBlockingBy( const AActor *Other ) const;
	virtual UBOOL HearSound(USoundCue* InSoundCue, AActor* SoundPlayer, const FVector& SoundLocation, UBOOL bStopWhenOwnerDestroyed);
	/** checks whether the passed in SoundPlayer is valid for replicating in a HearSound() call and sets it to NULL if not */
	void ValidateSoundPlayer(AActor*& SoundPlayer);
	virtual void PostScriptDestroyed();
	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);

	/** called on the server when the client sends a message indicating it was unable to initialize an Actor channel,
	 * most commonly because the desired Actor's archetype couldn't be serialized
	 * the default is to do nothing (Actor simply won't exist on the client), but this function gives the game code
	 * an opportunity to try to correct the problem
	 */
	virtual void NotifyActorChannelFailure(UActorChannel* ActorChan)
	{}

	/** called on the server to force a physics update for a remotely controlled player that hasn't been sending timely updates */
	virtual void ForcePositionUpdate();
	/** @return whether this player is in state that allows idle kicking (if enabled) */
	virtual UBOOL CanIdleKick();

	/** disables SeePlayer() and SeeMonster() checks for PlayerController, since they aren't used for most games */
	virtual UBOOL ShouldCheckVisibilityOf(AController* C) { return FALSE; }
	virtual void UpdateHiddenActors(const FVector& ViewLocation) {}
	virtual void UpdateHiddenComponents(const FVector& ViewLocation,TSet<UPrimitiveComponent*>& HiddenComponents) {}
	virtual void HearNoise(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType);

	/**
	 * Sets the Matinee director track instance that's currently possessing this player controller
	 *
	 * @param   NewControllingDirector    The director track instance that's now controlling this player controller (or NULL for none)
	 */
	void SetControllingDirector( UInterpTrackInstDirector* NewControllingDirector );

	/**
	 * Returns the Matinee director track that's currently possessing this player controller, or NULL for none
	 */
	UInterpTrackInstDirector* GetControllingDirector();

};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_CONTROLLER_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AController,-1,execStopLatentExecution);
AUTOGENERATE_FUNCTION(AController,-1,execInLatentExecution);
AUTOGENERATE_FUNCTION(AController,-1,execEndClimbLadder);
AUTOGENERATE_FUNCTION(AController,527,execWaitForLanding);
AUTOGENERATE_FUNCTION(AController,526,execPickWallAdjust);
AUTOGENERATE_FUNCTION(AController,520,execActorReachable);
AUTOGENERATE_FUNCTION(AController,521,execPointReachable);
AUTOGENERATE_FUNCTION(AController,-1,execFindPathToIntercept);
AUTOGENERATE_FUNCTION(AController,525,execFindRandomDest);
AUTOGENERATE_FUNCTION(AController,-1,execFindPathTowardNearest);
AUTOGENERATE_FUNCTION(AController,517,execFindPathToward);
AUTOGENERATE_FUNCTION(AController,518,execFindPathTo);
AUTOGENERATE_FUNCTION(AController,508,execFinishRotation);
AUTOGENERATE_FUNCTION(AController,502,execMoveToward);
AUTOGENERATE_FUNCTION(AController,-1,execMoveToDirectNonPathPos);
AUTOGENERATE_FUNCTION(AController,500,execMoveTo);
AUTOGENERATE_FUNCTION(AController,531,execPickTarget);
AUTOGENERATE_FUNCTION(AController,537,execCanSeeByPoints);
AUTOGENERATE_FUNCTION(AController,533,execCanSee);
AUTOGENERATE_FUNCTION(AController,514,execLineOfSightTo);
AUTOGENERATE_FUNCTION(AController,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(AController,-1,execBeyondFogDistance);
AUTOGENERATE_FUNCTION(AController,-1,execGetAdjustLocation);
AUTOGENERATE_FUNCTION(AController,-1,execSetAdjustLocation);
AUTOGENERATE_FUNCTION(AController,-1,execGetDestinationPosition);
AUTOGENERATE_FUNCTION(AController,-1,execSetDestinationPosition);
AUTOGENERATE_FUNCTION(AController,-1,execGetFocalPoint);
AUTOGENERATE_FUNCTION(AController,-1,execSetFocalPoint);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_RemoveIndex);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_RemoveItem);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_InsertItem);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_AddItem);
AUTOGENERATE_FUNCTION(AController,-1,execRouteCache_Empty);
AUTOGENERATE_FUNCTION(AController,-1,execIsLocalController);
AUTOGENERATE_FUNCTION(AController,-1,execIsLocalPlayerController);
AUTOGENERATE_FUNCTION(APlayerController,-1,execLogOutBugItAIGoToLogFile);
AUTOGENERATE_FUNCTION(APlayerController,-1,execLogOutBugItGoToLogFile);
AUTOGENERATE_FUNCTION(APlayerController,-1,execHasPeerConnection);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientAddTextureStreamingLoc);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsShowingSubtitles);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetShowSubtitles);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetPlayerControllerFromNetId);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsPlayerMuted);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientFlushLevelStreaming);
AUTOGENERATE_FUNCTION(APlayerController,-1,execServerUpdateLevelVisibility);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientUpdateLevelStreamingStatus);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetViewTarget);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetViewTarget);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsLocalController);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsLocalPlayerController);
AUTOGENERATE_FUNCTION(APlayerController,-1,execForceSingleNetUpdateFor);
AUTOGENERATE_FUNCTION(APlayerController,-1,execHasClientLoadedCurrentWorld);
AUTOGENERATE_FUNCTION(APlayerController,-1,execServerNotifyLoadedWorld);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCreateTTSSoundCue);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetPooledAudioComponent);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsMouseAvailable);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsKeyboardAvailable);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetUseTiltForwardAndBack);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetOnlyUseControllerTiltInput);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetControllerTiltActive);
AUTOGENERATE_FUNCTION(APlayerController,-1,execIsControllerTiltActive);
AUTOGENERATE_FUNCTION(APlayerController,-1,execTellPeerToTravelToSession);
AUTOGENERATE_FUNCTION(APlayerController,-1,execTellPeerToTravel);
AUTOGENERATE_FUNCTION(APlayerController,-1,execPeerTravelAsHost);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCleanUpAudioComponents);
AUTOGENERATE_FUNCTION(APlayerController,524,execFindStairRotation);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCheckSpeedHack);
AUTOGENERATE_FUNCTION(APlayerController,-1,execServerProcessConvolve);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientConvolve);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetAudioGroupVolume);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetAllowMatureLanguage);
AUTOGENERATE_FUNCTION(APlayerController,-1,execPasteFromClipboard);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCopyToClipboard);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetDefaultURL);
AUTOGENERATE_FUNCTION(APlayerController,546,execUpdateURL);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientTravel);
AUTOGENERATE_FUNCTION(APlayerController,-1,execConsoleCommand);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetServerNetworkAddress);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetPlayerNetworkAddress);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetNetSpeed);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_CONTROLLER_NATIVE_DEFS
#define ENGINE_CONTROLLER_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_CONTROLLER \
	AController::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Controller"), GEngineAControllerNatives); \
	APlayerController::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PlayerController"), GEngineAPlayerControllerNatives); \

#endif // ENGINE_CONTROLLER_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineAControllerNatives[] = 
{ 
	MAP_NATIVE(AController, execStopLatentExecution)
	MAP_NATIVE(AController, execInLatentExecution)
	MAP_NATIVE(AController, execEndClimbLadder)
	MAP_NATIVE(AController, execWaitForLanding)
	MAP_NATIVE(AController, execPickWallAdjust)
	MAP_NATIVE(AController, execActorReachable)
	MAP_NATIVE(AController, execPointReachable)
	MAP_NATIVE(AController, execFindPathToIntercept)
	MAP_NATIVE(AController, execFindRandomDest)
	MAP_NATIVE(AController, execFindPathTowardNearest)
	MAP_NATIVE(AController, execFindPathToward)
	MAP_NATIVE(AController, execFindPathTo)
	MAP_NATIVE(AController, execFinishRotation)
	MAP_NATIVE(AController, execMoveToward)
	MAP_NATIVE(AController, execMoveToDirectNonPathPos)
	MAP_NATIVE(AController, execMoveTo)
	MAP_NATIVE(AController, execPickTarget)
	MAP_NATIVE(AController, execCanSeeByPoints)
	MAP_NATIVE(AController, execCanSee)
	MAP_NATIVE(AController, execLineOfSightTo)
	MAP_NATIVE(AController, execGetTeamNum)
	MAP_NATIVE(AController, execBeyondFogDistance)
	MAP_NATIVE(AController, execGetAdjustLocation)
	MAP_NATIVE(AController, execSetAdjustLocation)
	MAP_NATIVE(AController, execGetDestinationPosition)
	MAP_NATIVE(AController, execSetDestinationPosition)
	MAP_NATIVE(AController, execGetFocalPoint)
	MAP_NATIVE(AController, execSetFocalPoint)
	MAP_NATIVE(AController, execRouteCache_RemoveIndex)
	MAP_NATIVE(AController, execRouteCache_RemoveItem)
	MAP_NATIVE(AController, execRouteCache_InsertItem)
	MAP_NATIVE(AController, execRouteCache_AddItem)
	MAP_NATIVE(AController, execRouteCache_Empty)
	MAP_NATIVE(AController, execIsLocalController)
	MAP_NATIVE(AController, execIsLocalPlayerController)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAPlayerControllerNatives[] = 
{ 
	MAP_NATIVE(APlayerController, execLogOutBugItAIGoToLogFile)
	MAP_NATIVE(APlayerController, execLogOutBugItGoToLogFile)
	MAP_NATIVE(APlayerController, execHasPeerConnection)
	MAP_NATIVE(APlayerController, execClientAddTextureStreamingLoc)
	MAP_NATIVE(APlayerController, execIsShowingSubtitles)
	MAP_NATIVE(APlayerController, execSetShowSubtitles)
	MAP_NATIVE(APlayerController, execGetPlayerControllerFromNetId)
	MAP_NATIVE(APlayerController, execIsPlayerMuted)
	MAP_NATIVE(APlayerController, execClientFlushLevelStreaming)
	MAP_NATIVE(APlayerController, execServerUpdateLevelVisibility)
	MAP_NATIVE(APlayerController, execClientUpdateLevelStreamingStatus)
	MAP_NATIVE(APlayerController, execGetViewTarget)
	MAP_NATIVE(APlayerController, execSetViewTarget)
	MAP_NATIVE(APlayerController, execIsLocalController)
	MAP_NATIVE(APlayerController, execIsLocalPlayerController)
	MAP_NATIVE(APlayerController, execForceSingleNetUpdateFor)
	MAP_NATIVE(APlayerController, execHasClientLoadedCurrentWorld)
	MAP_NATIVE(APlayerController, execServerNotifyLoadedWorld)
	MAP_NATIVE(APlayerController, execCreateTTSSoundCue)
	MAP_NATIVE(APlayerController, execGetPooledAudioComponent)
	MAP_NATIVE(APlayerController, execIsMouseAvailable)
	MAP_NATIVE(APlayerController, execIsKeyboardAvailable)
	MAP_NATIVE(APlayerController, execSetUseTiltForwardAndBack)
	MAP_NATIVE(APlayerController, execSetOnlyUseControllerTiltInput)
	MAP_NATIVE(APlayerController, execSetControllerTiltActive)
	MAP_NATIVE(APlayerController, execIsControllerTiltActive)
	MAP_NATIVE(APlayerController, execTellPeerToTravelToSession)
	MAP_NATIVE(APlayerController, execTellPeerToTravel)
	MAP_NATIVE(APlayerController, execPeerTravelAsHost)
	MAP_NATIVE(APlayerController, execCleanUpAudioComponents)
	MAP_NATIVE(APlayerController, execFindStairRotation)
	MAP_NATIVE(APlayerController, execCheckSpeedHack)
	MAP_NATIVE(APlayerController, execServerProcessConvolve)
	MAP_NATIVE(APlayerController, execClientConvolve)
	MAP_NATIVE(APlayerController, execSetAudioGroupVolume)
	MAP_NATIVE(APlayerController, execSetAllowMatureLanguage)
	MAP_NATIVE(APlayerController, execPasteFromClipboard)
	MAP_NATIVE(APlayerController, execCopyToClipboard)
	MAP_NATIVE(APlayerController, execGetDefaultURL)
	MAP_NATIVE(APlayerController, execUpdateURL)
	MAP_NATIVE(APlayerController, execClientTravel)
	MAP_NATIVE(APlayerController, execConsoleCommand)
	MAP_NATIVE(APlayerController, execGetServerNetworkAddress)
	MAP_NATIVE(APlayerController, execGetPlayerNetworkAddress)
	MAP_NATIVE(APlayerController, execSetNetSpeed)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(AController,Controller,Pawn)
VERIFY_CLASS_OFFSET_NODIE(AController,Controller,NavMeshPath_SearchExtent_Modifier)
VERIFY_CLASS_SIZE_NODIE(AController)
VERIFY_CLASS_OFFSET_NODIE(APlayerController,PlayerController,Player)
VERIFY_CLASS_OFFSET_NODIE(APlayerController,PlayerController,__InputMatchDelegate__Delegate)
VERIFY_CLASS_SIZE_NODIE(APlayerController)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
