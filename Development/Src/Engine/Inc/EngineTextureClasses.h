/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_TEXTURE_ENUMS
#define INCLUDED_ENGINE_TEXTURE_ENUMS 1

enum ETextureMipCount
{
    TMC_ResidentMips        =0,
    TMC_AllMips             =1,
    TMC_AllMipsBiased       =2,
    TMC_MAX                 =3,
};
#define FOREACH_ENUM_ETEXTUREMIPCOUNT(op) \
    op(TMC_ResidentMips) \
    op(TMC_AllMips) \
    op(TMC_AllMipsBiased) 
enum TextureMipGenSettings
{
    TMGS_FromTextureGroup   =0,
    TMGS_SimpleAverage      =1,
    TMGS_Sharpen0           =2,
    TMGS_Sharpen1           =3,
    TMGS_Sharpen2           =4,
    TMGS_Sharpen3           =5,
    TMGS_Sharpen4           =6,
    TMGS_Sharpen5           =7,
    TMGS_Sharpen6           =8,
    TMGS_Sharpen7           =9,
    TMGS_Sharpen8           =10,
    TMGS_Sharpen9           =11,
    TMGS_Sharpen10          =12,
    TMGS_NoMipmaps          =13,
    TMGS_LeaveExistingMips  =14,
    TMGS_Blur1              =15,
    TMGS_Blur2              =16,
    TMGS_Blur3              =17,
    TMGS_Blur4              =18,
    TMGS_Blur5              =19,
    TMGS_MAX                =20,
};
#define FOREACH_ENUM_TEXTUREMIPGENSETTINGS(op) \
    op(TMGS_FromTextureGroup) \
    op(TMGS_SimpleAverage) \
    op(TMGS_Sharpen0) \
    op(TMGS_Sharpen1) \
    op(TMGS_Sharpen2) \
    op(TMGS_Sharpen3) \
    op(TMGS_Sharpen4) \
    op(TMGS_Sharpen5) \
    op(TMGS_Sharpen6) \
    op(TMGS_Sharpen7) \
    op(TMGS_Sharpen8) \
    op(TMGS_Sharpen9) \
    op(TMGS_Sharpen10) \
    op(TMGS_NoMipmaps) \
    op(TMGS_LeaveExistingMips) \
    op(TMGS_Blur1) \
    op(TMGS_Blur2) \
    op(TMGS_Blur3) \
    op(TMGS_Blur4) \
    op(TMGS_Blur5) 
enum TextureGroup
{
    TEXTUREGROUP_World      =0,
    TEXTUREGROUP_WorldNormalMap=1,
    TEXTUREGROUP_WorldSpecular=2,
    TEXTUREGROUP_Character  =3,
    TEXTUREGROUP_CharacterNormalMap=4,
    TEXTUREGROUP_CharacterSpecular=5,
    TEXTUREGROUP_Weapon     =6,
    TEXTUREGROUP_WeaponNormalMap=7,
    TEXTUREGROUP_WeaponSpecular=8,
    TEXTUREGROUP_Vehicle    =9,
    TEXTUREGROUP_VehicleNormalMap=10,
    TEXTUREGROUP_VehicleSpecular=11,
    TEXTUREGROUP_Cinematic  =12,
    TEXTUREGROUP_Effects    =13,
    TEXTUREGROUP_EffectsNotFiltered=14,
    TEXTUREGROUP_Skybox     =15,
    TEXTUREGROUP_UI         =16,
    TEXTUREGROUP_Lightmap   =17,
    TEXTUREGROUP_RenderTarget=18,
    TEXTUREGROUP_MobileFlattened=19,
    TEXTUREGROUP_ProcBuilding_Face=20,
    TEXTUREGROUP_ProcBuilding_LightMap=21,
    TEXTUREGROUP_Shadowmap  =22,
    TEXTUREGROUP_ColorLookupTable=23,
    TEXTUREGROUP_Terrain_Heightmap=24,
    TEXTUREGROUP_Terrain_Weightmap=25,
    TEXTUREGROUP_ImageBasedReflection=26,
    TEXTUREGROUP_Bokeh      =27,
    TEXTUREGROUP_MAX        =28,
};
#define FOREACH_ENUM_TEXTUREGROUP(op) \
    op(TEXTUREGROUP_World) \
    op(TEXTUREGROUP_WorldNormalMap) \
    op(TEXTUREGROUP_WorldSpecular) \
    op(TEXTUREGROUP_Character) \
    op(TEXTUREGROUP_CharacterNormalMap) \
    op(TEXTUREGROUP_CharacterSpecular) \
    op(TEXTUREGROUP_Weapon) \
    op(TEXTUREGROUP_WeaponNormalMap) \
    op(TEXTUREGROUP_WeaponSpecular) \
    op(TEXTUREGROUP_Vehicle) \
    op(TEXTUREGROUP_VehicleNormalMap) \
    op(TEXTUREGROUP_VehicleSpecular) \
    op(TEXTUREGROUP_Cinematic) \
    op(TEXTUREGROUP_Effects) \
    op(TEXTUREGROUP_EffectsNotFiltered) \
    op(TEXTUREGROUP_Skybox) \
    op(TEXTUREGROUP_UI) \
    op(TEXTUREGROUP_Lightmap) \
    op(TEXTUREGROUP_RenderTarget) \
    op(TEXTUREGROUP_MobileFlattened) \
    op(TEXTUREGROUP_ProcBuilding_Face) \
    op(TEXTUREGROUP_ProcBuilding_LightMap) \
    op(TEXTUREGROUP_Shadowmap) \
    op(TEXTUREGROUP_ColorLookupTable) \
    op(TEXTUREGROUP_Terrain_Heightmap) \
    op(TEXTUREGROUP_Terrain_Weightmap) \
    op(TEXTUREGROUP_ImageBasedReflection) \
    op(TEXTUREGROUP_Bokeh) 
enum TextureAddress
{
    TA_Wrap                 =0,
    TA_Clamp                =1,
    TA_Mirror               =2,
    TA_MAX                  =3,
};
#define FOREACH_ENUM_TEXTUREADDRESS(op) \
    op(TA_Wrap) \
    op(TA_Clamp) \
    op(TA_Mirror) 
enum TextureFilter
{
    TF_Nearest              =0,
    TF_Linear               =1,
    TF_MAX                  =2,
};
#define FOREACH_ENUM_TEXTUREFILTER(op) \
    op(TF_Nearest) \
    op(TF_Linear) 
enum EPixelFormat
{
    PF_Unknown              =0,
    PF_A32B32G32R32F        =1,
    PF_A8R8G8B8             =2,
    PF_G8                   =3,
    PF_G16                  =4,
    PF_DXT1                 =5,
    PF_DXT3                 =6,
    PF_DXT5                 =7,
    PF_UYVY                 =8,
    PF_FloatRGB             =9,
    PF_FloatRGBA            =10,
    PF_DepthStencil         =11,
    PF_ShadowDepth          =12,
    PF_FilteredShadowDepth  =13,
    PF_R32F                 =14,
    PF_G16R16               =15,
    PF_G16R16F              =16,
    PF_G16R16F_FILTER       =17,
    PF_G32R32F              =18,
    PF_A2B10G10R10          =19,
    PF_A16B16G16R16         =20,
    PF_D24                  =21,
    PF_R16F                 =22,
    PF_R16F_FILTER          =23,
    PF_BC5                  =24,
    PF_V8U8                 =25,
    PF_A1                   =26,
    PF_FloatR11G11B10       =27,
    PF_A4R4G4B4             =28,
    PF_R5G6B5               =29,
    PF_MAX                  =30,
};
#define FOREACH_ENUM_EPIXELFORMAT(op) \
    op(PF_Unknown) \
    op(PF_A32B32G32R32F) \
    op(PF_A8R8G8B8) \
    op(PF_G8) \
    op(PF_G16) \
    op(PF_DXT1) \
    op(PF_DXT3) \
    op(PF_DXT5) \
    op(PF_UYVY) \
    op(PF_FloatRGB) \
    op(PF_FloatRGBA) \
    op(PF_DepthStencil) \
    op(PF_ShadowDepth) \
    op(PF_FilteredShadowDepth) \
    op(PF_R32F) \
    op(PF_G16R16) \
    op(PF_G16R16F) \
    op(PF_G16R16F_FILTER) \
    op(PF_G32R32F) \
    op(PF_A2B10G10R10) \
    op(PF_A16B16G16R16) \
    op(PF_D24) \
    op(PF_R16F) \
    op(PF_R16F_FILTER) \
    op(PF_BC5) \
    op(PF_V8U8) \
    op(PF_A1) \
    op(PF_FloatR11G11B10) \
    op(PF_A4R4G4B4) \
    op(PF_R5G6B5) 
enum TextureCompressionSettings
{
    TC_Default              =0,
    TC_Normalmap            =1,
    TC_Displacementmap      =2,
    TC_NormalmapAlpha       =3,
    TC_Grayscale            =4,
    TC_HighDynamicRange     =5,
    TC_OneBitAlpha          =6,
    TC_NormalmapUncompressed=7,
    TC_NormalmapBC5         =8,
    TC_OneBitMonochrome     =9,
    TC_SimpleLightmapModification=10,
    TC_VectorDisplacementmap=11,
    TC_MAX                  =12,
};
#define FOREACH_ENUM_TEXTURECOMPRESSIONSETTINGS(op) \
    op(TC_Default) \
    op(TC_Normalmap) \
    op(TC_Displacementmap) \
    op(TC_NormalmapAlpha) \
    op(TC_Grayscale) \
    op(TC_HighDynamicRange) \
    op(TC_OneBitAlpha) \
    op(TC_NormalmapUncompressed) \
    op(TC_NormalmapBC5) \
    op(TC_OneBitMonochrome) \
    op(TC_SimpleLightmapModification) \
    op(TC_VectorDisplacementmap) 
enum TextureFlipBookMethod
{
    TFBM_UL_ROW             =0,
    TFBM_UL_COL             =1,
    TFBM_UR_ROW             =2,
    TFBM_UR_COL             =3,
    TFBM_LL_ROW             =4,
    TFBM_LL_COL             =5,
    TFBM_LR_ROW             =6,
    TFBM_LR_COL             =7,
    TFBM_RANDOM             =8,
    TFBM_MAX                =9,
};
#define FOREACH_ENUM_TEXTUREFLIPBOOKMETHOD(op) \
    op(TFBM_UL_ROW) \
    op(TFBM_UL_COL) \
    op(TFBM_UR_ROW) \
    op(TFBM_UR_COL) \
    op(TFBM_LL_ROW) \
    op(TFBM_LL_COL) \
    op(TFBM_LR_ROW) \
    op(TFBM_LR_COL) \
    op(TFBM_RANDOM) 
enum EMovieStreamSource
{
    MovieStream_File        =0,
    MovieStream_Memory      =1,
    MovieStream_MAX         =2,
};
#define FOREACH_ENUM_EMOVIESTREAMSOURCE(op) \
    op(MovieStream_File) \
    op(MovieStream_Memory) 

#endif // !INCLUDED_ENGINE_TEXTURE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_TEXTURE_CLASSES
#define INCLUDED_ENGINE_TEXTURE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct FTextureGroupContainer
{
    BITFIELD TEXTUREGROUP_World:1;
    BITFIELD TEXTUREGROUP_WorldNormalMap:1;
    BITFIELD TEXTUREGROUP_WorldSpecular:1;
    BITFIELD TEXTUREGROUP_Character:1;
    BITFIELD TEXTUREGROUP_CharacterNormalMap:1;
    BITFIELD TEXTUREGROUP_CharacterSpecular:1;
    BITFIELD TEXTUREGROUP_Weapon:1;
    BITFIELD TEXTUREGROUP_WeaponNormalMap:1;
    BITFIELD TEXTUREGROUP_WeaponSpecular:1;
    BITFIELD TEXTUREGROUP_Vehicle:1;
    BITFIELD TEXTUREGROUP_VehicleNormalMap:1;
    BITFIELD TEXTUREGROUP_VehicleSpecular:1;
    BITFIELD TEXTUREGROUP_Cinematic:1;
    BITFIELD TEXTUREGROUP_Effects:1;
    BITFIELD TEXTUREGROUP_EffectsNotFiltered:1;
    BITFIELD TEXTUREGROUP_Skybox:1;
    BITFIELD TEXTUREGROUP_UI:1;
    BITFIELD TEXTUREGROUP_Lightmap:1;
    BITFIELD TEXTUREGROUP_RenderTarget:1;
    BITFIELD TEXTUREGROUP_MobileFlattened:1;
    BITFIELD TEXTUREGROUP_ProcBuilding_Face:1;
    BITFIELD TEXTUREGROUP_ProcBuilding_LightMap:1;
    BITFIELD TEXTUREGROUP_Shadowmap:1;
    BITFIELD TEXTUREGROUP_ColorLookupTable:1;
    BITFIELD TEXTUREGROUP_Terrain_Heightmap:1;
    BITFIELD TEXTUREGROUP_Terrain_Weightmap:1;
    BITFIELD TEXTUREGROUP_ImageBasedReflection:1;
    BITFIELD TEXTUREGROUP_Bokeh:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FTextureGroupContainer() {}
    FTextureGroupContainer(EEventParm)
    {
        appMemzero(this, sizeof(FTextureGroupContainer));
    }
};

class UTexture : public USurface
{
public:
    //## BEGIN PROPS Texture
    BITFIELD SRGB:1;
    BITFIELD RGBE:1;
    BITFIELD bIsSourceArtUncompressed:1;
    BITFIELD CompressionNoAlpha:1;
    BITFIELD CompressionNone:1;
    BITFIELD CompressionNoMipmaps_DEPRECATED:1;
    BITFIELD CompressionFullDynamicRange:1;
    BITFIELD DeferCompression:1;
    BITFIELD NeverStream:1;
    BITFIELD bDitherMipMapAlpha:1;
    BITFIELD bPreserveBorderR:1;
    BITFIELD bPreserveBorderG:1;
    BITFIELD bPreserveBorderB:1;
    BITFIELD bPreserveBorderA:1;
    BITFIELD bNoTiling:1;
    BITFIELD bForcePVRTC4:1;
    BITFIELD bAsyncResourceReleaseHasBeenStarted:1;
    BITFIELD bUseCinematicMipLevels:1;
    FLOAT UnpackMin[4];
    FLOAT UnpackMax[4];
    FByteBulkData SourceArt;
    BYTE CompressionSettings;
    BYTE Filter;
    BYTE LODGroup;
    BYTE CachedLODGroup;
    BYTE MipGenSettings;
    INT LODBias;
    INT CachedCombinedLODBias;
    INT NumCinematicMipLevels;
#if WITH_EDITORONLY_DATA
    FStringNoInit SourceFilePath;
    FStringNoInit SourceFileTimestamp;
#endif // WITH_EDITORONLY_DATA
    FTextureResource* Resource;
#if WITH_EDITORONLY_DATA
    FGuid LightingGuid;
#endif // WITH_EDITORONLY_DATA
    FLOAT AdjustBrightness;
    FLOAT AdjustBrightnessCurve;
    FLOAT AdjustVibrance;
    FLOAT AdjustSaturation;
    FLOAT AdjustRGBCurve;
    FLOAT AdjustHue;
    INT InternalFormatLODBias;
    //## END PROPS Texture

    DECLARE_ABSTRACT_CLASS(UTexture,USurface,0,Engine)
	/**
	 * Resets the resource for the texture.
	 */
	void ReleaseResource();

	/**
	 * Creates a new resource for the texture, and updates any cached references to the resource.
	 */
	virtual void UpdateResource();

	/**
	 * Implemented by subclasses to create a new resource for the texture.
	 */
	virtual FTextureResource* CreateResource() PURE_VIRTUAL(UTexture::CreateResource,return NULL;);

	/**
	 * Returns the cached combined LOD bias based on texture LOD group and LOD bias.
	 *
	 * @return	LOD bias
	 */
	INT GetCachedLODBias() const;

	/**
	 * Compresses the texture based on the compression settings. Make sure to update UTexture::PostEditChange
	 * if you add any variables that might require recompression.
	 */
	virtual void Compress();

	/**
	 * Returns whether or not the texture has source art at all
	 *
	 * @return	TRUE if the texture has source art. FALSE, otherwise.
	 */
	virtual UBOOL HasSourceArt() const { return FALSE; }

	/**
	 * Compresses the source art, if needed
	 */
	virtual void CompressSourceArt() {}

	/**
	 * Returns uncompressed source art.
	 *
	 * @param	OutSourceArt	[out]A buffer containing uncompressed source art.
	 */
	virtual void GetUncompressedSourceArt( TArray<BYTE>& OutSourceArt ) {}

	/**
	 * Sets the given buffer as the uncompressed source art. 
	 *
	 * @param	UncompressedData	Uncompressed source art data. 
	 * @param	DataSize			Size of the UncompressedData.
	 */
	virtual void SetUncompressedSourceArt( const void* UncompressedData, INT DataSize ) {}

	/**
	 * Sets the given buffer as the compressed source art.
	 *
	 * @param	CompressedData		Compressed source art data. 
	 * @param	DataSize			Size of the CompressedData.
	 */
	virtual void SetCompressedSourceArt( const void* CompressedData, INT DataSize ) {}

	/**
	 * @return The material value type of this texture.
	 */
	virtual EMaterialValueType GetMaterialType() PURE_VIRTUAL(UTexture::GetMaterialType,return MCT_Texture;);

	/**
	 * Waits until all streaming requests for this texture has been fully processed.
	 */
	virtual void WaitForStreaming()
	{
	}
	
	/**
	 * Updates the streaming status of the texture and performs finalization when appropriate. The function returns
	 * TRUE while there are pending requests in flight and updating needs to continue.
	 *
	 * @param bWaitForMipFading	Whether to wait for Mip Fading to complete before finalizing.
	 * @return					TRUE if there are requests in flight, FALSE otherwise
	 */
	virtual UBOOL UpdateStreamingStatus( UBOOL bWaitForMipFading = FALSE )
	{
		return FALSE;
	}

	// UObject interface.
	virtual void PreEditChange(UProperty* PropertyThatChanged);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();
	virtual void PreSave();
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	/**
	 * Used by various commandlets to purge editor only and platform-specific data from various objects
	 * 
	 * @param PlatformsToKeep Platforms for which to keep platform-specific data
	 * @param bStripLargeEditorData If TRUE, data used in the editor, but large enough to bloat download sizes, will be removed
	 */
	virtual void StripData(UE3::EPlatformType PlatformsToKeep, UBOOL bStripLargeEditorData);

	/**
	 *	Gets the average brightness of the texture (in linear space)
	 *
	 *	@param	bIgnoreTrueBlack		If TRUE, then pixels w/ 0,0,0 rgb values do not contribute.
	 *	@param	bUseGrayscale			If TRUE, use gray scale else use the max color component.
	 *
	 *	@return	FLOAT					The average brightness of the texture
	 */
	virtual FLOAT GetAverageBrightness(UBOOL bIgnoreTrueBlack, UBOOL bUseGrayscale);
	
	/** Helper functions for text output of texture properties... */
	static const TCHAR* GetCompressionSettingsString(TextureCompressionSettings InCompressionSettings);
	static TextureCompressionSettings GetCompressionSettingsFromString(const TCHAR* InCompressionSettingsStr);
	static const TCHAR* GetPixelFormatString(EPixelFormat InPixelFormat);
	static EPixelFormat GetPixelFormatFromString(const TCHAR* InPixelFormatStr);
	static const TCHAR* GetTextureFilterString(TextureFilter InFilter);
	static TextureFilter GetTextureFilterFromString(const TCHAR* InFilterStr);
	static const TCHAR* GetTextureAddressString(TextureAddress InAddress);
	static TextureAddress GetTextureAddressFromString(const TCHAR* InAddressStr);
	static const TCHAR* GetTextureGroupString(TextureGroup InGroup);
	static TextureGroup GetTextureGroupFromString(const TCHAR* InGroupStr);
	static const TCHAR* GetMipGenSettingsString(TextureMipGenSettings InEnum);
	// @param	bTextureGroup	TRUE=TexturGroup, FALSE=Texture otherwise
	static TextureMipGenSettings GetMipGenSettingsFromString(const TCHAR* InStr, UBOOL bTextureGroup);

	static DWORD GetTextureGroupBitfield( const FTextureGroupContainer& TextureGroups );

	virtual void GetTextureOffset_RenderThread(FLinearColor& UVOffset) const {}

	/**
	 * @return TRUE if the compression type is a normal map compression type
	 */
	bool IsNormalMap()
	{
		return	(CompressionSettings == TC_Normalmap) || (CompressionSettings == TC_NormalmapAlpha) || 
				(CompressionSettings == TC_NormalmapBC5) || (CompressionSettings == TC_NormalmapUncompressed);
	}

	/**
	 * Calculates the size of this texture if it had MipCount miplevels streamed in.
	 *
	 * @param	MipCount	Which mips to calculate size for.
	 * @return	Total size of all specified mips, in bytes
	 */
	virtual INT CalcTextureMemorySize( ETextureMipCount MipCount ) const
	{
		return 0;
	}

	virtual const FGuid& GetLightingGuid() const
	{
#if WITH_EDITORONLY_DATA
		return LightingGuid;
#else
		static const FGuid NullGuid( 0, 0, 0, 0 );
		return NullGuid; 
#endif // WITH_EDITORONLY_DATA
	}

	virtual void SetLightingGuid()
	{
#if WITH_EDITORONLY_DATA
		LightingGuid = appCreateGuid();
#endif // WITH_EDITORONLY_DATA
	}
};

struct FTexture2DMipMap
{
    FTextureMipBulkData Data;
    INT SizeX;
    INT SizeY;

		/**
		 * Special serialize function passing the owning UObject along as required by FUnytpedBulkData
		 * serialization.
		 *
		 * @param	Ar		Archive to serialize with
		 * @param	Owner	UObject this structure is serialized within
		 * @param	MipIdx	Current mip being serialized
		 */
		void Serialize( FArchive& Ar, UObject* Owner, INT MipIdx );
	
};

class UTexture2D : public UTexture
{
public:
    //## BEGIN PROPS Texture2D
    TIndirectArray<FTexture2DMipMap> Mips;
    TIndirectArray<FTexture2DMipMap> CachedPVRTCMips;
    TIndirectArray<FTexture2DMipMap> CachedATITCMips;
    TIndirectArray<FTexture2DMipMap> CachedETCMips;
    INT CachedFlashMipsMaxResolution;
    FTextureMipBulkData CachedFlashMips;
    INT SizeX;
    INT SizeY;
    INT OriginalSizeX;
    INT OriginalSizeY;
    BYTE Format;
    BYTE AddressX;
    BYTE AddressY;
    SCRIPT_ALIGN;
    BITFIELD bIsEditorOnly:1;
    BITFIELD bIsStreamable:1;
    BITFIELD bHasCancelationPending:1;
    BITFIELD bHasBeenLoadedFromPersistentArchive:1;
    BITFIELD bForceMiplevelsToBeResident:1;
    BITFIELD bGlobalForceMipLevelsToBeResident:1;
    BITFIELD bIsCompositingSource:1;
    BITFIELD bHasBeenPaintedInEditor:1;
    FLOAT ForceMipLevelsToBeResidentTimestamp;
    FName TextureFileCacheName;
    FGuid TextureFileCacheGuid;
    INT RequestedMips;
    INT ResidentMips;
    INT MipsToRemoveOnCompress;
    mutable FThreadSafeCounter PendingMipChangeRequestStatus;
private:
    TArrayNoInit<BYTE> SystemMemoryData;
    TLinkedList<UTexture2D*> StreamableTexturesLink;
    INT StreamingIndex;
public:
    INT MipTailBaseIdx;
    FTexture2DResourceMem* ResourceMem;
    INT FirstResourceMemMip;
    FLOAT Timer;
    //## END PROPS Texture2D

    void SetForceMipLevelsToBeResident(FLOAT Seconds,INT CinematicTextureGroups=0);
    DECLARE_FUNCTION(execSetForceMipLevelsToBeResident)
    {
        P_GET_FLOAT(Seconds);
        P_GET_INT_OPTX(CinematicTextureGroups,0);
        P_FINISH;
        this->SetForceMipLevelsToBeResident(Seconds,CinematicTextureGroups);
    }
    DECLARE_FUNCTION(execCreate);
    DECLARE_CLASS(UTexture2D,UTexture,0,Engine)
	// Static private variables.
private:
	/** First streamable texture link. Not handled by GC as BeginDestroy automatically unlinks.	*/
	static TLinkedList<UTexture2D*>* FirstStreamableLink;
	/** Current streamable texture link for iteration over textures. Not handled by GC as BeginDestroy automatically unlinks. */
	static TLinkedList<UTexture2D*>* CurrentStreamableLink;
	/** Number of streamable textures. */
	static INT NumStreamableTextures;

public:

	// UObject interface.
	void InitializeIntrinsicPropertyValues();
	virtual void Serialize(FArchive& Ar);
#if !CONSOLE
	// SetLinker is only virtual on consoles.
	virtual void SetLinker( ULinkerLoad* L, INT I );
#endif
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 * Called after the garbage collection mark phase on unreachable objects.
	 */
	virtual void BeginDestroy();
	/**
 	 * Called after object and all its dependencies have been serialized.
	 */
	virtual void PostLoad();
	/**
 	 * Called after object has been duplicated.
	 */
	virtual void PostDuplicate();

	/** 
	 * Generates a GUID for the texture if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void GenerateTextureFileCacheGUID(UBOOL bForceGeneration=FALSE);

	// USurface interface
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }
	virtual FLOAT GetSurfaceHeight() const { return SizeY; }

	/**
	 * @return Width/height this surface was before cooking or other modifications
	 */
	virtual FLOAT GetOriginalSurfaceWidth() const { return OriginalSizeX; }
	virtual FLOAT GetOriginalSurfaceHeight() const { return OriginalSizeY; }

	// UTexture interface.
	virtual FTextureResource* CreateResource();
	virtual void Compress();
	virtual EMaterialValueType GetMaterialType() { return MCT_Texture2D; }

	/**
	 * Scale the actual texture data of the top mip. This allows non-uniform scaling - use with care :)
	 */
	void ResizeTexture(const FVector2D& Scale);
	void ResizeTexture(FLOAT Scale)
	{
		FVector2D Scale2D(Scale, Scale);
		ResizeTexture(Scale2D);
	}

	/**
	 * Creates a new resource for the texture, and updates any cached references to the resource.
	 */
	virtual void UpdateResource();

	/**
	 * Used by various commandlets to purge editor only and platform-specific data from various objects
	 * 
	 * @param PlatformsToKeep Platforms for which to keep platform-specific data
	 * @param bStripLargeEditorData If TRUE, data used in the editor, but large enough to bloat download sizes, will be removed
	 */
	virtual void StripData(UE3::EPlatformType PlatformsToKeep, UBOOL bStripLargeEditorData);

	/**
	 *	Gets the average brightness of the texture in linear space
	 *
	 *	@param	bIgnoreTrueBlack		If TRUE, then pixels w/ 0,0,0 rgb values do not contribute.
	 *	@param	bUseGrayscale			If TRUE, use gray scale else use the max color component.
	 *
	 *	@return	FLOAT					The average brightness of the texture
	 */
	virtual FLOAT GetAverageBrightness(UBOOL bIgnoreTrueBlack, UBOOL bUseGrayscale);

	// UTexture2D interface.
	void Init(UINT InSizeX,UINT InSizeY,EPixelFormat InFormat);
	void LegacySerialize(FArchive& Ar);

	/**
	 * return the texture/pixel format that should be used internally for an incoming texture load request, if different onload conversion is required 
	 *
	 *	@param	Format					source texture format	
	 *	@param	Platform				destination platform, useful during cooking
	 */
	static EPixelFormat GetEffectivePixelFormat( const EPixelFormat Format, UBOOL bSRGB, UE3::EPlatformType Platform = UE3::PLATFORM_Unknown );

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * Calculates the size of this texture in bytes if it had MipCount miplevels streamed in.
	 *
	 * @param	MipCount	Number of mips to calculate size for, counting from the smallest 1x1 mip-level and up.
	 * @return	Size of MipCount mips in bytes
	 */
	INT CalcTextureMemorySize( INT MipCount ) const;

	/**
	 * Calculates the size of this texture if it had MipCount miplevels streamed in.
	 *
	 * @param	MipCount	Which mips to calculate size for.
	 * @return	Total size of all specified mips, in bytes
	 */
	virtual INT CalcTextureMemorySize( ETextureMipCount MipCount ) const;

	/**
	 * Returns the size of this texture in bytes on 360 if it had MipCount miplevels streamed in.
	 *
	 * @param	MipCount	Number of toplevel mips to calculate size for
	 * @return	size of top mipcount mips in bytes
	 */
	INT Get360Size( INT MipCount ) const;

	/**
	 *	Get the CRC of the source art pixels.
	 *
	 *	@param	[out]	OutSourceCRC		The CRC value of the source art pixels.
	 *
	 *	@return			UBOOL				TRUE if successful, FALSE if failed (or no source art)
	 */
	UBOOL GetSourceArtCRC(DWORD& OutSourceCRC);

	/**
	 * Returns whether or not the texture has source art at all
	 *
	 * @return	TRUE if the texture has source art. FALSE, otherwise.
	 */
	virtual UBOOL HasSourceArt() const;

	/**
	 * Compresses the source art, if needed
	 */
	virtual void CompressSourceArt();

	/**
	 * Returns uncompressed source art.
	 *
	 * @param	OutSourceArt	[out]A buffer containing uncompressed source art.
	 */
	virtual void GetUncompressedSourceArt( TArray<BYTE>& OutSourceArt );

	/**
	 * Sets the given buffer as the uncompressed source art.
	 *
	 * @param	UncompressedData	Uncompressed source art data. 
	 * @param	DataSize			Size of the UncompressedData.
	 */
	virtual void SetUncompressedSourceArt( const void* UncompressedData, INT DataSize );
	
	/**
	 * Sets the given buffer as the compressed source art. 
	 *
	 * @param	CompressedData		Compressed source art data. 
	 * @param	DataSize			Size of the CompressedData.
	 */
	virtual void SetCompressedSourceArt( const void* CompressedData, INT DataSize );
	
	/**
	 *	See if the source art of the two textures matches...
	 *
	 *	@param		InTexture		The texture to compare it to
	 *
	 *	@return		UBOOL			TRUE if they matche, FALSE if not
	 */
	UBOOL HasSameSourceArt(UTexture2D* InTexture);
	
	UBOOL HasAlphaChannel() const 
	{
		return Format == PF_A8R8G8B8 || Format == PF_DXT3 || Format == PF_DXT5;
	}

	/**
	 * Returns if the texture should be automatically biased to -1..1 range
	 */
	UBOOL BiasNormalMap() const;

	/**
	 * Returns whether the texture is ready for streaming aka whether it has had InitRHI called on it.
	 *
	 * @return TRUE if initialized and ready for streaming, FALSE otherwise
	 */
	UBOOL IsReadyForStreaming();

	/**
	 * Waits until all streaming requests for this texture has been fully processed.
	 */
	virtual void WaitForStreaming();
	
	/**
	 * Updates the streaming status of the texture and performs finalization when appropriate. The function returns
	 * TRUE while there are pending requests in flight and updating needs to continue.
	 *
	 * @param bWaitForMipFading	Whether to wait for Mip Fading to complete before finalizing.
	 * @return					TRUE if there are requests in flight, FALSE otherwise
	 */
	virtual UBOOL UpdateStreamingStatus( UBOOL bWaitForMipFading = FALSE );

	/**
	 * Tries to cancel a pending mip change request. Requests cannot be canceled if they are in the
	 * finalization phase.
	 *
	 * @param	TRUE if cancelation was successful, FALSE otherwise
	 */
	UBOOL CancelPendingMipChangeRequest();

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	/**
	 * Returns whether miplevels should be forced resident.
	 *
	 * @return TRUE if either transient or serialized override requests miplevels to be resident, FALSE otherwise
	 */
	UBOOL ShouldMipLevelsBeForcedResident() const;

	/**
	 * Whether all miplevels of this texture have been fully streamed in, LOD settings permitting.
	 */
	UBOOL IsFullyStreamedIn();

	/**
	 * Returns a reference to the global list of streamable textures.
	 *
	 * @return reference to global list of streamable textures.
	 */
	static TLinkedList<UTexture2D*>*& GetStreamableList();

	/**
	 * Returns a reference to the current streamable link.
	 *
	 * @return reference to current streamable link
	 */
	static TLinkedList<UTexture2D*>*& GetCurrentStreamableLink();

	/**
	 * Links texture to streamable list and updates streamable texture count.
	 */
	void LinkStreaming();

	/**
	 * Unlinks texture from streamable list, resets CurrentStreamableLink if it matches
	 * StreamableTexturesLink and also updates the streamable texture count.
	 */
	void UnlinkStreaming();
	
	/**
	 * Returns the number of streamable textures, maintained by link/ unlink code
	 *
	 * @return	Number of streamable textures
	 */
	static INT GetNumStreamableTextures();

	/**
	 * Cancels any pending texture streaming actions if possible.
	 * Returns when no more async loading requests are in flight.
	 */
	static void CancelPendingTextureStreaming();

	/**
	 * Initialize the GPU resource memory that will be used for the bulk mip data
	 * This memory is allocated based on the SizeX,SizeY of the texture and the first mip used
	 *
	 * @param FirstMipIdx first mip that will be resident	
	 * @return FTexture2DResourceMem container for the allocated GPU resource mem
	 */
	class FTexture2DResourceMem* InitResourceMem(INT FirstMipIdx);

	/**
	 * Calculates and returns the corresponding ResourceMem parameters for this texture.
	 *
	 * @param FirstMipIdx		Index of the largest mip-level stored within a seekfree (level) package
	 * @param OutSizeX			[out] Width of the stored largest mip-level
	 * @param OutSizeY			[out] Height of the stored largest mip-level
	 * @param OutNumMips		[out] Number of stored mips
	 * @param OutTexCreateFlags	[out] ETextureCreateFlags bit flags
	 * @return					TRUE if the texture should use a ResourceMem. If FALSE, none of the out parameters will be filled in.
	 */
	UBOOL GetResourceMemSettings(INT FirstMipIdx, INT& OutSizeX, INT& OutSizeY, INT& OutNumMips, DWORD& OutTexCreateFlags);

	/**
	 * Creates a platform-specific ResourceMem. If an AsyncCounter is provided, it will allocate asynchronously.
	 *
	 * @param SizeX				Width of the stored largest mip-level
	 * @param SizeY				Height of the stored largest mip-level
	 * @param NumMips			Number of stored mips
	 * @param TexCreateFlags	ETextureCreateFlags bit flags
	 * @param AsyncCounter		If specified, starts an async allocation. If NULL, allocates memory immediately.
	 * @return					Platform-specific ResourceMem.
	 */
	static FTexture2DResourceMem* CreateResourceMem(INT SizeX, INT SizeY, INT NumMips, EPixelFormat Format, DWORD TexCreateFlags, FThreadSafeCounter* AsyncCounter);

#if WITH_EDITOR
	/** Recreates system memory data for textures that do not use GPU resources (1 bit textures).  Should be called when data in the top level mip changes **/
	void UpdateSystemMemoryData();

	/**
	 *	Asynchronously update a set of regions of a texture with new data.
	 *	@param MipIndex - the mip number to update
	 *	@param NumRegions - number of regions to update
	 *	@param Regions - regions to update
	 *	@param SrcPitch - the pitch of the source data in bytes
	 *	@param SrcBpp - the size one pixel data in bytes
	 *	@param SrcData - the source data
	 *  @param bFreeData - if TRUE, the SrcData and Regions pointers will be freed after the update.
	 */
	void UpdateTextureRegions( INT MipIndex, UINT NumRegions, FUpdateTextureRegion2D* Regions, UINT SrcPitch, UINT SrcBpp, BYTE* SrcData, UBOOL bFreeData );
#endif

	/** Called after an editor or undo operation is formed on texture
	*/
	virtual void PostEditUndo();

	/** Returns system memory data for read only purposes **/
	const TArray<BYTE>& AccessSystemMemoryData() const { return SystemMemoryData; }
	
	friend struct FStreamingManagerTexture;
	friend struct FStreamingTexture;
};

class UTextureFlipBook : public UTexture2D, public FTickableObject
{
public:
    //## BEGIN PROPS TextureFlipBook
    FLOAT TimeIntoMovie;
    FLOAT TimeSinceLastFrame;
    FLOAT HorizontalScale;
    FLOAT VerticalScale;
    BITFIELD bPaused:1;
    BITFIELD bStopped:1;
    BITFIELD bLooping:1;
    BITFIELD bAutoPlay:1;
    INT HorizontalImages;
    INT VerticalImages;
    BYTE FBMethod;
    FLOAT FrameRate;
    FLOAT FrameTime;
    INT CurrentRow;
    INT CurrentColumn;
    FLOAT RenderOffsetU;
    FLOAT RenderOffsetV;
    FRenderCommandFence* ReleaseResourcesFence;
    //## END PROPS TextureFlipBook

    virtual void Play();
    virtual void Pause();
    virtual void Stop();
    virtual void SetCurrentFrame(INT Row,INT Col);
    DECLARE_FUNCTION(execPlay)
    {
        P_FINISH;
        this->Play();
    }
    DECLARE_FUNCTION(execPause)
    {
        P_FINISH;
        this->Pause();
    }
    DECLARE_FUNCTION(execStop)
    {
        P_FINISH;
        this->Stop();
    }
    DECLARE_FUNCTION(execSetCurrentFrame)
    {
        P_GET_INT(Row);
        P_GET_INT(Col);
        P_FINISH;
        this->SetCurrentFrame(Row,Col);
    }
    DECLARE_CLASS(UTextureFlipBook,UTexture2D,0,Engine)
	// FTickableObject interface

	/**
	 * Updates the movie texture if necessary by requesting a new frame from the decoder taking into account both
	 * game and movie framerate.
	 *
	 * @param DeltaTime		Time (in seconds) that has passed since the last time this function has been called.
	 */
	virtual void Tick( FLOAT DeltaTime );

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}
	
	// UObject interface.
	/**
	 * Initializes property values for intrinsic classes.  It is called immediately after the class default object
	 * is initialized against its archetype, but before any objects of this class are created.
	 */
	void InitializeIntrinsicPropertyValues();
	/**
	 * Serializes the compressed movie data.
	 *
	 * @param Ar	FArchive to serialize RawData with.
	 */
	virtual void Serialize(FArchive& Ar);
	
	/**
	 * Postload initialization of movie texture. Creates decoder object and retriever first frame.
	 */
	virtual void PostLoad();
	/**
	 * PostEditChange - gets called whenever a property is either edited via the Editor or the "set" console command.
	 *
	 * @param PropertyThatChanged	Property that changed
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& /*PropertyChangedEvent*/);

	/**
	 * Called after the garbage collection mark phase on unreachable objects.
	 */
	virtual void BeginDestroy();
	/**
	 * Called to check if the object is ready for FinishDestroy.  This is called after BeginDestroy to check the completion of the
	 * potentially asynchronous object cleanup.
	 * @return True if the object's asynchronous cleanup has completed and it is ready for FinishDestroy to be called.
	 */
	virtual UBOOL IsReadyForFinishDestroy();
	/**
	 * We need to ensure that the decoder doesn't have any references to RawData before destructing it.
	 */
	virtual void FinishDestroy();

	// Thumbnail interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	// FlipBook texture interface...
	void			SetStartFrame();
	virtual UBOOL	IsAFlipBook()	{ return true;	}
	virtual void	GetFlipBookOffset(FVector& Offset)
	{
		Offset.X = CurrentColumn	* HorizontalScale;
		Offset.Y = CurrentRow		* VerticalScale;
	}
	virtual void	GetFlipBookScale(FVector& Scale)
	{
		Scale.X	= HorizontalScale;
		Scale.Y = VerticalScale;
	}

	/**
	 *	Retrieve the UV offset
	 *
	 *	@param	UVOffset	FVector2D to fill in with the offset
	 */
	void GetTextureOffset(FVector2D& UVOffset);
	/**
	 *	Retrieve the UV offset
	 *
	 *	@param	UVOffset	FLinearColor to fill in with the offset
	 */
	virtual void GetTextureOffset_RenderThread(FLinearColor& UVOffset) const;

	/**	
	 *	Set the texture offset (pass it to the render thread)
	 */
	void SetTextureOffset();
	/**
	 *	Set the texture offset in the render thread
	 *
	 *	@param	UOffset		The value to set for the U offset
	 *	@param	VOffset		The value to set for the V offset
	 */
	void SetTextureOffset_RenderThread(FLOAT UOffset, FLOAT VOffset);
};

struct FSourceTexture2DRegion
{
    INT OffsetX;
    INT OffsetY;
    INT SizeX;
    INT SizeY;
    INT DestOffsetX;
    INT DestOffsetY;
    class UTexture2D* Texture2D;

    /** Constructors */
    FSourceTexture2DRegion() {}
    FSourceTexture2DRegion(EEventParm)
    {
        appMemzero(this, sizeof(FSourceTexture2DRegion));
    }
};

class UTexture2DComposite : public UTexture
{
public:
    //## BEGIN PROPS Texture2DComposite
    TArrayNoInit<struct FSourceTexture2DRegion> SourceRegions;
    INT MaxTextureSize;
    INT DestSizeX;
    INT DestSizeY;
    //## END PROPS Texture2DComposite

    UBOOL SourceTexturesFullyStreamedIn();
    void UpdateCompositeTexture(INT NumMipsToGenerate);
    void ResetSourceRegions();
    DECLARE_FUNCTION(execSourceTexturesFullyStreamedIn)
    {
        P_FINISH;
        *(UBOOL*)Result=this->SourceTexturesFullyStreamedIn();
    }
    DECLARE_FUNCTION(execUpdateCompositeTexture)
    {
        P_GET_INT(NumMipsToGenerate);
        P_FINISH;
        this->UpdateCompositeTexture(NumMipsToGenerate);
    }
    DECLARE_FUNCTION(execResetSourceRegions)
    {
        P_FINISH;
        this->ResetSourceRegions();
    }
    DECLARE_CLASS(UTexture2DComposite,UTexture,0,Engine)
private:
	/**
	 * Calculate the first available mip from a set of textures based on the LOD bias for each
	 * texture.
	 *
	 * @return first available mip index from the source regions
	 */
	INT GetFirstAvailableMipIndex(const TArray<FSourceTexture2DRegion>& ValidRegions);

	/**
	* Locks each region of the source RHI texture 2d resources and copies the block of data
	* for that region to the destination mip buffer. This is done for all mip levels.
	*
	* (Only called by the rendering thread)
	*/
	void RenderThread_CopyRectRegions(const TArray<FSourceTexture2DRegion>& ValidRegions);

	// UTexture interface.
	virtual FTextureResource* CreateResource();
	virtual EMaterialValueType GetMaterialType()  { return MCT_Texture2D; }

	// USurface interface.
	virtual FLOAT GetSurfaceWidth() const;
	virtual FLOAT GetSurfaceHeight() const;

	// UObject interface.
	virtual void Serialize(FArchive& Ar);
};

class UTexture2DDynamic : public UTexture
{
public:
    //## BEGIN PROPS Texture2DDynamic
    INT SizeX;
    INT SizeY;
    BYTE Format;
    INT NumMips;
    BITFIELD bIsResolveTarget:1;
    SCRIPT_ALIGN;
    //## END PROPS Texture2DDynamic

    void Init(INT InSizeX,INT InSizeY,BYTE InFormat=2,UBOOL InIsResolveTarget=FALSE);
    virtual void UpdateMip(INT MipIdx,const TArray<BYTE>& MipData);
    virtual void UpdateMipFromJPEG(INT MipIdx,const TArray<BYTE>& MipData);
    DECLARE_FUNCTION(execInit)
    {
        P_GET_INT(InSizeX);
        P_GET_INT(InSizeY);
        P_GET_BYTE_OPTX(InFormat,2);
        P_GET_UBOOL_OPTX(InIsResolveTarget,FALSE);
        P_FINISH;
        this->Init(InSizeX,InSizeY,InFormat,InIsResolveTarget);
    }
    DECLARE_FUNCTION(execUpdateMip)
    {
        P_GET_INT(MipIdx);
        P_GET_TARRAY_REF(BYTE,MipData);
        P_FINISH;
        this->UpdateMip(MipIdx,MipData);
    }
    DECLARE_FUNCTION(execUpdateMipFromJPEG)
    {
        P_GET_INT(MipIdx);
        P_GET_TARRAY_REF(BYTE,MipData);
        P_FINISH;
        this->UpdateMipFromJPEG(MipIdx,MipData);
    }
    DECLARE_FUNCTION(execCreate);
    DECLARE_CLASS(UTexture2DDynamic,UTexture,0,Engine)
public:
	// UTexture interface.
	virtual FTextureResource* CreateResource();
	virtual EMaterialValueType GetMaterialType()  { return MCT_Texture2D; }

	// USurface interface.
	virtual FLOAT GetSurfaceWidth() const;
	virtual FLOAT GetSurfaceHeight() const;

	// UObject interface.
	virtual void Serialize(FArchive& Ar);
};

class UTextureCube : public UTexture
{
public:
    //## BEGIN PROPS TextureCube
    INT SizeX;
    INT SizeY;
    BYTE Format;
    INT NumMips;
    BITFIELD bIsCubemapValid:1;
    class UTexture2D* FacePosX;
    class UTexture2D* FaceNegX;
    class UTexture2D* FacePosY;
    class UTexture2D* FaceNegY;
    class UTexture2D* FacePosZ;
    class UTexture2D* FaceNegZ;
    //## END PROPS TextureCube

    DECLARE_CLASS(UTextureCube,UTexture,0,Engine)
	// UObject interface.
	void InitializeIntrinsicPropertyValues();
	virtual void Serialize(FArchive& Ar);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();

	// Thumbnail interface.
	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	// USurface interface
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }
	virtual FLOAT GetSurfaceHeight() const { return SizeY; }

	// UTexture interface
	virtual FTextureResource* CreateResource();
	virtual EMaterialValueType GetMaterialType() { return MCT_TextureCube; }
	
	// UTextureCube interface

	/**
	 * Validates cubemap which entails verifying that all faces are non-NULL and share the same format, width, height and number of
	 * miplevels. The results are cached in the respective mirrored properties and bIsCubemapValid is set accordingly.
	 */
	void Validate();

	/**
	 * Returns the face associated with the passed in index.
	 *
	 * @param	FaceIndex	index of face to return
	 * @return	texture object associated with passed in face index
	 */
	UTexture2D* GetFace( INT FaceIndex ) const;

	/**
	 * Sets the face associated with the passed in index.
	 *
	 * @param	FaceIndex	index of face to return
	 * @param	FaceTexture	texture object to associate with passed in face index
	 */
	void SetFace(INT FaceIndex,UTexture2D* FaceTexture);

	/**
	 * Returns the size of this texture in bytes on 360 if it had MipCount miplevels streamed in.
	 *
	 * @param	MipCount	Number of toplevel mips to calculate size for
	 * @return	size of top mipcount mips in bytes
	 */
	INT Get360Size( INT MipCount ) const;

	/**
	 * Calculates the size of this texture if it had MipCount miplevels streamed in.
	 *
	 * @param	MipCount	Which mips to calculate size for.
	 * @return	Total size of all specified mips, in bytes
	 */
	virtual INT CalcTextureMemorySize( ETextureMipCount MipCount ) const;
};

class UTextureMovie : public UTexture
{
public:
    //## BEGIN PROPS TextureMovie
    INT SizeX;
    INT SizeY;
    BYTE Format;
    BYTE AddressX;
    BYTE AddressY;
    BYTE MovieStreamSource;
    class UClass* DecoderClass;
    class UCodecMovie* Decoder;
    BITFIELD Paused:1;
    BITFIELD Stopped:1;
    BITFIELD Looping:1;
    BITFIELD ResetOnLastFrame:1;
    BITFIELD AutoPlay:1;
    SCRIPT_ALIGN;
    FByteBulkData Data;
    FRenderCommandFence* ReleaseCodecFence;
    //## END PROPS TextureMovie

    virtual void Play();
    virtual void Pause();
    virtual void Stop();
    DECLARE_FUNCTION(execPlay)
    {
        P_FINISH;
        this->Play();
    }
    DECLARE_FUNCTION(execPause)
    {
        P_FINISH;
        this->Pause();
    }
    DECLARE_FUNCTION(execStop)
    {
        P_FINISH;
        this->Stop();
    }
    DECLARE_CLASS(UTextureMovie,UTexture,0,Engine)
	// USurface interface
	
	/**
	* @return width of surface
	*/
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }

	/**
	* @return height of surface
	*/
	virtual FLOAT GetSurfaceHeight() const { return SizeY; }

	// UTexture interface

	/**
	* Create a new movie texture resource
	*
	* @return newly created FTextureMovieResource
	*/
	virtual FTextureResource* CreateResource();

	/**
	* Materials should treat a movie texture like a regular 2D texture resource.
	*
	* @return EMaterialValueType for this resource
	*/
	virtual EMaterialValueType GetMaterialType();

	// UObject interface.
	
	/**
	 * Serializes the compressed movie data.
	 *
	 * @param Ar	FArchive to serialize RawData with.
	 */
	virtual void Serialize(FArchive& Ar);	
	
	/**
	 * Postload initialization of movie texture. Creates decoder object and retriever first frame.
	 */
	virtual void PostLoad();
	
	/**
	* Called before destroying the object.  This is called immediately upon deciding to destroy the object, to allow the object to begin an
	* asynchronous cleanup process.
	*
	* We need to ensure that the decoder doesn't have any references to the movie texture resource before destructing it.
	*/
	virtual void BeginDestroy();
	
	/**
	* Called when a property on this object has been modified externally
	*
	* @param PropertyThatChanged the property that will be modified
	*/
	virtual void PreEditChange(UProperty* PropertyAboutToChange);

	/**
	* Called when a property on this object has been modified externally
	*
	* @param PropertyThatChanged the property that was modified
	*/
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	* Called to check if the object is ready for FinishDestroy.  This is called after BeginDestroy to check the completion of the
	* potentially asynchronous object cleanup.
	* @return True if the object's asynchronous cleanup has completed and it is ready for FinishDestroy to be called.
	*/
	virtual UBOOL IsReadyForFinishDestroy();

	/**
	 * Called to finish destroying the object.  After UObject::FinishDestroy is called, the object's memory should no longer be accessed.
	 *
	 * note: because ExitProperties() is called here, Super::FinishDestroy() should always be called at the end of your child class's
	 * FinishDestroy() method, rather than at the beginning.
	 */
	virtual void FinishDestroy();

	// Thumbnail interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	// UTextureMovie

	/**
	 * Access the movie target resource for this movie texture object
	 * @return pointer to resource or NULL if not initialized
	 */
	class FTextureMovieResource* GetTextureMovieResource();
	
	/** 
	 * Creates a new codec and checks to see if it has a valid stream
	 */
	void InitDecoder();
};

class UTextureRenderTarget : public UTexture
{
public:
    //## BEGIN PROPS TextureRenderTarget
    BITFIELD bUpdateImmediate:1;
    BITFIELD bNeedsTwoCopies:1;
    BITFIELD bRenderOnce:1;
    FLOAT TargetGamma;
    //## END PROPS TextureRenderTarget

    DECLARE_ABSTRACT_CLASS(UTextureRenderTarget,UTexture,0,Engine)
	/**
	 * Access the render target resource for this texture target object
	 * @return pointer to resource or NULL if not initialized
	 */
	FTextureRenderTargetResource* GetRenderTargetResource();

	/**
	 * Returns a pointer to the (game thread managed) render target resource.  Note that you're not allowed
	 * to deferenced this pointer on the game thread, you can only pass the pointer around and check for NULLness
	 * @return pointer to resource
	 */
	FTextureRenderTargetResource* GameThread_GetRenderTargetResource();


	// UTexture interface.

	/**
	 * No mip data used so compression is not needed
	 */
	virtual void Compress();

	/**
	 * Create a new 2D render target texture resource
	 * @return newly created FTextureRenderTarget2DResource
	 */
	virtual FTextureResource* CreateResource();
	
	/**
	 * Materials should treat a render target 2D texture like a regular 2D texture resource.
	 * @return EMaterialValueType for this resource
	 */
	virtual EMaterialValueType GetMaterialType();
};

class UTextureRenderTarget2D : public UTextureRenderTarget
{
public:
    //## BEGIN PROPS TextureRenderTarget2D
    INT SizeX;
    INT SizeY;
    BYTE Format;
    BYTE AddressX;
    BYTE AddressY;
    SCRIPT_ALIGN;
    FLinearColor ClearColor;
    BITFIELD bForceLinearGamma:1;
    SCRIPT_ALIGN;
    //## END PROPS TextureRenderTarget2D

    DECLARE_FUNCTION(execCreate);
    DECLARE_CLASS(UTextureRenderTarget2D,UTextureRenderTarget,0,Engine)
	/**
	 * Initialize the settings needed to create a render target texture
	 * and create its resource
	 * @param	InSizeX - width of the texture
	 * @param	InSizeY - height of the texture
	 * @param	InFormat - format of the texture
	 * @param	bInForceLinearGame - forces render target to use linear gamma space
	 */
	void Init(UINT InSizeX, UINT InSizeY, EPixelFormat InFormat, UBOOL bInForceLinearGamma=FALSE);

	/**
	 * Utility for creating a new UTexture2D from a TextureRenderTarget2D
	 * TextureRenderTarget2D must be square and a power of two size.
	 * @param Outer - Outer to use when constructing the new Texture2D.
	 * @param NewTexName - Name of new UTexture2D object.
	 * @param ObjectFlags - Flags to apply to the new Texture2D object
	 * @param Flags - Various control flags for operation (see EConstructTextureFlags)
	 * @param AlphaOverride - If specified, the values here will become the alpha values in the resulting texture
	 * @param bSaveSourceArt - If true, source art will be saved.
	 * @return New UTexture2D object.
	 */
	UTexture2D* ConstructTexture2D(UObject* Outer, const FString& NewTexName, EObjectFlags ObjectFlags, DWORD Flags=CTF_Default, TArray<BYTE>* AlphaOverride=NULL, UBOOL bSaveSourceArt=FALSE);

	// USurface interface

	/**
	 * @return width of surface
	 */
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }

	/**
	 * @return height of surface
	 */
	virtual FLOAT GetSurfaceHeight() const { return SizeY; }

	// UTexture interface.

	/**
	 * Create a new 2D render target texture resource
	 * @return newly created FTextureRenderTarget2DResource
	 */
	virtual FTextureResource* CreateResource();

	/**
	 * Materials should treat a render target 2D texture like a regular 2D texture resource.
	 * @return EMaterialValueType for this resource
	 */
	virtual EMaterialValueType GetMaterialType();

	// UObject interface

	/**
	 * Called when any property in this object is modified in UnrealEd
	 * @param	PropertyThatChanged - changed property
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 * Called after the object has been loaded
	 */
	virtual void PostLoad();

	// Editor thumbnail interface.

	/**
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/**
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * Serialize properties (used for backwards compatibility with main branch)
	 */
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();
};

struct ScriptedTexture_eventRender_Parms
{
    class UCanvas* C;
    ScriptedTexture_eventRender_Parms(EEventParm)
    {
    }
};
class UScriptedTexture : public UTextureRenderTarget2D
{
public:
    //## BEGIN PROPS ScriptedTexture
    BITFIELD bNeedsUpdate:1;
    BITFIELD bSkipNextClear:1;
    FScriptDelegate __Render__Delegate;
    //## END PROPS ScriptedTexture

    void delegateRender(class UCanvas* C)
    {
        ScriptedTexture_eventRender_Parms Parms(EC_EventParm);
        Parms.C=C;
        ProcessDelegate(ENGINE_Render,&__Render__Delegate,&Parms);
    }
    DECLARE_CLASS(UScriptedTexture,UTextureRenderTarget2D,0,Engine)
	/** global list of scripted textures that should be updated */
	static TArray<UScriptedTexture*> GScriptedTextures;

	UScriptedTexture();
	virtual void BeginDestroy();

	virtual void UpdateResource();
	/** calls Render() (after setting up Canvas, etc) if the scripted texture needs an update */
	void CheckUpdate();

protected:
	/** native rendering hook. Default implementation just calls script delegate. */
	virtual void Render(UCanvas* C);
};

class UTextureRenderTargetCube : public UTextureRenderTarget
{
public:
    //## BEGIN PROPS TextureRenderTargetCube
    INT SizeX;
    BYTE Format;
    SCRIPT_ALIGN;
    //## END PROPS TextureRenderTargetCube

    DECLARE_CLASS(UTextureRenderTargetCube,UTextureRenderTarget,0,Engine)
	/** 
	* Initialize the settings needed to create a render target texture
	* and create its resource
	* @param	InSizeX - width of the texture
	* @param	InFormat - format of the texture
	*/
	void Init(UINT InSizeX, EPixelFormat InFormat);

	/**
	*	Utility for creating a new UTextureCube from a TextureRenderTargetCube.
	*	TextureRenderTargetCube must be square and a power of two size.
	*	@param	Outer			Outer to use when constructing the new TextureCube.
	*	@param	NewTexName		Name of new UTextureCube object.
	*	@param	Flags			Various control flags for operation (see EObjectFlags)
	*	@param	bSaveSourceArt	If true, source art will be saved.
	*	@return					New UTextureCube object.
	*/
	class UTextureCube* ConstructTextureCube(UObject* Outer, const FString& NewTexName, EObjectFlags InFlags, UBOOL bSaveSourceArt=FALSE);

	// USurface interface

	/**
	* @return width of surface
	*/
	virtual FLOAT GetSurfaceWidth() const { return SizeX; }
	
	/**
	* @return height of surface
	*/
	virtual FLOAT GetSurfaceHeight() const { return SizeX; }	

	// UTexture interface.

	/**
	* Create a new 2D render target texture resource
	* @return newly created FTextureRenderTarget2DResource
	*/
	virtual FTextureResource* CreateResource();
	
	/**
	* Materials should treat a render target 2D texture like a regular 2D texture resource.
	* @return EMaterialValueType for this resource
	*/
	virtual EMaterialValueType GetMaterialType();

	// UObject interface

	/** 
	* Called when any property in this object is modified in UnrealEd
	* @param	PropertyThatChanged - changed property
	*/
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** 
	 * Called after the object has been loaded
 	 */
	virtual void PostLoad();

	// Editor thumbnail interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * Serialize properties (used for backwards compatibility with main branch)
	 */
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_TEXTURE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UTexture2D,-1,execCreate);
AUTOGENERATE_FUNCTION(UTexture2D,-1,execSetForceMipLevelsToBeResident);
AUTOGENERATE_FUNCTION(UTextureFlipBook,-1,execSetCurrentFrame);
AUTOGENERATE_FUNCTION(UTextureFlipBook,-1,execStop);
AUTOGENERATE_FUNCTION(UTextureFlipBook,-1,execPause);
AUTOGENERATE_FUNCTION(UTextureFlipBook,-1,execPlay);
AUTOGENERATE_FUNCTION(UTexture2DComposite,-1,execResetSourceRegions);
AUTOGENERATE_FUNCTION(UTexture2DComposite,-1,execUpdateCompositeTexture);
AUTOGENERATE_FUNCTION(UTexture2DComposite,-1,execSourceTexturesFullyStreamedIn);
AUTOGENERATE_FUNCTION(UTexture2DDynamic,-1,execCreate);
AUTOGENERATE_FUNCTION(UTexture2DDynamic,-1,execUpdateMipFromJPEG);
AUTOGENERATE_FUNCTION(UTexture2DDynamic,-1,execUpdateMip);
AUTOGENERATE_FUNCTION(UTexture2DDynamic,-1,execInit);
AUTOGENERATE_FUNCTION(UTextureMovie,-1,execStop);
AUTOGENERATE_FUNCTION(UTextureMovie,-1,execPause);
AUTOGENERATE_FUNCTION(UTextureMovie,-1,execPlay);
AUTOGENERATE_FUNCTION(UTextureRenderTarget2D,-1,execCreate);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_TEXTURE_NATIVE_DEFS
#define ENGINE_TEXTURE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_TEXTURE \
	UTexture::StaticClass(); \
	UTexture2D::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Texture2D"), GEngineUTexture2DNatives); \
	UTextureFlipBook::StaticClass(); \
	GNativeLookupFuncs.Set(FName("TextureFlipBook"), GEngineUTextureFlipBookNatives); \
	UTexture2DComposite::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Texture2DComposite"), GEngineUTexture2DCompositeNatives); \
	UTexture2DDynamic::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Texture2DDynamic"), GEngineUTexture2DDynamicNatives); \
	UTextureCube::StaticClass(); \
	UTextureMovie::StaticClass(); \
	GNativeLookupFuncs.Set(FName("TextureMovie"), GEngineUTextureMovieNatives); \
	UTextureRenderTarget::StaticClass(); \
	UTextureRenderTarget2D::StaticClass(); \
	GNativeLookupFuncs.Set(FName("TextureRenderTarget2D"), GEngineUTextureRenderTarget2DNatives); \
	UScriptedTexture::StaticClass(); \
	UTextureRenderTargetCube::StaticClass(); \

#endif // ENGINE_TEXTURE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineUTexture2DNatives[] = 
{ 
	MAP_NATIVE(UTexture2D, execCreate)
	MAP_NATIVE(UTexture2D, execSetForceMipLevelsToBeResident)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUTextureFlipBookNatives[] = 
{ 
	MAP_NATIVE(UTextureFlipBook, execSetCurrentFrame)
	MAP_NATIVE(UTextureFlipBook, execStop)
	MAP_NATIVE(UTextureFlipBook, execPause)
	MAP_NATIVE(UTextureFlipBook, execPlay)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUTexture2DCompositeNatives[] = 
{ 
	MAP_NATIVE(UTexture2DComposite, execResetSourceRegions)
	MAP_NATIVE(UTexture2DComposite, execUpdateCompositeTexture)
	MAP_NATIVE(UTexture2DComposite, execSourceTexturesFullyStreamedIn)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUTexture2DDynamicNatives[] = 
{ 
	MAP_NATIVE(UTexture2DDynamic, execCreate)
	MAP_NATIVE(UTexture2DDynamic, execUpdateMipFromJPEG)
	MAP_NATIVE(UTexture2DDynamic, execUpdateMip)
	MAP_NATIVE(UTexture2DDynamic, execInit)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUTextureMovieNatives[] = 
{ 
	MAP_NATIVE(UTextureMovie, execStop)
	MAP_NATIVE(UTextureMovie, execPause)
	MAP_NATIVE(UTextureMovie, execPlay)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUTextureRenderTarget2DNatives[] = 
{ 
	MAP_NATIVE(UTextureRenderTarget2D, execCreate)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UTexture,Texture,UnpackMin)
VERIFY_CLASS_OFFSET_NODIE(UTexture,Texture,InternalFormatLODBias)
VERIFY_CLASS_SIZE_NODIE(UTexture)
VERIFY_CLASS_OFFSET_NODIE(UTexture2D,Texture2D,Mips)
VERIFY_CLASS_OFFSET_NODIE(UTexture2D,Texture2D,Timer)
VERIFY_CLASS_SIZE_NODIE(UTexture2D)
VERIFY_CLASS_OFFSET_NODIE(UTextureFlipBook,TextureFlipBook,TimeIntoMovie)
VERIFY_CLASS_OFFSET_NODIE(UTextureFlipBook,TextureFlipBook,ReleaseResourcesFence)
VERIFY_CLASS_SIZE_NODIE(UTextureFlipBook)
VERIFY_CLASS_OFFSET_NODIE(UTexture2DComposite,Texture2DComposite,SourceRegions)
VERIFY_CLASS_OFFSET_NODIE(UTexture2DComposite,Texture2DComposite,DestSizeY)
VERIFY_CLASS_SIZE_NODIE(UTexture2DComposite)
VERIFY_CLASS_OFFSET_NODIE(UTexture2DDynamic,Texture2DDynamic,SizeX)
VERIFY_CLASS_OFFSET_NODIE(UTexture2DDynamic,Texture2DDynamic,NumMips)
VERIFY_CLASS_SIZE_NODIE(UTexture2DDynamic)
VERIFY_CLASS_OFFSET_NODIE(UTextureCube,TextureCube,SizeX)
VERIFY_CLASS_OFFSET_NODIE(UTextureCube,TextureCube,FaceNegZ)
VERIFY_CLASS_SIZE_NODIE(UTextureCube)
VERIFY_CLASS_OFFSET_NODIE(UTextureMovie,TextureMovie,SizeX)
VERIFY_CLASS_OFFSET_NODIE(UTextureMovie,TextureMovie,ReleaseCodecFence)
VERIFY_CLASS_SIZE_NODIE(UTextureMovie)
VERIFY_CLASS_OFFSET_NODIE(UTextureRenderTarget,TextureRenderTarget,TargetGamma)
VERIFY_CLASS_SIZE_NODIE(UTextureRenderTarget)
VERIFY_CLASS_OFFSET_NODIE(UTextureRenderTarget2D,TextureRenderTarget2D,SizeX)
VERIFY_CLASS_OFFSET_NODIE(UTextureRenderTarget2D,TextureRenderTarget2D,ClearColor)
VERIFY_CLASS_SIZE_NODIE(UTextureRenderTarget2D)
VERIFY_CLASS_OFFSET_NODIE(UScriptedTexture,ScriptedTexture,__Render__Delegate)
VERIFY_CLASS_SIZE_NODIE(UScriptedTexture)
VERIFY_CLASS_OFFSET_NODIE(UTextureRenderTargetCube,TextureRenderTargetCube,SizeX)
VERIFY_CLASS_OFFSET_NODIE(UTextureRenderTargetCube,TextureRenderTargetCube,Format)
VERIFY_CLASS_SIZE_NODIE(UTextureRenderTargetCube)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
