/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_LENSFLARE_ENUMS
#define INCLUDED_ENGINE_LENSFLARE_ENUMS 1


#endif // !INCLUDED_ENGINE_LENSFLARE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_LENSFLARE_CLASSES
#define INCLUDED_ENGINE_LENSFLARE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class ALensFlareSource : public AActor
{
public:
    //## BEGIN PROPS LensFlareSource
    class ULensFlareComponent* LensFlareComp;
    BITFIELD bCurrentlyActive:1;
    SCRIPT_ALIGN;
    //## END PROPS LensFlareSource

    void SetTemplate(class ULensFlare* NewTemplate);
    DECLARE_FUNCTION(execSetTemplate)
    {
        P_GET_OBJECT(ULensFlare,NewTemplate);
        P_FINISH;
        this->SetTemplate(NewTemplate);
    }
    DECLARE_CLASS(ALensFlareSource,AActor,0,Engine)
	void AutoPopulateInstanceProperties();

	// AActor interface.
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

struct FLensFlareElementCurvePair
{
    FString CurveName;
    class UObject* CurveObject;

    /** Constructors */
    FLensFlareElementCurvePair()
    : CurveObject(NULL)
    {}
    FLensFlareElementCurvePair(EEventParm)
    {
        appMemzero(this, sizeof(FLensFlareElementCurvePair));
    }
};

struct FLensFlareElement
{
    FName ElementName;
    FLOAT RayDistance;
    BITFIELD bIsEnabled:1;
    BITFIELD bUseSourceDistance:1;
    BITFIELD bNormalizeRadialDistance:1;
    BITFIELD bModulateColorBySource:1;
    SCRIPT_ALIGN;
    FVector Size;
    TArrayNoInit<class UMaterialInterface*> LFMaterials;
    struct FRawDistributionFloat LFMaterialIndex;
    struct FRawDistributionFloat Scaling;
    struct FRawDistributionVector AxisScaling;
    struct FRawDistributionFloat Rotation;
    BITFIELD bOrientTowardsSource:1;
    SCRIPT_ALIGN;
    struct FRawDistributionVector Color;
    struct FRawDistributionFloat Alpha;
    struct FRawDistributionVector Offset;
    struct FRawDistributionVector DistMap_Scale;
    struct FRawDistributionVector DistMap_Color;
    struct FRawDistributionFloat DistMap_Alpha;

		void GetCurveObjects(TArray<FLensFlareElementCurvePair>& OutCurves);
		void DuplicateDistribution_Float(const FRawDistributionFloat& SourceDist, UObject* Outer, FRawDistributionFloat& NewDist);
		void DuplicateDistribution_Vector(const FRawDistributionVector& SourceDist, UObject* Outer, FRawDistributionVector& NewDist);
		UBOOL DuplicateFromSource(const FLensFlareElement& InSource, UObject* Outer);
		UObject* GetCurve(FString& CurveName);
	
};

class ULensFlare : public UObject
{
public:
    //## BEGIN PROPS LensFlare
    struct FLensFlareElement SourceElement;
    class UStaticMesh* SourceMesh;
    BYTE SourceDPG;
    BYTE ReflectionsDPG;
    TArrayNoInit<struct FLensFlareElement> Reflections;
    FLOAT OuterCone;
    FLOAT InnerCone;
    FLOAT ConeFudgeFactor;
    FLOAT Radius;
    BITFIELD bUseTrueConeCalculation:1;
    BITFIELD bUseFixedRelativeBoundingBox:1;
    BITFIELD bRenderDebugLines:1;
    BITFIELD ThumbnailImageOutOfDate:1;
    FLOAT MinStrength;
    struct FRawDistributionFloat ScreenPercentageMap;
    FBox FixedRelativeBoundingBox;
    class UInterpCurveEdSetup* CurveEdSetup;
    INT ReflectionCount;
    FRotator ThumbnailAngle;
    FLOAT ThumbnailDistance;
    class UTexture2D* ThumbnailImage;
    //## END PROPS LensFlare

    DECLARE_CLASS(ULensFlare,UObject,0,Engine)
	// UObject interface.
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();
	
	// CurveEditor helper interface
	void	AddElementCurvesToEditor(INT ElementIndex, UInterpCurveEdSetup* EdSetup);
	void	RemoveElementCurvesFromEditor(INT ElementIndex, UInterpCurveEdSetup* EdSetup);
	void	AddElementCurveToEditor(INT ElementIndex, FString& CurveName, UInterpCurveEdSetup* EdSetup);
	UObject* GetElementCurve(INT ElementIndex, FString& CurveName);
	
	//
	const FLensFlareElement* GetElement(INT ElementIndex) const;
	
	/** Return TRUE if element was found and bIsEnabled set to given value. */
	UBOOL SetElementEnabled(INT ElementIndex, UBOOL bInIsEnabled);
	
	/** Initialize the element at the given index */
	UBOOL InitializeElement(INT ElementIndex);

	/** Get the curve objects associated with the LensFlare itself */
	void GetCurveObjects(TArray<FLensFlareElementCurvePair>& OutCurves);
};

struct FLensFlareElementMaterials
{
    TArrayNoInit<class UMaterialInterface*> ElementMaterials;

    /** Constructors */
    FLensFlareElementMaterials() {}
    FLensFlareElementMaterials(EEventParm)
    {
        appMemzero(this, sizeof(FLensFlareElementMaterials));
    }
};

class ULensFlareComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LensFlareComponent
    class ULensFlare* Template;
    class UDrawLightConeComponent* PreviewInnerCone;
    class UDrawLightConeComponent* PreviewOuterCone;
    class UDrawLightRadiusComponent* PreviewRadius;
    BITFIELD bAutoActivate:1;
    BITFIELD bIsActive:1;
    BITFIELD bHasTranslucency:1;
    BITFIELD bHasUnlitTranslucency:1;
    BITFIELD bHasUnlitDistortion:1;
    BITFIELD bUsesSceneColor:1;
    BITFIELD bHasSeparateTranslucency:1;
    BITFIELD bUseTrueConeCalculation:1;
    BITFIELD bVisibleForMobile:1;
    FLOAT OuterCone;
    FLOAT InnerCone;
    FLOAT ConeFudgeFactor;
    FLOAT Radius;
    FLOAT MinStrength;
    FLinearColor SourceColor;
    TArrayNoInit<struct FLensFlareElementMaterials> Materials;
    class FRenderCommandFence* ReleaseResourcesFence;
    FLOAT NextTraceTime;
    //## END PROPS LensFlareComponent

    void SetTemplate(class ULensFlare* NewTemplate,UBOOL bForceSet=FALSE);
    virtual void SetSourceColor(FLinearColor InSourceColor);
    virtual void SetIsActive(UBOOL bInIsActive);
    virtual class UMaterialInterface* GetMaterial(INT ElementIndex);
    virtual void SetMaterial(INT ElementIndex,class UMaterialInterface* Material);
    DECLARE_FUNCTION(execSetTemplate)
    {
        P_GET_OBJECT(ULensFlare,NewTemplate);
        P_GET_UBOOL_OPTX(bForceSet,FALSE);
        P_FINISH;
        this->SetTemplate(NewTemplate,bForceSet);
    }
    DECLARE_FUNCTION(execSetSourceColor)
    {
        P_GET_STRUCT(FLinearColor,InSourceColor);
        P_FINISH;
        this->SetSourceColor(InSourceColor);
    }
    DECLARE_FUNCTION(execSetIsActive)
    {
        P_GET_UBOOL(bInIsActive);
        P_FINISH;
        this->SetIsActive(bInIsActive);
    }
    DECLARE_FUNCTION(execGetMaterial)
    {
        P_GET_INT(ElementIndex);
        P_FINISH;
        *(class UMaterialInterface**)Result=this->GetMaterial(ElementIndex);
    }
    DECLARE_FUNCTION(execSetMaterial)
    {
        P_GET_INT(ElementIndex);
        P_GET_OBJECT(UMaterialInterface,Material);
        P_FINISH;
        this->SetMaterial(ElementIndex,Material);
    }
    DECLARE_CLASS(ULensFlareComponent,UPrimitiveComponent,0,Engine)
	// UObject interface
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();

	// UActorComponent interface.
	virtual void Attach();

public:
	// UPrimitiveComponent interface
	virtual void UpdateBounds();
	virtual void Tick(FLOAT DeltaTime);

	/** 
	 *	Setup the Materials array for the lens flare component.
	 *	
	 *	@param	bForceReset		If TRUE, reset the array and refill it from the template.
	 */
	void SetupMaterialsArray(UBOOL bForceReset);

	virtual INT GetNumElements() const;
	virtual UMaterialInterface* GetElementMaterial(INT MaterialIndex) const;
	virtual void SetElementMaterial(INT ElementIndex, UMaterialInterface* InMaterial);

	/**
	 * Retrieves the materials used in this component
	 *
	 * @param OutMaterials	The list of used materials.
	 */
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const;

	/** Returns true if the prim is using a material with unlit distortion */
	virtual UBOOL HasUnlitDistortion() const;
	/** Returns true if the prim is using a material with unlit translucency */
	virtual UBOOL HasUnlitTranslucency() const;
	/** Returns true if the prim is using a material with lit translucency */
	virtual UBOOL HasLitTranslucency() const;
	/** Returns true if the prim is using a material with separate translucency */
 	virtual UBOOL HasSeparateTranslucency() const;

	/**
	* Returns true if the prim is using a material that samples the scene color texture.
	* If true then these primitives are drawn after all other translucency
	*/
	virtual UBOOL UsesSceneColor() const;
	
	/** 
	 * Initialize the draw data that gets used when creating the visualization scene proxys.
	 *
	 * @param bUseTemplate		If true, will initialize with the data found in the lens flare template object.
	 */
	virtual void InitializeVisualizationData(UBOOL bUseTemplate);

	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	// InstanceParameters interface
	void	AutoPopulateInstanceProperties();
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_LENSFLARE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(ALensFlareSource,-1,execSetTemplate);
AUTOGENERATE_FUNCTION(ULensFlareComponent,-1,execSetMaterial);
AUTOGENERATE_FUNCTION(ULensFlareComponent,-1,execGetMaterial);
AUTOGENERATE_FUNCTION(ULensFlareComponent,-1,execSetIsActive);
AUTOGENERATE_FUNCTION(ULensFlareComponent,-1,execSetSourceColor);
AUTOGENERATE_FUNCTION(ULensFlareComponent,-1,execSetTemplate);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_LENSFLARE_NATIVE_DEFS
#define ENGINE_LENSFLARE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_LENSFLARE \
	ALensFlareSource::StaticClass(); \
	GNativeLookupFuncs.Set(FName("LensFlareSource"), GEngineALensFlareSourceNatives); \
	ULensFlareComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("LensFlareComponent"), GEngineULensFlareComponentNatives); \
	ULensFlare::StaticClass(); \

#endif // ENGINE_LENSFLARE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineALensFlareSourceNatives[] = 
{ 
	MAP_NATIVE(ALensFlareSource, execSetTemplate)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineULensFlareComponentNatives[] = 
{ 
	MAP_NATIVE(ULensFlareComponent, execSetMaterial)
	MAP_NATIVE(ULensFlareComponent, execGetMaterial)
	MAP_NATIVE(ULensFlareComponent, execSetIsActive)
	MAP_NATIVE(ULensFlareComponent, execSetSourceColor)
	MAP_NATIVE(ULensFlareComponent, execSetTemplate)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(ALensFlareSource,LensFlareSource,LensFlareComp)
VERIFY_CLASS_SIZE_NODIE(ALensFlareSource)
VERIFY_CLASS_OFFSET_NODIE(ULensFlareComponent,LensFlareComponent,Template)
VERIFY_CLASS_OFFSET_NODIE(ULensFlareComponent,LensFlareComponent,NextTraceTime)
VERIFY_CLASS_SIZE_NODIE(ULensFlareComponent)
VERIFY_CLASS_OFFSET_NODIE(ULensFlare,LensFlare,SourceElement)
VERIFY_CLASS_OFFSET_NODIE(ULensFlare,LensFlare,ThumbnailImage)
VERIFY_CLASS_SIZE_NODIE(ULensFlare)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
