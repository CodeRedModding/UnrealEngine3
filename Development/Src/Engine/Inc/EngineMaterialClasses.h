/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_MATERIAL_ENUMS
#define INCLUDED_ENGINE_MATERIAL_ENUMS 1

enum ECustomMaterialOutputType
{
    CMOT_Float1             =0,
    CMOT_Float2             =1,
    CMOT_Float3             =2,
    CMOT_Float4             =3,
    CMOT_MAX                =4,
};
#define FOREACH_ENUM_ECUSTOMMATERIALOUTPUTTYPE(op) \
    op(CMOT_Float1) \
    op(CMOT_Float2) \
    op(CMOT_Float3) \
    op(CMOT_Float4) 
enum EDepthOfFieldFunctionValue
{
    TDOF_NearAndFarMask     =0,
    TDOF_NearMask           =1,
    TDOF_FarMask            =2,
    TDOF_MAX                =3,
};
#define FOREACH_ENUM_EDEPTHOFFIELDFUNCTIONVALUE(op) \
    op(TDOF_NearAndFarMask) \
    op(TDOF_NearMask) \
    op(TDOF_FarMask) 
enum EFunctionInputType
{
    FunctionInput_Scalar    =0,
    FunctionInput_Vector2   =1,
    FunctionInput_Vector3   =2,
    FunctionInput_Vector4   =3,
    FunctionInput_Texture2D =4,
    FunctionInput_TextureCube=5,
    FunctionInput_StaticBool=6,
    FunctionInput_MAX       =7,
};
#define FOREACH_ENUM_EFUNCTIONINPUTTYPE(op) \
    op(FunctionInput_Scalar) \
    op(FunctionInput_Vector2) \
    op(FunctionInput_Vector3) \
    op(FunctionInput_Vector4) \
    op(FunctionInput_Texture2D) \
    op(FunctionInput_TextureCube) \
    op(FunctionInput_StaticBool) 
enum ELandscapeLayerBlendType
{
    LB_AlphaBlend           =0,
    LB_HeightBlend          =1,
    LB_MAX                  =2,
};
#define FOREACH_ENUM_ELANDSCAPELAYERBLENDTYPE(op) \
    op(LB_AlphaBlend) \
    op(LB_HeightBlend) 
enum ESceneTextureType
{
    SceneTex_Lighting       =0,
    SceneTex_MAX            =1,
};
#define FOREACH_ENUM_ESCENETEXTURETYPE(op) \
    op(SceneTex_Lighting) 
enum ETerrainCoordMappingType
{
    TCMT_Auto               =0,
    TCMT_XY                 =1,
    TCMT_XZ                 =2,
    TCMT_YZ                 =3,
    TCMT_MAX                =4,
};
#define FOREACH_ENUM_ETERRAINCOORDMAPPINGTYPE(op) \
    op(TCMT_Auto) \
    op(TCMT_XY) \
    op(TCMT_XZ) \
    op(TCMT_YZ) 
enum ETextureColorChannel
{
    TCC_Red                 =0,
    TCC_Green               =1,
    TCC_Blue                =2,
    TCC_Alpha               =3,
    TCC_MAX                 =4,
};
#define FOREACH_ENUM_ETEXTURECOLORCHANNEL(op) \
    op(TCC_Red) \
    op(TCC_Green) \
    op(TCC_Blue) \
    op(TCC_Alpha) 
enum EMaterialVectorCoordTransform
{
    TRANSFORM_World         =0,
    TRANSFORM_View          =1,
    TRANSFORM_Local         =2,
    TRANSFORM_Tangent       =3,
    TRANSFORM_MAX           =4,
};
#define FOREACH_ENUM_EMATERIALVECTORCOORDTRANSFORM(op) \
    op(TRANSFORM_World) \
    op(TRANSFORM_View) \
    op(TRANSFORM_Local) \
    op(TRANSFORM_Tangent) 
enum EMaterialVectorCoordTransformSource
{
    TRANSFORMSOURCE_World   =0,
    TRANSFORMSOURCE_Local   =1,
    TRANSFORMSOURCE_Tangent =2,
    TRANSFORMSOURCE_View    =3,
    TRANSFORMSOURCE_MAX     =4,
};
#define FOREACH_ENUM_EMATERIALVECTORCOORDTRANSFORMSOURCE(op) \
    op(TRANSFORMSOURCE_World) \
    op(TRANSFORMSOURCE_Local) \
    op(TRANSFORMSOURCE_Tangent) \
    op(TRANSFORMSOURCE_View) 
enum EMaterialPositionTransform
{
    TRANSFORMPOS_World      =0,
    TRANSFORMPOS_MAX        =1,
};
#define FOREACH_ENUM_EMATERIALPOSITIONTRANSFORM(op) \
    op(TRANSFORMPOS_World) 
enum EMaterialPositionTransformSource
{
    TRANSFORMPOSSOURCE_Local=0,
    TRANSFORMPOSSOURCE_PostProjection=1,
    TRANSFORMPOSSOURCE_MAX  =2,
};
#define FOREACH_ENUM_EMATERIALPOSITIONTRANSFORMSOURCE(op) \
    op(TRANSFORMPOSSOURCE_Local) \
    op(TRANSFORMPOSSOURCE_PostProjection) 
enum EMaterialUsage
{
    MATUSAGE_SkeletalMesh   =0,
    MATUSAGE_FracturedMeshes=1,
    MATUSAGE_ParticleSprites=2,
    MATUSAGE_BeamTrails     =3,
    MATUSAGE_ParticleSubUV  =4,
    MATUSAGE_SpeedTree      =5,
    MATUSAGE_StaticLighting =6,
    MATUSAGE_GammaCorrection=7,
    MATUSAGE_LensFlare      =8,
    MATUSAGE_InstancedMeshParticles=9,
    MATUSAGE_FluidSurface   =10,
    MATUSAGE_Decals         =11,
    MATUSAGE_MaterialEffect =12,
    MATUSAGE_MorphTargets   =13,
    MATUSAGE_FogVolumes     =14,
    MATUSAGE_RadialBlur     =15,
    MATUSAGE_InstancedMeshes=16,
    MATUSAGE_SplineMesh     =17,
    MATUSAGE_ScreenDoorFade =18,
    MATUSAGE_APEXMesh       =19,
    MATUSAGE_Terrain        =20,
    MATUSAGE_Landscape      =21,
    MATUSAGE_MobileLandscape=22,
    MATUSAGE_MAX            =23,
};
#define FOREACH_ENUM_EMATERIALUSAGE(op) \
    op(MATUSAGE_SkeletalMesh) \
    op(MATUSAGE_FracturedMeshes) \
    op(MATUSAGE_ParticleSprites) \
    op(MATUSAGE_BeamTrails) \
    op(MATUSAGE_ParticleSubUV) \
    op(MATUSAGE_SpeedTree) \
    op(MATUSAGE_StaticLighting) \
    op(MATUSAGE_GammaCorrection) \
    op(MATUSAGE_LensFlare) \
    op(MATUSAGE_InstancedMeshParticles) \
    op(MATUSAGE_FluidSurface) \
    op(MATUSAGE_Decals) \
    op(MATUSAGE_MaterialEffect) \
    op(MATUSAGE_MorphTargets) \
    op(MATUSAGE_FogVolumes) \
    op(MATUSAGE_RadialBlur) \
    op(MATUSAGE_InstancedMeshes) \
    op(MATUSAGE_SplineMesh) \
    op(MATUSAGE_ScreenDoorFade) \
    op(MATUSAGE_APEXMesh) \
    op(MATUSAGE_Terrain) \
    op(MATUSAGE_Landscape) \
    op(MATUSAGE_MobileLandscape) 

#endif // !INCLUDED_ENGINE_MATERIAL_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_MATERIAL_CLASSES
#define INCLUDED_ENGINE_MATERIAL_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UMaterialExpression : public UObject
{
public:
    //## BEGIN PROPS MaterialExpression
    INT EditorX_DEPRECATED;
    INT EditorY_DEPRECATED;
#if WITH_EDITORONLY_DATA
    INT MaterialExpressionEditorX;
    INT MaterialExpressionEditorY;
#endif // WITH_EDITORONLY_DATA
    BITFIELD bRealtimePreview:1;
    BITFIELD bNeedToUpdatePreview:1;
    BITFIELD bIsParameterExpression:1;
    BITFIELD bShowOutputNameOnPin:1;
    BITFIELD bHidePreviewWindow:1;
    BITFIELD bShowInputs:1;
    BITFIELD bShowOutputs:1;
    BITFIELD bUsedByStaticParameterSet:1;
    class UMaterial* Material;
    class UMaterialFunction* Function;
    FStringNoInit Desc;
    FColor BorderColor;
    TArrayNoInit<FName> MenuCategories;
    TArrayNoInit<FExpressionOutput> Outputs;
    //## END PROPS MaterialExpression

    DECLARE_ABSTRACT_CLASS(UMaterialExpression,UObject,0,Engine)
	// UObject interface.
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// UMaterialExpression interface.

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL) {}

	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex) { return INDEX_NONE; }
	virtual INT CompilePreview(FMaterialCompiler* Compiler, INT OutputIndex) { return Compile(Compiler, OutputIndex); }
	virtual TArray<FExpressionOutput>& GetOutputs();
	virtual const TArray<FExpressionInput*> GetInputs();
	virtual FExpressionInput* GetInput(INT InputIndex);
	virtual FString GetInputName(INT InputIndex) const;
	virtual UBOOL IsInputConnectionRequired(INT InputIndex) const { return TRUE; }
	virtual INT GetWidth() const;
	virtual INT GetHeight() const;
	virtual UBOOL UsesLeftGutter() const;
	virtual UBOOL UsesRightGutter() const;
	virtual FString GetCaption() const;

	/** Gets a tooltip for the specified connector. */
	virtual void GetConnectorToolTip(INT InputIndex, INT OutputIndex, TArray<FString>& OutToolTip);

	/** Gets a tooltip for the expression itself. */
	virtual void GetExpressionToolTip(TArray<FString>& OutToolTip) {}

	virtual int GetLabelPadding() { return 0; }

	virtual INT CompilerError(FMaterialCompiler* Compiler, const TCHAR* pcMessage);

	virtual void Serialize(FArchive& Ar);

	/**
	 * @return TRUE if the expression preview needs realtime update
     */
	virtual UBOOL NeedsRealtimePreview() { return FALSE; }

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );

	/** Called before applying a transaction to the object.  Default implementation simply calls PreEditChange. */
	virtual void PreEditUndo();

	/** Called after applying a transaction to the object.  Default implementation simply calls PostEditChange. */
	virtual void PostEditUndo();

#if WITH_EDITOR
	/**
	 *	Called by the CleanupMaterials function, this will clear the inputs of the expression.
	 *	This only needs to be implemented by expressions that have bUsedByStaticParameterSet set to TRUE.
	 */
	virtual void ClearInputExpressions() {}
#endif

	/**
	 * Sets overrides in the material expression's static parameters
	 *
	 * @param	Permutation		The set of static parameters to override and their values	
	 */
	virtual void SetStaticParameterOverrides(const FStaticParameterSet* Permutation) {}

	/**
	 * Clears static parameter overrides so that static parameter expression defaults will be used
	 *	for subsequent compiles.
	 */
	virtual void ClearStaticParameterOverrides() {}

	/**
	 * Copies the SrcExpressions into the specified material.  Preserves internal references.
	 * New material expressions are created within the specified material.
	 */
	static void CopyMaterialExpressions(const TArray<class UMaterialExpression*>& SrcExpressions, const TArray<class UMaterialExpressionComment*>& SrcExpressionComments, 
		class UMaterial* Material, class UMaterialFunction* Function, TArray<class UMaterialExpression*>& OutNewExpressions, TArray<class UMaterialExpression*>& OutNewComments);
};

class UMaterialExpressionAbs : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionAbs
    FExpressionInput Input;
    //## END PROPS MaterialExpressionAbs

    DECLARE_CLASS(UMaterialExpressionAbs,UMaterialExpression,0,Engine)
    /**
	 * Creates the new shader code chunk needed for the Abs expression
	 *
	 * @param	Compiler - Material compiler that knows how to handle this expression
	 * @return	Index to the new FMaterialCompiler::CodeChunk entry for this expression
	 */	
	virtual INT Compile( FMaterialCompiler* Compiler, INT OutputIndex );

	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionActorWorldPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionActorWorldPosition
    //## END PROPS MaterialExpressionActorWorldPosition

    DECLARE_CLASS(UMaterialExpressionActorWorldPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionAdd : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionAdd
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionAdd

    DECLARE_CLASS(UMaterialExpressionAdd,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionAppendVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionAppendVector
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionAppendVector

    DECLARE_CLASS(UMaterialExpressionAppendVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionBumpOffset : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionBumpOffset
    FExpressionInput Coordinate;
    FExpressionInput Height;
    FExpressionInput HeightRatioInput;
    FLOAT HeightRatio;
    FLOAT ReferencePlane;
    //## END PROPS MaterialExpressionBumpOffset

    DECLARE_CLASS(UMaterialExpressionBumpOffset,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCameraVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCameraVector
    //## END PROPS MaterialExpressionCameraVector

    DECLARE_CLASS(UMaterialExpressionCameraVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionCameraWorldPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCameraWorldPosition
    //## END PROPS MaterialExpressionCameraWorldPosition

    DECLARE_CLASS(UMaterialExpressionCameraWorldPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionCeil : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCeil
    FExpressionInput Input;
    //## END PROPS MaterialExpressionCeil

    DECLARE_CLASS(UMaterialExpressionCeil,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionClamp : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionClamp
    FExpressionInput Input;
    FExpressionInput Min;
    FExpressionInput Max;
    //## END PROPS MaterialExpressionClamp

    DECLARE_CLASS(UMaterialExpressionClamp,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionComment : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionComment
    INT PosX;
    INT PosY;
    INT SizeX;
    INT SizeY;
    FStringNoInit Text;
    //## END PROPS MaterialExpressionComment

    DECLARE_CLASS(UMaterialExpressionComment,UMaterialExpression,0,Engine)
	/**
	 * Text description of this expression.
	 */
	virtual FString GetCaption() const;

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionComponentMask : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionComponentMask
    FExpressionInput Input;
    BITFIELD R:1;
    BITFIELD G:1;
    BITFIELD B:1;
    BITFIELD A:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionComponentMask

    DECLARE_CLASS(UMaterialExpressionComponentMask,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionConstant : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant
    FLOAT R;
    //## END PROPS MaterialExpressionConstant

    DECLARE_CLASS(UMaterialExpressionConstant,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstant2Vector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant2Vector
    FLOAT R;
    FLOAT G;
    //## END PROPS MaterialExpressionConstant2Vector

    DECLARE_CLASS(UMaterialExpressionConstant2Vector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstant3Vector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant3Vector
    FLOAT R;
    FLOAT G;
    FLOAT B;
    //## END PROPS MaterialExpressionConstant3Vector

    DECLARE_CLASS(UMaterialExpressionConstant3Vector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstant4Vector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstant4Vector
    FLOAT R;
    FLOAT G;
    FLOAT B;
    FLOAT A;
    //## END PROPS MaterialExpressionConstant4Vector

    DECLARE_CLASS(UMaterialExpressionConstant4Vector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionConstantBiasScale : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstantBiasScale
    FExpressionInput Input;
    FLOAT Bias;
    FLOAT Scale;
    //## END PROPS MaterialExpressionConstantBiasScale

    DECLARE_CLASS(UMaterialExpressionConstantBiasScale,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionConstantClamp : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionConstantClamp
    FExpressionInput Input;
    FLOAT Min;
    FLOAT Max;
    //## END PROPS MaterialExpressionConstantClamp

    DECLARE_CLASS(UMaterialExpressionConstantClamp,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCosine : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCosine
    FExpressionInput Input;
    FLOAT Period;
    //## END PROPS MaterialExpressionCosine

    DECLARE_CLASS(UMaterialExpressionCosine,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionCrossProduct : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCrossProduct
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionCrossProduct

    DECLARE_CLASS(UMaterialExpressionCrossProduct,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

struct FCustomInput
{
    FStringNoInit InputName;
    FExpressionInput Input;

    /** Constructors */
    FCustomInput() {}
    FCustomInput(EEventParm)
    {
        appMemzero(this, sizeof(FCustomInput));
    }
};

class UMaterialExpressionCustom : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCustom
    FStringNoInit Code;
    BYTE OutputType;
    FStringNoInit Description;
    TArrayNoInit<struct FCustomInput> Inputs;
    //## END PROPS MaterialExpressionCustom

    DECLARE_CLASS(UMaterialExpressionCustom,UMaterialExpression,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	
	// UMaterialExpression interface
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	void SwapReferenceTo( UMaterialExpression* OldExpression, UMaterialExpression* NewExpression );
	virtual const TArray<FExpressionInput*> GetInputs();
	virtual FExpressionInput* GetInput(INT InputIndex);
	virtual FString GetInputName(INT InputIndex) const;
};

class UMaterialExpressionCustomTexture : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionCustomTexture
    class UTexture* Texture;
    //## END PROPS MaterialExpressionCustomTexture

    DECLARE_CLASS(UMaterialExpressionCustomTexture,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT CompilePreview(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionDepthBiasedAlpha : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDepthBiasedAlpha
    BITFIELD bNormalize:1;
    FLOAT BiasScale;
    FExpressionInput Alpha;
    FExpressionInput Bias;
    //## END PROPS MaterialExpressionDepthBiasedAlpha

    DECLARE_CLASS(UMaterialExpressionDepthBiasedAlpha,UMaterialExpression,0,Engine)
	/**
	 *	Compile the material expression
	 *
	 *	@param	Compiler	Pointer to the material compiler to use
	 *
	 *	@return	INT			The compiled code index
	 */	
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	 */	
	virtual INT GetWidth() const;

	/**
	 */	
	virtual FString GetCaption() const;

	/**
	 */	
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDepthBiasedBlend : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDepthBiasedBlend
    BITFIELD bNormalize:1;
    FLOAT BiasScale;
    FExpressionInput RGB;
    FExpressionInput Alpha;
    FExpressionInput Bias;
    //## END PROPS MaterialExpressionDepthBiasedBlend

    DECLARE_CLASS(UMaterialExpressionDepthBiasedBlend,UMaterialExpression,0,Engine)
	/**
	 *	Compile the material expression
	 *
	 *	@param	Compiler	Pointer to the material compiler to use
	 *
	 *	@return	INT			The compiled code index
	 */	
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	 */	
	virtual INT GetWidth() const;

	/**
	 */	
	virtual FString GetCaption() const;

	/**
	 */	
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDepthOfFieldFunction : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDepthOfFieldFunction
    BYTE FunctionValue;
    SCRIPT_ALIGN;
    FExpressionInput Depth;
    //## END PROPS MaterialExpressionDepthOfFieldFunction

    DECLARE_CLASS(UMaterialExpressionDepthOfFieldFunction,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDeriveNormalZ : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDeriveNormalZ
    FExpressionInput InXY;
    //## END PROPS MaterialExpressionDeriveNormalZ

    DECLARE_CLASS(UMaterialExpressionDeriveNormalZ,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDesaturation : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDesaturation
    FExpressionInput Input;
    FExpressionInput Percent;
    FLinearColor LuminanceFactors;
    //## END PROPS MaterialExpressionDesaturation

    DECLARE_CLASS(UMaterialExpressionDesaturation,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const
	{
		return TEXT("Desaturation");
	}

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDestColor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDestColor
    //## END PROPS MaterialExpressionDestColor

    DECLARE_CLASS(UMaterialExpressionDestColor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionDestDepth : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDestDepth
    BITFIELD bNormalize:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionDestDepth

    DECLARE_CLASS(UMaterialExpressionDestDepth,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDistance
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionDistance

    DECLARE_CLASS(UMaterialExpressionDistance,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDivide : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDivide
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionDivide

    DECLARE_CLASS(UMaterialExpressionDivide,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDotProduct : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDotProduct
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionDotProduct

    DECLARE_CLASS(UMaterialExpressionDotProduct,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionDynamicParameter : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionDynamicParameter
    TArrayNoInit<FString> ParamNames;
    //## END PROPS MaterialExpressionDynamicParameter

    DECLARE_CLASS(UMaterialExpressionDynamicParameter,UMaterialExpression,0,Engine)
	// UObject interface.

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// UMaterialExpression interface.

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

    /**
	 * Creates the new shader code chunk needed for the Abs expression
	 *
	 * @param	Compiler - Material compiler that knows how to handle this expression
	 * @return	Index to the new FMaterialCompiler::CodeChunk entry for this expression
	 */	
	virtual INT Compile( FMaterialCompiler* Compiler, INT OutputIndex );

	/**
	 *	Get the outputs supported by this expression.
	 *
	 *	@param	Outputs		The TArray of outputs to fill in.
	 */
	virtual TArray<FExpressionOutput>& GetOutputs();

	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;

	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;

	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionMeshEmitterDynamicParameter : public UMaterialExpressionDynamicParameter
{
public:
    //## BEGIN PROPS MaterialExpressionMeshEmitterDynamicParameter
    //## END PROPS MaterialExpressionMeshEmitterDynamicParameter

    DECLARE_CLASS(UMaterialExpressionMeshEmitterDynamicParameter,UMaterialExpressionDynamicParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionFloor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFloor
    FExpressionInput Input;
    //## END PROPS MaterialExpressionFloor

    DECLARE_CLASS(UMaterialExpressionFloor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFluidNormal : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFluidNormal
    FExpressionInput Coordinates;
    //## END PROPS MaterialExpressionFluidNormal

    DECLARE_CLASS(UMaterialExpressionFluidNormal,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFmod : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFmod
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionFmod

    DECLARE_CLASS(UMaterialExpressionFmod,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFoliageImpulseDirection : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFoliageImpulseDirection
    //## END PROPS MaterialExpressionFoliageImpulseDirection

    DECLARE_CLASS(UMaterialExpressionFoliageImpulseDirection,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionFoliageNormalizedRotationAxisAndAngle : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFoliageNormalizedRotationAxisAndAngle
    //## END PROPS MaterialExpressionFoliageNormalizedRotationAxisAndAngle

    DECLARE_CLASS(UMaterialExpressionFoliageNormalizedRotationAxisAndAngle,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionFontSample : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFontSample
    class UFont* Font;
    INT FontTexturePage;
    //## END PROPS MaterialExpressionFontSample

    DECLARE_CLASS(UMaterialExpressionFontSample,UMaterialExpression,0,Engine)
	/** 
	* Generate the compiled material string for this expression
	* @param Compiler - shader material compiler
	* @return index to the new generated expression
	*/
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	* Width of the thumbnail for this expression int he material editor
	* @return size in pixels
	*/
	virtual INT GetWidth() const;

	/**
	* Caption description for this expression
	* @return string caption
	*/
	virtual FString GetCaption() const;

	/**
	* Padding for the text lable
	* @return size in pixels
	*/
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionFontSampleParameter : public UMaterialExpressionFontSample
{
public:
    //## BEGIN PROPS MaterialExpressionFontSampleParameter
    FName ParameterName;
    FGuid ExpressionGUID;
    FName Group;
    //## END PROPS MaterialExpressionFontSampleParameter

    DECLARE_CLASS(UMaterialExpressionFontSampleParameter,UMaterialExpressionFontSample,0,Engine)
	/** 
	* Generate the compiled material string for this expression
	* @param Compiler - shader material compiler
	* @return index to the new generated expression
	*/
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	* Caption description for this expression
	* @return string caption
	*/
	virtual FString GetCaption() const;
	
	/**
	 *	Sets the default Font if none is set
	 */
	virtual void SetDefaultFont();

	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );

	/**
	 * Called to get list of parameter names for static parameter sets
	 */
	void GetAllParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
};

class UMaterialExpressionFrac : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFrac
    FExpressionInput Input;
    //## END PROPS MaterialExpressionFrac

    DECLARE_CLASS(UMaterialExpressionFrac,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFresnel : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFresnel
    FLOAT Exponent;
    FExpressionInput Normal;
    //## END PROPS MaterialExpressionFresnel

    DECLARE_CLASS(UMaterialExpressionFresnel,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const
	{
		return FString(TEXT("Fresnel"));
	}

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFunctionInput : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFunctionInput
    FExpressionInput Preview;
    FStringNoInit InputName;
    FStringNoInit Description;
    FGuid Id;
    BYTE InputType;
    SCRIPT_ALIGN;
    FVector4 PreviewValue;
    BITFIELD bUsePreviewValueAsDefault:1;
    BITFIELD bCompilingFunctionPreview:1;
    INT SortPriority;
    //## END PROPS MaterialExpressionFunctionInput

    DECLARE_CLASS(UMaterialExpressionFunctionInput,UMaterialExpression,0,Engine)
	// UObject interface
	virtual void PostLoad();
	virtual void PostDuplicate();
	virtual void PostEditImport();
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual UBOOL CanEditChange( const UProperty* InProperty ) const;

	// UMaterialExpression interface
	virtual FString GetCaption() const;
	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
	virtual void GetExpressionToolTip(TArray<FString>& OutToolTip);
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT CompilePreview(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	/** Generates the Id for this input. */
	void ConditionallyGenerateId(UBOOL bForce);

	/** Validates InputName.  Must be called after InputName is changed to prevent duplicate inputs. */
	void ValidateName();

private:

	/** Helper function which compiles this expression for previewing. */
	INT CompilePreviewValue(FMaterialCompiler* Compiler);
};

class UMaterialExpressionFunctionOutput : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionFunctionOutput
    FStringNoInit OutputName;
    FStringNoInit Description;
    INT SortPriority;
    FExpressionInput A;
    BITFIELD bLastPreviewed:1;
    SCRIPT_ALIGN;
    FGuid Id;
    //## END PROPS MaterialExpressionFunctionOutput

    DECLARE_CLASS(UMaterialExpressionFunctionOutput,UMaterialExpression,0,Engine)
	// UObject interface
	virtual void PostLoad();
	virtual void PostDuplicate();
	virtual void PostEditImport();
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// UMaterialExpression interface
	virtual FString GetCaption() const;
	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
	virtual FString GetInputName(INT InputIndex) const
	{
		return TEXT("");
	}
	virtual void GetExpressionToolTip(TArray<FString>& OutToolTip);
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/** Generates the Id for this input. */
	void ConditionallyGenerateId(UBOOL bForce);

	/** Validates OutputName.  Must be called after OutputName is changed to prevent duplicate outputs. */
	void ValidateName();
};

class UMaterialExpressionIf : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionIf
    FExpressionInput A;
    FExpressionInput B;
    FExpressionInput AGreaterThanB;
    FExpressionInput AEqualsB;
    FExpressionInput ALessThanB;
    //## END PROPS MaterialExpressionIf

    DECLARE_CLASS(UMaterialExpressionIf,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

struct FLayerBlendInput
{
    FName LayerName;
    BYTE BlendType;
    SCRIPT_ALIGN;
    FExpressionInput LayerInput;
    FExpressionInput HeightInput;
    FLOAT PreviewWeight;
    const FStaticTerrainLayerWeightParameter* InstanceOverride;

    /** Constructors */
    FLayerBlendInput() {}
    FLayerBlendInput(EEventParm)
    {
        appMemzero(this, sizeof(FLayerBlendInput));
    }
};

class UMaterialExpressionLandscapeLayerBlend : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLandscapeLayerBlend
    TArrayNoInit<struct FLayerBlendInput> Layers;
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionLandscapeLayerBlend

    DECLARE_CLASS(UMaterialExpressionLandscapeLayerBlend,UMaterialExpression,0,Engine)
	// UMaterialExpression interface
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	void SwapReferenceTo( UMaterialExpression* OldExpression, UMaterialExpression* NewExpression );
	virtual const TArray<FExpressionInput*> GetInputs();
	virtual FExpressionInput* GetInput(INT InputIndex);
	virtual FString GetInputName(INT InputIndex) const;

	/** GUID generation. */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);
	virtual void PostLoad();
	virtual void PostDuplicate();
	virtual void PostEditImport();

#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Called by the CleanupMaterials function, this will clear the inputs of the expression.
	 *	This only needs to be implemented by expressions that have bUsedByStaticParameterSet set to TRUE.
	 */
	virtual void ClearInputExpressions();
#endif

	/**
	 * Called to get list of parameter names for static parameter sets
	 */
	void GetAllParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * Sets overrides in the material expression's static parameters
	 *
	 * @param	Permutation		The set of static parameters to override and their values	
	 */
	virtual void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);

	/**
	 * Clears static parameter overrides so that static parameter expression defaults will be used
	 *	for subsequent compiles.
	 */
	virtual void ClearStaticParameterOverrides();
};

class UMaterialExpressionLensFlareIntensity : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareIntensity
    //## END PROPS MaterialExpressionLensFlareIntensity

    DECLARE_CLASS(UMaterialExpressionLensFlareIntensity,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareOcclusion : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareOcclusion
    //## END PROPS MaterialExpressionLensFlareOcclusion

    DECLARE_CLASS(UMaterialExpressionLensFlareOcclusion,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareRadialDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareRadialDistance
    //## END PROPS MaterialExpressionLensFlareRadialDistance

    DECLARE_CLASS(UMaterialExpressionLensFlareRadialDistance,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareRayDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareRayDistance
    //## END PROPS MaterialExpressionLensFlareRayDistance

    DECLARE_CLASS(UMaterialExpressionLensFlareRayDistance,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLensFlareSourceDistance : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLensFlareSourceDistance
    //## END PROPS MaterialExpressionLensFlareSourceDistance

    DECLARE_CLASS(UMaterialExpressionLensFlareSourceDistance,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	
	/**
	 *	Get the width required by this expression (in the material editor).
	 *
	 *	@return	INT			The width in pixels.
	 */
	virtual INT GetWidth() const;
	
	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionLightmapUVs : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLightmapUVs
    //## END PROPS MaterialExpressionLightmapUVs

    DECLARE_CLASS(UMaterialExpressionLightmapUVs,UMaterialExpression,0,Engine)
	// UMaterialExpression interface.
    /**
	 * Creates the new shader code chunk needed for the Abs expression
	 *
	 * @param	Compiler - Material compiler that knows how to handle this expression
	 * @return	Index to the new FMaterialCompiler::CodeChunk entry for this expression
	 */	
	virtual INT Compile( FMaterialCompiler* Compiler, INT OutputIndex );

	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;
};

class UMaterialExpressionLightmassReplace : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLightmassReplace
    FExpressionInput Realtime;
    FExpressionInput Lightmass;
    //## END PROPS MaterialExpressionLightmassReplace

    DECLARE_CLASS(UMaterialExpressionLightmassReplace,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionLightVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLightVector
    //## END PROPS MaterialExpressionLightVector

    DECLARE_CLASS(UMaterialExpressionLightVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionLinearInterpolate : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionLinearInterpolate
    FExpressionInput A;
    FExpressionInput B;
    FExpressionInput Alpha;
    //## END PROPS MaterialExpressionLinearInterpolate

    DECLARE_CLASS(UMaterialExpressionLinearInterpolate,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

struct FFunctionExpressionInput
{
    class UMaterialExpressionFunctionInput* ExpressionInput;
    FGuid ExpressionInputId;
    FExpressionInput Input;

    /** Constructors */
    FFunctionExpressionInput() {}
    FFunctionExpressionInput(EEventParm)
    {
        appMemzero(this, sizeof(FFunctionExpressionInput));
    }
};

struct FFunctionExpressionOutput
{
    class UMaterialExpressionFunctionOutput* ExpressionOutput;
    FGuid ExpressionOutputId;
    FExpressionOutput Output;

    /** Constructors */
    FFunctionExpressionOutput() {}
    FFunctionExpressionOutput(EEventParm)
    {
        appMemzero(this, sizeof(FFunctionExpressionOutput));
    }
};

class UMaterialExpressionMaterialFunctionCall : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionMaterialFunctionCall
    class UMaterialFunction* MaterialFunction;
    TArrayNoInit<struct FFunctionExpressionInput> FunctionInputs;
    TArrayNoInit<struct FFunctionExpressionOutput> FunctionOutputs;
    //## END PROPS MaterialExpressionMaterialFunctionCall

    DECLARE_CLASS(UMaterialExpressionMaterialFunctionCall,UMaterialExpression,0,Engine)
	// UObject interface
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// UMaterialExpression interface
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	void SwapReferenceTo( UMaterialExpression* OldExpression, UMaterialExpression* NewExpression );
	virtual const TArray<FExpressionInput*> GetInputs();
	virtual FExpressionInput* GetInput(INT InputIndex);
	virtual FString GetInputName(INT InputIndex) const;
	virtual UBOOL IsInputConnectionRequired(INT InputIndex) const;
	virtual void GetConnectorToolTip(INT InputIndex, INT OutputIndex, TArray<FString>& OutToolTip);
	virtual void GetExpressionToolTip(TArray<FString>& OutToolTip);
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );

	/** Sets a new material function, given an old function so that links can be passed over if the name matches. */
	void SetMaterialFunction(UMaterialFunction* ThisFunctionResource, UMaterialFunction* OldFunctionResource, UMaterialFunction* NewResource);

	/** 
	 * Updates FunctionInputs and FunctionOutputs from the MaterialFunction.  
	 * This must be called to keep the inputs and outputs up to date with the function being used. 
	 */
	void UpdateFromFunctionResource();

private:
	
	/** Helper that fixes up expression links where possible. */
	void FixupReferencingExpressions(
		const TArray<FFunctionExpressionOutput>& NewOutputs,
		const TArray<FFunctionExpressionOutput>& OriginalOutputs,
		TArray<UMaterialExpression*>& Expressions, 
		TArray<FExpressionInput*>& MaterialInputs,
		UBOOL bMatchByName);
};

class UMaterialExpressionMeshEmitterVertexColor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionMeshEmitterVertexColor
    //## END PROPS MaterialExpressionMeshEmitterVertexColor

    DECLARE_CLASS(UMaterialExpressionMeshEmitterVertexColor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionMultiply : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionMultiply
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionMultiply

    DECLARE_CLASS(UMaterialExpressionMultiply,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionNormalize : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionNormalize
    FExpressionInput VectorInput;
    //## END PROPS MaterialExpressionNormalize

    DECLARE_CLASS(UMaterialExpressionNormalize,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const { return TEXT("Normalize"); }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionObjectOrientation : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionObjectOrientation
    //## END PROPS MaterialExpressionObjectOrientation

    DECLARE_CLASS(UMaterialExpressionObjectOrientation,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionObjectRadius : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionObjectRadius
    //## END PROPS MaterialExpressionObjectRadius

    DECLARE_CLASS(UMaterialExpressionObjectRadius,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionObjectWorldPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionObjectWorldPosition
    //## END PROPS MaterialExpressionObjectWorldPosition

    DECLARE_CLASS(UMaterialExpressionObjectWorldPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionOcclusionPercentage : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionOcclusionPercentage
    //## END PROPS MaterialExpressionOcclusionPercentage

    DECLARE_CLASS(UMaterialExpressionOcclusionPercentage,UMaterialExpression,0,Engine)
	/**
	 *	Compile this expression with the given compiler.
	 *	
	 *	@return	INT			The code index for this expression.
	 */
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	 *	Returns the text to display on the material expression (in the material editor).
	 *
	 *	@return	FString		The text to display.
	 */
	virtual FString GetCaption() const;
	
	/**
	 *	Returns the amount of padding to use for the label.
	 *
	 *	@return INT			The padding (in pixels).
	 */
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionOneMinus : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionOneMinus
    FExpressionInput Input;
    //## END PROPS MaterialExpressionOneMinus

    DECLARE_CLASS(UMaterialExpressionOneMinus,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionPanner : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPanner
    FExpressionInput Coordinate;
    FExpressionInput Time;
    FLOAT SpeedX;
    FLOAT SpeedY;
    //## END PROPS MaterialExpressionPanner

    DECLARE_CLASS(UMaterialExpressionPanner,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	/**
	 * @return TRUE if the expression preview needs realtime update
     */
	virtual UBOOL NeedsRealtimePreview() { return Time.Expression==NULL && (SpeedX != 0.f || SpeedY != 0.f); }
};

class UMaterialExpressionParameter : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionParameter
    FName ParameterName;
    FGuid ExpressionGUID;
    FName Group;
    //## END PROPS MaterialExpressionParameter

    DECLARE_CLASS(UMaterialExpressionParameter,UMaterialExpression,0,Engine)
	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );

	/**
	 * Called to get list of parameter names for static parameter sets
	 */
	void GetAllParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
};

class UMaterialExpressionScalarParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionScalarParameter
    FLOAT DefaultValue;
    //## END PROPS MaterialExpressionScalarParameter

    DECLARE_CLASS(UMaterialExpressionScalarParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionStaticBoolParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionStaticBoolParameter
    BITFIELD DefaultValue:1;
    BITFIELD ExtendedCaptionDisplay:1;
    SCRIPT_ALIGN;
    const FStaticSwitchParameter* InstanceOverride;
    //## END PROPS MaterialExpressionStaticBoolParameter

    DECLARE_CLASS(UMaterialExpressionStaticBoolParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT CompilePreview(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	virtual void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);
	virtual void ClearStaticParameterOverrides();
};

class UMaterialExpressionStaticSwitchParameter : public UMaterialExpressionStaticBoolParameter
{
public:
    //## BEGIN PROPS MaterialExpressionStaticSwitchParameter
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionStaticSwitchParameter

    DECLARE_CLASS(UMaterialExpressionStaticSwitchParameter,UMaterialExpressionStaticBoolParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	virtual FString GetInputName(INT InputIndex) const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

#if WITH_EDITOR
	/**
	 *	Called by the CleanupMaterials function, this will clear the inputs of the expression.
	 *	This only needs to be implemented by expressions that have bUsedByStaticParameterSet set to TRUE.
	 */
	virtual void ClearInputExpressions();
#endif
};

class UMaterialExpressionStaticComponentMaskParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionStaticComponentMaskParameter
    FExpressionInput Input;
    BITFIELD DefaultR:1;
    BITFIELD DefaultG:1;
    BITFIELD DefaultB:1;
    BITFIELD DefaultA:1;
    SCRIPT_ALIGN;
    const FStaticComponentMaskParameter* InstanceOverride;
    //## END PROPS MaterialExpressionStaticComponentMaskParameter

    DECLARE_CLASS(UMaterialExpressionStaticComponentMaskParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

#if WITH_EDITOR
	/**
	 *	Called by the CleanupMaterials function, this will clear the inputs of the expression.
	 *	This only needs to be implemented by expressions that have bUsedByStaticParameterSet set to TRUE.
	 */
	virtual void ClearInputExpressions();
#endif

	virtual void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);
	virtual void ClearStaticParameterOverrides();
};

class UMaterialExpressionVectorParameter : public UMaterialExpressionParameter
{
public:
    //## BEGIN PROPS MaterialExpressionVectorParameter
    FLinearColor DefaultValue;
    //## END PROPS MaterialExpressionVectorParameter

    DECLARE_CLASS(UMaterialExpressionVectorParameter,UMaterialExpressionParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionParticleMacroUV : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionParticleMacroUV
    BITFIELD bUseViewSpace:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionParticleMacroUV

    DECLARE_CLASS(UMaterialExpressionParticleMacroUV,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionPerInstanceRandom : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPerInstanceRandom
    //## END PROPS MaterialExpressionPerInstanceRandom

    DECLARE_CLASS(UMaterialExpressionPerInstanceRandom,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionPixelDepth : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPixelDepth
    BITFIELD bNormalize:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionPixelDepth

    DECLARE_CLASS(UMaterialExpressionPixelDepth,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionPower : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionPower
    FExpressionInput Base;
    FExpressionInput Exponent;
    //## END PROPS MaterialExpressionPower

    DECLARE_CLASS(UMaterialExpressionPower,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionQualitySwitch : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionQualitySwitch
    FExpressionInput High;
    FExpressionInput Low;
    //## END PROPS MaterialExpressionQualitySwitch

    DECLARE_CLASS(UMaterialExpressionQualitySwitch,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionReflectionVector : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionReflectionVector
    //## END PROPS MaterialExpressionReflectionVector

    DECLARE_CLASS(UMaterialExpressionReflectionVector,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionRotateAboutAxis : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionRotateAboutAxis
    FExpressionInput NormalizedRotationAxisAndAngle;
    FExpressionInput PositionOnAxis;
    FExpressionInput Position;
    //## END PROPS MaterialExpressionRotateAboutAxis

    DECLARE_CLASS(UMaterialExpressionRotateAboutAxis,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionRotator : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionRotator
    FExpressionInput Coordinate;
    FExpressionInput Time;
    FLOAT CenterX;
    FLOAT CenterY;
    FLOAT Speed;
    //## END PROPS MaterialExpressionRotator

    DECLARE_CLASS(UMaterialExpressionRotator,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	/**
	 * @return TRUE if the expression preview needs realtime update
     */
	virtual UBOOL NeedsRealtimePreview() { return Time.Expression==NULL && Speed != 0.f; }
};

class UMaterialExpressionSceneDepth : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSceneDepth
    FExpressionInput Coordinates;
    BITFIELD bNormalize:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionSceneDepth

    DECLARE_CLASS(UMaterialExpressionSceneDepth,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	virtual FString GetCaption() const;
};

class UMaterialExpressionSceneTexture : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSceneTexture
    FExpressionInput Coordinates;
    BYTE SceneTextureType;
    SCRIPT_ALIGN;
    BITFIELD ScreenAlign:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionSceneTexture

    DECLARE_CLASS(UMaterialExpressionSceneTexture,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	virtual FString GetCaption() const;
};

class UMaterialExpressionScreenPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionScreenPosition
    BITFIELD ScreenAlign:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionScreenPosition

    DECLARE_CLASS(UMaterialExpressionScreenPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionScreenSize : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionScreenSize
    //## END PROPS MaterialExpressionScreenSize

    DECLARE_CLASS(UMaterialExpressionScreenSize,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionSine : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSine
    FExpressionInput Input;
    FLOAT Period;
    //## END PROPS MaterialExpressionSine

    DECLARE_CLASS(UMaterialExpressionSine,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionSphereMask : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSphereMask
    FExpressionInput A;
    FExpressionInput B;
    FExpressionInput Radius;
    FExpressionInput Hardness;
    FLOAT AttenuationRadius;
    FLOAT HardnessPercent;
    //## END PROPS MaterialExpressionSphereMask

    DECLARE_CLASS(UMaterialExpressionSphereMask,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	virtual void Serialize(FArchive& Ar);

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionSquareRoot : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSquareRoot
    FExpressionInput Input;
    //## END PROPS MaterialExpressionSquareRoot

    DECLARE_CLASS(UMaterialExpressionSquareRoot,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionStaticBool : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionStaticBool
    BITFIELD Value:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionStaticBool

    DECLARE_CLASS(UMaterialExpressionStaticBool,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT CompilePreview(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionStaticSwitch : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionStaticSwitch
    BITFIELD DefaultValue:1;
    BITFIELD ExtendedCaptionDisplay:1;
    SCRIPT_ALIGN;
    FExpressionInput A;
    FExpressionInput B;
    FExpressionInput Value;
    //## END PROPS MaterialExpressionStaticSwitch

    DECLARE_CLASS(UMaterialExpressionStaticSwitch,UMaterialExpression,0,Engine)
	virtual UBOOL CanEditChange( const UProperty* InProperty ) const;
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	virtual FString GetInputName(INT InputIndex) const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionSubtract : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionSubtract
    FExpressionInput A;
    FExpressionInput B;
    //## END PROPS MaterialExpressionSubtract

    DECLARE_CLASS(UMaterialExpressionSubtract,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTerrainLayerCoords : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTerrainLayerCoords
    BYTE MappingType;
    FLOAT MappingScale;
    FLOAT MappingRotation;
    FLOAT MappingPanU;
    FLOAT MappingPanV;
    //## END PROPS MaterialExpressionTerrainLayerCoords

    DECLARE_CLASS(UMaterialExpressionTerrainLayerCoords,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionTerrainLayerSwitch : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTerrainLayerSwitch
    const FStaticTerrainLayerWeightParameter* InstanceOverride;
    FExpressionInput LayerUsed;
    FExpressionInput LayerNotUsed;
    FName ParameterName;
    BITFIELD PreviewUsed:1;
    SCRIPT_ALIGN;
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionTerrainLayerSwitch

    DECLARE_CLASS(UMaterialExpressionTerrainLayerSwitch,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	
	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );

	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();

#if WITH_EDITOR
	/**
	 *	Called by the CleanupMaterials function, this will clear the inputs of the expression.
	 *	This only needs to be implemented by expressions that have bUsedByStaticParameterSet set to TRUE.
	 */
	virtual void ClearInputExpressions();
#endif

	/**
	 * Called to get list of parameter names for static parameter sets
	 */
	void GetAllParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * Sets overrides in the material expression's static parameters
	 *
	 * @param	Permutation		The set of static parameters to override and their values	
	 */
	virtual void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);

	/**
	 * Clears static parameter overrides so that static parameter expression defaults will be used
	 *	for subsequent compiles.
	 */
	virtual void ClearStaticParameterOverrides();
};

class UMaterialExpressionTerrainLayerWeight : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTerrainLayerWeight
    const FStaticTerrainLayerWeightParameter* InstanceOverride;
    FExpressionInput Base;
    FExpressionInput Layer;
    FName ParameterName;
    FLOAT PreviewWeight;
    FGuid ExpressionGUID;
    //## END PROPS MaterialExpressionTerrainLayerWeight

    DECLARE_CLASS(UMaterialExpressionTerrainLayerWeight,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );

	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();

#if WITH_EDITOR
	/**
	 *	Called by the CleanupMaterials function, this will clear the inputs of the expression.
	 *	This only needs to be implemented by expressions that have bUsedByStaticParameterSet set to TRUE.
	 */
	virtual void ClearInputExpressions();
#endif

	/**
	 * Called to get list of parameter names for static parameter sets
	 */
	void GetAllParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * Sets overrides in the material expression's static parameters
	 *
	 * @param	Permutation		The set of static parameters to override and their values	
	 */
	virtual void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);

	/**
	 * Clears static parameter overrides so that static parameter expression defaults will be used
	 *	for subsequent compiles.
	 */
	virtual void ClearStaticParameterOverrides();
};

class UMaterialExpressionTexelSize : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTexelSize
    //## END PROPS MaterialExpressionTexelSize

    DECLARE_CLASS(UMaterialExpressionTexelSize,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionTextureCoordinate : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTextureCoordinate
    INT CoordinateIndex;
    FLOAT UTiling;
    FLOAT VTiling;
    BITFIELD UnMirrorU:1;
    BITFIELD UnMirrorV:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionTextureCoordinate

    DECLARE_CLASS(UMaterialExpressionTextureCoordinate,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionTextureObject : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTextureObject
    class UTexture* Texture;
    //## END PROPS MaterialExpressionTextureObject

    DECLARE_CLASS(UMaterialExpressionTextureObject,UMaterialExpression,0,Engine)
	virtual FString GetCaption() const;
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT CompilePreview(FMaterialCompiler* Compiler, INT OutputIndex);
};

class UMaterialExpressionTextureSample : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSample
    class UTexture* Texture;
    FExpressionInput Coordinates;
    FExpressionInput TextureObject;
    //## END PROPS MaterialExpressionTextureSample

    DECLARE_CLASS(UMaterialExpressionTextureSample,UMaterialExpression,0,Engine)
	UBOOL CanEditChange(const UProperty* InProperty) const;

	virtual const TArray<FExpressionInput*> GetInputs();
	virtual FExpressionInput* GetInput(INT InputIndex);
	virtual FString GetInputName(INT InputIndex) const;
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }
	
	/**
	 * Updates the material's cached reference to the resource for a given texture.
	 * @param Texture - The UTexture which has a new FTexture.
	 */
	void UpdateTextureResource(class UTexture* Texture);

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );
};

class UMaterialExpressionDepthBiasBlend : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionDepthBiasBlend
    BITFIELD bNormalize:1;
    FLOAT BiasScale;
    FExpressionInput Bias;
    //## END PROPS MaterialExpressionDepthBiasBlend

    DECLARE_CLASS(UMaterialExpressionDepthBiasBlend,UMaterialExpressionTextureSample,0,Engine)
	/**
	 *	Compile the material expression
	 *
	 *	@param	Compiler	Pointer to the material compiler to use
	 *
	 *	@return	INT			The compiled code index
	 */	
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);

	/**
	 */	
	virtual INT GetWidth() const;

	/**
	 */	
	virtual FString GetCaption() const;

	/**
	 */	
	virtual INT GetLabelPadding() { return 8; }

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionFlipBookSample : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionFlipBookSample
    //## END PROPS MaterialExpressionFlipBookSample

    DECLARE_CLASS(UMaterialExpressionFlipBookSample,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionMeshSubUV : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionMeshSubUV
    //## END PROPS MaterialExpressionMeshSubUV

    DECLARE_CLASS(UMaterialExpressionMeshSubUV,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionMeshSubUVBlend : public UMaterialExpressionMeshSubUV
{
public:
    //## BEGIN PROPS MaterialExpressionMeshSubUVBlend
    //## END PROPS MaterialExpressionMeshSubUVBlend

    DECLARE_CLASS(UMaterialExpressionMeshSubUVBlend,UMaterialExpressionMeshSubUV,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionParticleSubUV : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionParticleSubUV
    //## END PROPS MaterialExpressionParticleSubUV

    DECLARE_CLASS(UMaterialExpressionParticleSubUV,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT GetWidth() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 8; }
};

class UMaterialExpressionTextureSampleParameter : public UMaterialExpressionTextureSample
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameter
    FName ParameterName;
    FGuid ExpressionGUID;
    FName Group;
    //## END PROPS MaterialExpressionTextureSampleParameter

    DECLARE_ABSTRACT_CLASS(UMaterialExpressionTextureSampleParameter,UMaterialExpressionTextureSample,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();

	/** 
	 * Generates a GUID for this expression if one doesn't already exist. 
	 *
	 * @param bForceGeneration	Whether we should generate a GUID even if it is already valid.
	 */
	void ConditionallyGenerateGUID(UBOOL bForceGeneration=FALSE);

	/** Tries to generate a GUID. */
	virtual void PostLoad();

	/** Tries to generate a GUID. */
	virtual void PostDuplicate();

	/** Tries to generate a GUID. */
	virtual void PostEditImport();

	/**
	 * MatchesSearchQuery: Check this expression to see if it matches the search query
	 * @param SearchQuery - User's search query (never blank)
	 * @return TRUE if the expression matches the search query
     */
	virtual UBOOL MatchesSearchQuery( const TCHAR* SearchQuery );

	/**
	 * Called to get list of parameter names for static parameter sets
	 */
	void GetAllParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
};

class UMaterialExpressionTextureObjectParameter : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureObjectParameter
    //## END PROPS MaterialExpressionTextureObjectParameter

    DECLARE_CLASS(UMaterialExpressionTextureObjectParameter,UMaterialExpressionTextureSampleParameter,0,Engine)
	virtual FString GetCaption() const;
	virtual const TCHAR* GetRequirements();
	virtual const TArray<FExpressionInput*> GetInputs();
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual INT CompilePreview(FMaterialCompiler* Compiler, INT OutputIndex);
};

class UMaterialExpressionTextureSampleParameter2D : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameter2D
    //## END PROPS MaterialExpressionTextureSampleParameter2D

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameter2D,UMaterialExpressionTextureSampleParameter,0,Engine)
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();
};

class UMaterialExpressionAntialiasedTextureMask : public UMaterialExpressionTextureSampleParameter2D
{
public:
    //## BEGIN PROPS MaterialExpressionAntialiasedTextureMask
    FLOAT Threshold;
    BYTE Channel;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionAntialiasedTextureMask

    DECLARE_CLASS(UMaterialExpressionAntialiasedTextureMask,UMaterialExpressionTextureSampleParameter2D,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	virtual void SetDefaultTexture();

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTextureSampleParameterFlipbook : public UMaterialExpressionTextureSampleParameter2D
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterFlipbook
    //## END PROPS MaterialExpressionTextureSampleParameterFlipbook

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterFlipbook,UMaterialExpressionTextureSampleParameter2D,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
};

class UMaterialExpressionTextureSampleParameterMeshSubUV : public UMaterialExpressionTextureSampleParameter2D
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterMeshSubUV
    //## END PROPS MaterialExpressionTextureSampleParameterMeshSubUV

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterMeshSubUV,UMaterialExpressionTextureSampleParameter2D,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
};

class UMaterialExpressionTextureSampleParameterMeshSubUVBlend : public UMaterialExpressionTextureSampleParameterMeshSubUV
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterMeshSubUVBlend
    //## END PROPS MaterialExpressionTextureSampleParameterMeshSubUVBlend

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterMeshSubUVBlend,UMaterialExpressionTextureSampleParameterMeshSubUV,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionTextureSampleParameterSubUV : public UMaterialExpressionTextureSampleParameter2D
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterSubUV
    //## END PROPS MaterialExpressionTextureSampleParameterSubUV

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterSubUV,UMaterialExpressionTextureSampleParameter2D,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
};

class UMaterialExpressionTextureSampleParameterCube : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterCube
    //## END PROPS MaterialExpressionTextureSampleParameterCube

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterCube,UMaterialExpressionTextureSampleParameter,0,Engine)
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();
};

class UMaterialExpressionTextureSampleParameterMovie : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterMovie
    //## END PROPS MaterialExpressionTextureSampleParameterMovie

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterMovie,UMaterialExpressionTextureSampleParameter,0,Engine)
	/**
	 * Textual description for this material expression
	 *
	 * @return	Caption text
	 */	
	virtual FString GetCaption() const;

	/**
	 * Return true if the texture is a movie texture
	 *
	 * @param	InTexture - texture to test
	 * @return	true/false
	 */	
	virtual UBOOL TextureIsValid( UTexture* InTexture );

    /**
	 * Called when TextureIsValid==false
	 *
	 * @return	Descriptive error text
	 */	
	virtual const TCHAR* GetRequirements();
};

class UMaterialExpressionTextureSampleParameterNormal : public UMaterialExpressionTextureSampleParameter
{
public:
    //## BEGIN PROPS MaterialExpressionTextureSampleParameterNormal
    const FNormalParameter* InstanceOverride;
    //## END PROPS MaterialExpressionTextureSampleParameterNormal

    DECLARE_CLASS(UMaterialExpressionTextureSampleParameterNormal,UMaterialExpressionTextureSampleParameter,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
	virtual UBOOL TextureIsValid( UTexture* InTexture );
	virtual const TCHAR* GetRequirements();
	
	virtual void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);
	virtual void ClearStaticParameterOverrides();

	/**
	 *	Sets the default texture if none is set
	 */
	virtual void SetDefaultTexture();

	/**
	 *	Since there are no input expressions, the ClearInputExpressions function is not required.
	 */
};

class UMaterialExpressionTime : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTime
    BITFIELD bIgnorePause:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionTime

    DECLARE_CLASS(UMaterialExpressionTime,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * @return TRUE if the expression preview needs realtime update
     */
	virtual UBOOL NeedsRealtimePreview() { return TRUE; }
};

class UMaterialExpressionTransform : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTransform
    FExpressionInput Input;
    BYTE TransformSourceType;
    BYTE TransformType;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionTransform

    DECLARE_CLASS(UMaterialExpressionTransform,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTransformPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTransformPosition
    FExpressionInput Input;
    BYTE TransformSourceType;
    BYTE TransformType;
    SCRIPT_ALIGN;
    //## END PROPS MaterialExpressionTransformPosition

    DECLARE_CLASS(UMaterialExpressionTransformPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialExpressionTwoSidedSign : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionTwoSidedSign
    //## END PROPS MaterialExpressionTwoSidedSign

    DECLARE_CLASS(UMaterialExpressionTwoSidedSign,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionVertexColor : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionVertexColor
    //## END PROPS MaterialExpressionVertexColor

    DECLARE_CLASS(UMaterialExpressionVertexColor,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionWindDirectionAndSpeed : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionWindDirectionAndSpeed
    //## END PROPS MaterialExpressionWindDirectionAndSpeed

    DECLARE_CLASS(UMaterialExpressionWindDirectionAndSpeed,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionWorldNormal : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionWorldNormal
    //## END PROPS MaterialExpressionWorldNormal

    DECLARE_CLASS(UMaterialExpressionWorldNormal,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;
};

class UMaterialExpressionWorldPosition : public UMaterialExpression
{
public:
    //## BEGIN PROPS MaterialExpressionWorldPosition
    //## END PROPS MaterialExpressionWorldPosition

    DECLARE_CLASS(UMaterialExpressionWorldPosition,UMaterialExpression,0,Engine)
	virtual INT Compile(FMaterialCompiler* Compiler, INT OutputIndex);
	virtual FString GetCaption() const;

	/**
	 * Replaces references to the passed in expression with references to a different expression or NULL.
	 * @param	OldExpression		Expression to find reference to.
	 * @param	NewExpression		Expression to replace reference with.
	 */
	virtual void SwapReferenceTo(UMaterialExpression* OldExpression,UMaterialExpression* NewExpression = NULL);
};

class UMaterialFunction : public UObject
{
public:
    //## BEGIN PROPS MaterialFunction
    FGuid StateId;
#if WITH_EDITORONLY_DATA
    class UMaterialFunction* ParentFunction;
#endif // WITH_EDITORONLY_DATA
    FStringNoInit Description;
    BITFIELD bExposeToLibrary:1;
    BITFIELD bReentrantFlag:1;
    TArrayNoInit<FString> LibraryCategories;
    TArrayNoInit<class UMaterialExpression*> FunctionExpressions;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class UMaterialExpressionComment*> FunctionEditorComments;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS MaterialFunction

    DECLARE_CLASS(UMaterialFunction,UObject,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();

	/** Recursively updates all function call expressions in this function, or in nested functions. */
	void UpdateFromFunctionResource();

	/** Gets the inputs and outputs that this function exposes, for a function call expression to use. */
	void GetInputsAndOutputs(TArray<FFunctionExpressionInput>& OutInputs, TArray<FFunctionExpressionOutput>& OutOutputs) const;

	INT Compile(FMaterialCompiler* Compiler, const FFunctionExpressionOutput& Output, const TArray<FFunctionExpressionInput>& Inputs);

	/** Returns TRUE if this function is dependent on the passed in function, directly or indirectly. */
	UBOOL IsDependent(UMaterialFunction* OtherFunction);

	/** Returns an array of the functions that this function is dependent on, directly or indirectly. */
	void GetDependentFunctions(TArray<UMaterialFunction*>& DependentFunctions) const;
};

struct FLightmassMaterialInterfaceSettings
{
    BITFIELD bCastShadowAsMasked:1;
    FLOAT EmissiveBoost;
    FLOAT DiffuseBoost;
    FLOAT SpecularBoost;
    FLOAT ExportResolutionScale;
    FLOAT DistanceFieldPenumbraScale;
    BITFIELD bOverrideCastShadowAsMasked:1;
    BITFIELD bOverrideEmissiveBoost:1;
    BITFIELD bOverrideDiffuseBoost:1;
    BITFIELD bOverrideSpecularBoost:1;
    BITFIELD bOverrideExportResolutionScale:1;
    BITFIELD bOverrideDistanceFieldPenumbraScale:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FLightmassMaterialInterfaceSettings() {}
    FLightmassMaterialInterfaceSettings(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassMaterialInterfaceSettings));
    }
};

class UMaterialInterface : public USurface
{
public:
    //## BEGIN PROPS MaterialInterface
    FRenderCommandFence ParentRefFence;
protected:
    struct FLightmassMaterialInterfaceSettings LightmassSettings;
public:
#if WITH_EDITORONLY_DATA
    FStringNoInit PreviewMesh;
    FGuid LightingGuid;
#endif // WITH_EDITORONLY_DATA
    BITFIELD bHasQualitySwitch:1;
    BITFIELD bAutoFlattenMobile:1;
    BITFIELD bAutoFlattenMobileNormalTexture:1;
    BITFIELD bMobileAllowFog:1;
    BITFIELD bGenerateSubUV:1;
    BITFIELD bUseMobileSpecular:1;
    BITFIELD bUseMobileVertexSpecular_DEPRECATED:1;
    BITFIELD bUseMobilePixelSpecular:1;
    BITFIELD bUseMobileBumpOffset:1;
    BITFIELD bLockColorBlending:1;
    BITFIELD bUseMobileUniformColorMultiply:1;
    BITFIELD bUseMobileVertexColorMultiply:1;
    BITFIELD bUseMobileDetailNormal:1;
    BITFIELD bBaseTextureTransformed:1;
    BITFIELD bEmissiveTextureTransformed:1;
    BITFIELD bNormalTextureTransformed:1;
    BITFIELD bMaskTextureTransformed:1;
    BITFIELD bDetailTextureTransformed:1;
    BITFIELD bUseMobileWaveVertexMovement:1;
    BITFIELD bMobileEnableBounceLight:1;
    BITFIELD bUseMobileLandscapeMonochromeLayerBlending:1;
    SCRIPT_ALIGN;
    FColor FlattenBackgroundColor;
    class UTexture* MobileBaseTexture;
    class UTexture* FlattenedTexture_DEPRECATED;
    BYTE MobileBaseTextureTexCoordsSource;
    BYTE MobileAmbientOcclusionSource;
    BYTE MobileSpecularMask;
    BYTE MobileEmissiveColorSource;
    BYTE MobileEmissiveMaskSource;
    BYTE MobileEnvironmentMaskSource;
    BYTE MobileEnvironmentBlendMode;
    BYTE MobileRimLightingMaskSource;
    BYTE MobileMaskTextureTexCoordsSource;
    BYTE MobileAlphaValueSource;
    BYTE MobileDetailTextureTexCoordsSource;
    BYTE MobileTextureBlendFactorSource;
    BYTE MobileColorMultiplySource;
    class UTexture* MobileNormalTexture;
    FLOAT SubUVFrameRate;
    INT SubUVFrameCountAlongAxes;
    FLOAT SubUVFrameSize;
    FLinearColor MobileSpecularColor;
    FLOAT MobileSpecularPower;
    class UTexture* MobileEmissiveTexture;
    FLinearColor MobileEmissiveColor;
    class UTexture* MobileEnvironmentTexture;
    FLOAT MobileEnvironmentAmount;
    FLinearColor MobileEnvironmentColor;
    FLOAT MobileEnvironmentFresnelAmount;
    FLOAT MobileEnvironmentFresnelExponent;
    FLOAT MobileRimLightingStrength;
    FLOAT MobileRimLightingExponent;
    FLinearColor MobileRimLightingColor;
    FLOAT MobileBumpOffsetReferencePlane;
    FLOAT MobileBumpOffsetHeightRatio;
    class UTexture* MobileMaskTexture;
    FLOAT MobileOpacityMultiplier;
    class UTexture* MobileDetailTexture;
    class UTexture* MobileDetailTexture2;
    class UTexture* MobileDetailTexture3;
    FLinearColor DefaultUniformColor_DEPRECATED;
    FLinearColor MobileDefaultUniformColor;
    FLOAT TransformCenterX_DEPRECATED;
    FLOAT MobileTransformCenterX;
    FLOAT TransformCenterY_DEPRECATED;
    FLOAT MobileTransformCenterY;
    FLOAT PannerSpeedX_DEPRECATED;
    FLOAT MobilePannerSpeedX;
    FLOAT PannerSpeedY_DEPRECATED;
    FLOAT MobilePannerSpeedY;
    FLOAT RotateSpeed_DEPRECATED;
    FLOAT MobileRotateSpeed;
    FLOAT FixedScaleX_DEPRECATED;
    FLOAT MobileFixedScaleX;
    FLOAT FixedScaleY_DEPRECATED;
    FLOAT MobileFixedScaleY;
    FLOAT SineScaleX_DEPRECATED;
    FLOAT MobileSineScaleX;
    FLOAT SineScaleY_DEPRECATED;
    FLOAT MobileSineScaleY;
    FLOAT SineScaleFrequencyMultipler_DEPRECATED;
    FLOAT MobileSineScaleFrequencyMultipler;
    FLOAT FixedOffsetX_DEPRECATED;
    FLOAT MobileFixedOffsetX;
    FLOAT FixedOffsetY_DEPRECATED;
    FLOAT MobileFixedOffsetY;
    FLOAT MobileTangentVertexFrequencyMultiplier;
    FLOAT MobileVerticalFrequencyMultiplier;
    FLOAT MobileMaxVertexMovementAmplitude;
    FLOAT MobileSwayFrequencyMultiplier;
    FLOAT MobileSwayMaxAngle;
    FVector MobileDirectionalLightDirection;
    FLOAT MobileDirectionalLightBrightness;
    FColor MobileDirectionalLightColor;
    FVector MobileBounceLightDirection;
    FLOAT MobileBounceLightBrightness;
    FColor MobileBounceLightColor;
    FLOAT MobileSkyLightBrightness;
    FColor MobileSkyLightColor;
    FName MobileLandscapeLayerNames[4];
    FColor MobileLandscapeMonochomeLayerColors[4];
    //## END PROPS MaterialInterface

    virtual UBOOL GetParameterDesc(FName ParameterName,FString& OutDesc);
    virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue,INT& OutFontPage);
    virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
    virtual UBOOL GetScalarCurveParameterValue(FName ParameterName,FInterpCurveFloat& OutValue);
    virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
    virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
    virtual UBOOL GetVectorCurveParameterValue(FName ParameterName,FInterpCurveVector& OutValue);
    virtual UBOOL GetLinearColorParameterValue(FName ParameterName,FLinearColor& OutValue);
    virtual UBOOL GetLinearColorCurveParameterValue(FName ParameterName,FInterpCurveLinearColor& OutValue);
    virtual UBOOL GetGroupName(FName ParameterName,FName& GroupName);
    virtual UBOOL GetMobileScalarParameterValue(FName ParameterName,FLOAT& OutValue);
    virtual UBOOL GetMobileTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
    virtual UBOOL GetMobileVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
    virtual void SetForceMipLevelsToBeResident(UBOOL OverrideForceMiplevelsToBeResident,UBOOL bForceMiplevelsToBeResidentValue,FLOAT ForceDuration,INT CinematicTextureGroups=0);
    DECLARE_FUNCTION(execGetMaterial);
    DECLARE_FUNCTION(execGetPhysicalMaterial);
    DECLARE_FUNCTION(execGetParameterDesc)
    {
        P_GET_NAME(ParameterName);
        P_GET_STR_REF(OutDesc);
        P_FINISH;
        *(UBOOL*)Result=this->GetParameterDesc(ParameterName,OutDesc);
    }
    DECLARE_FUNCTION(execGetFontParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT_REF(UFont,OutFontValue);
        P_GET_INT_REF(OutFontPage);
        P_FINISH;
        *(UBOOL*)Result=this->GetFontParameterValue(ParameterName,OutFontValue,OutFontPage);
    }
    DECLARE_FUNCTION(execGetScalarParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetScalarParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetScalarCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveFloat,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetScalarCurveParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetTextureParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT_REF(UTexture,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetTextureParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetVectorParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_REF(FLinearColor,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetVectorParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetVectorCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveVector,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetVectorCurveParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetLinearColorParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_REF(FLinearColor,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetLinearColorParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetLinearColorCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveLinearColor,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetLinearColorCurveParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetGroupName)
    {
        P_GET_NAME(ParameterName);
        P_GET_NAME_REF(GroupName);
        P_FINISH;
        *(UBOOL*)Result=this->GetGroupName(ParameterName,GroupName);
    }
    DECLARE_FUNCTION(execGetMobileScalarParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetMobileScalarParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetMobileTextureParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT_REF(UTexture,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetMobileTextureParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execGetMobileVectorParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_REF(FLinearColor,OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetMobileVectorParameterValue(ParameterName,OutValue);
    }
    DECLARE_FUNCTION(execSetForceMipLevelsToBeResident)
    {
        P_GET_UBOOL(OverrideForceMiplevelsToBeResident);
        P_GET_UBOOL(bForceMiplevelsToBeResidentValue);
        P_GET_FLOAT(ForceDuration);
        P_GET_INT_OPTX(CinematicTextureGroups,0);
        P_FINISH;
        this->SetForceMipLevelsToBeResident(OverrideForceMiplevelsToBeResident,bForceMiplevelsToBeResidentValue,ForceDuration,CinematicTextureGroups);
    }
    DECLARE_ABSTRACT_CLASS(UMaterialInterface,USurface,0,Engine)
	/**
	 * Get the material which this is an instance of.
	 */
	virtual class UMaterial* GetMaterial() PURE_VIRTUAL(UMaterialInterface::GetMaterial,return NULL;);


	/**Fix up for deprecated properties*/
	virtual void PostLoad ();

	/** Perform any fixup before saving. */
	virtual void PreSave();

	/**
	* Tests this material for dependency on a given material.
	* @param	TestDependency - The material to test for dependency upon.
	* @return	True if the material is dependent on TestDependency.
	*/
	virtual UBOOL IsDependent(UMaterialInterface* TestDependency) { return TestDependency == this; }

	/**
	* Returns a pointer to the FMaterialRenderProxy used for rendering.
	*
	* @param	Selected	specify TRUE to return an alternate material used for rendering this material when part of a selection
	*						@note: only valid in the editor!
	*
	* @return	The resource to use for rendering this material instance.
	*/
	virtual FMaterialRenderProxy* GetRenderProxy(UBOOL Selected, UBOOL bHovered=FALSE) const PURE_VIRTUAL(UMaterialInterface::GetRenderProxy,return NULL;);

	/**
	* Returns a pointer to the physical material used by this material instance.
	* @return The physical material.
	*/
	virtual UPhysicalMaterial* GetPhysicalMaterial() const PURE_VIRTUAL(UMaterialInterface::GetPhysicalMaterial,return NULL;);

	/**
	 * Returns the material textures used to render this primitive for the given quality level
	 * Internally calls GetUsedMaterials() and GetUsedTextures() for each material.
	 *
	 * @param OutTextures	[out] The list of used textures.
	 * @param Quality		The platform to get material textures for. If unspecified, it will get textures for current SystemSetting
	 * @param bAllQualities	Whether to iterate for all platforms. The Platform parameter is ignored if this is set to TRUE.
	 * @param bAllowOverride Whether you want to be given the original textures or allow override textures instead of the originals.
	*/
	virtual void GetUsedTextures(TArray<UTexture*> &OutTextures, const EMaterialShaderQuality Quality=MSQ_UNSPECIFIED, const UBOOL bAllQualities = FALSE, UBOOL bAllowOverride=TRUE)
		PURE_VIRTUAL(UMaterialInterface::GetUsedTextures,);

	/**
	* Checks whether the specified texture is needed to render the material instance.
	* @param Texture	The texture to check.
	* @param bAllowOverride Whether you want to be given the original textures or allow override textures instead of the originals.
	* @return UBOOL - TRUE if the material uses the specified texture.
	*/
	virtual UBOOL UsesTexture(const UTexture* Texture, const UBOOL bAllowOverride=TRUE) PURE_VIRTUAL(UMaterialInterface::UsesTexture,return FALSE;);

	/**
	 * Overrides a specific texture (transient)
	 *
	 * @param InTextureToOverride The texture to override
	 * @param OverrideTexture The new texture to use
	 */
	virtual void OverrideTexture( const UTexture* InTextureToOverride, UTexture* OverrideTexture ) PURE_VIRTUAL(UMaterialInterface::OverrideTexture,return;);

	/**
	 * Checks if the material can be used with the given usage flag.  
	 * If the flag isn't set in the editor, it will be set and the material will be recompiled with it.
	 * @param Usage - The usage flag to check
	 * @param bSkipPrim - Bypass the primitive type checks
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	virtual UBOOL CheckMaterialUsage(const EMaterialUsage Usage, const UBOOL bSkipPrim = FALSE) PURE_VIRTUAL(UMaterialInterface::CheckMaterialUsage,return FALSE;);

	/**
	* Allocates a new material resource
	* @return	The allocated resource
	*/
	virtual FMaterialResource* AllocateResource() PURE_VIRTUAL(UMaterialInterface::AllocateResource,return NULL;);

	/**
	 * Gets the static permutation resource if the instance has one
	 * @return - the appropriate FMaterialResource if one exists, otherwise NULL
	 */
	virtual FMaterialResource* GetMaterialResource(EMaterialShaderQuality OverrideQuality=MSQ_UNSPECIFIED) { return NULL; }

	/**
	 * @return the flattened texture for the material
	 */
	virtual UTexture* GetMobileTexture(const INT /* EMobileTextureUnit */ MobileTextureUnit);

	/**
	 * Used by various commandlets to purge editor only and platform-specific data from various objects
	 * 
	 * @param PlatformsToKeep Platforms for which to keep platform-specific data
	 * @param bStripLargeEditorData If TRUE, data used in the editor, but large enough to bloat download sizes, will be removed
	 */
	virtual void StripData(UE3::EPlatformType PlatformsToKeep, UBOOL bStripLargeEditorData);

	/**
	 * Compiles a FMaterialResource on the given platform with the given static parameters
	 *
	 * @param StaticParameters - The set of static parameters to compile for
	 * @param StaticPermutation - The resource to compile
	 * @param Platform - The platform to compile for
	 * @param Quality - The material quality to compile for
	 * @param bFlushExistingShaderMaps - Indicates that existing shader maps should be discarded
	 * @return TRUE if compilation was successful or not necessary
	 */
	virtual UBOOL CompileStaticPermutation(
		FStaticParameterSet* StaticParameters, 
		FMaterialResource* StaticPermutation, 
		EShaderPlatform Platform, 
		EMaterialShaderQuality Quality,
		UBOOL bFlushExistingShaderMaps,
		UBOOL bDebugDump)
		PURE_VIRTUAL(UMaterialInterface::CompileStaticPermutation,return FALSE;);

	/**
	* Gets the value of the given static switch parameter
	*
	* @param	ParameterName	The name of the static switch parameter
	* @param	OutValue		Will contain the value of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticSwitchParameterValue(FName ParameterName,UBOOL &OutValue,FGuid &OutExpressionGuid) 
		PURE_VIRTUAL(UMaterialInterface::GetStaticSwitchParameterValue,return FALSE;);

	/**
	* Gets the value of the given static component mask parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	R, G, B, A		Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticComponentMaskParameterValue(FName ParameterName, UBOOL &R, UBOOL &G, UBOOL &B, UBOOL &A, FGuid &OutExpressionGuid) 
		PURE_VIRTUAL(UMaterialInterface::GetStaticComponentMaskParameterValue,return FALSE;);

	/**
	* Gets the compression format of the given normal parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	CompressionSettings	Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetNormalParameterValue(FName ParameterName, BYTE& OutCompressionSettings, FGuid &OutExpressionGuid)
		PURE_VIRTUAL(UMaterialInterface::GetNormalParameterValue,return FALSE;);

	/**
	* Gets the weightmap index of the given terrain layer weight parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	OutWeightmapIndex	Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetTerrainLayerWeightParameterValue(FName ParameterName, INT& OutWeightmapIndex, FGuid &OutExpressionGuid)
		PURE_VIRTUAL(UMaterialInterface::GetTerrainLayerWeightParameterValue,return FALSE;);

	virtual UBOOL IsFallbackMaterial() { return FALSE; }

	/**
	 * NOTE: This will be called on the render thread, it is not recommended to override this in a subclass as
	 * it is likely to cause unsafe behavior.
	 *
	 * @return the quality level this material wants to render with, based on if it has a quality switch, etc
	 */
	EMaterialShaderQuality GetDesiredQualityLevel() const;

	/**
	 * NOTE: The UMaterial overload of this is written to work on rendering thread, BUT THE UMaterialInstance overload 
	 * IS NOT SAFE on rendering thread! Use GetDesiredQualityLevel()
	 *
	 * @return the quality level this material can render with (may not match DesiredQualityLevel if we've unloaded a quality level, then switched system settings)
	 */
	virtual EMaterialShaderQuality GetQualityLevel() const PURE_VIRTUAL(UMaterialInterface::GetQualityLevel,return MSQ_HIGH;);

	/** @return The material's view relevance. */
	FMaterialViewRelevance GetViewRelevance();

	INT GetWidth() const;
	INT GetHeight() const;

	virtual const FGuid& GetLightingGuid() const
	{
#if WITH_EDITORONLY_DATA
		return LightingGuid;
#else
		static const FGuid NullGuid( 0, 0, 0, 0 );
		return NullGuid; 
#endif // WITH_EDITORONLY_DATA
	}

	virtual void SetLightingGuid()
	{
#if WITH_EDITORONLY_DATA
		LightingGuid = appCreateGuid();
#endif // WITH_EDITORONLY_DATA
	}

	// USurface interface
	virtual FLOAT GetSurfaceWidth() const { return GetWidth(); }
	virtual FLOAT GetSurfaceHeight() const { return GetHeight(); }

	// UObject interface
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void Serialize(FArchive& Ar);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Serialize the given shader map to the given archive
	 *
	 *	@param	InShaderMap				The shader map to serialize; when loading will be NULL.
	 *	@param	Ar						The archvie to serialize it to.
	 *
	 *	@return	FMaterialShaderMap*		The shader map serialized
	 */
	FMaterialShaderMap* SerializeShaderMap(FMaterialShaderMap* InShaderMap, FArchive& Ar);
	
	/**
	 *	Check if the textures have changed since the last time the material was
	 *	serialized for Lightmass... Update the lists while in here.
	 *	NOTE: This will mark the package dirty if they have changed.
	 *
	 *	@return	UBOOL	TRUE if the textures have changed.
	 *					FALSE if they have not.
	 */
	virtual UBOOL UpdateLightmassTextureTracking() 
	{ 
		return FALSE; 
	}
	
	/** @return The override bOverrideCastShadowAsMasked setting of the material. */
	inline UBOOL GetOverrideCastShadowAsMasked() const
	{
		return LightmassSettings.bOverrideCastShadowAsMasked;
	}
	/** @return The override emissive boost setting of the material. */
	inline UBOOL GetOverrideEmissiveBoost() const
	{
		return LightmassSettings.bOverrideEmissiveBoost;
	}
	/** @return The override diffuse boost setting of the material. */
	inline UBOOL GetOverrideDiffuseBoost() const
	{
		return LightmassSettings.bOverrideDiffuseBoost;
	}
	/** @return The override specular boost setting of the material. */
	inline UBOOL GetOverrideSpecularBoost() const
	{
		return LightmassSettings.bOverrideSpecularBoost;
	}
	/** @return The override export resolution scale setting of the material. */
	inline UBOOL GetOverrideExportResolutionScale() const
	{
		return LightmassSettings.bOverrideExportResolutionScale;
	}
	inline UBOOL GetOverrideDistanceFieldPenumbraScale() const
	{
		return LightmassSettings.bOverrideDistanceFieldPenumbraScale;
	}

	/** @return	The bCastShadowAsMasked value for this material. */
	virtual UBOOL GetCastShadowAsMasked() const
	{
		return LightmassSettings.bCastShadowAsMasked;
	}
	/** @return	The Emissive boost value for this material. */
	virtual FLOAT GetEmissiveBoost() const
	{
		return LightmassSettings.EmissiveBoost;
	}
	/** @return	The Diffuse boost value for this material. */
	virtual FLOAT GetDiffuseBoost() const
	{
		return LightmassSettings.DiffuseBoost;
	}
	/** @return	The Specular boost value for this material. */
	virtual FLOAT GetSpecularBoost() const
	{
		return LightmassSettings.SpecularBoost;
	}
	/** @return	The ExportResolutionScale value for this material. */
	virtual FLOAT GetExportResolutionScale() const
	{
		return LightmassSettings.ExportResolutionScale;
	}
	virtual FLOAT GetDistanceFieldPenumbraScale() const
	{
		return LightmassSettings.DistanceFieldPenumbraScale;
	}

	/** @param	bInOverrideCastShadowAsMasked	The override CastShadowAsMasked setting to set. */
	inline void SetOverrideCastShadowAsMasked(UBOOL bInOverrideCastShadowAsMasked)
	{
		LightmassSettings.bOverrideCastShadowAsMasked = bInOverrideCastShadowAsMasked;
	}
	/** @param	bInOverrideEmissiveBoost	The override emissive boost setting to set. */
	inline void SetOverrideEmissiveBoost(UBOOL bInOverrideEmissiveBoost)
	{
		LightmassSettings.bOverrideEmissiveBoost = bInOverrideEmissiveBoost;
	}
	/** @param bInOverrideDiffuseBoost		The override diffuse boost setting of the parent material. */
	inline void SetOverrideDiffuseBoost(UBOOL bInOverrideDiffuseBoost)
	{
		LightmassSettings.bOverrideDiffuseBoost = bInOverrideDiffuseBoost;
	}
	/** @param bInOverrideSpecularBoost		The override specular boost setting of the parent material. */
	inline void SetOverrideSpecularBoost(UBOOL bInOverrideSpecularBoost)
	{
		LightmassSettings.bOverrideSpecularBoost = bInOverrideSpecularBoost;
	}
	/** @param bInOverrideExportResolutionScale	The override export resolution scale setting of the parent material. */
	inline void SetOverrideExportResolutionScale(UBOOL bInOverrideExportResolutionScale)
	{
		LightmassSettings.bOverrideExportResolutionScale = bInOverrideExportResolutionScale;
	}
	inline void SetOverrideDistanceFieldPenumbraScale(UBOOL bInOverrideDistanceFieldPenumbraScale)
	{
		LightmassSettings.bOverrideDistanceFieldPenumbraScale = bInOverrideDistanceFieldPenumbraScale;
	}

	/** @param	InCastShadowAsMasked	The CastShadowAsMasked value for this material. */
	inline void SetCastShadowAsMasked(UBOOL InCastShadowAsMasked)
	{
		LightmassSettings.bCastShadowAsMasked = InCastShadowAsMasked;
	}
	/** @param	InEmissiveBoost		The Emissive boost value for this material. */
	inline void SetEmissiveBoost(FLOAT InEmissiveBoost)
	{
		LightmassSettings.EmissiveBoost = InEmissiveBoost;
	}
	/** @param	InDiffuseBoost		The Diffuse boost value for this material. */
	inline void SetDiffuseBoost(FLOAT InDiffuseBoost)
	{
		LightmassSettings.DiffuseBoost = InDiffuseBoost;
	}
	/** @param	InSpecularBoost		The Specular boost value for this material. */
	inline void SetSpecularBoost(FLOAT InSpecularBoost)
	{
		LightmassSettings.SpecularBoost = InSpecularBoost;
	}
	/** @param	InExportResolutionScale		The ExportResolutionScale value for this material. */
	inline void SetExportResolutionScale(FLOAT InExportResolutionScale)
	{
		LightmassSettings.ExportResolutionScale = InExportResolutionScale;
	}
	inline void SetDistanceFieldPenumbraScale(FLOAT InDistanceFieldPenumbraScale)
	{
		LightmassSettings.DistanceFieldPenumbraScale = InDistanceFieldPenumbraScale;
	}

	/**
	 *	Get all of the textures in the expression chain for the given property (ie fill in the given array with all textures in the chain).
	 *
	 *	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	 *	@param	OutTextures				The array to fill in all of the textures.
	 *	@param	OutTextureParamNames	Optional array to fill in with texture parameter names.
	 *	@param	InStaticParameterSet	Optional static parameter set - if specified only follow StaticSwitches according to its settings
	 *
	 *	@return	UBOOL			TRUE if successful, FALSE if not.
	 */
	virtual UBOOL GetTexturesInPropertyChain(EMaterialProperty InProperty, TArray<UTexture*>& OutTextures,  TArray<FName>* OutTextureParamNames, class FStaticParameterSet* InStaticParameterSet)
		PURE_VIRTUAL(UMaterialInterface::GetTexturesInPropertyChain,return FALSE;);

	/**
	 * Returns the lookup texture to be used in the physical material mask.  Tries to get the parents lookup texture if not overridden here. 
	 */
	virtual UTexture2D* GetPhysicalMaterialMaskTexture() const { return NULL; }

	/**
	 * Returns the black physical material to be used in the physical material mask.  Tries to get the parents black phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetBlackPhysicalMaterial() const { return NULL; }

	/**
	 * Returns the white physical material to be used in the physical material mask.  Tries to get the parents white phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetWhitePhysicalMaterial() const { return NULL; }

	/** 
	 * Returns the UV channel that should be used to look up physical material mask information 
	 */
	virtual INT GetPhysMaterialMaskUVChannel() const { return -1; }

	/** 
	 * Returns True if this material has a valid physical material mask setup.
 	 */
	UBOOL HasValidPhysicalMaterialMask() const;

	/**
	 * Returns True if this material is a valid mobile value source for the specified value source.
	 */
	UBOOL IsValidMobileValueSource (const EMobileValueSource InSource) const;

	/**
	 * Determines the texel on the physical material mask that was hit and returns the physical material corresponding to hit texel's color
	 * 
	 * @param HitUV the UV that was hit during collision.
	 */
	UPhysicalMaterial* DetermineMaskedPhysicalMaterialFromUV( const FVector2D& HitUV ) const;

	/**
	 *	Retrieve the list of mobile parameter group names.
	 *
	 *	@param	OutGroupNames		TArray filled with the group names
	 */
	static void GetMobileParameterGroupNames(TArray<FName>& OutGroupNames);

	/**
	 *	Retrieve the list of mobile scalar parameter names for the given group.
	 *
	 *	@param	InGroupName			Name of the group
	 *	@param	OutParamNames		TArray filled with the parameter names
	 *	@return	UBOOL				TRUE if group was valid, FALSE if not
	 */
	static UBOOL GetMobileScalarParameterNamesForGroup(FName& InGroupName, TArray<FName>& OutParamNames);

	/**
	 *	Retrieve the list of mobile vector parameter names for the given group.
	 *
	 *	@param	InGroupName			Name of the group
	 *	@param	OutParamNames		TArray filled with the parameter names
	 *	@return	UBOOL				TRUE if group was valid, FALSE if not
	 */
	static UBOOL GetMobileVectorParameterNamesForGroup(FName& InGroupName, TArray<FName>& OutParamNames);

	/**
	 *	Retrieve the list of mobile texture parameter names for the given group.
	 *
	 *	@param	InGroupName			Name of the group
	 *	@param	OutParamNames		TArray filled with the parameter names
	 *	@return	UBOOL				TRUE if group was valid, FALSE if not
	 */
	static UBOOL GetMobileTextureParameterNamesForGroup(FName& InGroupName, TArray<FName>& OutParamNames);
};

struct FMaterialFunctionInfo
{
    FGuid StateId;
    class UMaterialFunction* Function;

    /** Constructors */
    FMaterialFunctionInfo() {}
    FMaterialFunctionInfo(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialFunctionInfo));
    }
};

class UMaterial : public UMaterialInterface
{
public:
    //## BEGIN PROPS Material
    class UPhysicalMaterial* PhysMaterial;
    class UClass* PhysicalMaterial;
    class UTexture2D* PhysMaterialMask;
    INT PhysMaterialMaskUVChannel;
    class UPhysicalMaterial* BlackPhysicalMaterial;
    class UPhysicalMaterial* WhitePhysicalMaterial;
    FColorMaterialInput DiffuseColor;
    FScalarMaterialInput DiffusePower;
    FColorMaterialInput SpecularColor;
    FScalarMaterialInput SpecularPower;
    FVectorMaterialInput Normal;
    FColorMaterialInput EmissiveColor;
    FScalarMaterialInput Opacity;
    FScalarMaterialInput OpacityMask;
    FLOAT OpacityMaskClipValue;
    FLOAT ShadowDepthBias;
    FVector2MaterialInput Distortion;
    BYTE BlendMode;
    BYTE LightingModel;
    BYTE D3D11TessellationMode;
    SCRIPT_ALIGN;
    FColorMaterialInput CustomLighting;
    FColorMaterialInput CustomSkylightDiffuse;
    FVectorMaterialInput AnisotropicDirection;
    FScalarMaterialInput TwoSidedLightingMask;
    FColorMaterialInput TwoSidedLightingColor;
    FVectorMaterialInput WorldPositionOffset;
    FVectorMaterialInput WorldDisplacement;
    FScalarMaterialInput TessellationMultiplier;
    FColorMaterialInput SubsurfaceInscatteringColor;
    FColorMaterialInput SubsurfaceAbsorptionColor;
    FScalarMaterialInput SubsurfaceScatteringRadius;
    BITFIELD EnableSubsurfaceScattering:1;
    BITFIELD EnableSeparateTranslucency:1;
    BITFIELD bEnableMaskedAntialiasing:1;
    BITFIELD TwoSided:1;
    BITFIELD TwoSidedSeparatePass:1;
    BITFIELD bDisableDepthTest:1;
    BITFIELD bSceneTextureRenderBehindTranslucency:1;
    BITFIELD bAllowFog:1;
    BITFIELD bTranslucencyReceiveDominantShadowsFromStatic:1;
    BITFIELD bTranslucencyInheritDominantShadowsFromOpaque:1;
    BITFIELD bAllowTranslucencyDoF:1;
    BITFIELD bUseOneLayerDistortion:1;
    BITFIELD bUseLitTranslucencyDepthPass:1;
    BITFIELD bUseLitTranslucencyPostRenderDepthPass:1;
    BITFIELD bCastLitTranslucencyShadowAsMasked:1;
    BITFIELD bUsedAsLightFunction:1;
    BITFIELD bUsedWithFogVolumes:1;
    BITFIELD bUsedAsSpecialEngineMaterial:1;
    BITFIELD bUsedWithSkeletalMesh:1;
    BITFIELD bUsedWithTerrain:1;
    BITFIELD bUsedWithLandscape:1;
    BITFIELD bUsedWithMobileLandscape:1;
    BITFIELD bUsedWithFracturedMeshes:1;
    BITFIELD bUsedWithParticleSystem:1;
    BITFIELD bUsedWithParticleSprites:1;
    BITFIELD bUsedWithBeamTrails:1;
    BITFIELD bUsedWithParticleSubUV:1;
    BITFIELD bUsedWithSpeedTree:1;
    BITFIELD bUsedWithStaticLighting:1;
    BITFIELD bUsedWithLensFlare:1;
    BITFIELD bUsedWithGammaCorrection:1;
    BITFIELD bUsedWithInstancedMeshParticles:1;
    BITFIELD bUsedWithFluidSurfaces:1;
    BITFIELD bUsedWithDecals:1;
    BITFIELD bUsedWithMaterialEffect:1;
    BITFIELD bUsedWithMorphTargets:1;
    BITFIELD bUsedWithRadialBlur:1;
    BITFIELD bUsedWithInstancedMeshes:1;
    BITFIELD bUsedWithSplineMeshes:1;
    BITFIELD bUsedWithAPEXMeshes:1;
    BITFIELD bUsedWithScreenDoorFade:1;
    BITFIELD bEnableCrackFreeDisplacement:1;
    BITFIELD bUseImageBasedReflections:1;
    BITFIELD Wireframe:1;
    BITFIELD bPerPixelCameraVector:1;
    BITFIELD bAllowLightmapSpecular:1;
    BITFIELD bIsFallbackMaterial_DEPRECATED:1;
    BITFIELD bUsesDistortion:1;
    BITFIELD bIsMasked:1;
    BITFIELD bIsPreviewMaterial:1;
    FLOAT ImageReflectionNormalDampening;
    FMaterialResource* MaterialResources[2];
    class FDefaultMaterialInstance* DefaultMaterialInstances[3];
    INT EditorX;
    INT EditorY;
    INT EditorPitch;
    INT EditorYaw;
    TArrayNoInit<class UMaterialExpression*> Expressions;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class UMaterialExpressionComment*> EditorComments;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<struct FMaterialFunctionInfo> MaterialFunctionInfos;
    TMap< FName, TArray<UMaterialExpression*> > EditorParameters;
    TArrayNoInit<class UTexture*> ReferencedTextures_DEPRECATED;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<FGuid> ReferencedTextureGuids;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS Material

    DECLARE_CLASS(UMaterial,UMaterialInterface,0,Engine)
	// Constructor.
	UMaterial();

	/** @return TRUE if the material uses distortion */
	UBOOL HasDistortion() const;
	/** @return TRUE if the material uses the scene color texture */
	UBOOL UsesSceneColor() const;

	/**
	 * Allocates a material resource off the heap to be stored in MaterialResource.
	 */
	virtual FMaterialResource* AllocateResource();

	/** Returns the textures used to render this material for the given quality */
	virtual void GetUsedTextures(TArray<UTexture*> &OutTextures, const EMaterialShaderQuality Quality=MSQ_UNSPECIFIED, const UBOOL bAllQualities=FALSE, UBOOL bAllowOverride=FALSE);

	/**
	* Checks whether the specified texture is needed to render the material instance.
	* @param Texture	The texture to check.
	* @param bAllowOverride Whether you want to be given the original textures or allow override textures instead of the originals.
	* @return UBOOL - TRUE if the material uses the specified texture.
	*/
	virtual UBOOL UsesTexture(const UTexture* Texture, const UBOOL bAllowOverride=TRUE);

	/**
	 * Overrides a specific texture (transient)
	 *
	 * @param InTextureToOverride The texture to override
	 * @param OverrideTexture The new texture to use
	 */
	virtual void OverrideTexture( const UTexture* InTextureToOverride, UTexture* OverrideTexture );

private:

	/** Sets the value associated with the given usage flag. */
	void SetUsageByFlag(const EMaterialUsage Usage, const UBOOL NewValue);

public:

	/** Gets the name of the given usage flag. */
	FString GetUsageName(const EMaterialUsage Usage) const;

	/** Gets the value associated with the given usage flag. */
	UBOOL GetUsageByFlag(const EMaterialUsage Usage) const;

	/**
	 * Checks if the material can be used with the given usage flag.
	 * If the flag isn't set in the editor, it will be set and the material will be recompiled with it.
	 * @param Usage - The usage flag to check
	 * @param bSkipPrim - Bypass the primitive type checks
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	virtual UBOOL CheckMaterialUsage(const EMaterialUsage Usage, const UBOOL bSkipPrim = FALSE);

	/**
	 * Sets the given usage flag.
	 * @param bNeedsRecompile - TRUE if the material was recompiled for the usage change
	 * @param Usage - The usage flag to set
	 * @param bSkipPrim - Bypass the primitive type checks
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	UBOOL SetMaterialUsage(UBOOL &bNeedsRecompile, const EMaterialUsage Usage, const UBOOL bSkipPrim = FALSE);

	/**
	 * @param	OutParameterNames		Storage array for the parameter names we are returning.
	 * @param	OutParameterIds			Storage array for the parameter id's we are returning.
	 *
	 * @return	Returns a array of parameter names used in this material for the specified expression type.
	 */
	template<typename ExpressionType>
	void GetAllParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	
	void GetAllVectorParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllScalarParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllTextureParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllFontParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllStaticSwitchParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllStaticComponentMaskParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllNormalParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);
	void GetAllTerrainLayerWeightParameterNames(TArray<FName> &OutParameterNames, TArray<FGuid> &OutParameterIds);

	/**
	 * Attempts to find a expression by its GUID.
	 *
	 * @param InGUID GUID to search for.
	 *
	 * @return Returns a expression object pointer if one is found, otherwise NULL if nothing is found.
	 */
	template<typename ExpressionType>
	ExpressionType* FindExpressionByGUID(const FGuid &InGUID)
	{
		ExpressionType* Result = NULL;

		for(INT ExpressionIndex = 0;ExpressionIndex < Expressions.Num();ExpressionIndex++)
		{
			ExpressionType* ExpressionPtr =
				Cast<ExpressionType>(Expressions(ExpressionIndex));

			if(ExpressionPtr && ExpressionPtr->ExpressionGUID.IsValid() && ExpressionPtr->ExpressionGUID==InGUID)
			{
				Result = ExpressionPtr;
				break;
			}
		}

		return Result;
	}

	// UMaterialInterface interface.


	/**
	 * NOTE: This is carefully written to work on the rendering thread
	 *
	 * @return the quality level this material should render with
	 */
	virtual EMaterialShaderQuality GetQualityLevel() const;

	/**
	 * Get the material which this is an instance of.
	 */
	virtual UMaterial* GetMaterial();
    virtual UBOOL GetParameterDesc(FName ParameterName, FString& OutDesc);
    virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
    virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
    virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
	virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue,INT& OutFontPage);
	/**
	* Retrieves name of group from Material Expression to be used for grouping in Material Instance Editor 
	*
	* @param ParameterName	    Name of parameter to retrieve
	* @param OutDesc		    Group name to be filled
	* @return				    True if successful	 
	*/
	virtual UBOOL GetGroupName(FName ParameterName, FName& OutDesc);
	/**
	 * Gets the value of the given static switch parameter
	 *
	 * @param	ParameterName	The name of the static switch parameter
	 * @param	OutValue		Will contain the value of the parameter if successful
	 * @return					True if successful
	 */
	virtual UBOOL GetStaticSwitchParameterValue(FName ParameterName,UBOOL &OutValue,FGuid &OutExpressionGuid);

	/**
	 * Gets the value of the given static component mask parameter
	 *
	 * @param	ParameterName	The name of the parameter
	 * @param	R, G, B, A		Will contain the values of the parameter if successful
	 * @return					True if successful
	 */
	virtual UBOOL GetStaticComponentMaskParameterValue(FName ParameterName, UBOOL &R, UBOOL &G, UBOOL &B, UBOOL &A, FGuid &OutExpressionGuid);

	/**
	* Gets the compression format of the given normal parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	CompressionSettings	Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetNormalParameterValue(FName ParameterName, BYTE& OutCompressionSettings, FGuid &OutExpressionGuid);

	/**
	* Gets the weightmap index of the given terrain layer weight parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	OutWeightmapIndex	Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetTerrainLayerWeightParameterValue(FName ParameterName, INT& OutWeightmapIndex, FGuid &OutExpressionGuid);

	virtual FMaterialRenderProxy* GetRenderProxy(UBOOL Selected, UBOOL bHovered=FALSE) const;
	virtual UPhysicalMaterial* GetPhysicalMaterial() const;

	/**
	 * Compiles a FMaterialResource on the given platform with the given static parameters
	 *
	 * @param StaticParameters - The set of static parameters to compile for
	 * @param StaticPermutation - The resource to compile
	 * @param Platform - The platform to compile for
	 * @param Quality - The material quality to compile for
	 * @param bFlushExistingShaderMaps - Indicates that existing shader maps should be discarded
	 * @return TRUE if compilation was successful or not necessary
	 */
	UBOOL CompileStaticPermutation(
		FStaticParameterSet* StaticParameters,
		FMaterialResource* StaticPermutation,
		EShaderPlatform Platform,
		EMaterialShaderQuality Quality,
		UBOOL bFlushExistingShaderMaps,
		UBOOL bDebugDump);

	/**
	 * Compiles material resources for the current platform if the shader map for that resource didn't already exist.
	 *
	 * @param ShaderPlatform - platform to compile for
	 * @param bFlushExistingShaderMaps - forces a compile, removes existing shader maps from shader cache.
	 */
	void CacheResourceShaders(EShaderPlatform Platform, UBOOL bFlushExistingShaderMaps=FALSE);

private:
	/**
	 * Flushes existing resource shader maps and resets the material resource's Ids.
	 */
	virtual void FlushResourceShaderMaps();

	/** 
	 * Rebuilds the MaterialFunctionInfos array with the current state of the material's function dependencies,
	 * And updates any function call nodes in this material so their inputs and outputs stay valid.
	 */
	void RebuildMaterialFunctionInfo();

public:
	/**
	 * Gets the material resource based on current quality level
	 * @return - the appropriate FMaterialResource if one exists, otherwise NULL
	 */
	virtual FMaterialResource* GetMaterialResource(EMaterialShaderQuality OverrideQuality=MSQ_UNSPECIFIED);

	/** === USurface interface === */
	/**
	 * Method for retrieving the width of this surface.
	 *
	 * This implementation returns the maximum width of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the width of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceWidth() const;
	/**
	 * Method for retrieving the height of this surface.
	 *
	 * This implementation returns the maximum height of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the height of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceHeight() const;

	// UObject interface.
	/**
	 * Called before serialization on save to propagate referenced textures. This is not done
	 * during content cooking as the material expressions used to retrieve this information will
	 * already have been dissociated via RemoveExpressions
	 */
	void PreSave();

	virtual void AddReferencedObjects(TArray<UObject*>& ObjectArray);
	virtual void Serialize(FArchive& Ar);
	virtual void PostDuplicate();
	virtual void PostLoad();
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	/**
	 * @return		Sum of the size of textures referenced by this material.
	 */
	virtual INT GetResourceSize();

	/**
	 * Null any material expression references for this material
	 *
	 * @param bRemoveAllExpressions If TRUE, the function will remove every expression and uniform expression from the material and its material resources
	 */
	void RemoveExpressions(UBOOL bRemoveAllExpressions=FALSE);

	UBOOL IsFallbackMaterial() 
	{ 
		return bIsFallbackMaterial_DEPRECATED; 
	}

	/**
	 * Goes through every material, flushes the specified types and re-initializes the material's shader maps.
	 */
	static void UpdateMaterialShaders(TArray<FShaderType*>& ShaderTypesToFlush, TArray<const FVertexFactoryType*>& VFTypesToFlush);

	/**
	 * Adds an expression node that represents a parameter to the list of material parameters.
	 *
	 * @param	Expression	Pointer to the node that is going to be inserted if it's a parameter type.
	 */
	virtual UBOOL AddExpressionParameter(UMaterialExpression* Expression);

	/**
	 * Removes an expression node that represents a parameter from the list of material parameters.
	 *
	 * @param	Expression	Pointer to the node that is going to be removed if it's a parameter type.
	 */
	virtual UBOOL RemoveExpressionParameter(UMaterialExpression* Expression);

	/**
	 * A parameter with duplicates has to update its peers so that they all have the same value. If this step isn't performed then
	 * the expression nodes will not accurately display the final compiled material.
	 *
	 * @param	Parameter	Pointer to the expression node whose state needs to be propagated.
	 */
	virtual void PropagateExpressionParameterChanges(UMaterialExpression* Parameter);

	/**
	 * This function removes the expression from the editor parameters list (if it exists) and then re-adds it.
	 *
	 * @param	Expression	The expression node that represents a parameter that needs updating.
	 */
	virtual void UpdateExpressionParameterName(UMaterialExpression* Expression);

	/**
	 * Iterates through all of the expression nodes in the material and finds any parameters to put in EditorParameters.
	 */
	virtual void BuildEditorParameterList();

	/**
	 * Returns TRUE if the provided expression parameter has duplicates.
	 *
	 * @param	Expression	The expression parameter to check for duplicates.
	 */
	virtual UBOOL HasDuplicateParameters(UMaterialExpression* Expression);

	/**
	 * Returns TRUE if the provided expression dynamic parameter has duplicates.
	 *
	 * @param	Expression	The expression dynamic parameter to check for duplicates.
	 */
	virtual UBOOL HasDuplicateDynamicParameters(UMaterialExpression* Expression);

	/**
	 * Iterates through all of the expression nodes and fixes up changed names on
	 * matching dynamic parameters when a name change occurs.
	 *
	 * @param	Expression	The expression dynamic parameter.
	 */
	virtual void UpdateExpressionDynamicParameterNames(UMaterialExpression* Expression);

	/**
	 * Gets the name of a parameter.
	 *
	 * @param	Expression	The expression to retrieve the name from.
	 * @param	OutName		The variable that will hold the parameter name.
	 * @return	TRUE if the expression is a parameter with a name.
	 */
	static UBOOL GetExpressionParameterName(UMaterialExpression* Expression, FName& OutName);

	/**
	 * Copies the values of an expression parameter to another expression parameter of the same class.
	 *
	 * @param	Source			The source parameter.
	 * @param	Destination		The destination parameter that will receive Source's values.
	 */
	static UBOOL CopyExpressionParameters(UMaterialExpression* Source, UMaterialExpression* Destination);

	/**
	 * Returns TRUE if the provided expression node is a parameter.
	 *
	 * @param	Expression	The expression node to inspect.
	 */
	static UBOOL IsParameter(UMaterialExpression* Expression);

	/**
	 * Returns TRUE if the provided expression node is a dynamic parameter.
	 *
	 * @param	Expression	The expression node to inspect.
	 */
	static UBOOL IsDynamicParameter(UMaterialExpression* Expression);

	/**
	 * Returns the number of parameter groups. NOTE: The number returned can be innaccurate if you have parameters of different types with the same name.
	 */
	inline INT GetNumEditorParameters() const
	{
		return EditorParameters.Num();
	}

	/**
	 * Empties the editor parameters for the material.
	 */
	inline void EmptyEditorParameters()
	{
		EditorParameters.Empty();
	}

	/**
	 * Returns the lookup texture to be used in the physical material mask.  Tries to get the parents lookup texture if not overridden here. 
	 */
	virtual UTexture2D* GetPhysicalMaterialMaskTexture() const { return PhysMaterialMask; }

	/**
	 * Returns the black physical material to be used in the physical material mask.  Tries to get the parents black phys mat if not overridden here
	 */
	virtual UPhysicalMaterial* GetBlackPhysicalMaterial() const { return BlackPhysicalMaterial; }

	/**
	 * Returns the white physical material to be used in the physical material mask.  Tries to get the parents white phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetWhitePhysicalMaterial() const { return WhitePhysicalMaterial; }

	/** 
	 * Returns the UV channel that should be used to look up physical material mask information 
	 */
	virtual INT GetPhysMaterialMaskUVChannel() const { return PhysMaterialMaskUVChannel; }

	/**
	 *	See if the given mobile group is enabled for this material chain
	 *
	 *	@param	InGroupName		Name of the group
	 *	@return	UBOOL			TRUE if it is enabled, FALSE if not
	 */
	virtual UBOOL IsMobileGroupEnabled(FName& InGroupName);

protected:
	/**
	 * Sets overrides in the material's static parameters
	 *
	 * @param	Permutation		The set of static parameters to override and their values
	 */
	void SetStaticParameterOverrides(const FStaticParameterSet* Permutation);

	/**
	 * Clears static parameter overrides so that static parameter expression defaults will be used
	 *	for subsequent compiles.
	 */
	void ClearStaticParameterOverrides();

public:
	/** Helper functions for text output of properties... */
	static const TCHAR* GetMaterialLightingModelString(EMaterialLightingModel InMaterialLightingModel);
	static EMaterialLightingModel GetMaterialLightingModelFromString(const TCHAR* InMaterialLightingModelStr);
	static const TCHAR* GetBlendModeString(EBlendMode InBlendMode);
	static EBlendMode GetBlendModeFromString(const TCHAR* InBlendModeStr);

	/**
	 *	Check if the textures have changed since the last time the material was
	 *	serialized for Lightmass... Update the lists while in here.
	 *	NOTE: This will mark the package dirty if they have changed.
	 *
	 *	@return	UBOOL	TRUE if the textures have changed.
	 *					FALSE if they have not.
	 */
	virtual UBOOL UpdateLightmassTextureTracking();

	/**
	*	Get the expression input for the given property
	*
	*	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	*
	*	@return	FExpressionInput*		A pointer to the expression input of the property specified, 
	*									or NULL if an invalid property was requested.
	*/
	FExpressionInput* GetExpressionInputForProperty(EMaterialProperty InProperty);

	/**
	 *	Get all referenced expressions (returns the chains for all properties).
	 *
	 *	@param	OutExpressions			The array to fill in all of the expressions.
	 *	@param	InStaticParameterSet	Optional static parameter set - if supplied only walk the StaticSwitch branches according to it.
	 *
	 *	@return	UBOOL					TRUE if successful, FALSE if not.
	 */
	virtual UBOOL GetAllReferencedExpressions(TArray<UMaterialExpression*>& OutExpressions, class FStaticParameterSet* InStaticParameterSet);

	/**
	 *	Get the expression chain for the given property (ie fill in the given array with all expressions in the chain).
	 *
	 *	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	 *	@param	OutExpressions			The array to fill in all of the expressions.
	 *	@param	InStaticParameterSet	Optional static parameter set - if supplied only walk the StaticSwitch branches according to it.
	 *
	 *	@return	UBOOL					TRUE if successful, FALSE if not.
	 */
	virtual UBOOL GetExpressionsInPropertyChain(EMaterialProperty InProperty, 
		TArray<UMaterialExpression*>& OutExpressions, class FStaticParameterSet* InStaticParameterSet);

	/**
	 *	Get all of the textures in the expression chain for the given property (ie fill in the given array with all textures in the chain).
	 *
	 *	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	 *	@param	OutTextures				The array to fill in all of the textures.
	 *	@param	InStaticParameterSet	Optional static parameter set - if supplied only walk the StaticSwitch branches according to it.
	 *	@param	OutTextureParamNames	Optional array to fill in with texture parameter names.
	 *
	 *	@return	UBOOL			TRUE if successful, FALSE if not.
	 */
	virtual UBOOL GetTexturesInPropertyChain(EMaterialProperty InProperty, TArray<UTexture*>& OutTextures, 
		TArray<FName>* OutTextureParamNames, class FStaticParameterSet* InStaticParameterSet);

protected:
	/**
	 *	Recursively retrieve the expressions contained in the chain of the given expression.
	 *
	 *	@param	InExpression			The expression to start at.
	 *	@param	InOutProcessedInputs	An array of processed expression inputs. (To avoid circular loops causing infinite recursion)
	 *	@param	OutExpressions			The array to fill in all of the expressions.
	 *	@param	InStaticParameterSet	Optional static parameter set - if supplied only walk the StaticSwitch branches according to it.
	 *
	 *	@return	UBOOL					TRUE if successful, FALSE if not.
	 */
	virtual UBOOL RecursiveGetExpressionChain(UMaterialExpression* InExpression, TArray<FExpressionInput*>& InOutProcessedInputs, 
		TArray<UMaterialExpression*>& OutExpressions, class FStaticParameterSet* InStaticParameterSet);

	/**
	*	Recursively update the bRealtimePreview for each expression based on whether it is connected to something that is time-varying.
	*	This is determined based on the result of UMaterialExpression::NeedsRealtimePreview();
	*
	*	@param	InExpression				The expression to start at.
	*	@param	InOutExpressionsToProcess	Array of expressions we still need to process.
	*
	*/
	void RecursiveUpdateRealtimePreview(UMaterialExpression* InExpression, TArray<UMaterialExpression*>& InOutExpressionsToProcess);


	friend class FLightmassMaterialProxy;
};

class UMaterialInstance : public UMaterialInterface
{
public:
    //## BEGIN PROPS MaterialInstance
    class UPhysicalMaterial* PhysMaterial;
    class UMaterialInterface* Parent;
    class UTexture2D* PhysMaterialMask;
    INT PhysMaterialMaskUVChannel;
    class UPhysicalMaterial* BlackPhysicalMaterial;
    class UPhysicalMaterial* WhitePhysicalMaterial;
    BITFIELD bHasStaticPermutationResource:1;
    BITFIELD bStaticPermutationDirty:1;
    BITFIELD ReentrantFlag:1;
    BITFIELD bNeedsMaterialFlattening:1;
    SCRIPT_ALIGN;
    FStaticParameterSet* StaticParameters[2];
    FMaterialResource* StaticPermutationResources[2];
    class FMaterialInstanceResource* Resources[3];
    TArrayNoInit<class UTexture*> ReferencedTextures_DEPRECATED;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<FGuid> ReferencedTextureGuids;
#endif // WITH_EDITORONLY_DATA
    FGuid ParentLightingGuid;
    //## END PROPS MaterialInstance

    virtual void SetParent(class UMaterialInterface* NewParent);
    virtual void SetVectorParameterValue(FName ParameterName,const FLinearColor& Value);
    virtual void SetScalarParameterValue(FName ParameterName,FLOAT Value);
    virtual void SetScalarCurveParameterValue(FName ParameterName,const FInterpCurveFloat& Value);
    virtual void SetTextureParameterValue(FName ParameterName,class UTexture* Value);
    virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& Value);
    virtual void SetFontParameterValue(FName ParameterName,class UFont* FontValue,INT FontPage);
    virtual void ClearParameterValues();
    virtual UBOOL IsInMapOrTransientPackage() const;
    DECLARE_FUNCTION(execSetParent)
    {
        P_GET_OBJECT(UMaterialInterface,NewParent);
        P_FINISH;
        this->SetParent(NewParent);
    }
    DECLARE_FUNCTION(execSetVectorParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_REF(FLinearColor,Value);
        P_FINISH;
        this->SetVectorParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetScalarParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetScalarParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetScalarCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveFloat,Value);
        P_FINISH;
        this->SetScalarCurveParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetTextureParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(UTexture,Value);
        P_FINISH;
        this->SetTextureParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetFontParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(UFont,FontValue);
        P_GET_INT(FontPage);
        P_FINISH;
        this->SetFontParameterValue(ParameterName,FontValue,FontPage);
    }
    DECLARE_FUNCTION(execClearParameterValues)
    {
        P_FINISH;
        this->ClearParameterValues();
    }
    DECLARE_FUNCTION(execIsInMapOrTransientPackage)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsInMapOrTransientPackage();
    }
    DECLARE_ABSTRACT_CLASS(UMaterialInstance,UMaterialInterface,0,Engine)
	// Constructor.
	UMaterialInstance();

	/**
	* Passes the allocation request up the MIC chain
	* @return	The allocated resource
	*/
	FMaterialResource* AllocateResource();

	/** Initializes the material instance's resources. */
	virtual void InitResources();

	/**
	 * Gets the static permutation resource if the instance has one
	 * @return - the appropriate FMaterialResource if one exists, otherwise NULL
	 */
	virtual FMaterialResource* GetMaterialResource(EMaterialShaderQuality OverrideQuality=MSQ_UNSPECIFIED);

	/**
	 * @return the flattened texture for the material instance, or the parent's if we don't have one
	 */
	virtual UTexture* GetMobileTexture(const INT MobileTextureUnit);

	// UMaterialInterface interface.

	/**
	 * NOTE: This is NOT SAFE to use on the rendering thread!
	 * 
	 * @return the quality level this material should render with
	 */
	virtual EMaterialShaderQuality GetQualityLevel() const;

	/**
	 * Get the material which this is an instance of.
	 */
	virtual UMaterial* GetMaterial();

	/** Returns the textures used to render this material for the given quality */
	virtual void GetUsedTextures(TArray<UTexture*> &OutTextures, const EMaterialShaderQuality Quality=MSQ_UNSPECIFIED, const UBOOL bAllQualities = FALSE, UBOOL bAllowOverride=TRUE);

	/**
	* Checks whether the specified texture is needed to render the material instance.
	* @param Texture	The texture to check.
	* @param bAllowOverride Whether you want to be given the original textures or allow override textures instead of the originals.
	* @return UBOOL - TRUE if the material uses the specified texture.
	*/
	virtual UBOOL UsesTexture(const UTexture* Texture, const UBOOL bAllowOverride=TRUE);

	/**
	 * Overrides a specific texture (transient)
	 *
	 * @param InTextureToOverride The texture to override
	 * @param OverrideTexture The new texture to use
	 */
	virtual void OverrideTexture( const UTexture* InTextureToOverride, UTexture* OverrideTexture );


	/**
	 * Checks if the material can be used with the given usage flag.
	 * If the flag isn't set in the editor, it will be set and the material will be recompiled with it.
	 * @param Usage - The usage flag to check
	 * @param bSkipPrim - Bypass the primitive type checks
	 * @return UBOOL - TRUE if the material can be used for rendering with the given type.
	 */
	virtual UBOOL CheckMaterialUsage(const EMaterialUsage Usage, const UBOOL bSkipPrim = FALSE);

	/**
	* Gets the value of the given static switch parameter.  If it is not found in this instance then
	*		the request is forwarded up the MIC chain.
	*
	* @param	ParameterName	The name of the static switch parameter
	* @param	OutValue		Will contain the value of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticSwitchParameterValue(FName ParameterName,UBOOL &OutValue,FGuid &OutExpressionGuid);

	/**
	* Gets the value of the given static component mask parameter. If it is not found in this instance then
	*		the request is forwarded up the MIC chain.
	*
	* @param	ParameterName	The name of the parameter
	* @param	R, G, B, A		Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetStaticComponentMaskParameterValue(FName ParameterName, UBOOL &R, UBOOL &G, UBOOL &B, UBOOL &A,FGuid &OutExpressionGuid);

	/**
	* Gets the compression format of the given normal parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	CompressionSettings	Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetNormalParameterValue(FName ParameterName, BYTE& OutCompressionSettings, FGuid &OutExpressionGuid);

	/**
	* Gets the weightmap index of the given terrain layer weight parameter
	*
	* @param	ParameterName	The name of the parameter
	* @param	OutWeightmapIndex	Will contain the values of the parameter if successful
	* @return					True if successful
	*/
	virtual UBOOL GetTerrainLayerWeightParameterValue(FName ParameterName, INT& OutWeightmapIndex, FGuid &OutExpressionGuid);

	virtual UBOOL IsDependent(UMaterialInterface* TestDependency);
	virtual FMaterialRenderProxy* GetRenderProxy(UBOOL Selected, UBOOL bHovered=FALSE) const;
	virtual UPhysicalMaterial* GetPhysicalMaterial() const;

	/**
	* Makes a copy of all the instance's inherited and overridden static parameters
	*
	* @param StaticParameters - The set of static parameters to fill, must be empty
	*/
	void GetStaticParameterValues(FStaticParameterSet* StaticParameters);

	/**
	* Sets the instance's static parameters and marks it dirty if appropriate.
	*
	* @param	EditorParameters	The new static parameters.  If the set does not contain any static parameters,
	*								the static permutation resource will be released.
	* @return		TRUE if the static permutation resource has been marked dirty
	*/
	UBOOL SetStaticParameterValues(const FStaticParameterSet* EditorParameters);

	/**
	* Checks if any of the static parameter values are outdated based on what they reference (eg a normalmap has changed format)
	*
	* @param	EditorParameters	The new static parameters. 
	*/
	virtual void CheckStaticParameterValues(FStaticParameterSet* EditorParameters);

	/**
	* Compiles the static permutation resource if the base material has changed and updates dirty states
	*/
	void UpdateStaticPermutation();

	/**
	* Updates static parameters and recompiles the static permutation resource if necessary
	*/
	void InitStaticPermutation();

	/**
	* Compiles material resources for the given platform if the shader map for that resource didn't already exist.
	*
	* @param ShaderPlatform - the platform to compile for.
	* @param bFlushExistingShaderMaps - forces a compile, removes existing shader maps from shader cache.
	*/
	void CacheResourceShaders(EShaderPlatform ShaderPlatform, UBOOL bFlushExistingShaderMaps=FALSE, UBOOL bDebugDump=FALSE);

	/**
	 * Passes the compile request up the MIC chain
	 *
	 * @param StaticParameters - The set of static parameters to compile for
	 * @param StaticPermutation - The resource to compile
	 * @param Platform - The platform to compile for
	 * @param Quality - The material quality to compile for
	 * @param bFlushExistingShaderMaps - Indicates that existing shader maps should be discarded
	 * @return TRUE if compilation was successful or not necessary
	 */
	UBOOL CompileStaticPermutation(
		FStaticParameterSet* Permutation,
		FMaterialResource* StaticPermutation,
		EShaderPlatform Platform,
		EMaterialShaderQuality Quality,
		UBOOL bFlushExistingShaderMaps,
		UBOOL bDebugDump);

	/**
	* Allocates the static permutation resources for all platforms if they haven't been already.
	* Also updates the material resource's Material member as it may have changed.
	*/
	void AllocateStaticPermutations();

	/**
	* Releases the static permutation resource if it exists, in a thread safe way
	*/
	void ReleaseStaticPermutations();

	/** === USurface interface === */
	/**
	 * Method for retrieving the width of this surface.
	 *
	 * This implementation returns the maximum width of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the width of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceWidth() const;
	/**
	 * Method for retrieving the height of this surface.
	 *
	 * This implementation returns the maximum height of all textures applied to this material - not exactly accurate, but best approximation.
	 *
	 * @return	the height of this surface, in pixels.
	 */
	virtual FLOAT GetSurfaceHeight() const;

	// UObject interface.
	virtual void AddReferencedObjects(TArray<UObject*>& ObjectArray);
	void PreSave();
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	/**
	* Refreshes parameter names using the stored reference to the expression object for the parameter.
	*/
	virtual void UpdateParameterNames();

#if !FINAL_RELEASE
	/** Displays warning if this material instance is not safe to modify in the game (is in content package) */
	void CheckSafeToModifyInGame(const TCHAR* FuncName, const TCHAR* ParamName) const;
#endif

	/**
	 *	Check if the textures have changed since the last time the material was
	 *	serialized for Lightmass... Update the lists while in here.
	 *	NOTE: This will mark the package dirty if they have changed.
	 *
	 *	@return	UBOOL	TRUE if the textures have changed.
	 *					FALSE if they have not.
	 */
	virtual UBOOL UpdateLightmassTextureTracking();

	/** @return	The bCastShadowAsMasked value for this material. */
	virtual UBOOL GetCastShadowAsMasked() const;
	/** @return	The Emissive boost value for this material. */
	virtual FLOAT GetEmissiveBoost() const;
	/** @return	The Diffuse boost value for this material. */
	virtual FLOAT GetDiffuseBoost() const;
	/** @return	The Specular boost value for this material. */
	virtual FLOAT GetSpecularBoost() const;
	/** @return	The ExportResolutionScale value for this material. */
	virtual FLOAT GetExportResolutionScale() const;
	virtual FLOAT GetDistanceFieldPenumbraScale() const;

	/**
	 *	Get all of the textures in the expression chain for the given property (ie fill in the given array with all textures in the chain).
	 *
	 *	@param	InProperty				The material property chain to inspect, such as MP_DiffuseColor.
	 *	@param	OutTextures				The array to fill in all of the textures.
	 *	@param	InStaticParameterSet	Optional static parameter set - if supplied only walk the StaticSwitch branches according to it.
	 *	@param	OutTextureParamNames	Optional array to fill in with texture parameter names.
	 *
	 *	@return	UBOOL			TRUE if successful, FALSE if not.
	 */
	virtual UBOOL GetTexturesInPropertyChain(EMaterialProperty InProperty, TArray<UTexture*>& OutTextures, 
		TArray<FName>* OutTextureParamNames, class FStaticParameterSet* InStaticParameterSet);

	/**
	 * Returns the lookup texture to be used in the physical material mask.  Tries to get the parents lookup texture if not overridden here. 
	 */
	virtual UTexture2D* GetPhysicalMaterialMaskTexture() const;

	/**
	 * Returns the black physical material to be used in the physical material mask.  Tries to get the parents black phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetBlackPhysicalMaterial() const;
	
	/**
	 * Returns the white physical material to be used in the physical material mask.  Tries to get the parents white phys mat if not overridden here. 
	 */
	virtual UPhysicalMaterial* GetWhitePhysicalMaterial() const;

	/** 
	 * Returns the UV channel that should be used to look up physical material mask information. Tries to get the parents UV channel if not present here. 
	 */
	virtual INT GetPhysMaterialMaskUVChannel() const;

	/**
	 *	Setup the mobile properties for this instance
	 */
	virtual void SetupMobileProperties();
};

struct FFontParameterValue
{
    FName ParameterName;
    class UFont* FontValue;
    INT FontPage;
    FGuid ExpressionGUID;

		UBOOL operator==(const FFontParameterValue& Other) const
		{
			return 
				ParameterName == Other.ParameterName &&
				FontValue == Other.FontValue &&
				FontPage == Other.FontPage &&
				ExpressionGUID == Other.ExpressionGUID;
		}
	
};

struct FScalarParameterValue
{
    FName ParameterName;
    FLOAT ParameterValue;
    FGuid ExpressionGUID;

		UBOOL operator==(const FScalarParameterValue& Other) const
		{
			return 
				ParameterName == Other.ParameterName &&
				ParameterValue == Other.ParameterValue &&
				ExpressionGUID == Other.ExpressionGUID;
		}
	
};

struct FTextureParameterValue
{
    FName ParameterName;
    class UTexture* ParameterValue;
    FGuid ExpressionGUID;

		UBOOL operator==(const FTextureParameterValue& Other) const
		{
			return 
				ParameterName == Other.ParameterName &&
				ParameterValue == Other.ParameterValue &&
				ExpressionGUID == Other.ExpressionGUID;
		}
	
};

struct FVectorParameterValue
{
    FName ParameterName;
    FLinearColor ParameterValue;
    FGuid ExpressionGUID;

		UBOOL operator==(const FVectorParameterValue& Other) const
		{
			return 
				ParameterName == Other.ParameterName &&
				ParameterValue == Other.ParameterValue &&
				ExpressionGUID == Other.ExpressionGUID;
		}
	
};

class UMaterialInstanceConstant : public UMaterialInstance
{
public:
    //## BEGIN PROPS MaterialInstanceConstant
    TArrayNoInit<struct FFontParameterValue> FontParameterValues;
    TArrayNoInit<struct FScalarParameterValue> ScalarParameterValues;
    TArrayNoInit<struct FTextureParameterValue> TextureParameterValues;
    TArrayNoInit<struct FVectorParameterValue> VectorParameterValues;
    //## END PROPS MaterialInstanceConstant

    virtual void SetParent(class UMaterialInterface* NewParent);
    virtual void SetScalarParameterValue(FName ParameterName,FLOAT Value);
    virtual void SetTextureParameterValue(FName ParameterName,class UTexture* Value);
    virtual void SetVectorParameterValue(FName ParameterName,const FLinearColor& Value);
    virtual void SetFontParameterValue(FName ParameterName,class UFont* FontValue,INT FontPage);
    virtual UBOOL GetMobileScalarParameterValue(FName ParameterName,FLOAT& OutValue);
    virtual UBOOL GetMobileTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
    virtual UBOOL GetMobileVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
    virtual void ClearParameterValues();
    DECLARE_CLASS(UMaterialInstanceConstant,UMaterialInstance,0,Engine)
	// Constructor.
	UMaterialInstanceConstant();

	// UMaterialInstance interface.
	virtual void InitResources();

	/**
	* Checks if any of the static parameter values are outdated based on what they reference (eg a normalmap has changed format)
	*
	* @param	EditorParameters	The new static parameters. 
	*/
	virtual void CheckStaticParameterValues(FStaticParameterSet* EditorParameters);

	// UMaterialInterface interface.
	virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue, INT& OutFontPage);
	virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
	virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
	virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);

	// UObject interface.
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	* Refreshes parameter names using the stored reference to the expression object for the parameter.
	*/
	virtual void UpdateParameterNames();

	/**
	 *	Cleanup the TextureParameter lists in the instance
	 *
	 *	@param	InRefdTextureParamsMap		Map of actual TextureParams used by the parent.
	 *
	 *	NOTE: This is intended to be called only when cooking for stripped platforms!
	 */
	virtual void CleanupTextureParameterReferences(const TMap<FName,UTexture*>& InRefdTextureParamsMap);

	/**
	 *	Setup the mobile properties for this instance
	 */
	virtual void SetupMobileProperties();

	/**
	 *	Set the mobile scalar parameter value to the given value.
	 *
	 *	@param	ParameterName		Name of the parameter to set
	 *	@param	InValue				The scalar value to set it to
	 */
	void SetMobileScalarParameterValue(FName& ParameterName, FLOAT InValue);
	/**
	 *	Set the mobile texture parameter value to the given value.
	 *
	 *	@param	ParameterName		Name of the parameter to set
	 *	@param	InValue				The texture value to set it to
	 */
	void SetMobileTextureParameterValue(FName& ParameterName, UTexture* InValue);
	/**
	 *	Set the mobile vector parameter value to the given value.
	 *
	 *	@param	ParameterName		Name of the parameter to set
	 *	@param	InValue				The vector value to set it to
	 */
	void SetMobileVectorParameterValue(FName& ParameterName, const FLinearColor& InValue);

	/**
	 * This will iterate over MICs in the world and find identical MICs and replace uses of the 
	 * duplicate ones to a single unique MIC. It's based on Parent, overriden parameters, and
	 * the level they are in. This only operates on transient or MICs in a level, it won't
	 * try to mess with content packages.
	 *
	 * @param NumFailuresToPrint If you are looking for a reason why some MICs don't get GC'd, specify a number greater than 0, and the function will tell you why that number aren't getting GC'd (via OBJ REFS)
	 */
	static void CollapseMICs(UINT NumFailuresToPrint=0);
};

class ULandscapeMaterialInstanceConstant : public UMaterialInstanceConstant
{
public:
    //## BEGIN PROPS LandscapeMaterialInstanceConstant
    BITFIELD bIsLayerThumbnail:1;
    INT DataWeightmapIndex;
    INT DataWeightmapSize;
    //## END PROPS LandscapeMaterialInstanceConstant

    DECLARE_CLASS(ULandscapeMaterialInstanceConstant,UMaterialInstanceConstant,0,Engine)
	/**
	* Custom version of AllocateResource to minimize the shaders we need to generate 
	* @return	The allocated resource
	*/
	FMaterialResource* AllocateResource();

	static FString LandscapeVisibilitySwitchName;
};

struct FParameterValueOverTime
{
    FGuid ExpressionGUID;
    FLOAT StartTime;
    FName ParameterName;
    BITFIELD bLoop:1;
    BITFIELD bAutoActivate:1;
    FLOAT CycleTime;
    BITFIELD bNormalizeTime:1;
    FLOAT OffsetTime;
    BITFIELD bOffsetFromEnd:1;
    SCRIPT_ALIGN;

		/** Constructors */
		FParameterValueOverTime() {}
		FParameterValueOverTime(EEventParm)
		{
			appMemzero(this, sizeof(FParameterValueOverTime));
		}
		void InitToDefaults()
		{
			appMemzero(this, sizeof(FParameterValueOverTime));
			StartTime=-1.0f;
			bLoop=FALSE;
			bAutoActivate=FALSE;
			CycleTime=1.0f;
			bNormalizeTime=FALSE;
		}
		FParameterValueOverTime(ENativeConstructor)
		{
			InitToDefaults();
		}
	
};

struct FFontParameterValueOverTime : public FParameterValueOverTime
{
    class UFont* FontValue;
    INT FontPage;

    /** Constructors */
    FFontParameterValueOverTime() {}
    FFontParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FFontParameterValueOverTime));
    }
};

struct FScalarParameterValueOverTime : public FParameterValueOverTime
{
    FLOAT ParameterValue;
    FInterpCurveFloat ParameterValueCurve;

    /** Constructors */
    FScalarParameterValueOverTime() {}
    FScalarParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FScalarParameterValueOverTime));
    }
};

struct FTextureParameterValueOverTime : public FParameterValueOverTime
{
    class UTexture* ParameterValue;

    /** Constructors */
    FTextureParameterValueOverTime() {}
    FTextureParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FTextureParameterValueOverTime));
    }
};

struct FVectorParameterValueOverTime : public FParameterValueOverTime
{
    FLinearColor ParameterValue;
    FInterpCurveVector ParameterValueCurve;

    /** Constructors */
    FVectorParameterValueOverTime() {}
    FVectorParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FVectorParameterValueOverTime));
    }
};

struct FLinearColorParameterValueOverTime : public FParameterValueOverTime
{
    FLinearColor ParameterValue;
    FInterpCurveLinearColor ParameterValueCurve;

    /** Constructors */
    FLinearColorParameterValueOverTime() {}
    FLinearColorParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FLinearColorParameterValueOverTime));
    }
};

class UMaterialInstanceTimeVarying : public UMaterialInstance
{
public:
    //## BEGIN PROPS MaterialInstanceTimeVarying
    BITFIELD bAutoActivateAll:1;
    FLOAT Duration;
    TArrayNoInit<struct FFontParameterValueOverTime> FontParameterValues;
    TArrayNoInit<struct FScalarParameterValueOverTime> ScalarParameterValues;
    TArrayNoInit<struct FTextureParameterValueOverTime> TextureParameterValues;
    TArrayNoInit<struct FVectorParameterValueOverTime> VectorParameterValues;
    TArrayNoInit<struct FLinearColorParameterValueOverTime> LinearColorParameterValues;
    //## END PROPS MaterialInstanceTimeVarying

    virtual void SetParent(class UMaterialInterface* NewParent);
    virtual void SetScalarParameterValue(FName ParameterName,FLOAT Value);
    virtual void SetScalarCurveParameterValue(FName ParameterName,const FInterpCurveFloat& Value);
    virtual void SetScalarStartTime(FName ParameterName,FLOAT Value);
    virtual void SetDuration(FLOAT Value);
    virtual void SetTextureParameterValue(FName ParameterName,class UTexture* Value);
    virtual void SetVectorParameterValue(FName ParameterName,const FLinearColor& Value);
    virtual void SetVectorCurveParameterValue(FName ParameterName,const FInterpCurveVector& Value);
    virtual void SetLinearColorParameterValue(FName ParameterName,const FLinearColor& Value);
    virtual void SetLinearColorCurveParameterValue(FName ParameterName,const FInterpCurveLinearColor& Value);
    virtual void SetVectorStartTime(FName ParameterName,FLOAT Value);
    virtual void SetFontParameterValue(FName ParameterName,class UFont* FontValue,INT FontPage);
    virtual void ClearParameterValues();
    virtual FLOAT GetMaxDurationFromAllParameters();
    virtual UBOOL CheckForVectorParameterConflicts(FName ParameterName);
    DECLARE_FUNCTION(execSetScalarStartTime)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetScalarStartTime(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetDuration)
    {
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetDuration(Value);
    }
    DECLARE_FUNCTION(execSetVectorCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveVector,Value);
        P_FINISH;
        this->SetVectorCurveParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetLinearColorParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_REF(FLinearColor,Value);
        P_FINISH;
        this->SetLinearColorParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetLinearColorCurveParameterValue)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_INIT_REF(FInterpCurveLinearColor,Value);
        P_FINISH;
        this->SetLinearColorCurveParameterValue(ParameterName,Value);
    }
    DECLARE_FUNCTION(execSetVectorStartTime)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetVectorStartTime(ParameterName,Value);
    }
    DECLARE_FUNCTION(execGetMaxDurationFromAllParameters)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetMaxDurationFromAllParameters();
    }
    DECLARE_FUNCTION(execCheckForVectorParameterConflicts)
    {
        P_GET_NAME(ParameterName);
        P_FINISH;
        *(UBOOL*)Result=this->CheckForVectorParameterConflicts(ParameterName);
    }
    DECLARE_CLASS(UMaterialInstanceTimeVarying,UMaterialInstance,0,Engine)
	// Constructor.
	UMaterialInstanceTimeVarying();

	// UMaterialInstance interface.
	virtual void InitResources();

	// UMaterialInterface interface.
	virtual UBOOL GetFontParameterValue(FName ParameterName,class UFont*& OutFontValue, INT& OutFontPage);
	/**
	 * For MITVs you can utilize both single Scalar values and InterpCurve values.
	 *
	 * If there is any data in the InterpCurve, then the MITV will utilize that. Else it will utilize the Scalar value
	 * of the same name.
	 **/
	virtual UBOOL GetScalarParameterValue(FName ParameterName,FLOAT& OutValue);
	virtual UBOOL GetScalarCurveParameterValue(FName ParameterName,FInterpCurveFloat& OutValue);
	virtual UBOOL GetTextureParameterValue(FName ParameterName,class UTexture*& OutValue);
	virtual UBOOL GetVectorParameterValue(FName ParameterName,FLinearColor& OutValue);
	virtual UBOOL GetVectorCurveParameterValue(FName ParameterName,FInterpCurveVector &OutValue);
	virtual UBOOL GetLinearColorParameterValue(FName ParameterName,FLinearColor& OutValue);
	virtual UBOOL GetLinearColorCurveParameterValue(FName ParameterName,FInterpCurveLinearColor &OutValue);

	// UObject interface.
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	* Refreshes parameter names using the stored reference to the expression object for the parameter.
	*/
	virtual void UpdateParameterNames();

	/**
	 *	Cleanup the TextureParameter lists in the instance
	 *
	 *	@param	InRefdTextureParamsMap		Map of actual TextureParams used by the parent.
	 *
	 *	NOTE: This is intended to be called only when cooking for stripped platforms!
	 */
	virtual void CleanupTextureParameterReferences(const TMap<FName,UTexture*>& InRefdTextureParamsMap);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_MATERIAL_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execSetForceMipLevelsToBeResident);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetMobileVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetMobileTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetMobileScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetGroupName);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetLinearColorCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetLinearColorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetVectorCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetScalarCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetParameterDesc);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetPhysicalMaterial);
AUTOGENERATE_FUNCTION(UMaterialInterface,-1,execGetMaterial);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execIsInMapOrTransientPackage);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execClearParameterValues);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execGetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetScalarCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execSetParent);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execClearParameterValues);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execGetMobileVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execGetMobileTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execGetMobileScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceConstant,-1,execSetParent);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execCheckForVectorParameterConflicts);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execGetMaxDurationFromAllParameters);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execClearParameterValues);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetFontParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetVectorStartTime);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetLinearColorCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetLinearColorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetVectorCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetVectorParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetTextureParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetDuration);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetScalarStartTime);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetScalarCurveParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetScalarParameterValue);
AUTOGENERATE_FUNCTION(UMaterialInstanceTimeVarying,-1,execSetParent);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_MATERIAL_NATIVE_DEFS
#define ENGINE_MATERIAL_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_MATERIAL \
	UMaterialExpression::StaticClass(); \
	UMaterialExpressionAbs::StaticClass(); \
	UMaterialExpressionActorWorldPosition::StaticClass(); \
	UMaterialExpressionAdd::StaticClass(); \
	UMaterialExpressionAppendVector::StaticClass(); \
	UMaterialExpressionBumpOffset::StaticClass(); \
	UMaterialExpressionCameraVector::StaticClass(); \
	UMaterialExpressionCameraWorldPosition::StaticClass(); \
	UMaterialExpressionCeil::StaticClass(); \
	UMaterialExpressionClamp::StaticClass(); \
	UMaterialExpressionComment::StaticClass(); \
	UMaterialExpressionComponentMask::StaticClass(); \
	UMaterialExpressionConstant::StaticClass(); \
	UMaterialExpressionConstant2Vector::StaticClass(); \
	UMaterialExpressionConstant3Vector::StaticClass(); \
	UMaterialExpressionConstant4Vector::StaticClass(); \
	UMaterialExpressionConstantBiasScale::StaticClass(); \
	UMaterialExpressionConstantClamp::StaticClass(); \
	UMaterialExpressionCosine::StaticClass(); \
	UMaterialExpressionCrossProduct::StaticClass(); \
	UMaterialExpressionCustom::StaticClass(); \
	UMaterialExpressionCustomTexture::StaticClass(); \
	UMaterialExpressionDepthBiasedAlpha::StaticClass(); \
	UMaterialExpressionDepthBiasedBlend::StaticClass(); \
	UMaterialExpressionDepthOfFieldFunction::StaticClass(); \
	UMaterialExpressionDeriveNormalZ::StaticClass(); \
	UMaterialExpressionDesaturation::StaticClass(); \
	UMaterialExpressionDestColor::StaticClass(); \
	UMaterialExpressionDestDepth::StaticClass(); \
	UMaterialExpressionDistance::StaticClass(); \
	UMaterialExpressionDivide::StaticClass(); \
	UMaterialExpressionDotProduct::StaticClass(); \
	UMaterialExpressionDynamicParameter::StaticClass(); \
	UMaterialExpressionMeshEmitterDynamicParameter::StaticClass(); \
	UMaterialExpressionFloor::StaticClass(); \
	UMaterialExpressionFluidNormal::StaticClass(); \
	UMaterialExpressionFmod::StaticClass(); \
	UMaterialExpressionFoliageImpulseDirection::StaticClass(); \
	UMaterialExpressionFoliageNormalizedRotationAxisAndAngle::StaticClass(); \
	UMaterialExpressionFontSample::StaticClass(); \
	UMaterialExpressionFontSampleParameter::StaticClass(); \
	UMaterialExpressionFrac::StaticClass(); \
	UMaterialExpressionFresnel::StaticClass(); \
	UMaterialExpressionFunctionInput::StaticClass(); \
	UMaterialExpressionFunctionOutput::StaticClass(); \
	UMaterialExpressionIf::StaticClass(); \
	UMaterialExpressionLandscapeLayerBlend::StaticClass(); \
	UMaterialExpressionLensFlareIntensity::StaticClass(); \
	UMaterialExpressionLensFlareOcclusion::StaticClass(); \
	UMaterialExpressionLensFlareRadialDistance::StaticClass(); \
	UMaterialExpressionLensFlareRayDistance::StaticClass(); \
	UMaterialExpressionLensFlareSourceDistance::StaticClass(); \
	UMaterialExpressionLightmapUVs::StaticClass(); \
	UMaterialExpressionLightmassReplace::StaticClass(); \
	UMaterialExpressionLightVector::StaticClass(); \
	UMaterialExpressionLinearInterpolate::StaticClass(); \
	UMaterialExpressionMaterialFunctionCall::StaticClass(); \
	UMaterialExpressionMeshEmitterVertexColor::StaticClass(); \
	UMaterialExpressionMultiply::StaticClass(); \
	UMaterialExpressionNormalize::StaticClass(); \
	UMaterialExpressionObjectOrientation::StaticClass(); \
	UMaterialExpressionObjectRadius::StaticClass(); \
	UMaterialExpressionObjectWorldPosition::StaticClass(); \
	UMaterialExpressionOcclusionPercentage::StaticClass(); \
	UMaterialExpressionOneMinus::StaticClass(); \
	UMaterialExpressionPanner::StaticClass(); \
	UMaterialExpressionParameter::StaticClass(); \
	UMaterialExpressionScalarParameter::StaticClass(); \
	UMaterialExpressionStaticBoolParameter::StaticClass(); \
	UMaterialExpressionStaticSwitchParameter::StaticClass(); \
	UMaterialExpressionStaticComponentMaskParameter::StaticClass(); \
	UMaterialExpressionVectorParameter::StaticClass(); \
	UMaterialExpressionParticleMacroUV::StaticClass(); \
	UMaterialExpressionPerInstanceRandom::StaticClass(); \
	UMaterialExpressionPixelDepth::StaticClass(); \
	UMaterialExpressionPower::StaticClass(); \
	UMaterialExpressionQualitySwitch::StaticClass(); \
	UMaterialExpressionReflectionVector::StaticClass(); \
	UMaterialExpressionRotateAboutAxis::StaticClass(); \
	UMaterialExpressionRotator::StaticClass(); \
	UMaterialExpressionSceneDepth::StaticClass(); \
	UMaterialExpressionSceneTexture::StaticClass(); \
	UMaterialExpressionScreenPosition::StaticClass(); \
	UMaterialExpressionScreenSize::StaticClass(); \
	UMaterialExpressionSine::StaticClass(); \
	UMaterialExpressionSphereMask::StaticClass(); \
	UMaterialExpressionSquareRoot::StaticClass(); \
	UMaterialExpressionStaticBool::StaticClass(); \
	UMaterialExpressionStaticSwitch::StaticClass(); \
	UMaterialExpressionSubtract::StaticClass(); \
	UMaterialExpressionTerrainLayerCoords::StaticClass(); \
	UMaterialExpressionTerrainLayerSwitch::StaticClass(); \
	UMaterialExpressionTerrainLayerWeight::StaticClass(); \
	UMaterialExpressionTexelSize::StaticClass(); \
	UMaterialExpressionTextureCoordinate::StaticClass(); \
	UMaterialExpressionTextureObject::StaticClass(); \
	UMaterialExpressionTextureSample::StaticClass(); \
	UMaterialExpressionDepthBiasBlend::StaticClass(); \
	UMaterialExpressionFlipBookSample::StaticClass(); \
	UMaterialExpressionMeshSubUV::StaticClass(); \
	UMaterialExpressionMeshSubUVBlend::StaticClass(); \
	UMaterialExpressionParticleSubUV::StaticClass(); \
	UMaterialExpressionTextureSampleParameter::StaticClass(); \
	UMaterialExpressionTextureObjectParameter::StaticClass(); \
	UMaterialExpressionTextureSampleParameter2D::StaticClass(); \
	UMaterialExpressionAntialiasedTextureMask::StaticClass(); \
	UMaterialExpressionTextureSampleParameterFlipbook::StaticClass(); \
	UMaterialExpressionTextureSampleParameterMeshSubUV::StaticClass(); \
	UMaterialExpressionTextureSampleParameterMeshSubUVBlend::StaticClass(); \
	UMaterialExpressionTextureSampleParameterSubUV::StaticClass(); \
	UMaterialExpressionTextureSampleParameterCube::StaticClass(); \
	UMaterialExpressionTextureSampleParameterMovie::StaticClass(); \
	UMaterialExpressionTextureSampleParameterNormal::StaticClass(); \
	UMaterialExpressionTime::StaticClass(); \
	UMaterialExpressionTransform::StaticClass(); \
	UMaterialExpressionTransformPosition::StaticClass(); \
	UMaterialExpressionTwoSidedSign::StaticClass(); \
	UMaterialExpressionVertexColor::StaticClass(); \
	UMaterialExpressionWindDirectionAndSpeed::StaticClass(); \
	UMaterialExpressionWorldNormal::StaticClass(); \
	UMaterialExpressionWorldPosition::StaticClass(); \
	UMaterialFunction::StaticClass(); \
	UMaterialInterface::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MaterialInterface"), GEngineUMaterialInterfaceNatives); \
	UMaterial::StaticClass(); \
	UMaterialInstance::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MaterialInstance"), GEngineUMaterialInstanceNatives); \
	UMaterialInstanceConstant::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MaterialInstanceConstant"), GEngineUMaterialInstanceConstantNatives); \
	ULandscapeMaterialInstanceConstant::StaticClass(); \
	UMaterialInstanceTimeVarying::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MaterialInstanceTimeVarying"), GEngineUMaterialInstanceTimeVaryingNatives); \

#endif // ENGINE_MATERIAL_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineUMaterialInterfaceNatives[] = 
{ 
	MAP_NATIVE(UMaterialInterface, execSetForceMipLevelsToBeResident)
	MAP_NATIVE(UMaterialInterface, execGetMobileVectorParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetMobileTextureParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetMobileScalarParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetGroupName)
	MAP_NATIVE(UMaterialInterface, execGetLinearColorCurveParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetLinearColorParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetVectorCurveParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetVectorParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetTextureParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetScalarCurveParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetScalarParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetFontParameterValue)
	MAP_NATIVE(UMaterialInterface, execGetParameterDesc)
	MAP_NATIVE(UMaterialInterface, execGetPhysicalMaterial)
	MAP_NATIVE(UMaterialInterface, execGetMaterial)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMaterialInstanceNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstance, execIsInMapOrTransientPackage)
	MAP_NATIVE(UMaterialInstance, execClearParameterValues)
	MAP_NATIVE(UMaterialInstance, execSetFontParameterValue)
	MAP_NATIVE(UMaterialInstance, execGetTextureParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetTextureParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetScalarCurveParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstance, execSetParent)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMaterialInstanceConstantNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstanceConstant, execClearParameterValues)
	MAP_NATIVE(UMaterialInstanceConstant, execGetMobileVectorParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execGetMobileTextureParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execGetMobileScalarParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execSetFontParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execSetTextureParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant, execSetParent)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMaterialInstanceTimeVaryingNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstanceTimeVarying, execCheckForVectorParameterConflicts)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execGetMaxDurationFromAllParameters)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execClearParameterValues)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetFontParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetVectorStartTime)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetLinearColorCurveParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetLinearColorParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetVectorCurveParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetTextureParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetDuration)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetScalarStartTime)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetScalarCurveParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstanceTimeVarying, execSetParent)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpression,MaterialExpression,EditorX_DEPRECATED)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpression,MaterialExpression,Outputs)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpression)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAbs,MaterialExpressionAbs,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAbs)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionActorWorldPosition)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAdd,MaterialExpressionAdd,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAdd,MaterialExpressionAdd,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAdd)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAppendVector,MaterialExpressionAppendVector,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAppendVector,MaterialExpressionAppendVector,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAppendVector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionBumpOffset,MaterialExpressionBumpOffset,Coordinate)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionBumpOffset,MaterialExpressionBumpOffset,ReferencePlane)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionBumpOffset)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCameraVector)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCameraWorldPosition)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCeil,MaterialExpressionCeil,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCeil)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionClamp,MaterialExpressionClamp,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionClamp,MaterialExpressionClamp,Max)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionClamp)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionComment,MaterialExpressionComment,PosX)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionComment,MaterialExpressionComment,Text)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionComment)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionComponentMask,MaterialExpressionComponentMask,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionComponentMask)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant,MaterialExpressionConstant,R)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant2Vector,MaterialExpressionConstant2Vector,R)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant2Vector,MaterialExpressionConstant2Vector,G)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant2Vector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant3Vector,MaterialExpressionConstant3Vector,R)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant3Vector,MaterialExpressionConstant3Vector,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant3Vector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant4Vector,MaterialExpressionConstant4Vector,R)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstant4Vector,MaterialExpressionConstant4Vector,A)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant4Vector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstantBiasScale,MaterialExpressionConstantBiasScale,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstantBiasScale,MaterialExpressionConstantBiasScale,Scale)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstantBiasScale)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstantClamp,MaterialExpressionConstantClamp,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionConstantClamp,MaterialExpressionConstantClamp,Max)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstantClamp)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCosine,MaterialExpressionCosine,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCosine,MaterialExpressionCosine,Period)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCosine)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCrossProduct,MaterialExpressionCrossProduct,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCrossProduct,MaterialExpressionCrossProduct,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCrossProduct)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCustom,MaterialExpressionCustom,Code)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCustom,MaterialExpressionCustom,Inputs)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCustom)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionCustomTexture,MaterialExpressionCustomTexture,Texture)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCustomTexture)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasedAlpha,MaterialExpressionDepthBiasedAlpha,BiasScale)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasedAlpha,MaterialExpressionDepthBiasedAlpha,Bias)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthBiasedAlpha)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasedBlend,MaterialExpressionDepthBiasedBlend,BiasScale)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasedBlend,MaterialExpressionDepthBiasedBlend,Bias)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthBiasedBlend)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthOfFieldFunction,MaterialExpressionDepthOfFieldFunction,FunctionValue)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthOfFieldFunction,MaterialExpressionDepthOfFieldFunction,Depth)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthOfFieldFunction)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDeriveNormalZ,MaterialExpressionDeriveNormalZ,InXY)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDeriveNormalZ)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDesaturation,MaterialExpressionDesaturation,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDesaturation,MaterialExpressionDesaturation,LuminanceFactors)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDesaturation)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDestColor)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDestDepth)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDistance,MaterialExpressionDistance,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDistance,MaterialExpressionDistance,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDistance)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDivide,MaterialExpressionDivide,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDivide,MaterialExpressionDivide,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDivide)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDotProduct,MaterialExpressionDotProduct,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDotProduct,MaterialExpressionDotProduct,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDotProduct)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDynamicParameter,MaterialExpressionDynamicParameter,ParamNames)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDynamicParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshEmitterDynamicParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFloor,MaterialExpressionFloor,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFloor)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFluidNormal,MaterialExpressionFluidNormal,Coordinates)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFluidNormal)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFmod,MaterialExpressionFmod,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFmod,MaterialExpressionFmod,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFmod)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFoliageImpulseDirection)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFoliageNormalizedRotationAxisAndAngle)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFontSample,MaterialExpressionFontSample,Font)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFontSample,MaterialExpressionFontSample,FontTexturePage)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFontSample)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFontSampleParameter,MaterialExpressionFontSampleParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFontSampleParameter,MaterialExpressionFontSampleParameter,Group)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFontSampleParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFrac,MaterialExpressionFrac,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFrac)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFresnel,MaterialExpressionFresnel,Exponent)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFresnel,MaterialExpressionFresnel,Normal)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFresnel)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFunctionInput,MaterialExpressionFunctionInput,Preview)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFunctionInput,MaterialExpressionFunctionInput,SortPriority)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFunctionInput)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFunctionOutput,MaterialExpressionFunctionOutput,OutputName)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionFunctionOutput,MaterialExpressionFunctionOutput,Id)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFunctionOutput)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionIf,MaterialExpressionIf,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionIf,MaterialExpressionIf,ALessThanB)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionIf)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLandscapeLayerBlend,MaterialExpressionLandscapeLayerBlend,Layers)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLandscapeLayerBlend,MaterialExpressionLandscapeLayerBlend,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLandscapeLayerBlend)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareIntensity)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareOcclusion)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareRadialDistance)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareRayDistance)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLensFlareSourceDistance)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLightmapUVs)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLightmassReplace,MaterialExpressionLightmassReplace,Realtime)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLightmassReplace,MaterialExpressionLightmassReplace,Lightmass)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLightmassReplace)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLightVector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLinearInterpolate,MaterialExpressionLinearInterpolate,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionLinearInterpolate,MaterialExpressionLinearInterpolate,Alpha)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLinearInterpolate)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionMaterialFunctionCall,MaterialExpressionMaterialFunctionCall,MaterialFunction)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionMaterialFunctionCall,MaterialExpressionMaterialFunctionCall,FunctionOutputs)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMaterialFunctionCall)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshEmitterVertexColor)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionMultiply,MaterialExpressionMultiply,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionMultiply,MaterialExpressionMultiply,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMultiply)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionNormalize,MaterialExpressionNormalize,VectorInput)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionNormalize)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionObjectOrientation)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionObjectRadius)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionObjectWorldPosition)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionOcclusionPercentage)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionOneMinus,MaterialExpressionOneMinus,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionOneMinus)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionPanner,MaterialExpressionPanner,Coordinate)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionPanner,MaterialExpressionPanner,SpeedY)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPanner)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionParameter,MaterialExpressionParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionParameter,MaterialExpressionParameter,Group)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionScalarParameter,MaterialExpressionScalarParameter,DefaultValue)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionScalarParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticBoolParameter,MaterialExpressionStaticBoolParameter,InstanceOverride)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionStaticBoolParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticSwitchParameter,MaterialExpressionStaticSwitchParameter,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticSwitchParameter,MaterialExpressionStaticSwitchParameter,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionStaticSwitchParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticComponentMaskParameter,MaterialExpressionStaticComponentMaskParameter,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticComponentMaskParameter,MaterialExpressionStaticComponentMaskParameter,InstanceOverride)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionStaticComponentMaskParameter)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionVectorParameter,MaterialExpressionVectorParameter,DefaultValue)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionVectorParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionParticleMacroUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPerInstanceRandom)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPixelDepth)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionPower,MaterialExpressionPower,Base)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionPower,MaterialExpressionPower,Exponent)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPower)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionQualitySwitch,MaterialExpressionQualitySwitch,High)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionQualitySwitch,MaterialExpressionQualitySwitch,Low)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionQualitySwitch)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionReflectionVector)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionRotateAboutAxis,MaterialExpressionRotateAboutAxis,NormalizedRotationAxisAndAngle)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionRotateAboutAxis,MaterialExpressionRotateAboutAxis,Position)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionRotateAboutAxis)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionRotator,MaterialExpressionRotator,Coordinate)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionRotator,MaterialExpressionRotator,Speed)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionRotator)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSceneDepth,MaterialExpressionSceneDepth,Coordinates)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSceneDepth)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSceneTexture,MaterialExpressionSceneTexture,Coordinates)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSceneTexture,MaterialExpressionSceneTexture,SceneTextureType)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSceneTexture)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionScreenPosition)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionScreenSize)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSine,MaterialExpressionSine,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSine,MaterialExpressionSine,Period)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSine)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSphereMask,MaterialExpressionSphereMask,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSphereMask,MaterialExpressionSphereMask,HardnessPercent)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSphereMask)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSquareRoot,MaterialExpressionSquareRoot,Input)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSquareRoot)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionStaticBool)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticSwitch,MaterialExpressionStaticSwitch,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionStaticSwitch,MaterialExpressionStaticSwitch,Value)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionStaticSwitch)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSubtract,MaterialExpressionSubtract,A)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionSubtract,MaterialExpressionSubtract,B)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSubtract)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerCoords,MaterialExpressionTerrainLayerCoords,MappingType)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerCoords,MaterialExpressionTerrainLayerCoords,MappingPanV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTerrainLayerCoords)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerSwitch,MaterialExpressionTerrainLayerSwitch,InstanceOverride)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerSwitch,MaterialExpressionTerrainLayerSwitch,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTerrainLayerSwitch)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerWeight,MaterialExpressionTerrainLayerWeight,InstanceOverride)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTerrainLayerWeight,MaterialExpressionTerrainLayerWeight,ExpressionGUID)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTerrainLayerWeight)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTexelSize)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureCoordinate,MaterialExpressionTextureCoordinate,CoordinateIndex)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureCoordinate,MaterialExpressionTextureCoordinate,VTiling)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureCoordinate)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureObject,MaterialExpressionTextureObject,Texture)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureObject)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSample,MaterialExpressionTextureSample,Texture)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSample,MaterialExpressionTextureSample,TextureObject)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSample)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasBlend,MaterialExpressionDepthBiasBlend,BiasScale)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionDepthBiasBlend,MaterialExpressionDepthBiasBlend,Bias)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDepthBiasBlend)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFlipBookSample)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshSubUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMeshSubUVBlend)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionParticleSubUV)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSampleParameter,MaterialExpressionTextureSampleParameter,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSampleParameter,MaterialExpressionTextureSampleParameter,Group)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureObjectParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameter2D)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAntialiasedTextureMask,MaterialExpressionAntialiasedTextureMask,Threshold)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionAntialiasedTextureMask,MaterialExpressionAntialiasedTextureMask,Channel)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAntialiasedTextureMask)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterFlipbook)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterMeshSubUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterMeshSubUVBlend)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterSubUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterCube)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterMovie)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTextureSampleParameterNormal,MaterialExpressionTextureSampleParameterNormal,InstanceOverride)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSampleParameterNormal)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTime)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTransform,MaterialExpressionTransform,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTransform,MaterialExpressionTransform,TransformType)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTransform)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTransformPosition,MaterialExpressionTransformPosition,Input)
VERIFY_CLASS_OFFSET_NODIE(UMaterialExpressionTransformPosition,MaterialExpressionTransformPosition,TransformType)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTransformPosition)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTwoSidedSign)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionVertexColor)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionWindDirectionAndSpeed)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionWorldNormal)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionWorldPosition)
VERIFY_CLASS_OFFSET_NODIE(UMaterialFunction,MaterialFunction,StateId)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UMaterialFunction,MaterialFunction,FunctionEditorComments)
#else
VERIFY_CLASS_OFFSET_NODIE(UMaterialFunction,MaterialFunction,FunctionExpressions)
#endif
VERIFY_CLASS_SIZE_NODIE(UMaterialFunction)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInterface,MaterialInterface,ParentRefFence)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInterface,MaterialInterface,MobileLandscapeMonochomeLayerColors)
VERIFY_CLASS_SIZE_NODIE(UMaterialInterface)
VERIFY_CLASS_OFFSET_NODIE(UMaterial,Material,PhysMaterial)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UMaterial,Material,ReferencedTextureGuids)
#else
VERIFY_CLASS_OFFSET_NODIE(UMaterial,Material,ReferencedTextures_DEPRECATED)
#endif
VERIFY_CLASS_SIZE_NODIE(UMaterial)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstance,MaterialInstance,PhysMaterial)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstance,MaterialInstance,ParentLightingGuid)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstance)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstanceConstant,MaterialInstanceConstant,FontParameterValues)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstanceConstant,MaterialInstanceConstant,VectorParameterValues)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceConstant)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeMaterialInstanceConstant,LandscapeMaterialInstanceConstant,DataWeightmapIndex)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeMaterialInstanceConstant,LandscapeMaterialInstanceConstant,DataWeightmapSize)
VERIFY_CLASS_SIZE_NODIE(ULandscapeMaterialInstanceConstant)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstanceTimeVarying,MaterialInstanceTimeVarying,Duration)
VERIFY_CLASS_OFFSET_NODIE(UMaterialInstanceTimeVarying,MaterialInstanceTimeVarying,LinearColorParameterValues)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceTimeVarying)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
