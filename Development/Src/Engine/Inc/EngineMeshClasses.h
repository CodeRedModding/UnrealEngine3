/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_MESH_ENUMS
#define INCLUDED_ENGINE_MESH_ENUMS 1

enum EImpactDamageOverride
{
    IDO_None                =0,
    IDO_On                  =1,
    IDO_Off                 =2,
    IDO_MAX                 =3,
};
#define FOREACH_ENUM_EIMPACTDAMAGEOVERRIDE(op) \
    op(IDO_None) \
    op(IDO_On) \
    op(IDO_Off) 

#endif // !INCLUDED_ENGINE_MESH_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_MESH_CLASSES
#define INCLUDED_ENGINE_MESH_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UApexAsset : public UObject
{
public:
    //## BEGIN PROPS ApexAsset
    FStringNoInit OriginalApexName;
    TArrayNoInit<class UApexComponentBase*> ApexComponents;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class UApexAsset*> NamedReferences;
    FStringNoInit SourceFilePath;
    FStringNoInit SourceFileTimestamp;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS ApexAsset

    DECLARE_CLASS(UApexAsset,UObject,0,Engine)
	public:
		/** Display strings for the generic browser */
		virtual	TArray<FString>	GetGenericBrowserInfo();

	   	/** virtual method to return the number of materials used by this asset */
		virtual UINT                GetNumMaterials(void) const   { return 0; }
		/** virtual method to return a particular material by index */
		virtual UMaterialInterface *GetMaterial(UINT Index) const { return 0; }
		/** Returns the default ::NxParameterized::Interface describing the Actor Desc for this asset. */
		virtual void * GetNxParameterized(void) { return 0; };
		/** Returns a *copy* of the :NxParameterized::Interface for this asset. Caller must manually 'destroy' it.*/
		virtual void * GetAssetNxParameterized(void) { return 0; };
		/*** Export asset to a file, in xml/bin format.
		**
		** @param Name: The name of file name for exported asset
		** @param isKeepUE3Coords: Export type, in original coords (true) or keep UE3 coords (false)
		** 
		**/
		virtual UBOOL Export(const FName& Name, UBOOL isKeepUE3Coords){ return true; };
		/** Re-assigns the APEX material resources by name with the current array of UE3 materials */
		virtual void UpdateMaterials(void) { };


		virtual void ResetNamedReferences(void);
		virtual void AddNamedReference(class UApexAsset *obj);
		virtual void RemoveNamedReference(class UApexAsset *obj);
		virtual void NotifyApexEditMode(class ApexEditInterface *iface) { };

		/** Whether the APEX asset's materials can be overridden in the actor's ApexComponent */
		virtual UBOOL SupportsMaterialOverride() const { return FALSE; }

	protected:
		// Called when the Asset gets rebuilt (in editor only).
		void OnApexAssetLost(void);
		void OnApexAssetReset(void);
};

struct FNxDestructibleDepthParameters
{
    BITFIELD TAKE_IMPACT_DAMAGE_DEPRECATED:1;
    BITFIELD IGNORE_POSE_UPDATES_DEPRECATED:1;
    BITFIELD IGNORE_RAYCAST_CALLBACKS_DEPRECATED:1;
    BITFIELD IGNORE_CONTACT_CALLBACKS_DEPRECATED:1;
    BITFIELD USER_FLAG_0_DEPRECATED:1;
    BITFIELD USER_FLAG_1_DEPRECATED:1;
    BITFIELD USER_FLAG_2_DEPRECATED:1;
    BITFIELD USER_FLAG_3_DEPRECATED:1;
    SCRIPT_ALIGN;
    BYTE ImpactDamageOverride;
    SCRIPT_ALIGN;

    /** Constructors */
    FNxDestructibleDepthParameters() {}
    FNxDestructibleDepthParameters(EEventParm)
    {
        appMemzero(this, sizeof(FNxDestructibleDepthParameters));
    }
};

struct FNxDestructibleParametersFlag
{
    BITFIELD ACCUMULATE_DAMAGE:1;
    BITFIELD ASSET_DEFINED_SUPPORT:1;
    BITFIELD WORLD_SUPPORT:1;
    BITFIELD DEBRIS_TIMEOUT:1;
    BITFIELD DEBRIS_MAX_SEPARATION:1;
    BITFIELD CRUMBLE_SMALLEST_CHUNKS:1;
    BITFIELD ACCURATE_RAYCASTS:1;
    BITFIELD USE_VALID_BOUNDS:1;
    BITFIELD FORM_EXTENDED_STRUCTURES:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FNxDestructibleParametersFlag() {}
    FNxDestructibleParametersFlag(EEventParm)
    {
        appMemzero(this, sizeof(FNxDestructibleParametersFlag));
    }
};

struct FNxDestructibleDamageParameters
{
    FLOAT DamageThreshold;
    FLOAT DamageSpread;
    FLOAT ImpactDamage;
    FLOAT ImpactResistance;
    INT DefaultImpactDamageDepth;

    /** Constructors */
    FNxDestructibleDamageParameters() {}
    FNxDestructibleDamageParameters(EEventParm)
    {
        appMemzero(this, sizeof(FNxDestructibleDamageParameters));
    }
};

struct FNxDestructibleDebrisParameters
{
    FLOAT DebrisLifetimeMin;
    FLOAT DebrisLifetimeMax;
    FLOAT DebrisMaxSeparationMin;
    FLOAT DebrisMaxSeparationMax;
    FBox ValidBounds;

    /** Constructors */
    FNxDestructibleDebrisParameters() {}
    FNxDestructibleDebrisParameters(EEventParm)
    {
        appMemzero(this, sizeof(FNxDestructibleDebrisParameters));
    }
};

struct FNxDestructibleAdvancedParameters
{
    FLOAT DamageCap;
    FLOAT ImpactVelocityThreshold;
    FLOAT MaxChunkSpeed;
    FLOAT MassScaleExponent;
    FLOAT MassScale;
    FLOAT FractureImpulseScale;

    /** Constructors */
    FNxDestructibleAdvancedParameters() {}
    FNxDestructibleAdvancedParameters(EEventParm)
    {
        appMemzero(this, sizeof(FNxDestructibleAdvancedParameters));
    }
};

struct FNxDestructibleParameters
{
    struct FNxDestructibleDamageParameters DamageParameters;
    struct FNxDestructibleDebrisParameters DebrisParameters;
    struct FNxDestructibleAdvancedParameters AdvancedParameters;
    FLOAT DamageThreshold_DEPRECATED;
    FLOAT DamageToRadius_DEPRECATED;
    FLOAT DamageCap_DEPRECATED;
    FLOAT ForceToDamage_DEPRECATED;
    FLOAT ImpactVelocityThreshold_DEPRECATED;
    FLOAT MaterialStrength_DEPRECATED;
    FLOAT DamageToPercentDeformation_DEPRECATED;
    FLOAT DeformationPercentLimit_DEPRECATED;
    BITFIELD bFormExtendedStructures_DEPRECATED:1;
    INT SupportDepth;
    INT MinimumFractureDepth;
    INT DebrisDepth;
    INT EssentialDepth;
    FLOAT DebrisLifetimeMin_DEPRECATED;
    FLOAT DebrisLifetimeMax_DEPRECATED;
    FLOAT DebrisMaxSeparationMin_DEPRECATED;
    FLOAT DebrisMaxSeparationMax_DEPRECATED;
    FBox ValidBounds_DEPRECATED;
    FLOAT MaxChunkSpeed_DEPRECATED;
    FLOAT MassScaleExponent_DEPRECATED;
    struct FNxDestructibleParametersFlag Flags;
    FLOAT GrbVolumeLimit_DEPRECATED;
    FLOAT GrbParticleSpacing_DEPRECATED;
    FLOAT FractureImpulseScale_DEPRECATED;
    TArrayNoInit<struct FNxDestructibleDepthParameters> DepthParameters;
    INT DynamicChunksDominanceGroup;
    BITFIELD UseDynamicChunksGroupsMask:1;
    SCRIPT_ALIGN;
    BYTE DynamicChunksChannel;
    SCRIPT_ALIGN;
    FRBCollisionChannelContainer DynamicChunksCollideWithChannels;

    /** Constructors */
    FNxDestructibleParameters() {}
    FNxDestructibleParameters(EEventParm)
    {
        appMemzero(this, sizeof(FNxDestructibleParameters));
    }
};

class UApexDestructibleAsset : public UApexAsset
{
public:
    //## BEGIN PROPS ApexDestructibleAsset
    class FIApexAsset* MApexAsset;
    TArrayNoInit<class UMaterialInterface*> Materials;
    TArrayNoInit<class UFractureMaterial*> FractureMaterials;
    BITFIELD bPlaySingleFractureMaterialEffect:1;
    BITFIELD bHasUniqueAssetMaterialNames:1;
    BITFIELD bDynamic_DEPRECATED:1;
    class UPhysicalMaterial* DefaultPhysMaterial;
    class UApexStaticDestructibleComponent* MDestructibleThumbnailComponent;
    FStringNoInit CrumbleEmitterName;
    FStringNoInit DustEmitterName;
    struct FNxDestructibleParameters DestructibleParameters;
    //## END PROPS ApexDestructibleAsset

    DECLARE_CLASS(UApexDestructibleAsset,UApexAsset,0,Engine)
	public:
		/** Notification of the post load event. */
		virtual void                 PostLoad();

		/**** Serializes the asset
		* @param : Ar is a reference to the FArchive to either serialize from or to.
		*/
		virtual void                 Serialize(FArchive& Ar);

		/*** Returns the array of strings to display in the browser window */
		virtual TArray<FString>      GetGenericBrowserInfo();

		/*** This method is called when a generic asset is imported from an external file on disk.
		**
		** @param Buffer : A pointer to the raw data.
		** @param BufferSize : The length of the raw input data.
		** @param Name : The name of the asset which is being imported.
		**
		** @return : Returns true if the import was successful.
		**/
		UBOOL                        Import( const BYTE* Buffer, INT BufferSize, const FString& Name,UBOOL convertToUE3Coordinates );

		/*** Export asset to a file, in xml/bin format.
		**
		** @param Name: The name of file name for exported asset
		** @param isKeepUE3Coords: Export type, in original coords (true) or keep UE3 coords (false)
		** 
		**/
		virtual UBOOL Export(const FName& Name, UBOOL isKeepUE3Coords);

		/*** This method is called after a property has changed. */
		virtual void                 PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

		/** Fix up unique material names in the APEX asset after rename or duplication */
		virtual void PostRename();
		virtual void PostDuplicate();

		/** This method is called prior to the object being destroyed */
		virtual void                 BeginDestroy(void);

		/** Releases a destructible actor.
		** @param ApexDestructibleActor : The destructibe actor to release.
		** @param Component : The associated component to release.
		**/
		void                         ReleaseDestructibleActor( class       physx::apex::NxDestructibleActor     &ApexDestructibleActor,     class UApexComponentBase &Component);

		/** create an APEX destructible preview object.
		**
		** @param : ApexDestructiblePreviewDesc : A descriptor for the preview object.
		** @param : Component : A reference to the component being creaated.
		**
		** @return : Returns the destructible preview object if successful or a NULL pointer if it failed.
		**/
		physx::apex::NxDestructiblePreview *CreateDestructiblePreview(class UApexComponentBase &Component);

		/** Releases the previously created APEX destructible preview object.
		**
		** @param :	ApexDestructiblePreview : A reference to the previously created destructible preview object.
		** @param : Component : A reference to the component object.
		**/
		void                         ReleaseDestructiblePreview(physx::apex::NxDestructiblePreview     &ApexDestructiblePreview,     class UApexComponentBase &Component);

		/*** Returns the number of materials used by this asset */
		virtual UINT                GetNumMaterials(void) const { return Materials.Num();  }

		/*** Returns a particular material by index **/
		virtual UMaterialInterface *GetMaterial(UINT Index) const { return Materials(Index); }

		/** Returns the default ::NxParameterized::Interface for this asset. **/
		virtual void * 				GetNxParameterized(void);

		/** Returns a *copy* of the :NxParameterized::Interface for this asset. Caller must manually 'destroy' it.*/
		virtual void * GetAssetNxParameterized(void);

		/** Returns the APEX asset interface pointer for this object */
		class FIApexAsset * GetApexGenericAsset() const { return MApexAsset; }

		/** A method to update the APEX named resource pointers with individual materials assigned to this asset */
		void UpdateMaterials(void);

		virtual void NotifyApexEditMode(class ApexEditInterface *iface);		

		/** Whether the APEX asset's materials can be overridden in the actor's ApexComponent */
		virtual UBOOL SupportsMaterialOverride() const { return bHasUniqueAssetMaterialNames; }

		/** Update old assets. Only has an effect when called from the editor. */
		void FixupAsset();

	private:
};

struct ApexDestructibleActor_eventSpawnFractureEmitter_Parms
{
    class UParticleSystem* EmitterTemplate;
    FVector SpawnLocation;
    FVector SpawnDirection;
    ApexDestructibleActor_eventSpawnFractureEmitter_Parms(EEventParm)
    {
    }
};
class AApexDestructibleActor : public AActor
{
public:
    //## BEGIN PROPS ApexDestructibleActor
    class UDynamicLightEnvironmentComponent* LightEnvironment;
    BITFIELD bFractureMaterialOverride:1;
    BITFIELD bPlaySingleFractureMaterialEffect:1;
    TArrayNoInit<class UFractureMaterial*> FractureMaterials;
    class UApexStaticDestructibleComponent* StaticDestructibleComponent;
    INT LOD;
    TArray<BYTE> VisibilityFactors;
    TArrayNoInit<class USoundCue*> FractureSounds;
    TArrayNoInit<class UParticleSystem*> FractureParticleEffects;
    //## END PROPS ApexDestructibleActor

    virtual void CacheFractureEffects();
    virtual void TakeDamage(INT Damage,class AController* EventInstigator,FVector HitLocation,FVector Momentum,class UClass* DamageType,struct FTraceHitInfo HitInfo=FTraceHitInfo(EC_EventParm),class AActor* DamageCauser=NULL);
    virtual void TakeRadiusDamage(class AController* InstigatedBy,FLOAT BaseDamage,FLOAT DamageRadius,class UClass* DamageType,FLOAT Momentum,FVector HurtOrigin,UBOOL bFullDamage,class AActor* DamageCauser,FLOAT DamageFalloffExponent=1.000000);
    DECLARE_FUNCTION(execCacheFractureEffects)
    {
        P_FINISH;
        this->CacheFractureEffects();
    }
    DECLARE_FUNCTION(execTakeDamage)
    {
        P_GET_INT(Damage);
        P_GET_OBJECT(AController,EventInstigator);
        P_GET_STRUCT(FVector,HitLocation);
        P_GET_STRUCT(FVector,Momentum);
        P_GET_OBJECT(UClass,DamageType);
        P_GET_STRUCT_OPTX(struct FTraceHitInfo,HitInfo,FTraceHitInfo(EC_EventParm));
        P_GET_OBJECT_OPTX(AActor,DamageCauser,NULL);
        P_FINISH;
        this->TakeDamage(Damage,EventInstigator,HitLocation,Momentum,DamageType,HitInfo,DamageCauser);
    }
    DECLARE_FUNCTION(execTakeRadiusDamage)
    {
        P_GET_OBJECT(AController,InstigatedBy);
        P_GET_FLOAT(BaseDamage);
        P_GET_FLOAT(DamageRadius);
        P_GET_OBJECT(UClass,DamageType);
        P_GET_FLOAT(Momentum);
        P_GET_STRUCT(FVector,HurtOrigin);
        P_GET_UBOOL(bFullDamage);
        P_GET_OBJECT(AActor,DamageCauser);
        P_GET_FLOAT_OPTX(DamageFalloffExponent,1.000000);
        P_FINISH;
        this->TakeRadiusDamage(InstigatedBy,BaseDamage,DamageRadius,DamageType,Momentum,HurtOrigin,bFullDamage,DamageCauser,DamageFalloffExponent);
    }
    void eventSpawnFractureEmitter(class UParticleSystem* EmitterTemplate,FVector SpawnLocation,FVector SpawnDirection)
    {
        ApexDestructibleActor_eventSpawnFractureEmitter_Parms Parms(EC_EventParm);
        Parms.EmitterTemplate=EmitterTemplate;
        Parms.SpawnLocation=SpawnLocation;
        Parms.SpawnDirection=SpawnDirection;
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnFractureEmitter),&Parms);
    }
    DECLARE_CLASS(AApexDestructibleActor,AActor,0,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	// Function to check whether Actor still has chunks, if it doesn't destroy actor.
	virtual void TickAuthoritative( FLOAT DeltaSeconds );

	/** Synchronizes this actor to all rigid body components **/
	virtual void SyncActorToRBPhysics();

	/*** Sets the physics on this actor
	* @param NewPhysics : Use PHYS_None for a static destructible, PHYS_RigidBody for a dynamic destructible.
	* @param NewFloor   : Not used.
	* @param NewFloorV  : Not used.
	*/
	virtual void setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV);

	/** Process a property change event.
	*   @param PropertyThatChanged : The property value which changed
	*/
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** Process an edit move event.
	*
	* @param : bFinished : True if the move is complete.
	*/
	virtual void PostEditMove(UBOOL bFinished);

	/** Notification of the post load event. */
	virtual void PostLoad();

	/**
	 * Called by MirrorActors to perform a mirroring operation on the actor. Overridden since
	 * APEX destructible actors can't handle mirror transforms.
	 */
	virtual void EditorApplyMirror(const FVector& MirrorScale, const FVector& PivotLocation);

	/** Loads the editor parameters from the asset */
	void LoadEditorParametersFromAsset();

	/** Update old actors. Only has an effect when called from the editor. */
	void FixupActor();

	/** Spawn fracture effects at the given location & given direction for the given fracture depth. */
	void SpawnFractureEffects(FVector& Location, FVector& Direction, INT Depth);

	/** Customize Apex Destructible's physRigidBody so that it checks the collision with volumes. */
	virtual void physRigidBody(FLOAT DeltaTime);

	/** Overrides the damage for a DamageCauser, if such is specified
	*   @param BaseDamage:      Output base damage   
	*   @param DamageRadius:    Output damage radius
	*   @param Momentum:        Output momentum
	*   @param DamageCauser:	DamageCauser for the override lookup
	*/
	virtual void OverrideDamageParams(FLOAT& BaseDamage, FLOAT& DamageRadius, FLOAT& Momentum, const AActor* DamageCauser) const;

	// AActor interface
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);
};

class UFracturedBaseComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS FracturedBaseComponent
protected:
    class FFracturedBaseResources* ComponentBaseResources;
    FRenderCommandFence ReleaseResourcesFence;
    TArrayNoInit<BYTE> VisibleFragments;
    BITFIELD bVisibilityHasChanged:1;
    BITFIELD bVisibilityReset:1;
    BITFIELD bInitialVisibilityValue:1;
    BITFIELD bUseDynamicIndexBuffer:1;
    BITFIELD bUseDynamicIBWithHiddenFragments:1;
private:
    INT NumResourceIndices;
protected:
    INT bResetStaticMesh;
public:
    //## END PROPS FracturedBaseComponent

    virtual UBOOL SetStaticMesh(class UStaticMesh* NewMesh,UBOOL bForce=FALSE);
    virtual TArray<BYTE> GetVisibleFragments() const;
    virtual UBOOL IsFragmentVisible(INT FragmentIndex) const;
    virtual INT GetNumFragments() const;
    virtual INT GetNumVisibleFragments() const;
    DECLARE_FUNCTION(execGetVisibleFragments)
    {
        P_FINISH;
        *(TArray<BYTE>*)Result=this->GetVisibleFragments();
    }
    DECLARE_FUNCTION(execIsFragmentVisible)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(UBOOL*)Result=this->IsFragmentVisible(FragmentIndex);
    }
    DECLARE_FUNCTION(execGetNumFragments)
    {
        P_FINISH;
        *(INT*)Result=this->GetNumFragments();
    }
    DECLARE_FUNCTION(execGetNumVisibleFragments)
    {
        P_FINISH;
        *(INT*)Result=this->GetNumVisibleFragments();
    }
    DECLARE_ABSTRACT_CLASS(UFracturedBaseComponent,UStaticMeshComponent,0,Engine)
public:
	//UObject

	/** Blocks until the component's render resources have been released so that they can safely be modified */
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** 
	 * Signals to the object to begin asynchronously releasing resources
	 */
	virtual void BeginDestroy();

	/**
	 * Check for asynchronous resource cleanup completion
	 * @return	TRUE if the rendering resources have been released
	 */
	virtual UBOOL IsReadyForFinishDestroy();

	//Accessors
	INT GetNumVisibleTriangles() const;
	UBOOL GetInitialVisibilityValue() const;

protected:

	/**
	 * Called after all objects referenced by this object have been serialized. Order of PostLoad routed to 
	 * multiple objects loaded in one set is not deterministic though ConditionalPostLoad can be forced to
	 * ensure an object has been "PostLoad"ed.
	 */
	virtual void PostLoad();

	virtual void InitResources();
	virtual void ReleaseResources();
	void ReleaseBaseResources();

	/** Attaches the component to the scene, and initializes the component's resources if they have not been yet. */
	virtual void Attach();	

	/** Checks if the given fragment is visible. */
	virtual UBOOL IsElementFragmentVisible(INT ElementIndex, INT FragmentIndex, INT InteriorElementIndex, INT CoreFragmentIndex, UBOOL bAnyFragmentsHidden) const;

	/** 
	 * Updates the fragments of this component that are visible.  
	 * @param NewVisibleFragments - visibility factors for this component, corresponding to FracturedStaticMesh's Fragments array
	 * @param bForceUpdate - whether to update this component's resources even if no fragments have changed visibility
	 */
	virtual void UpdateVisibleFragments(const TArray<BYTE>& NewVisibleFragments, UBOOL bForceUpdate);

	/** 
	 * Resets VisibleFragments to bInitialVisibilityValue. 
	 * Does not cause a reattach, so the results won't be propagated to the render thread until the next reattach. 
	 */
	void ResetVisibility();

	/** 
	* Determine if the mesh currently has any hidden fragments
	* @return TRUE if >0 hidden fragments
	*/
	UBOOL HasHiddenFragments() const;

private:

	/** Enqueues a rendering command to update the component's dynamic index buffer. */
	void UpdateComponentIndexBuffer();

	friend class FFracturedBaseSceneProxy;
};

struct FFragmentGroup
{
    TArrayNoInit<INT> FragmentIndices;
    BITFIELD bGroupIsRooted:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FFragmentGroup() {}
    FFragmentGroup(EEventParm)
    {
        appMemzero(this, sizeof(FFragmentGroup));
    }
};

class UFracturedStaticMeshComponent : public UFracturedBaseComponent
{
public:
    //## BEGIN PROPS FracturedStaticMeshComponent
protected:
    TArrayNoInit<BYTE> FragmentNeighborsVisible;
    FBox VisibleBox;
    BITFIELD bUseSkinnedRendering:1;
public:
    BITFIELD bUseVisibleVertsForBounds:1;
    BITFIELD bTopFragmentsRootNonDestroyable:1;
    BITFIELD bBottomFragmentsRootNonDestroyable:1;
    FLOAT TopBottomFragmentDistThreshold;
    class UMaterialInterface* LoseChunkOutsideMaterialOverride;
    FLOAT FragmentBoundsMaxZ;
    FLOAT FragmentBoundsMinZ;
    class UFracturedSkinnedMeshComponent* SkinnedComponent;
    //## END PROPS FracturedStaticMeshComponent

    void SetVisibleFragments(const TArray<BYTE>& VisibilityFactors);
    UBOOL IsFragmentDestroyable(INT FragmentIndex) const;
    UBOOL IsRootFragment(INT FragmentIndex) const;
    UBOOL IsNoPhysFragment(INT FragmentIndex) const;
    FBox GetFragmentBox(INT FragmentIndex) const;
    FVector GetFragmentAverageExteriorNormal(INT FragmentIndex) const;
    INT GetCoreFragmentIndex() const;
    TArray<struct FFragmentGroup> GetFragmentGroups(const TArray<INT>& IgnoreFragments,FLOAT MinConnectionArea) const;
    TArray<INT> GetBoundaryHiddenFragments(const TArray<INT>& AdditionalVisibleFragments) const;
    void RecreatePhysState();
    class UPhysicalMaterial* GetFracturedMeshPhysMaterial();
    DECLARE_FUNCTION(execSetVisibleFragments)
    {
        P_GET_TARRAY(BYTE,VisibilityFactors);
        P_FINISH;
        this->SetVisibleFragments(VisibilityFactors);
    }
    DECLARE_FUNCTION(execIsFragmentDestroyable)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(UBOOL*)Result=this->IsFragmentDestroyable(FragmentIndex);
    }
    DECLARE_FUNCTION(execIsRootFragment)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(UBOOL*)Result=this->IsRootFragment(FragmentIndex);
    }
    DECLARE_FUNCTION(execIsNoPhysFragment)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(UBOOL*)Result=this->IsNoPhysFragment(FragmentIndex);
    }
    DECLARE_FUNCTION(execGetFragmentBox)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(FBox*)Result=this->GetFragmentBox(FragmentIndex);
    }
    DECLARE_FUNCTION(execGetFragmentAverageExteriorNormal)
    {
        P_GET_INT(FragmentIndex);
        P_FINISH;
        *(FVector*)Result=this->GetFragmentAverageExteriorNormal(FragmentIndex);
    }
    DECLARE_FUNCTION(execGetCoreFragmentIndex)
    {
        P_FINISH;
        *(INT*)Result=this->GetCoreFragmentIndex();
    }
    DECLARE_FUNCTION(execGetFragmentGroups)
    {
        P_GET_TARRAY(INT,IgnoreFragments);
        P_GET_FLOAT(MinConnectionArea);
        P_FINISH;
        *(TArray<struct FFragmentGroup>*)Result=this->GetFragmentGroups(IgnoreFragments,MinConnectionArea);
    }
    DECLARE_FUNCTION(execGetBoundaryHiddenFragments)
    {
        P_GET_TARRAY(INT,AdditionalVisibleFragments);
        P_FINISH;
        *(TArray<INT>*)Result=this->GetBoundaryHiddenFragments(AdditionalVisibleFragments);
    }
    DECLARE_FUNCTION(execRecreatePhysState)
    {
        P_FINISH;
        this->RecreatePhysState();
    }
    DECLARE_FUNCTION(execGetFracturedMeshPhysMaterial)
    {
        P_FINISH;
        *(class UPhysicalMaterial**)Result=this->GetFracturedMeshPhysMaterial();
    }
    DECLARE_CLASS(UFracturedStaticMeshComponent,UFracturedBaseComponent,0,Engine)
public:
	//UObject
	virtual void Serialize(FArchive& Ar);

	//UPrimitiveComponent
	virtual void UpdateBounds();
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual UBOOL LineCheck(FCheckResult& Result, const FVector& End, const FVector& Start, const FVector& Extent, DWORD TraceFlags);
	virtual UBOOL PointCheck(FCheckResult& Result,const FVector& Location,const FVector& Extent,DWORD TraceFlags);
	virtual void CookPhysConvexDataForScale(ULevel* Level, const FVector& TotalScale3D, INT& TriByteCount, INT& TriMeshCount, INT& HullByteCount, INT& HullCount);
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
	virtual void GenerateDecalRenderData(class FDecalState* Decal, TArray< FDecalRenderData* >& OutDecalRenderDatas) const;

	/** Allocates an implementation of FStaticLightingMesh that will handle static lighting for this component */
	virtual class FStaticMeshStaticLightingMesh* AllocateStaticLightingMesh(INT LODIndex, const TArray<ULightComponent*>& InRelevantLights);

protected:

	/** Attaches the component to the scene, and initializes the component's resources if they have not been yet. */
	virtual void Attach();

	/**
	* Detach the component from the scene and remove its render proxy
	* @param bWillReattach TRUE if the detachment will be followed by an attachment
	*/
	virtual void Detach( UBOOL bWillReattach = FALSE );

	/**
	* @return	FALSE since fractured geometry will handle its own decal detachment
	*/
	virtual UBOOL AllowDecalRemovalOnDetach() const
	{
		return FALSE;
	}

	/** 
	 * Retrieves the materials used in this component 
	 * 
	 * @param OutMaterials	The list of used materials.
	 */
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const;

	virtual void UpdateTransform();

	/** Update FragmentBoundsMin/MaxZ */
	void UpdateFragmentMinMaxZ();

	/** See if the bTopFragmentsSupportNonDestroyable/bBottomFragmentsSupportNonDestroyable flags indicate this chunk. */
	UBOOL FragmentInstanceIsSupportNonDestroyable(int FragmentIndex) const;

	/** Checks if the given fragment is visible. */
	virtual UBOOL IsElementFragmentVisible(INT ElementIndex, INT FragmentIndex, INT InteriorElementIndex, INT CoreFragmentIndex, UBOOL bAnyFragmentsHidden) const;

	/**
	 * Updates the fragments of this component that are visible.
	 * @param NewVisibleFragments - visibility factors for this component, corresponding to FracturedStaticMesh's Fragments array
	 * @param bForceUpdate - whether to update this component's resources even if no fragments have changed visibility
	 */
	virtual void UpdateVisibleFragments(const TArray<BYTE>& NewVisibleFragments, UBOOL bForceUpdate);

	friend class FFracturedStaticMeshSceneProxy;
};

struct FDeferredPartToSpawn
{
    INT ChunkIndex;
    FVector InitialVel;
    FVector InitialAngVel;
    FLOAT RelativeScale;
    BITFIELD bExplosion:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FDeferredPartToSpawn() {}
    FDeferredPartToSpawn(EEventParm)
    {
        appMemzero(this, sizeof(FDeferredPartToSpawn));
    }
};

struct FracturedStaticMeshActor_eventSetLoseChunkReplacementMaterial_Parms
{
    FracturedStaticMeshActor_eventSetLoseChunkReplacementMaterial_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventHideFragmentsToMaximizeMemoryUsage_Parms
{
    FracturedStaticMeshActor_eventHideFragmentsToMaximizeMemoryUsage_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventHideOneFragment_Parms
{
    FracturedStaticMeshActor_eventHideOneFragment_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventResetVisibility_Parms
{
    FracturedStaticMeshActor_eventResetVisibility_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventBreakOffPartsInRadius_Parms
{
    FVector Origin;
    FLOAT Radius;
    FLOAT RBStrength;
    UBOOL bWantPhysChunksAndParticles;
    FracturedStaticMeshActor_eventBreakOffPartsInRadius_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventExplode_Parms
{
    FracturedStaticMeshActor_eventExplode_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventSpawnDeferredParts_Parms
{
    UBOOL ReturnValue;
    FracturedStaticMeshActor_eventSpawnDeferredParts_Parms(EEventParm)
    {
    }
};
struct FracturedStaticMeshActor_eventBreakOffIsolatedIslands_Parms
{
    TArray<BYTE> FragmentVis;
    TArray<INT> IgnoreFrags;
    FVector ChunkDir;
    TArray<class AFracturedStaticMeshPart*> DisableCollWithPart;
    UBOOL bWantPhysChunks;
    FracturedStaticMeshActor_eventBreakOffIsolatedIslands_Parms(EEventParm)
    {
    }
};
class AFracturedStaticMeshActor : public AActor
{
public:
    //## BEGIN PROPS FracturedStaticMeshActor
    INT MaxPartsToSpawnAtOnce;
    class UFracturedStaticMeshComponent* FracturedStaticMeshComponent;
    class UFracturedSkinnedMeshComponent* SkinnedComponent;
    TArrayNoInit<INT> ChunkHealth;
    BITFIELD bHasShownMissingSoundWarning:1;
    BITFIELD bBreakChunksOnActorTouch:1;
    BITFIELD bShouldSaveForCheckpoint:1;
    TArrayNoInit<class UClass*> FracturedByDamageType;
    FLOAT ChunkHealthScale;
    TArrayNoInit<class UParticleSystem*> OverrideFragmentDestroyEffects;
    FLOAT FractureCullMinDistance;
    FLOAT FractureCullMaxDistance;
    TArrayNoInit<struct FDeferredPartToSpawn> DeferredPartsToSpawn;
    struct FPhysEffectInfo PartImpactEffect;
    class USoundCue* ExplosionFractureSound;
    class USoundCue* SingleChunkFractureSound;
    class UMaterialInterface* MI_LoseChunkPreviousMaterial;
    //## END PROPS FracturedStaticMeshActor

    class AFracturedStaticMeshPart* SpawnPart(INT ChunkIndex,FVector InitialVel,FVector InitialAngVel,FLOAT RelativeScale,UBOOL bExplosion);
    class AFracturedStaticMeshPart* SpawnPartMulti(const TArray<INT>& ChunkIndices,FVector InitialVel,FVector InitialAngVel,FLOAT RelativeScale,UBOOL bExplosion);
    void ResetHealth();
    virtual void BreakOffIsolatedIslands(TArray<BYTE>& FragmentVis,const TArray<INT>& IgnoreFrags,FVector ChunkDir,const TArray<class AFracturedStaticMeshPart*>& DisableCollWithPart,UBOOL bWantPhysChunks);
    virtual UBOOL SpawnDeferredParts();
    void RemoveDecals(INT IndexToRemoveDecalsFrom);
    virtual void BreakOffPartsInRadius(FVector Origin,FLOAT Radius,FLOAT RBStrength,UBOOL bWantPhysChunksAndParticles);
    virtual void ResetVisibility();
    DECLARE_FUNCTION(execSpawnPart)
    {
        P_GET_INT(ChunkIndex);
        P_GET_STRUCT(FVector,InitialVel);
        P_GET_STRUCT(FVector,InitialAngVel);
        P_GET_FLOAT(RelativeScale);
        P_GET_UBOOL(bExplosion);
        P_FINISH;
        *(class AFracturedStaticMeshPart**)Result=this->SpawnPart(ChunkIndex,InitialVel,InitialAngVel,RelativeScale,bExplosion);
    }
    DECLARE_FUNCTION(execSpawnPartMulti)
    {
        P_GET_TARRAY(INT,ChunkIndices);
        P_GET_STRUCT(FVector,InitialVel);
        P_GET_STRUCT(FVector,InitialAngVel);
        P_GET_FLOAT(RelativeScale);
        P_GET_UBOOL(bExplosion);
        P_FINISH;
        *(class AFracturedStaticMeshPart**)Result=this->SpawnPartMulti(ChunkIndices,InitialVel,InitialAngVel,RelativeScale,bExplosion);
    }
    DECLARE_FUNCTION(execResetHealth)
    {
        P_FINISH;
        this->ResetHealth();
    }
    DECLARE_FUNCTION(execBreakOffIsolatedIslands)
    {
        P_GET_TARRAY_REF(BYTE,FragmentVis);
        P_GET_TARRAY(INT,IgnoreFrags);
        P_GET_STRUCT(FVector,ChunkDir);
        P_GET_TARRAY(class AFracturedStaticMeshPart*,DisableCollWithPart);
        P_GET_UBOOL(bWantPhysChunks);
        P_FINISH;
        this->BreakOffIsolatedIslands(FragmentVis,IgnoreFrags,ChunkDir,DisableCollWithPart,bWantPhysChunks);
    }
    DECLARE_FUNCTION(execSpawnDeferredParts)
    {
        P_FINISH;
        *(UBOOL*)Result=this->SpawnDeferredParts();
    }
    DECLARE_FUNCTION(execRemoveDecals)
    {
        P_GET_INT(IndexToRemoveDecalsFrom);
        P_FINISH;
        this->RemoveDecals(IndexToRemoveDecalsFrom);
    }
    DECLARE_FUNCTION(execBreakOffPartsInRadius)
    {
        P_GET_STRUCT(FVector,Origin);
        P_GET_FLOAT(Radius);
        P_GET_FLOAT(RBStrength);
        P_GET_UBOOL(bWantPhysChunksAndParticles);
        P_FINISH;
        this->BreakOffPartsInRadius(Origin,Radius,RBStrength,bWantPhysChunksAndParticles);
    }
    DECLARE_FUNCTION(execResetVisibility)
    {
        P_FINISH;
        this->ResetVisibility();
    }
    void eventSetLoseChunkReplacementMaterial()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SetLoseChunkReplacementMaterial),NULL);
    }
    void eventHideFragmentsToMaximizeMemoryUsage()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_HideFragmentsToMaximizeMemoryUsage),NULL);
    }
    void eventHideOneFragment()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_HideOneFragment),NULL);
    }
    void eventResetVisibility()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ResetVisibility),NULL);
    }
    void eventBreakOffPartsInRadius(FVector Origin,FLOAT Radius,FLOAT RBStrength,UBOOL bWantPhysChunksAndParticles)
    {
        FracturedStaticMeshActor_eventBreakOffPartsInRadius_Parms Parms(EC_EventParm);
        Parms.Origin=Origin;
        Parms.Radius=Radius;
        Parms.RBStrength=RBStrength;
        Parms.bWantPhysChunksAndParticles=bWantPhysChunksAndParticles ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_BreakOffPartsInRadius),&Parms);
    }
    void eventExplode()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Explode),NULL);
    }
    UBOOL eventSpawnDeferredParts()
    {
        FracturedStaticMeshActor_eventSpawnDeferredParts_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnDeferredParts),&Parms);
        return Parms.ReturnValue;
    }
    void eventBreakOffIsolatedIslands(TArray<BYTE>& FragmentVis,const TArray<INT>& IgnoreFrags,FVector ChunkDir,const TArray<class AFracturedStaticMeshPart*>& DisableCollWithPart,UBOOL bWantPhysChunks)
    {
        FracturedStaticMeshActor_eventBreakOffIsolatedIslands_Parms Parms(EC_EventParm);
        Parms.FragmentVis=FragmentVis;
        Parms.IgnoreFrags=IgnoreFrags;
        Parms.ChunkDir=ChunkDir;
        Parms.DisableCollWithPart=DisableCollWithPart;
        Parms.bWantPhysChunks=bWantPhysChunks ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_BreakOffIsolatedIslands),&Parms);
        FragmentVis=Parms.FragmentVis;
    }
    DECLARE_CLASS(AFracturedStaticMeshActor,AActor,0,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual UBOOL InStasis();
};

class AFracturedStaticMeshPart : public AFracturedStaticMeshActor
{
public:
    //## BEGIN PROPS FracturedStaticMeshPart
    FLOAT DestroyPartRadiusFactor;
    class AFracturedStaticMeshActor* BaseFracturedMeshActor;
    BITFIELD bHasBeenRecycled:1;
    BITFIELD bChangeRBChannelWhenAsleep:1;
    BITFIELD bCompositeThatExplodesOnImpact:1;
    FLOAT LastSpawnTime;
    INT PartPoolIndex;
    FLOAT FracPartGravScale;
    BYTE AsleepRBChannel;
    SCRIPT_ALIGN;
    FVector OldVelocity;
    FLOAT CurrentVibrationLevel;
    FLOAT LastImpactSoundTime;
    //## END PROPS FracturedStaticMeshPart

    virtual void Initialize();
    virtual void RecyclePart(UBOOL bAddToFreePool);
    DECLARE_FUNCTION(execInitialize)
    {
        P_FINISH;
        this->Initialize();
    }
    DECLARE_FUNCTION(execRecyclePart)
    {
        P_GET_UBOOL(bAddToFreePool);
        P_FINISH;
        this->RecyclePart(bAddToFreePool);
    }
    DECLARE_CLASS(AFracturedStaticMeshPart,AFracturedStaticMeshActor,0,Engine)
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual FLOAT GetGravityZ();
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& MyInfo, const FRigidBodyCollisionInfo& OtherInfo, const FCollisionImpactData& RigidCollisionData);
#if WITH_NOVODEX
	virtual void ModifyNxActorDesc(NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp, const class NxGroupsMask& GroupsMask, UINT MatIndex);
	virtual void PostInitRigidBody(NxActor* nActor, NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp);
#endif // WITH_NOVODEX
};

#define UCONST_FSM_DEFAULTRECYCLETIME 0.2

struct FractureManager_eventReturnPartActor_Parms
{
    class AFracturedStaticMeshPart* Part;
    FractureManager_eventReturnPartActor_Parms(EEventParm)
    {
    }
};
struct FractureManager_eventSpawnPartActor_Parms
{
    class AFracturedStaticMeshActor* Parent;
    FVector SpawnLocation;
    FRotator SpawnRotation;
    class AFracturedStaticMeshPart* ReturnValue;
    FractureManager_eventSpawnPartActor_Parms(EEventParm)
    {
    }
};
struct FractureManager_eventSpawnChunkDestroyEffect_Parms
{
    class UParticleSystem* Effect;
    FBox ChunkBox;
    FVector ChunkDir;
    FLOAT Scale;
    FractureManager_eventSpawnChunkDestroyEffect_Parms(EEventParm)
    {
    }
};
class AFractureManager : public AActor
{
public:
    //## BEGIN PROPS FractureManager
    INT FSMPartPoolSize;
    BITFIELD bEnableAntiVibration:1;
    BITFIELD bEnableSpawnChunkEffectForRadialDamage:1;
    FLOAT DestroyVibrationLevel;
    FLOAT DestroyMinAngVel;
    FLOAT ExplosionVelScale;
    TArrayNoInit<class AFracturedStaticMeshPart*> PartPool;
    TArrayNoInit<INT> FreeParts;
    TArrayNoInit<class AFracturedStaticMeshActor*> ActorsWithDeferredPartsToSpawn;
    //## END PROPS FractureManager

    virtual FLOAT GetNumFSMPartsScale();
    virtual FLOAT GetFSMDirectSpawnChanceScale();
    virtual FLOAT GetFSMRadialSpawnChanceScale();
    virtual FLOAT GetFSMFractureCullDistanceScale();
    virtual void CreateFSMParts();
    virtual void ResetPoolVisibility();
    virtual class AFracturedStaticMeshPart* GetFSMPart(class AFracturedStaticMeshActor* Parent,FVector SpawnLocation,FRotator SpawnRotation);
    DECLARE_FUNCTION(execGetNumFSMPartsScale)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetNumFSMPartsScale();
    }
    DECLARE_FUNCTION(execGetFSMDirectSpawnChanceScale)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetFSMDirectSpawnChanceScale();
    }
    DECLARE_FUNCTION(execGetFSMRadialSpawnChanceScale)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetFSMRadialSpawnChanceScale();
    }
    DECLARE_FUNCTION(execGetFSMFractureCullDistanceScale)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetFSMFractureCullDistanceScale();
    }
    DECLARE_FUNCTION(execCreateFSMParts)
    {
        P_FINISH;
        this->CreateFSMParts();
    }
    DECLARE_FUNCTION(execResetPoolVisibility)
    {
        P_FINISH;
        this->ResetPoolVisibility();
    }
    DECLARE_FUNCTION(execGetFSMPart)
    {
        P_GET_OBJECT(AFracturedStaticMeshActor,Parent);
        P_GET_STRUCT(FVector,SpawnLocation);
        P_GET_STRUCT(FRotator,SpawnRotation);
        P_FINISH;
        *(class AFracturedStaticMeshPart**)Result=this->GetFSMPart(Parent,SpawnLocation,SpawnRotation);
    }
    void eventReturnPartActor(class AFracturedStaticMeshPart* Part)
    {
        FractureManager_eventReturnPartActor_Parms Parms(EC_EventParm);
        Parms.Part=Part;
        ProcessEvent(FindFunctionChecked(ENGINE_ReturnPartActor),&Parms);
    }
    class AFracturedStaticMeshPart* eventSpawnPartActor(class AFracturedStaticMeshActor* Parent,FVector SpawnLocation,FRotator SpawnRotation)
    {
        FractureManager_eventSpawnPartActor_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.Parent=Parent;
        Parms.SpawnLocation=SpawnLocation;
        Parms.SpawnRotation=SpawnRotation;
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnPartActor),&Parms);
        return Parms.ReturnValue;
    }
    void eventSpawnChunkDestroyEffect(class UParticleSystem* Effect,FBox ChunkBox,FVector ChunkDir,FLOAT Scale)
    {
        FractureManager_eventSpawnChunkDestroyEffect_Parms Parms(EC_EventParm);
        Parms.Effect=Effect;
        Parms.ChunkBox=ChunkBox;
        Parms.ChunkDir=ChunkDir;
        Parms.Scale=Scale;
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnChunkDestroyEffect),&Parms);
    }
    DECLARE_CLASS(AFractureManager,AActor,0,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	virtual void TickSpecial( FLOAT DeltaSeconds );
};

class AImageReflection : public AActor
{
public:
    //## BEGIN PROPS ImageReflection
    BITFIELD bEnabled:1;
    class UDEPRECATED_ImageReflectionComponent* ReflectionComponent_DEPRECATED;
    class UImageBasedReflectionComponent* ImageReflectionComponent;
    //## END PROPS ImageReflection

    DECLARE_CLASS(AImageReflection,AActor,0,Engine)
protected:
	virtual void PostLoad();
};

class AImageReflectionSceneCapture : public AImageReflection
{
public:
    //## BEGIN PROPS ImageReflectionSceneCapture
    FLOAT DepthRange;
    FLOAT ColorRange;
    //## END PROPS ImageReflectionSceneCapture

    DECLARE_CLASS(AImageReflectionSceneCapture,AImageReflection,0,Engine)
protected:
	virtual void PostDuplicate();
};

class AImageReflectionShadowPlane : public AActor
{
public:
    //## BEGIN PROPS ImageReflectionShadowPlane
    BITFIELD bEnabled:1;
    class UImageReflectionShadowPlaneComponent* ReflectionShadowComponent;
    //## END PROPS ImageReflectionShadowPlane

    DECLARE_CLASS(AImageReflectionShadowPlane,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AImageReflectionShadowPlane)
};

class UDEPRECATED_ImageReflectionComponent : public UActorComponent
{
public:
    //## BEGIN PROPS ImageReflectionComponent
    class UTexture2D* ReflectionTexture;
    //## END PROPS ImageReflectionComponent

    DECLARE_CLASS(UDEPRECATED_ImageReflectionComponent,UActorComponent,0|CLASS_Deprecated,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDEPRECATED_ImageReflectionComponent)
};

class UImageReflectionShadowPlaneComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS ImageReflectionShadowPlaneComponent
    BITFIELD bEnabled:1;
    SCRIPT_ALIGN;
    FPlane ReflectionPlane;
    //## END PROPS ImageReflectionShadowPlaneComponent

    void SetEnabled(UBOOL bSetEnabled);
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bSetEnabled);
        P_FINISH;
        this->SetEnabled(bSetEnabled);
    }
    DECLARE_CLASS(UImageReflectionShadowPlaneComponent,UPrimitiveComponent,0,Engine)
protected:
	// ActorComponent interface.
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );
};

class UApexComponentBase : public UMeshComponent
{
public:
    //## BEGIN PROPS ApexComponentBase
protected:
    class FApexBaseResources* ComponentBaseResources;
    FRenderCommandFence ReleaseResourcesFence;
public:
    class UApexAsset* Asset;
    FColor WireframeColor;
    BITFIELD bAssetChanged:1;
    SCRIPT_ALIGN;
    //## END PROPS ApexComponentBase

    DECLARE_CLASS(UApexComponentBase,UMeshComponent,0,Engine)
	public:
		virtual physx::apex::NxApexRenderable *GetApexRenderable(void) const { return 0; }
		
	protected:
		virtual void UpdateApexEditorState(UProperty* PropertyThatChanged = NULL) {}
		
	private:
		friend class UApexAsset;
		// Called when the Asset gets rebuilt (in editor only).
		virtual void OnApexAssetLost(void)  {  }
		virtual void OnApexAssetReset(void) {  }
		
	public:

		//UObject

		//UActorComponent
		virtual UBOOL IsValidComponent() const { return UMeshComponent::IsValidComponent(); }

		// UMeshComponent interface.
		virtual INT                 GetNumElements(void) const;
		virtual UMaterialInterface *GetMaterial(INT MaterialIndex) const;

		//UPrimitiveComponent
		virtual void UpdateTransform();
		virtual void UpdateBounds();
		virtual void InitComponentRBPhys(UBOOL bFixed);
		virtual void TermComponentRBPhys(FRBPhysScene *InScene);
		
		/**
		 * Called after all objects referenced by this object have been serialized. Order of PostLoad routed to 
		 * multiple objects loaded in one set is not deterministic though ConditionalPostLoad can be forced to
		 * ensure an object has been "PostLoad"ed.
		 */
		virtual void PostLoad();

		virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
		void         PostEditMove(UBOOL bFinished);

		/**
		 * Check for asynchronous resource cleanup completion
		 * @return	TRUE if the rendering resources have been released
		 */
		virtual UBOOL IsReadyForFinishDestroy();

	protected:
		/** Attaches the component to the scene, and initializes the component's resources if they have not been yet. */
		virtual void Attach();
		
		/** 
		* Detach the component from the scene and remove its render proxy 
		* @param bWillReattach TRUE if the detachment will be followed by an attachment
		*/
		virtual void Detach(UBOOL bWillReattach = FALSE);

		friend class FApexBaseSceneProxy;
};

class UApexDynamicComponent : public UApexComponentBase
{
public:
    //## BEGIN PROPS ApexDynamicComponent
protected:
    class FApexDynamicResources* ComponentDynamicResources;
public:
    //## END PROPS ApexDynamicComponent

    DECLARE_CLASS(UApexDynamicComponent,UApexComponentBase,0,Engine)
public:

protected:

	friend class FApexDynamicSceneProxy;
};

class UApexStaticComponent : public UApexComponentBase
{
public:
    //## BEGIN PROPS ApexStaticComponent
    //## END PROPS ApexStaticComponent

    DECLARE_CLASS(UApexStaticComponent,UApexComponentBase,0,Engine)
	public:
		//UObject
		/** Serializes this object
		*
		* @param : Ar the archive object to serialize into or out of.
		*/
		virtual void Serialize(FArchive& Ar);

		/*** Creates a primitive scene proxy for this object.
		*/
		virtual FPrimitiveSceneProxy* CreateSceneProxy();

	protected:
		/**
		* @return	FALSE since fractured geometry will handle its own decal detachment
		*/
		virtual UBOOL AllowDecalRemovalOnDetach() const
		{
			return FALSE;
		}

		friend class FApexStaticSceneProxy;
};

class UApexStaticDestructibleComponent : public UApexStaticComponent
{
public:
    //## BEGIN PROPS ApexStaticDestructibleComponent
    FLOAT SleepEnergyThreshold;
    FLOAT SleepDamping;
    physx::apex::NxDestructibleActor* ApexDestructibleActor;
    physx::apex::NxDestructiblePreview* ApexDestructiblePreview;
    BITFIELD bIsThumbnailComponent:1;
    SCRIPT_ALIGN;
    //## END PROPS ApexStaticDestructibleComponent

    DECLARE_CLASS(UApexStaticDestructibleComponent,UApexStaticComponent,0,Engine)
	protected:
		/** Internal function that updates physics objects to match the RBChannel/RBCollidesWithChannel info. */
		virtual void UpdatePhysicsToRBChannels();

		/** This method handles property changes to the component */
		virtual void UpdateApexEditorState(UProperty* PropertyThatChanged = NULL);

	public:
		/** This method returns the APEX renderable for this destructible component */
		virtual physx::apex::NxApexRenderable *GetApexRenderable(void) const;

		/** Performs a per-frame tick operation on the apex static destructible component */
		virtual void Tick(FLOAT DeltaTime);
		/** Returns true if the component is valid. */
		virtual UBOOL IsValidComponent() const;

		// PrimitiveComponent interface
		/** Performs a LineCheck against this component object.
		*  @param Result : a reference to an FCheckResults class that contains the results.
		*  @param End    : The end of the line check
		*  @param Start  : The start of the line check
		*  @param Extent : The extent of the line check
		*  @param TraceFlags : Defines a bit sequence of which objects are considered for the line check.
		*
		*  @return : Returns TRUE if the LineCheck hit.
		**/
		virtual UBOOL LineCheck(FCheckResult& Result, const FVector& End, const FVector& Start, const FVector& Extent, DWORD TraceFlags);

		/** Performs a single Point inside/outside check against this component.
		*  @param Result : a reference to an FCheckResults class that contains the results.
		*  @param Location : The point location to check against.
		*  @param Extent : The extent of the point check
		*  @param TraceFlags : Defines a bit sequence of which objects are considered for the point check.
		*
		*  @return : Returns TRUE if the point hit the component.
		**/
		virtual UBOOL PointCheck(FCheckResult& Result,const FVector& Location,const FVector& Extent,DWORD TraceFlags);

		/** Initializes the rigid body physics components of this object.
		*
		* @param : bFixed : indicates whether or not the object is fixed
		**/
		virtual void  InitComponentRBPhys(UBOOL bFixed);

		/** Terminates the rigid body components in this object
		*
		* @param InScene : A pointer to the rigid body physics scene.
		**/
		virtual void  TermComponentRBPhys(FRBPhysScene *InScene);

		// StaticMeshComponent interface
		/*** Cooks the convex hull data for this object at a specific scale.
		*
		* @param Level : A pointer to the ULevel this object is contained within.
		* @param TotalScale3D : The scale this object is being cooked for.
		* @param TriByteCount : Reference returns the number of bytes the trianngle data takes.
		* @param TriMeshCount : A reference which returns the number of triangles meshes created
		* @param HullByteCount : A reference which returns the number of bytes the convex hull took up.
		* @param HullCount : A reference which returns the number of hulls which were created.
		*
		**/
		virtual void  CookPhysConvexDataForScale(ULevel* Level, const FVector& TotalScale3D, INT& TriByteCount, INT& TriMeshCount, INT& HullByteCount, INT& HullCount);

		// We will release the ApexRenderable in the destroying phase
		virtual void BeginDestroy();

		virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

		virtual void SetMaterial(int ElementIndex, UMaterialInterface* Material);

		virtual void UpdateRBKinematicData();
	private:
		/***
		* Called when the asset is lost or reset
		**/
		virtual void OnApexAssetLost(void);
		virtual void OnApexAssetReset(void);
};

class UFracturedSkinnedMeshComponent : public UFracturedBaseComponent
{
public:
    //## BEGIN PROPS FracturedSkinnedMeshComponent
protected:
    class FFracturedSkinResources* ComponentSkinResources;
    TArrayNoInit<FMatrix> FragmentTransforms;
    TArrayNoInit<class UFracturedStaticMeshComponent*> DependentComponents;
    BITFIELD bBecameVisible:1;
    BITFIELD bFragmentTransformsChanged:1;
    SCRIPT_ALIGN;
public:
    //## END PROPS FracturedSkinnedMeshComponent

    DECLARE_CLASS(UFracturedSkinnedMeshComponent,UFracturedBaseComponent,0,Engine)
public:
	//UPrimitiveComponent
	virtual void UpdateBounds();
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual UBOOL ShouldRecreateProxyOnUpdateTransform() const;

	/* Sets the visiblity of a single fragment, and starts a deferred reattach if visiblity changed. */
	void SetFragmentVisibility(INT FragmentIndex, UBOOL bVisibility);

	/* Updates the transform of a single fragment. */
	void SetFragmentTransform(INT FragmentIndex, const FMatrix& LocalToWorld);

	/* Adds a dependent component whose visibility will affect this component's visibility. */
	void RegisterDependentComponent(UFracturedStaticMeshComponent* InComponent);

	/* Removes a dependent component whose visibility will affect this component's visibility. */
	void RemoveDependentComponent(UFracturedStaticMeshComponent* InComponent);

	/** Static: Updates the GPU with bone matrices for this skinned fractured mesh */
	static void UpdateDynamicBoneData_RenderThread(FFracturedSkinResources* ComponentSkinResources, const TArray<FMatrix>& FragmentTransforms);

protected:

	virtual void InitResources();
	virtual void ReleaseResources();
	void ReleaseSkinResources();

	/** Attaches the component to the scene, and initializes the component's resources if they have not been yet. */
	virtual void Attach();

	virtual void UpdateTransform();

	friend class FFracturedSkinnedMeshSceneProxy;
};

class UImageBasedReflectionComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS ImageBasedReflectionComponent
    BITFIELD bEnabled:1;
    BITFIELD bTwoSided:1;
    class UTexture2D* ReflectionTexture;
    FLinearColor ReflectionColor;
    //## END PROPS ImageBasedReflectionComponent

    void SetEnabled(UBOOL bSetEnabled);
    void UpdateImageReflectionParameters();
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bSetEnabled);
        P_FINISH;
        this->SetEnabled(bSetEnabled);
    }
    DECLARE_FUNCTION(execUpdateImageReflectionParameters)
    {
        P_FINISH;
        this->UpdateImageReflectionParameters();
    }
    DECLARE_CLASS(UImageBasedReflectionComponent,UStaticMeshComponent,0,Engine)
protected:
	// ActorComponent interface.
	virtual UBOOL IsValidComponent() const { return ReflectionTexture != NULL; }
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );
	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

struct FInstancedStaticMeshInstanceData
{
    FMatrix Transform;
    FVector2D LightmapUVBias;
    FVector2D ShadowmapUVBias;

		// Serialization
		friend FArchive& operator<<(FArchive& Ar, FInstancedStaticMeshInstanceData& InstanceData)
		{
			// @warning BulkSerialize: FInstancedStaticMeshInstanceData is serialized as memory dump
			// See TArray::BulkSerialize for detailed description of implied limitations.
			Ar << InstanceData.Transform << InstanceData.LightmapUVBias << InstanceData.ShadowmapUVBias;
			return Ar;
		}
	
};

struct FInstancedStaticMeshMappingInfo
{
    class FInstancedStaticMeshStaticLightingTextureMapping* Mapping;
    class FInstancedLightMap2D* LightMap;
    class UTexture2D* LightmapTexture;
    class UShadowMap2D* ShadowmapTexture;

    /** Constructors */
    FInstancedStaticMeshMappingInfo() {}
    FInstancedStaticMeshMappingInfo(EEventParm)
    {
        appMemzero(this, sizeof(FInstancedStaticMeshMappingInfo));
    }
};

class UInstancedStaticMeshComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS InstancedStaticMeshComponent
    TArrayNoInit<struct FInstancedStaticMeshInstanceData> PerInstanceData_DEPRECATED;
    TArrayNoInit<struct FInstancedStaticMeshInstanceData> PerInstanceSMData;
    INT NumPendingLightmaps;
    INT ComponentJoinKey;
    TArrayNoInit<struct FInstancedStaticMeshMappingInfo> CachedMappings;
    INT InstancingRandomSeed;
    INT InstanceStartCullDistance;
    INT InstanceEndCullDistance;
#if WITH_EDITORONLY_DATA
    TBitArray<> SelectedInstances;
#endif // WITH_EDITORONLY_DATA
    BITFIELD bDontResolveInstancedLightmaps:1;
    SCRIPT_ALIGN;
    //## END PROPS InstancedStaticMeshComponent

    DECLARE_CLASS(UInstancedStaticMeshComponent,UStaticMeshComponent,0,Engine)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
	virtual void GetStaticLightingInfo(FStaticLightingPrimitiveInfo& OutPrimitiveInfo,const TArray<ULightComponent*>& InRelevantLights,const FLightingBuildOptions& Options);

	void UpdateInstances();
	void ApplyAllMappings();
	
	static TSet<AActor*> ActorsWithInstancedComponents;
	static void ResolveInstancedLightmaps(UBOOL bWasLightingSuccessful, UBOOL bIgnoreTextureForBatching=FALSE);
	static void ResolveInstancedLightmapsForActor(AActor* InActor, UBOOL bWasLightingSuccessful, UBOOL bIgnoreTextureForBatching=FALSE);

	virtual void GetLightAndShadowMapMemoryUsage( INT& LightMapMemoryUsage, INT& ShadowMapMemoryUsage ) const;

	/**
	 * Serialize function.
	 *
	 * @param	Ar	Archive to serialize with
	 */
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns whether or not this component is instanced.
	 *
	 * @return	TRUE if this component represents multiple instances of a primitive.
	 */
	virtual UBOOL IsPrimitiveInstanced() const
	{
		return TRUE;
	}

	/**
	 * For instanced components, returns the number of instances.
	 *
	 * @return	Number of instances
	 */
	virtual INT GetInstanceCount() const
	{
		return PerInstanceSMData.Num();
	}

	/**
	 * Returns whether this primitive should render selection.
	 */
	virtual UBOOL ShouldRenderSelected() const
	{
		return UPrimitiveComponent::ShouldRenderSelected()
#if WITH_EDITORONLY_DATA
		// Also render selected if we have an array of selected instances
		|| SelectedInstances.Num() > 0
#endif
		;
	}

	/**
	 * For instanced components, returns the Local -> World transform for the specific instance number.
	 * If the function is called on non-instanced components, the component's LocalToWorld will be returned.
	 * You should override this method in derived classes that support instancing.
	 *
	 * @param	InInstanceIndex	The index of the instance to return the Local -> World transform for
	 *
	 * @return	Number of instances
	 */
	virtual const FMatrix GetInstanceLocalToWorld( INT InInstanceIndex ) const
	{
		return PerInstanceSMData( InInstanceIndex ).Transform * LocalToWorld;
	}

	virtual void InitComponentRBPhys(UBOOL bFixed);


#if STATS
	/**
	 * Called after all objects referenced by this object have been serialized. Order of PostLoad routed to 
	 * multiple objects loaded in one set is not deterministic though ConditionalPostLoad can be forced to
	 * ensure an object has been "PostLoad"ed.
	 */
	virtual void PostLoad();

	/**
	 * Informs object of pending destruction via GC.
	 */
	void BeginDestroy();

	/**
	 * Attaches the component to a ParentToWorld transform, owner and scene.
	 * Requires IsValidComponent() == true.
	 */
	virtual void Attach();

	/**
	 * Detaches the component from the scene it is in.
	 * Requires bAttached == true
	 *
	 * @param bWillReattach TRUE is passed if Attach will be called immediately afterwards.  This can be used to
	 *                      preserve state between reattachments.
	 */
	virtual void Detach( UBOOL bWillReattach = FALSE );
#endif
};

struct FSplineMeshParams
{
    FVector StartPos;
    FVector StartTangent;
    FVector2D StartScale;
    FLOAT StartRoll;
    FVector2D StartOffset;
    FVector EndPos;
    FVector EndTangent;
    FVector2D EndScale;
    FLOAT EndRoll;
    FVector2D EndOffset;

    /** Constructors */
    FSplineMeshParams() {}
    FSplineMeshParams(EEventParm)
    {
        appMemzero(this, sizeof(FSplineMeshParams));
    }
};

class USplineMeshComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS SplineMeshComponent
    struct FSplineMeshParams SplineParams;
    FVector SplineXDir;
    BITFIELD bSmoothInterpRollScale:1;
    SCRIPT_ALIGN;
    //## END PROPS SplineMeshComponent

    DECLARE_CLASS(USplineMeshComponent,UStaticMeshComponent,0,Engine)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();

	virtual UBOOL PointCheck(FCheckResult& Result,const FVector& Location,const FVector& Extent,DWORD TraceFlags);
	virtual UBOOL LineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);


	/** Allocates an implementation of FStaticLightingMesh that will handle static lighting for this component */
	virtual class FStaticMeshStaticLightingMesh* AllocateStaticLightingMesh(INT LODIndex, const TArray<ULightComponent*>& InRelevantLights);

	/** Calculates the spline transform, including roll, scale, and offset along the spline at a specified distance */
	FMatrix CalcSliceTransform(const USplineComponent* SplineComp, const FLOAT DistanceAlong);
};

struct FClothingLodInfo
{
    TArray<INT> LODMaterialMap;

    /** Constructors */
    FClothingLodInfo() {}
    FClothingLodInfo(EEventParm)
    {
        appMemzero(this, sizeof(FClothingLodInfo));
    }
};

class UApexClothingAsset : public UApexAsset
{
public:
    //## BEGIN PROPS ApexClothingAsset
    TArrayNoInit<struct FClothingLodInfo> LodMaterialInfo;
    class FIApexAsset* MApexAsset;
    TArrayNoInit<class UMaterialInterface*> Materials;
    class UApexGenericAsset* ApexClothingLibrary_DEPRECATED;
    BITFIELD bUseHardwareCloth:1;
    BITFIELD bFallbackSkinning:1;
    BITFIELD bSlowStart:1;
    BITFIELD bRecomputeNormals:1;
    BITFIELD bAllowAdaptiveTargetFrequency:1;
    BITFIELD bResetAfterTeleport:1;
    BITFIELD bUseLocalSpaceSimulation:1;
    BITFIELD bHasUniqueAssetMaterialNames:1;
    BITFIELD IgnoreInitialTrigger:1;
    INT UVChannelForTangentUpdate;
    FLOAT MaxDistanceBlendTime;
    FLOAT ContinuousRotationThreshold;
    FLOAT ContinuousDistanceThreshold;
    FLOAT LodWeightsMaxDistance;
    FLOAT LodWeightsDistanceWeight;
    FLOAT LodWeightsBias;
    FLOAT LodWeightsBenefitsBias;
    FLOAT LODDecayTime;
    class USoundCue* SoundOnMove;
    class USoundCue* SoundOnRest;
    class USoundCue* SoundWhileMoving;
    FLOAT SpeedThresholdOnMove;
    FLOAT SpeedThresholdOnRest;
    //## END PROPS ApexClothingAsset

    DECLARE_CLASS(UApexClothingAsset,UApexAsset,0,Engine)
	public:
		/** Notification of the post load event. */
		virtual void                 PostLoad();

		/**** Serializes the asset
		* @param : Ar is a reference to the FArchive to either serialize from or to.
		*/
		virtual void                 Serialize(FArchive& Ar);

		/*** Returns the array of strings to display in the browser window */
		virtual TArray<FString>      GetGenericBrowserInfo();

		/*** This method is called when a generic asset is imported from an external file on disk.
		**
		** @param Buffer : A pointer to the raw data.
		** @param BufferSize : The length of the raw input data.
		** @param Name : The name of the asset which is being imported.
		**
		** @return : Returns true if the import was successful.
		**/
		UBOOL                        Import( const BYTE* Buffer, INT BufferSize, const FString& Name,UBOOL convertToUE3Coordinates );

		/*** Export asset to a file, in xml/bin format.
		**
		** @param Name: The name of file name for exported asset
		** @param isKeepUE3Coords: Export type, in original coords (true) or keep UE3 coords (false)
		** 
		**/
		virtual UBOOL Export(const FName& Name, UBOOL isKeepUE3Coords);


		/*** This method is called after a property has changed. */
		virtual void                 PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

		/** Fix up unique material names in the APEX asset after rename or duplication */
		virtual void PostRename();
		virtual void PostDuplicate();

		/** This method is called prior to the object being destroyed */
		virtual void                 BeginDestroy(void);

		/*** This method is called when the asset is renamed
		**
		** @param : InName : The new name of the object
		** @param : NewOuter : The new outer object (package) for this object.
		** @param : Flags : The ERenameFlags to honor.
		**
		** @return : Returns TRUE if the rename was successful
		**/
		virtual UBOOL Rename( const TCHAR* NewName=NULL, UObject* NewOuter=NULL, ERenameFlags Flags=REN_None );

	   	/** virtual method to return the number of materials used by this asset */
		virtual UINT                GetNumMaterials(void) const 
		{ 
#if WITH_EDITORONLY_DATA
			return Materials.Num();  
#else
			return 0;
#endif // WITH_EDITORONLY_DATA
		}
		/** Returns the default ::NxParameterized::Interface for this asset. */
		virtual UMaterialInterface* GetMaterial(UINT Index) const 
		{ 
#if WITH_EDITORONLY_DATA
			return Materials(Index); 
#else
			return NULL;
#endif // WITH_EDITORONLY_DATA
		}

		/** Returns the default ::NxParameterized::Interface for this object */
		virtual void * GetNxParameterized(void);

		/** Returns a *copy* of the :NxParameterized::Interface for this asset. Caller must manually 'destroy' it.*/
		virtual void * GetAssetNxParameterized(void);

		/** Interface to ApexGenericAsset */
		class FIApexAsset * GetApexGenericAsset() const { return MApexAsset; }

		/** Re-assigns the APEX material resources by name with the current array of UE3 materials */
		void UpdateMaterials(void);
		virtual void NotifyApexEditMode(class ApexEditInterface *iface);

		/** Whether the APEX asset's materials can be overridden */
		virtual UBOOL SupportsMaterialOverride() const { return bHasUniqueAssetMaterialNames; }
		
	private:
};

class UApexGenericAsset : public UApexAsset
{
public:
    //## BEGIN PROPS ApexGenericAsset
    class FIApexAsset* MApexAsset;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class UMaterialInterface*> Materials;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS ApexGenericAsset

    DECLARE_CLASS(UApexGenericAsset,UApexAsset,0,Engine)
	public:
		/**** Serializes the asset
		* @param : Ar is a reference to the FArchive to either serialize from or to.
		*/
		virtual void                 Serialize(FArchive& Ar);

		/*** Returns the array of strings to display in the browser window */
		virtual TArray<FString>      GetGenericBrowserInfo();
		
		/*** This method is called when a generic asset is imported from an external file on disk.
		**
		** @param Buffer : A pointer to the raw data.
		** @param BufferSize : The length of the raw input data.
		** @param Name : The name of the asset which is being imported.
		**
		** @return : Returns true if the import was successful.
		**/
		UBOOL                        Import( const BYTE* Buffer, INT BufferSize, const FString& Name );

		/*** This method is called after a property has changed. */
		virtual void                 PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

		/** This method is called prior to the object being destroyed */
		virtual void                 BeginDestroy(void);

		/*** This method is called when the asset is renamed
		**
		** @param : InName : The new name of the object
		** @param : NewOuter : The new outer object (package) for this object.
		** @param : Flags : The ERenameFlags to honor.
		**
		** @return : Returns TRUE if the rename was successful
		**/
		virtual UBOOL Rename( const TCHAR* NewName=NULL, UObject* NewOuter=NULL, ERenameFlags Flags=REN_None );

		/** Returns the default ::NxParameterized::Interface for this object */
		virtual void * GetNxParameterized(void);
		/** Returns a *copy* of the :NxParameterized::Interface for this asset. Caller must manually 'destroy' it.*/
		virtual void * GetAssetNxParameterized(void);
		
		/**
		* Returns a one line description of an object for viewing in the thumbnail view of the generic browser
		*/
		virtual FString GetDesc( void );
		
		virtual void CreateDefaultAssetType(INT t,class UApexGenericAsset *parent);
		
	   	/** virtual method to return the number of materials used by this asset */
		virtual UINT                GetNumMaterials(void) const 
		{ 
#if WITH_EDITORONLY_DATA
			return Materials.Num();  
#else
			return 0;
#endif // WITH_EDITORONLY_DATA
		}
		/** Returns the default ::NxParameterized::Interface for this asset. */
		virtual UMaterialInterface* GetMaterial(UINT Index) const 
		{ 
#if WITH_EDITORONLY_DATA
			return Materials(Index); 
#else
			return NULL;
#endif // WITH_EDITORONLY_DATA
		}
		/** Re-assigns the APEX material resources by name with the current array of UE3 materials */
		void UpdateMaterials(void);
		virtual void NotifyApexEditMode(class ApexEditInterface *iface);
		
		/** Returns the pointer to the FIApexAsset interface */
		class FIApexAsset * GetApexGenericAsset() const { return MApexAsset; }


	private:
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_MESH_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AApexDestructibleActor,-1,execTakeRadiusDamage);
AUTOGENERATE_FUNCTION(AApexDestructibleActor,-1,execTakeDamage);
AUTOGENERATE_FUNCTION(AApexDestructibleActor,-1,execCacheFractureEffects);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execResetVisibility);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execBreakOffPartsInRadius);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execRemoveDecals);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execSpawnDeferredParts);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execBreakOffIsolatedIslands);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execResetHealth);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execSpawnPartMulti);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshActor,-1,execSpawnPart);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshPart,-1,execRecyclePart);
AUTOGENERATE_FUNCTION(AFracturedStaticMeshPart,-1,execInitialize);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetFSMPart);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execResetPoolVisibility);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execCreateFSMParts);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetFSMFractureCullDistanceScale);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetFSMRadialSpawnChanceScale);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetFSMDirectSpawnChanceScale);
AUTOGENERATE_FUNCTION(AFractureManager,-1,execGetNumFSMPartsScale);
AUTOGENERATE_FUNCTION(UImageReflectionShadowPlaneComponent,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execGetNumVisibleFragments);
AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execGetNumFragments);
AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execIsFragmentVisible);
AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execGetVisibleFragments);
AUTOGENERATE_FUNCTION(UFracturedBaseComponent,-1,execSetStaticMesh);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetFracturedMeshPhysMaterial);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execRecreatePhysState);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetBoundaryHiddenFragments);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetFragmentGroups);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetCoreFragmentIndex);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetFragmentAverageExteriorNormal);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execGetFragmentBox);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execIsNoPhysFragment);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execIsRootFragment);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execIsFragmentDestroyable);
AUTOGENERATE_FUNCTION(UFracturedStaticMeshComponent,-1,execSetVisibleFragments);
AUTOGENERATE_FUNCTION(UImageBasedReflectionComponent,-1,execUpdateImageReflectionParameters);
AUTOGENERATE_FUNCTION(UImageBasedReflectionComponent,-1,execSetEnabled);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_MESH_NATIVE_DEFS
#define ENGINE_MESH_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_MESH \
	AApexDestructibleActor::StaticClass(); \
	GNativeLookupFuncs.Set(FName("ApexDestructibleActor"), GEngineAApexDestructibleActorNatives); \
	AFracturedStaticMeshActor::StaticClass(); \
	GNativeLookupFuncs.Set(FName("FracturedStaticMeshActor"), GEngineAFracturedStaticMeshActorNatives); \
	AFracturedStaticMeshPart::StaticClass(); \
	GNativeLookupFuncs.Set(FName("FracturedStaticMeshPart"), GEngineAFracturedStaticMeshPartNatives); \
	AFractureManager::StaticClass(); \
	GNativeLookupFuncs.Set(FName("FractureManager"), GEngineAFractureManagerNatives); \
	AImageReflection::StaticClass(); \
	AImageReflectionSceneCapture::StaticClass(); \
	AImageReflectionShadowPlane::StaticClass(); \
	UDEPRECATED_ImageReflectionComponent::StaticClass(); \
	UPrimitiveComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PrimitiveComponent"), GEngineUPrimitiveComponentNatives); \
	UImageReflectionShadowPlaneComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("ImageReflectionShadowPlaneComponent"), GEngineUImageReflectionShadowPlaneComponentNatives); \
	UMeshComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MeshComponent"), GEngineUMeshComponentNatives); \
	UApexComponentBase::StaticClass(); \
	UApexDynamicComponent::StaticClass(); \
	UApexStaticComponent::StaticClass(); \
	UApexStaticDestructibleComponent::StaticClass(); \
	UStaticMeshComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("StaticMeshComponent"), GEngineUStaticMeshComponentNatives); \
	UFracturedBaseComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("FracturedBaseComponent"), GEngineUFracturedBaseComponentNatives); \
	UFracturedSkinnedMeshComponent::StaticClass(); \
	UFracturedStaticMeshComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("FracturedStaticMeshComponent"), GEngineUFracturedStaticMeshComponentNatives); \
	UImageBasedReflectionComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("ImageBasedReflectionComponent"), GEngineUImageBasedReflectionComponentNatives); \
	UInstancedStaticMeshComponent::StaticClass(); \
	USplineMeshComponent::StaticClass(); \
	UApexAsset::StaticClass(); \
	UApexClothingAsset::StaticClass(); \
	UApexDestructibleAsset::StaticClass(); \
	UApexGenericAsset::StaticClass(); \

#endif // ENGINE_MESH_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineAApexDestructibleActorNatives[] = 
{ 
	MAP_NATIVE(AApexDestructibleActor, execTakeRadiusDamage)
	MAP_NATIVE(AApexDestructibleActor, execTakeDamage)
	MAP_NATIVE(AApexDestructibleActor, execCacheFractureEffects)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAFracturedStaticMeshActorNatives[] = 
{ 
	MAP_NATIVE(AFracturedStaticMeshActor, execResetVisibility)
	MAP_NATIVE(AFracturedStaticMeshActor, execBreakOffPartsInRadius)
	MAP_NATIVE(AFracturedStaticMeshActor, execRemoveDecals)
	MAP_NATIVE(AFracturedStaticMeshActor, execSpawnDeferredParts)
	MAP_NATIVE(AFracturedStaticMeshActor, execBreakOffIsolatedIslands)
	MAP_NATIVE(AFracturedStaticMeshActor, execResetHealth)
	MAP_NATIVE(AFracturedStaticMeshActor, execSpawnPartMulti)
	MAP_NATIVE(AFracturedStaticMeshActor, execSpawnPart)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAFracturedStaticMeshPartNatives[] = 
{ 
	MAP_NATIVE(AFracturedStaticMeshPart, execRecyclePart)
	MAP_NATIVE(AFracturedStaticMeshPart, execInitialize)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAFractureManagerNatives[] = 
{ 
	MAP_NATIVE(AFractureManager, execGetFSMPart)
	MAP_NATIVE(AFractureManager, execResetPoolVisibility)
	MAP_NATIVE(AFractureManager, execCreateFSMParts)
	MAP_NATIVE(AFractureManager, execGetFSMFractureCullDistanceScale)
	MAP_NATIVE(AFractureManager, execGetFSMRadialSpawnChanceScale)
	MAP_NATIVE(AFractureManager, execGetFSMDirectSpawnChanceScale)
	MAP_NATIVE(AFractureManager, execGetNumFSMPartsScale)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUPrimitiveComponentNatives[] = 
{ 
	MAP_NATIVE(UPrimitiveComponent, execClosestPointOnComponentToComponent)
	MAP_NATIVE(UPrimitiveComponent, execClosestPointOnComponentToPoint)
	MAP_NATIVE(UPrimitiveComponent, execGetRotation)
	MAP_NATIVE(UPrimitiveComponent, execGetPosition)
	MAP_NATIVE(UPrimitiveComponent, execSetAbsolute)
	MAP_NATIVE(UPrimitiveComponent, execSetScale3D)
	MAP_NATIVE(UPrimitiveComponent, execSetScale)
	MAP_NATIVE(UPrimitiveComponent, execSetRotation)
	MAP_NATIVE(UPrimitiveComponent, execSetTranslation)
	MAP_NATIVE(UPrimitiveComponent, execSetActorCollision)
	MAP_NATIVE(UPrimitiveComponent, execSetTraceBlocking)
	MAP_NATIVE(UPrimitiveComponent, execSetViewOwnerDepthPriorityGroup)
	MAP_NATIVE(UPrimitiveComponent, execSetDepthPriorityGroup)
	MAP_NATIVE(UPrimitiveComponent, execSetLightingChannels)
	MAP_NATIVE(UPrimitiveComponent, execSetCullDistance)
	MAP_NATIVE(UPrimitiveComponent, execSetLightEnvironment)
	MAP_NATIVE(UPrimitiveComponent, execSetShadowParent)
	MAP_NATIVE(UPrimitiveComponent, execSetIgnoreOwnerHidden)
	MAP_NATIVE(UPrimitiveComponent, execSetOnlyOwnerSee)
	MAP_NATIVE(UPrimitiveComponent, execSetOwnerNoSee)
	MAP_NATIVE(UPrimitiveComponent, execSetHidden)
	MAP_NATIVE(UPrimitiveComponent, execShouldComponentAddToScene)
	MAP_NATIVE(UPrimitiveComponent, execSetRBDominanceGroup)
	MAP_NATIVE(UPrimitiveComponent, execGetRootBodyInstance)
	MAP_NATIVE(UPrimitiveComponent, execSetPhysMaterialOverride)
	MAP_NATIVE(UPrimitiveComponent, execInitRBPhys)
	MAP_NATIVE(UPrimitiveComponent, execSetNotifyRigidBodyCollision)
	MAP_NATIVE(UPrimitiveComponent, execSetRBChannel)
	MAP_NATIVE(UPrimitiveComponent, execSetRBCollisionChannels)
	MAP_NATIVE(UPrimitiveComponent, execSetRBCollidesWithChannel)
	MAP_NATIVE(UPrimitiveComponent, execSetBlockRigidBody)
	MAP_NATIVE(UPrimitiveComponent, execRigidBodyIsAwake)
	MAP_NATIVE(UPrimitiveComponent, execPutRigidBodyToSleep)
	MAP_NATIVE(UPrimitiveComponent, execWakeRigidBody)
	MAP_NATIVE(UPrimitiveComponent, execSetRBRotation)
	MAP_NATIVE(UPrimitiveComponent, execSetRBPosition)
	MAP_NATIVE(UPrimitiveComponent, execRetardRBLinearVelocity)
	MAP_NATIVE(UPrimitiveComponent, execSetRBAngularVelocity)
	MAP_NATIVE(UPrimitiveComponent, execSetRBLinearVelocity)
	MAP_NATIVE(UPrimitiveComponent, execAddTorque)
	MAP_NATIVE(UPrimitiveComponent, execAddRadialForce)
	MAP_NATIVE(UPrimitiveComponent, execAddForce)
	MAP_NATIVE(UPrimitiveComponent, execAddRadialImpulse)
	MAP_NATIVE(UPrimitiveComponent, execAddImpulse)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUImageReflectionShadowPlaneComponentNatives[] = 
{ 
	MAP_NATIVE(UImageReflectionShadowPlaneComponent, execSetEnabled)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMeshComponentNatives[] = 
{ 
	MAP_NATIVE(UMeshComponent, execPrestreamTextures)
	MAP_NATIVE(UMeshComponent, execGetNumElements)
	MAP_NATIVE(UMeshComponent, execSetMaterial)
	MAP_NATIVE(UMeshComponent, execGetMaterial)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUStaticMeshComponentNatives[] = 
{ 
	MAP_NATIVE(UStaticMeshComponent, execCanBecomeDynamic)
	MAP_NATIVE(UStaticMeshComponent, execSetForceStaticDecals)
	MAP_NATIVE(UStaticMeshComponent, execDisableRBCollisionWithSMC)
	MAP_NATIVE(UStaticMeshComponent, execSetStaticMesh)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUFracturedBaseComponentNatives[] = 
{ 
	MAP_NATIVE(UFracturedBaseComponent, execGetNumVisibleFragments)
	MAP_NATIVE(UFracturedBaseComponent, execGetNumFragments)
	MAP_NATIVE(UFracturedBaseComponent, execIsFragmentVisible)
	MAP_NATIVE(UFracturedBaseComponent, execGetVisibleFragments)
	MAP_NATIVE(UFracturedBaseComponent, execSetStaticMesh)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUFracturedStaticMeshComponentNatives[] = 
{ 
	MAP_NATIVE(UFracturedStaticMeshComponent, execGetFracturedMeshPhysMaterial)
	MAP_NATIVE(UFracturedStaticMeshComponent, execRecreatePhysState)
	MAP_NATIVE(UFracturedStaticMeshComponent, execGetBoundaryHiddenFragments)
	MAP_NATIVE(UFracturedStaticMeshComponent, execGetFragmentGroups)
	MAP_NATIVE(UFracturedStaticMeshComponent, execGetCoreFragmentIndex)
	MAP_NATIVE(UFracturedStaticMeshComponent, execGetFragmentAverageExteriorNormal)
	MAP_NATIVE(UFracturedStaticMeshComponent, execGetFragmentBox)
	MAP_NATIVE(UFracturedStaticMeshComponent, execIsNoPhysFragment)
	MAP_NATIVE(UFracturedStaticMeshComponent, execIsRootFragment)
	MAP_NATIVE(UFracturedStaticMeshComponent, execIsFragmentDestroyable)
	MAP_NATIVE(UFracturedStaticMeshComponent, execSetVisibleFragments)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUImageBasedReflectionComponentNatives[] = 
{ 
	MAP_NATIVE(UImageBasedReflectionComponent, execUpdateImageReflectionParameters)
	MAP_NATIVE(UImageBasedReflectionComponent, execSetEnabled)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(AApexDestructibleActor,ApexDestructibleActor,LightEnvironment)
VERIFY_CLASS_OFFSET_NODIE(AApexDestructibleActor,ApexDestructibleActor,FractureParticleEffects)
VERIFY_CLASS_SIZE_NODIE(AApexDestructibleActor)
VERIFY_CLASS_OFFSET_NODIE(AFracturedStaticMeshActor,FracturedStaticMeshActor,MaxPartsToSpawnAtOnce)
VERIFY_CLASS_OFFSET_NODIE(AFracturedStaticMeshActor,FracturedStaticMeshActor,MI_LoseChunkPreviousMaterial)
VERIFY_CLASS_SIZE_NODIE(AFracturedStaticMeshActor)
VERIFY_CLASS_OFFSET_NODIE(AFracturedStaticMeshPart,FracturedStaticMeshPart,DestroyPartRadiusFactor)
VERIFY_CLASS_OFFSET_NODIE(AFracturedStaticMeshPart,FracturedStaticMeshPart,LastImpactSoundTime)
VERIFY_CLASS_SIZE_NODIE(AFracturedStaticMeshPart)
VERIFY_CLASS_OFFSET_NODIE(AFractureManager,FractureManager,FSMPartPoolSize)
VERIFY_CLASS_OFFSET_NODIE(AFractureManager,FractureManager,ActorsWithDeferredPartsToSpawn)
VERIFY_CLASS_SIZE_NODIE(AFractureManager)
VERIFY_CLASS_OFFSET_NODIE(AImageReflection,ImageReflection,ReflectionComponent_DEPRECATED)
VERIFY_CLASS_OFFSET_NODIE(AImageReflection,ImageReflection,ImageReflectionComponent)
VERIFY_CLASS_SIZE_NODIE(AImageReflection)
VERIFY_CLASS_OFFSET_NODIE(AImageReflectionSceneCapture,ImageReflectionSceneCapture,DepthRange)
VERIFY_CLASS_OFFSET_NODIE(AImageReflectionSceneCapture,ImageReflectionSceneCapture,ColorRange)
VERIFY_CLASS_SIZE_NODIE(AImageReflectionSceneCapture)
VERIFY_CLASS_OFFSET_NODIE(AImageReflectionShadowPlane,ImageReflectionShadowPlane,ReflectionShadowComponent)
VERIFY_CLASS_SIZE_NODIE(AImageReflectionShadowPlane)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_ImageReflectionComponent,ImageReflectionComponent,ReflectionTexture)
VERIFY_CLASS_SIZE_NODIE(UDEPRECATED_ImageReflectionComponent)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,Tag)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,Bounds)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,SceneInfo)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,DetachFence)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,LocalToWorldDeterminant)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,LocalToWorld)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,MotionBlurInfoIndex)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,DecalList)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,DecalsToReattach)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,ShadowParent)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,ReplacementPrimitive)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,FogVolumeComponent)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,OverrideLightComponent)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,LightEnvironment)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,PreviousLightEnvironment)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,MinDrawDistance)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,MassiveLODDistance)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,CachedMaxDrawDistance)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,MotionBlurInstanceScale)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,CachedCullDistance_DEPRECATED)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,DepthPriorityGroup)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,ViewOwnerDepthPriorityGroup)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,DetailMode)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,RBChannel)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,RBDominanceGroup)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,PreviewEnvironmentShadowing)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,OctreeNodes)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,TranslucencySortPriority)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,VisibilityId)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,LightingChannels)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,RBCollideWithChannels)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,PhysMaterialOverride)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,BodyInstance)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,CachedParentToWorld)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,Translation)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,Rotation)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,Scale)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,Scale3D)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,BoundsScale)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,LastSubmitTime)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,LastRenderTime)
VERIFY_CLASS_OFFSET_NODIE(UPrimitiveComponent,PrimitiveComponent,ScriptRigidBodyCollisionThreshold)
VERIFY_CLASS_SIZE_NODIE(UPrimitiveComponent)
VERIFY_CLASS_OFFSET_NODIE(UImageReflectionShadowPlaneComponent,ImageReflectionShadowPlaneComponent,ReflectionPlane)
VERIFY_CLASS_SIZE_NODIE(UImageReflectionShadowPlaneComponent)
VERIFY_CLASS_OFFSET_NODIE(UMeshComponent,MeshComponent,Materials)
VERIFY_CLASS_SIZE_NODIE(UMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(UApexComponentBase,ApexComponentBase,ComponentBaseResources)
VERIFY_CLASS_OFFSET_NODIE(UApexComponentBase,ApexComponentBase,WireframeColor)
VERIFY_CLASS_SIZE_NODIE(UApexComponentBase)
VERIFY_CLASS_OFFSET_NODIE(UApexDynamicComponent,ApexDynamicComponent,ComponentDynamicResources)
VERIFY_CLASS_SIZE_NODIE(UApexDynamicComponent)
VERIFY_CLASS_SIZE_NODIE(UApexStaticComponent)
VERIFY_CLASS_OFFSET_NODIE(UApexStaticDestructibleComponent,ApexStaticDestructibleComponent,SleepEnergyThreshold)
VERIFY_CLASS_OFFSET_NODIE(UApexStaticDestructibleComponent,ApexStaticDestructibleComponent,ApexDestructiblePreview)
VERIFY_CLASS_SIZE_NODIE(UApexStaticDestructibleComponent)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,ForcedLodModel)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,PreviousLODLevel)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,WireframeColor)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,OverriddenLightMapResolution_DEPRECATED)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,OverriddenLightMapRes)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,OverriddenLODMaxRange)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,StreamingDistanceMultiplier)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,SubDivisionStepSize)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,SimpleLightmapModificationTexture)
#endif
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,SimpleLightmapModificationFunction)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,IrrelevantLights)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,LODData)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,VertexPositionVersionNumber)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponent,StaticMeshComponent,LightmassSettings)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(UFracturedBaseComponent,FracturedBaseComponent,ComponentBaseResources)
VERIFY_CLASS_OFFSET_NODIE(UFracturedBaseComponent,FracturedBaseComponent,bResetStaticMesh)
VERIFY_CLASS_SIZE_NODIE(UFracturedBaseComponent)
VERIFY_CLASS_OFFSET_NODIE(UFracturedSkinnedMeshComponent,FracturedSkinnedMeshComponent,ComponentSkinResources)
VERIFY_CLASS_OFFSET_NODIE(UFracturedSkinnedMeshComponent,FracturedSkinnedMeshComponent,DependentComponents)
VERIFY_CLASS_SIZE_NODIE(UFracturedSkinnedMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(UFracturedStaticMeshComponent,FracturedStaticMeshComponent,FragmentNeighborsVisible)
VERIFY_CLASS_OFFSET_NODIE(UFracturedStaticMeshComponent,FracturedStaticMeshComponent,SkinnedComponent)
VERIFY_CLASS_SIZE_NODIE(UFracturedStaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(UImageBasedReflectionComponent,ImageBasedReflectionComponent,ReflectionTexture)
VERIFY_CLASS_OFFSET_NODIE(UImageBasedReflectionComponent,ImageBasedReflectionComponent,ReflectionColor)
VERIFY_CLASS_SIZE_NODIE(UImageBasedReflectionComponent)
VERIFY_CLASS_OFFSET_NODIE(UInstancedStaticMeshComponent,InstancedStaticMeshComponent,PerInstanceData_DEPRECATED)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInstancedStaticMeshComponent,InstancedStaticMeshComponent,SelectedInstances)
#else
VERIFY_CLASS_OFFSET_NODIE(UInstancedStaticMeshComponent,InstancedStaticMeshComponent,InstanceEndCullDistance)
#endif
VERIFY_CLASS_SIZE_NODIE(UInstancedStaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(USplineMeshComponent,SplineMeshComponent,SplineParams)
VERIFY_CLASS_OFFSET_NODIE(USplineMeshComponent,SplineMeshComponent,SplineXDir)
VERIFY_CLASS_SIZE_NODIE(USplineMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(UApexAsset,ApexAsset,OriginalApexName)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UApexAsset,ApexAsset,SourceFileTimestamp)
#else
VERIFY_CLASS_OFFSET_NODIE(UApexAsset,ApexAsset,ApexComponents)
#endif
VERIFY_CLASS_SIZE_NODIE(UApexAsset)
VERIFY_CLASS_OFFSET_NODIE(UApexClothingAsset,ApexClothingAsset,LodMaterialInfo)
VERIFY_CLASS_OFFSET_NODIE(UApexClothingAsset,ApexClothingAsset,SpeedThresholdOnRest)
VERIFY_CLASS_SIZE_NODIE(UApexClothingAsset)
VERIFY_CLASS_OFFSET_NODIE(UApexDestructibleAsset,ApexDestructibleAsset,MApexAsset)
VERIFY_CLASS_OFFSET_NODIE(UApexDestructibleAsset,ApexDestructibleAsset,DestructibleParameters)
VERIFY_CLASS_SIZE_NODIE(UApexDestructibleAsset)
VERIFY_CLASS_OFFSET_NODIE(UApexGenericAsset,ApexGenericAsset,MApexAsset)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UApexGenericAsset,ApexGenericAsset,Materials)
#endif
VERIFY_CLASS_SIZE_NODIE(UApexGenericAsset)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
