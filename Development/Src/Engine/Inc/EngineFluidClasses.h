/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_FLUID_ENUMS
#define INCLUDED_ENGINE_FLUID_ENUMS 1

enum EInfluenceType
{
    Fluid_Flow              =0,
    Fluid_Raindrops         =1,
    Fluid_Wave              =2,
    Fluid_Sphere            =3,
    Fluid_MAX               =4,
};
#define FOREACH_ENUM_EINFLUENCETYPE(op) \
    op(Fluid_Flow) \
    op(Fluid_Raindrops) \
    op(Fluid_Wave) \
    op(Fluid_Sphere) 

#endif // !INCLUDED_ENGINE_FLUID_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_FLUID_CLASSES
#define INCLUDED_ENGINE_FLUID_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UFluidSurfaceComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS FluidSurfaceComponent
    class UMaterialInterface* FluidMaterial;
    INT LightMapResolution;
    FLightmassPrimitiveSettings LightmassSettings;
    BITFIELD EnableSimulation:1;
    BITFIELD EnableDetail:1;
    BITFIELD bTiling:1;
    BITFIELD bPause:1;
    BITFIELD bShowSimulationNormals:1;
    BITFIELD bShowSimulationPosition:1;
    BITFIELD bShowDetailNormals:1;
    BITFIELD bShowDetailPosition:1;
    BITFIELD bShowFluidSimulation:1;
    BITFIELD bShowFluidDetail:1;
    BITFIELD bTestRipple:1;
    BITFIELD bTestRippleCenterOnDetail:1;
    INT SimulationQuadsX;
    INT SimulationQuadsY;
    FLOAT GridSpacing;
    FLOAT GridSpacingLowRes;
    class AActor* TargetSimulation;
    FLOAT GPUTessellationFactor;
    FLOAT FluidDamping;
    FLOAT FluidTravelSpeed;
    FLOAT FluidHeightScale;
    FLOAT FluidUpdateRate;
    FLOAT ForceImpact;
    FLOAT ForceContinuous;
    FLOAT LightingContrast;
    class AActor* TargetDetail;
    FLOAT DeactivationDistance;
    INT DetailResolution;
    FLOAT DetailSize;
    FLOAT DetailDamping;
    FLOAT DetailTravelSpeed;
    FLOAT DetailTransfer;
    FLOAT DetailHeightScale;
    FLOAT DetailUpdateRate;
    FLOAT NormalLength;
    FLOAT TestRippleSpeed;
    FLOAT TestRippleFrequency;
    FLOAT TestRippleRadius;
    FLOAT FluidWidth;
    FLOAT FluidHeight;
    FLOAT TestRippleTime;
    FLOAT TestRippleAngle;
    FLOAT DeactivationTimer;
    FLOAT ViewDistance;
    FVector SimulationPosition;
    FVector DetailPosition;
    TArrayNoInit<BYTE> ClampMap;
    TArrayNoInit<class UShadowMap2D*> ShadowMaps;
    FLightMapRef LightMap;
    class FFluidSimulation* FluidSimulation;
    //## END PROPS FluidSurfaceComponent

    void ApplyForce(FVector WorldPos,FLOAT Strength,FLOAT Radius,UBOOL bImpulse=FALSE);
    void SetDetailPosition(FVector WorldPos);
    void SetSimulationPosition(FVector WorldPos);
    DECLARE_FUNCTION(execApplyForce)
    {
        P_GET_STRUCT(FVector,WorldPos);
        P_GET_FLOAT(Strength);
        P_GET_FLOAT(Radius);
        P_GET_UBOOL_OPTX(bImpulse,FALSE);
        P_FINISH;
        this->ApplyForce(WorldPos,Strength,Radius,bImpulse);
    }
    DECLARE_FUNCTION(execSetDetailPosition)
    {
        P_GET_STRUCT(FVector,WorldPos);
        P_FINISH;
        this->SetDetailPosition(WorldPos);
    }
    DECLARE_FUNCTION(execSetSimulationPosition)
    {
        P_GET_STRUCT(FVector,WorldPos);
        P_FINISH;
        this->SetSimulationPosition(WorldPos);
    }
    DECLARE_CLASS(UFluidSurfaceComponent,UPrimitiveComponent,0,Engine)
public:
	UFluidSurfaceComponent();

	UMaterialInterface*		GetMaterial() const;
	FMaterialViewRelevance	GetMaterialViewRelevance() const;
	const class FFluidGPUResource* GetFluidGPUResource() const;					
	void					InitResources( UBOOL bActive );
	void					ReleaseResources( UBOOL bBlockOnRelease );
	void					RebuildClampMap();
	void					OnScaleChange();

	// Base class interfaces.
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void			Serialize(FArchive& Ar);
	virtual void			AddReferencedObjects(TArray<UObject*>& ObjectArray);
	virtual void			UpdateBounds();
	virtual void			Attach();
	virtual void			Detach( UBOOL bWillReattach );
	virtual void			PreEditChange(UProperty* PropertyAboutToChange);
	virtual void			PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void			BeginDestroy();
	virtual UBOOL			IsReadyForFinishDestroy();
	virtual void			FinishDestroy();
	virtual void			Tick(FLOAT DeltaTime);
	virtual UBOOL			LineCheck(FCheckResult& Result, const FVector& End, const FVector& Start, const FVector& Extent, DWORD TraceFlags);
	virtual UBOOL			PointCheck(FCheckResult& Result,const FVector& Location,const FVector& Extent,DWORD TraceFlags);
	virtual void			InvalidateLightingCache();

	/** 
	 * Retrieves the materials used in this component 
	 * 
	 * @param OutMaterials	The list of used materials.
	 */
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const;

	/**
	 * Returns the lightmap resolution used for this primivite instnace in the case of it supporting texture light/ shadow maps.
	 * 0 if not supported or no static shadowing.
	 *
	 * @param	Width	[out]	Width of light/shadow map
	 * @param	Height	[out]	Height of light/shadow map
	 *
	 * @return	UBOOL			TRUE if LightMap values are padded, FALSE if not
	 */
	virtual UBOOL			GetLightMapResolution( INT& Width, INT& Height ) const;
	virtual INT				GetStaticLightMapResolution() const;
	virtual void			GetLightAndShadowMapMemoryUsage( INT& LightMapMemoryUsage, INT& ShadowMapMemoryUsage ) const;
	virtual void			GetStaticLightingInfo(FStaticLightingPrimitiveInfo& OutPrimitiveInfo,const TArray<ULightComponent*>& InRelevantLights,const FLightingBuildOptions& Options);
	virtual ELightMapInteractionType GetStaticLightingType() const	{ return LMIT_Texture;	}
	/** Gets the emissive boost for the primitive component. */
	virtual FLOAT			GetEmissiveBoost(INT ElementIndex) const;
	/** Gets the diffuse boost for the primitive component. */
	virtual FLOAT			GetDiffuseBoost(INT ElementIndex) const;
	/** Gets the specular boost for the primitive component. */
	virtual FLOAT			GetSpecularBoost(INT ElementIndex) const;
	virtual void			GetStreamingTextureInfo(TArray<FStreamingTexturePrimitiveInfo>& OutStreamingTextures) const;

private:
	UBOOL					PropertyNeedsResourceRecreation(UProperty* Property);
	void					UpdateMemory(FLOAT DeltaTime);

	/**
	 *	Calculates the distance from the fluid's edge to the specified position.
	 *	@param WorldPosition	A world-space position to measure the distance to.
	 *	@return					Distance from the fluid's edge to the specified position, or 0 if it's inside the fluid.
	 */
	FLOAT					CalcDistance( const FVector& WorldPosition );
};

class AFluidSurfaceActor : public AActor
{
public:
    //## BEGIN PROPS FluidSurfaceActor
    class UFluidSurfaceComponent* FluidComponent;
    class UParticleSystem* ProjectileEntryEffect;
    //## END PROPS FluidSurfaceActor

    DECLARE_CLASS(AFluidSurfaceActor,AActor,0,Engine)
	// UObject interface.
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// AActor interface.
	virtual void PostEditImport();
	virtual void PostEditMove(UBOOL bFinished);
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual UBOOL IsAFluidSurface() const					{ return TRUE; }
	virtual class AFluidSurfaceActor* GetAFluidSurface()	{ return this; }

#if WITH_EDITOR
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
#endif
};

class UFluidInfluenceComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS FluidInfluenceComponent
    BITFIELD bActive:1;
    BITFIELD RaindropFillEntireFluid:1;
    BITFIELD bIsToggleTriggered:1;
    class AFluidSurfaceActor* FluidActor;
    BYTE InfluenceType;
    FLOAT MaxDistance;
    FLOAT WaveStrength;
    FLOAT WaveFrequency;
    FLOAT WavePhase;
    FLOAT WaveRadius;
    FLOAT RaindropAreaRadius;
    FLOAT RaindropRadius;
    FLOAT RaindropStrength;
    FLOAT RaindropRate;
    FLOAT FlowSpeed;
    INT FlowNumRipples;
    FLOAT FlowSideMotionRadius;
    FLOAT FlowWaveRadius;
    FLOAT FlowStrength;
    FLOAT FlowFrequency;
    FLOAT SphereOuterRadius;
    FLOAT SphereInnerRadius;
    FLOAT SphereStrength;
    FLOAT CurrentAngle;
    FLOAT CurrentTimer;
    class AFluidSurfaceActor* CurrentFluidActor;
    //## END PROPS FluidInfluenceComponent

    DECLARE_CLASS(UFluidInfluenceComponent,UPrimitiveComponent,0,Engine)
public:
	// Base class interfaces
	virtual void	PostLoad( );
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void	UpdateBounds( );
	virtual void	Tick( FLOAT DeltaTime );

	// Influence functions
	void			UpdateFlow( FLOAT DeltaSeconds );
	void			UpdateRaindrops( FLOAT DeltaSeconds );
	void			UpdateWave( FLOAT DeltaSeconds );
	void			UpdateSphere( FLOAT DeltaSeconds );
	void			CheckSettings( UBOOL bUpdateIcon );
	UBOOL			IsTouching( AFluidSurfaceActor* Fluid );
};

class AFluidInfluenceActor : public AActor
{
public:
    //## BEGIN PROPS FluidInfluenceActor
    class UArrowComponent* FlowDirection;
    class USpriteComponent* Sprite;
    class UFluidInfluenceComponent* InfluenceComponent;
    BITFIELD bActive:1;
    BITFIELD bToggled:1;
    SCRIPT_ALIGN;
    //## END PROPS FluidInfluenceActor

    DECLARE_CLASS(AFluidInfluenceActor,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AFluidInfluenceActor)
};

class AFluidSurfaceActorMovable : public AFluidSurfaceActor
{
public:
    //## BEGIN PROPS FluidSurfaceActorMovable
    //## END PROPS FluidSurfaceActorMovable

    DECLARE_CLASS(AFluidSurfaceActorMovable,AFluidSurfaceActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AFluidSurfaceActorMovable)
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_FLUID_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UFluidSurfaceComponent,-1,execSetSimulationPosition);
AUTOGENERATE_FUNCTION(UFluidSurfaceComponent,-1,execSetDetailPosition);
AUTOGENERATE_FUNCTION(UFluidSurfaceComponent,-1,execApplyForce);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_FLUID_NATIVE_DEFS
#define ENGINE_FLUID_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_FLUID \
	AFluidInfluenceActor::StaticClass(); \
	AFluidSurfaceActor::StaticClass(); \
	AFluidSurfaceActorMovable::StaticClass(); \
	UFluidInfluenceComponent::StaticClass(); \
	UFluidSurfaceComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("FluidSurfaceComponent"), GEngineUFluidSurfaceComponentNatives); \

#endif // ENGINE_FLUID_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineUFluidSurfaceComponentNatives[] = 
{ 
	MAP_NATIVE(UFluidSurfaceComponent, execSetSimulationPosition)
	MAP_NATIVE(UFluidSurfaceComponent, execSetDetailPosition)
	MAP_NATIVE(UFluidSurfaceComponent, execApplyForce)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(AFluidInfluenceActor,FluidInfluenceActor,FlowDirection)
VERIFY_CLASS_OFFSET_NODIE(AFluidInfluenceActor,FluidInfluenceActor,InfluenceComponent)
VERIFY_CLASS_SIZE_NODIE(AFluidInfluenceActor)
VERIFY_CLASS_OFFSET_NODIE(AFluidSurfaceActor,FluidSurfaceActor,FluidComponent)
VERIFY_CLASS_OFFSET_NODIE(AFluidSurfaceActor,FluidSurfaceActor,ProjectileEntryEffect)
VERIFY_CLASS_SIZE_NODIE(AFluidSurfaceActor)
VERIFY_CLASS_SIZE_NODIE(AFluidSurfaceActorMovable)
VERIFY_CLASS_OFFSET_NODIE(UFluidInfluenceComponent,FluidInfluenceComponent,FluidActor)
VERIFY_CLASS_OFFSET_NODIE(UFluidInfluenceComponent,FluidInfluenceComponent,CurrentFluidActor)
VERIFY_CLASS_SIZE_NODIE(UFluidInfluenceComponent)
VERIFY_CLASS_OFFSET_NODIE(UFluidSurfaceComponent,FluidSurfaceComponent,FluidMaterial)
VERIFY_CLASS_OFFSET_NODIE(UFluidSurfaceComponent,FluidSurfaceComponent,FluidSimulation)
VERIFY_CLASS_SIZE_NODIE(UFluidSurfaceComponent)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
