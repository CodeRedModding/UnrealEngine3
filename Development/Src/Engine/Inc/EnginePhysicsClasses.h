/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_PHYSICS_ENUMS
#define INCLUDED_ENGINE_PHYSICS_ENUMS 1

enum EWorldAttractorFalloffType
{
    FOFF_Constant           =0,
    FOFF_Linear             =1,
    FOFF_Exponent           =2,
    FOFF_MAX                =3,
};
#define FOREACH_ENUM_EWORLDATTRACTORFALLOFFTYPE(op) \
    op(FOFF_Constant) \
    op(FOFF_Linear) \
    op(FOFF_Exponent) 
enum EDamageParameterOverrideMode
{
    DPOM_Absolute           =0,
    DPOM_Multiplier         =1,
    DPOM_MAX                =2,
};
#define FOREACH_ENUM_EDAMAGEPARAMETEROVERRIDEMODE(op) \
    op(DPOM_Absolute) \
    op(DPOM_Multiplier) 
enum ESleepFamily
{
    SF_Normal               =0,
    SF_Sensitive            =1,
    SF_MAX                  =2,
};
#define FOREACH_ENUM_ESLEEPFAMILY(op) \
    op(SF_Normal) \
    op(SF_Sensitive) 
enum EPhysEffectType
{
    EPMET_Impact            =0,
    EPMET_Slide             =1,
    EPMET_MAX               =2,
};
#define FOREACH_ENUM_EPHYSEFFECTTYPE(op) \
    op(EPMET_Impact) \
    op(EPMET_Slide) 
enum EWheelSide
{
    SIDE_None               =0,
    SIDE_Left               =1,
    SIDE_Right              =2,
    SIDE_MAX                =3,
};
#define FOREACH_ENUM_EWHEELSIDE(op) \
    op(SIDE_None) \
    op(SIDE_Left) \
    op(SIDE_Right) 

#endif // !INCLUDED_ENGINE_PHYSICS_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_PHYSICS_CLASSES
#define INCLUDED_ENGINE_PHYSICS_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct KActor_eventApplyImpulse_Parms
{
    FVector ImpulseDir;
    FLOAT ImpulseMag;
    FVector HitLocation;
    struct FTraceHitInfo HitInfo;
    class UClass* DamageType;
    KActor_eventApplyImpulse_Parms(EEventParm)
    {
    }
};
class AKActor : public ADynamicSMActor
{
public:
    //## BEGIN PROPS KActor
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bWakeOnLevelStart:1;
    BITFIELD bCurrentSlide:1;
    BITFIELD bSlideActive:1;
    BITFIELD bEnableStayUprightSpring:1;
    BITFIELD bLimitMaxPhysicsVelocity:1;
    BITFIELD bNeedsRBStateReplication:1;
    BITFIELD bDisableClientSidePawnInteractions:1;
    class UParticleSystemComponent* ImpactEffectComponent;
    class UAudioComponent* ImpactSoundComponent;
    class UAudioComponent* ImpactSoundComponent2;
    FLOAT LastImpactTime;
    struct FPhysEffectInfo ImpactEffectInfo;
    class UParticleSystemComponent* SlideEffectComponent;
    class UAudioComponent* SlideSoundComponent;
    FLOAT LastSlideTime;
    struct FPhysEffectInfo SlideEffectInfo;
    FLOAT StayUprightTorqueFactor;
    FLOAT StayUprightMaxTorque;
    FLOAT MaxPhysicsVelocity;
    FRigidBodyState RBState;
    FLOAT AngErrorAccumulator;
    FVector ReplicatedDrawScale3D;
    FVector InitialLocation;
    FRotator InitialRotation;
    //## END PROPS KActor

    class UPhysicalMaterial* GetKActorPhysMaterial();
    void ResolveRBState();
    DECLARE_FUNCTION(execGetKActorPhysMaterial)
    {
        P_FINISH;
        *(class UPhysicalMaterial**)Result=this->GetKActorPhysMaterial();
    }
    DECLARE_FUNCTION(execResolveRBState)
    {
        P_FINISH;
        this->ResolveRBState();
    }
    void eventApplyImpulse(FVector ImpulseDir,FLOAT ImpulseMag,FVector HitLocation,struct FTraceHitInfo HitInfo=FTraceHitInfo(EC_EventParm),class UClass* DamageType=NULL)
    {
        KActor_eventApplyImpulse_Parms Parms(EC_EventParm);
        Parms.ImpulseDir=ImpulseDir;
        Parms.ImpulseMag=ImpulseMag;
        Parms.HitLocation=HitLocation;
        Parms.HitInfo=HitInfo;
        Parms.DamageType=DamageType;
        ProcessEvent(FindFunctionChecked(ENGINE_ApplyImpulse),&Parms);
    }
    DECLARE_CLASS(AKActor,ADynamicSMActor,0|CLASS_NativeReplication,Engine)
	// AActor interface
	virtual void physRigidBody(FLOAT DeltaTime);
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& MyInfo, const FRigidBodyCollisionInfo& OtherInfo, const FCollisionImpactData& RigidCollisionData);
	UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	virtual void TickSpecial(FLOAT DeltaSeconds);
};

class AKActorFromStatic : public AKActor
{
public:
    //## BEGIN PROPS KActorFromStatic
    class AActor* MyStaticMeshActor;
    FLOAT MaxImpulseSpeed;
    //## END PROPS KActorFromStatic

    void DisablePrecomputedLighting();
    void MakeStatic();
    class AKActorFromStatic* MakeDynamic(class UStaticMeshComponent* MovableMesh);
    DECLARE_FUNCTION(execDisablePrecomputedLighting)
    {
        P_FINISH;
        this->DisablePrecomputedLighting();
    }
    DECLARE_FUNCTION(execMakeStatic)
    {
        P_FINISH;
        this->MakeStatic();
    }
    DECLARE_FUNCTION(execMakeDynamic)
    {
        P_GET_OBJECT(UStaticMeshComponent,MovableMesh);
        P_FINISH;
        *(class AKActorFromStatic**)Result=this->MakeDynamic(MovableMesh);
    }
    DECLARE_CLASS(AKActorFromStatic,AKActor,0|CLASS_Transient,Engine)
	virtual void NotifyBump(AActor *Other, UPrimitiveComponent* OtherComp, const FVector &HitNormal);
	virtual UBOOL IgnoreBlockingBy( const AActor *Other ) const;
};

struct KActorSpawnable_eventRecycleInternal_Parms
{
    KActorSpawnable_eventRecycleInternal_Parms(EEventParm)
    {
    }
};
class AKActorSpawnable : public AKActor
{
public:
    //## BEGIN PROPS KActorSpawnable
    BITFIELD bRecycleScaleToZero:1;
    BITFIELD bScalingToZero:1;
    SCRIPT_ALIGN;
    //## END PROPS KActorSpawnable

    void ResetComponents();
    DECLARE_FUNCTION(execResetComponents)
    {
        P_FINISH;
        this->ResetComponents();
    }
    void eventRecycleInternal()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RecycleInternal),NULL);
    }
    DECLARE_CLASS(AKActorSpawnable,AKActor,0,Engine)
	virtual void TickSpecial(FLOAT DeltaSeconds);
};

class AKAsset : public AActor
{
public:
    //## BEGIN PROPS KAsset
    class USkeletalMeshComponent* SkeletalMeshComponent;
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bWakeOnLevelStart:1;
    BITFIELD bBlockPawns:1;
    class USkeletalMesh* ReplicatedMesh;
    class UPhysicsAsset* ReplicatedPhysAsset;
    //## END PROPS KAsset

    DECLARE_CLASS(AKAsset,AActor,0|CLASS_NativeReplication,Engine)
public:
	// AActor interface.
	virtual INT* GetOptimizedRepList(BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);

	/**
	* Function that gets called from within Map_Check to allow this actor to check itself
	* for any potential errors and register them with map check dialog.
	*/
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);
	UBOOL IgnoreBlockingBy(const AActor* Other) const;
};

struct FVehicleState
{
    FRigidBodyState RBState;
    BYTE ServerBrake;
    BYTE ServerGas;
    BYTE ServerSteering;
    BYTE ServerRise;
    SCRIPT_ALIGN;
    BITFIELD bServerHandbrake:1;
    INT ServerView;

    /** Constructors */
    FVehicleState() {}
    FVehicleState(EEventParm)
    {
        appMemzero(this, sizeof(FVehicleState));
    }
};

struct SVehicle_eventSuspensionHeavyShift_Parms
{
    FLOAT Delta;
    SVehicle_eventSuspensionHeavyShift_Parms(EEventParm)
    {
    }
};
class ASVehicle : public AVehicle
{
public:
    //## BEGIN PROPS SVehicle
    class USVehicleSimBase* SimObj;
    TArrayNoInit<class USVehicleWheel*> Wheels;
    FVector COMOffset;
    FVector InertiaTensorMultiplier;
    BITFIELD bStayUpright:1;
    BITFIELD bUseSuspensionAxis:1;
    BITFIELD bUpdateWheelShapes:1;
    BITFIELD bVehicleOnGround:1;
    BITFIELD bVehicleOnWater:1;
    BITFIELD bIsInverted:1;
    BITFIELD bChassisTouchingGround:1;
    BITFIELD bWasChassisTouchingGroundLastTick:1;
    BITFIELD bCanFlip:1;
    BITFIELD bFlipRight:1;
    BITFIELD bIsUprighting:1;
    BITFIELD bOutputHandbrake:1;
    BITFIELD bHoldingDownHandbrake:1;
    FLOAT StayUprightRollResistAngle;
    FLOAT StayUprightPitchResistAngle;
    FLOAT StayUprightStiffness;
    FLOAT StayUprightDamping;
    class URB_StayUprightSetup* StayUprightConstraintSetup;
    class URB_ConstraintInstance* StayUprightConstraintInstance;
    FLOAT HeavySuspensionShiftPercent;
    FLOAT MaxSpeed;
    FLOAT MaxAngularVelocity;
    FLOAT TimeOffGround;
    FLOAT UprightLiftStrength;
    FLOAT UprightTorqueStrength;
    FLOAT UprightTime;
    FLOAT UprightStartTime;
    class UAudioComponent* EngineSound;
    class UAudioComponent* SquealSound;
    class USoundCue* CollisionSound;
    class USoundCue* EnterVehicleSound;
    class USoundCue* ExitVehicleSound;
    FLOAT CollisionIntervalSecs;
    FLOAT SquealThreshold;
    FLOAT SquealLatThreshold;
    FLOAT LatAngleVolumeMult;
    FLOAT EngineStartOffsetSecs;
    FLOAT EngineStopOffsetSecs;
    FLOAT LastCollisionSoundTime;
    FLOAT OutputBrake;
    FLOAT OutputGas;
    FLOAT OutputSteering;
    FLOAT OutputRise;
    FLOAT ForwardVel;
    INT NumPoweredWheels;
    FVector BaseOffset;
    FLOAT CamDist;
    INT DriverViewPitch;
    INT DriverViewYaw;
    struct FVehicleState VState;
    FLOAT AngErrorAccumulator;
    FLOAT RadialImpulseScaling;
    //## END PROPS SVehicle

    virtual void AddForce(FVector Force);
    virtual void AddImpulse(FVector Impulse);
    virtual void AddTorque(FVector Torque);
    virtual UBOOL IsSleeping();
    void SetWheelCollision(INT WheelNum,UBOOL bCollision);
    virtual void InitVehicleRagdoll(class USkeletalMesh* RagdollMesh,class UPhysicsAsset* RagdollPhysAsset,FVector ActorMove,UBOOL bClearAnimTree);
    virtual UBOOL HasWheelsOnGround();
    DECLARE_FUNCTION(execAddForce)
    {
        P_GET_STRUCT(FVector,Force);
        P_FINISH;
        this->AddForce(Force);
    }
    DECLARE_FUNCTION(execAddImpulse)
    {
        P_GET_STRUCT(FVector,Impulse);
        P_FINISH;
        this->AddImpulse(Impulse);
    }
    DECLARE_FUNCTION(execAddTorque)
    {
        P_GET_STRUCT(FVector,Torque);
        P_FINISH;
        this->AddTorque(Torque);
    }
    DECLARE_FUNCTION(execIsSleeping)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsSleeping();
    }
    DECLARE_FUNCTION(execSetWheelCollision)
    {
        P_GET_INT(WheelNum);
        P_GET_UBOOL(bCollision);
        P_FINISH;
        this->SetWheelCollision(WheelNum,bCollision);
    }
    DECLARE_FUNCTION(execInitVehicleRagdoll)
    {
        P_GET_OBJECT(USkeletalMesh,RagdollMesh);
        P_GET_OBJECT(UPhysicsAsset,RagdollPhysAsset);
        P_GET_STRUCT(FVector,ActorMove);
        P_GET_UBOOL(bClearAnimTree);
        P_FINISH;
        this->InitVehicleRagdoll(RagdollMesh,RagdollPhysAsset,ActorMove,bClearAnimTree);
    }
    DECLARE_FUNCTION(execHasWheelsOnGround)
    {
        P_FINISH;
        *(UBOOL*)Result=this->HasWheelsOnGround();
    }
    void eventSuspensionHeavyShift(FLOAT Delta)
    {
        SVehicle_eventSuspensionHeavyShift_Parms Parms(EC_EventParm);
        Parms.Delta=Delta;
        ProcessEvent(FindFunctionChecked(ENGINE_SuspensionHeavyShift),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(ASVehicle,AVehicle,0|CLASS_Config|CLASS_NativeReplication,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// Actor interface.
	virtual void physRigidBody(FLOAT DeltaTime);
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickAuthoritative( FLOAT DeltaSeconds );
	virtual void setPhysics(BYTE NewPhysics, AActor *NewFloor, FVector NewFloorV);
	virtual void PostNetReceiveLocation();
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );

	// SVehicle interface.
	virtual void VehiclePackRBState();
	virtual void VehicleUnpackRBState();
	virtual FVector GetDampingForce(const FVector& InForce);

#if WITH_NOVODEX

    virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& MyInfo, const FRigidBodyCollisionInfo& OtherInfo, const FCollisionImpactData& RigidCollisionData);
	virtual void ModifyNxActorDesc(NxActorDesc& ActorDesc,UPrimitiveComponent* PrimComp, const class NxGroupsMask& GroupsMask, UINT MatIndex);
	virtual void PostInitRigidBody(NxActor* nActor, NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp);
	virtual void PreTermRigidBody(NxActor* nActor);
	virtual void TermRBPhys(FRBPhysScene* Scene);
#endif

	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime) {}

	/** Set any params on wheel particle effect */
	virtual void SetWheelEffectParams(USVehicleWheel* VW, FLOAT SlipVel);
};

class ARB_ConstraintActor : public ARigidBodyBase
{
public:
    //## BEGIN PROPS RB_ConstraintActor
    class AActor* ConstraintActor1;
    class AActor* ConstraintActor2;
    class URB_ConstraintSetup* ConstraintSetup;
    class URB_ConstraintInstance* ConstraintInstance;
    BITFIELD bDisableCollision:1;
    BITFIELD bUpdateActor1RefFrame:1;
    BITFIELD bUpdateActor2RefFrame:1;
    class AActor* PulleyPivotActor1;
    class AActor* PulleyPivotActor2;
    //## END PROPS RB_ConstraintActor

    void SetDisableCollision(UBOOL NewDisableCollision);
    void InitConstraint(class AActor* Actor1,class AActor* Actor2,FName Actor1Bone=NAME_None,FName Actor2Bone=NAME_None,FLOAT BreakThreshold=0);
    void TermConstraint();
    DECLARE_FUNCTION(execSetDisableCollision)
    {
        P_GET_UBOOL(NewDisableCollision);
        P_FINISH;
        this->SetDisableCollision(NewDisableCollision);
    }
    DECLARE_FUNCTION(execInitConstraint)
    {
        P_GET_OBJECT(AActor,Actor1);
        P_GET_OBJECT(AActor,Actor2);
        P_GET_NAME_OPTX(Actor1Bone,NAME_None);
        P_GET_NAME_OPTX(Actor2Bone,NAME_None);
        P_GET_FLOAT_OPTX(BreakThreshold,0);
        P_FINISH;
        this->InitConstraint(Actor1,Actor2,Actor1Bone,Actor2Bone,BreakThreshold);
    }
    DECLARE_FUNCTION(execTermConstraint)
    {
        P_FINISH;
        this->TermConstraint();
    }
    DECLARE_ABSTRACT_CLASS(ARB_ConstraintActor,ARigidBodyBase,0,Engine)
	virtual void physRigidBody(FLOAT DeltaTime) {};
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	
	/** Used for checking that this constraint is valid buring map build
	  */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
	virtual void InitRBPhys();
	virtual void TermRBPhys(FRBPhysScene* Scene);

	void UpdateConstraintFramesFromActor();
};

class ARB_LineImpulseActor : public ARigidBodyBase
{
public:
    //## BEGIN PROPS RB_LineImpulseActor
    FLOAT ImpulseStrength;
    FLOAT ImpulseRange;
    BITFIELD bVelChange:1;
    BITFIELD bStopAtFirstHit:1;
    BITFIELD bCauseFracture:1;
    class UArrowComponent* Arrow;
    BYTE ImpulseCount;
    SCRIPT_ALIGN;
    //## END PROPS RB_LineImpulseActor

    void FireLineImpulse();
    DECLARE_FUNCTION(execFireLineImpulse)
    {
        P_FINISH;
        this->FireLineImpulse();
    }
    DECLARE_CLASS(ARB_LineImpulseActor,ARigidBodyBase,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

#if WITH_EDITOR
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
#endif
};

class ARB_RadialImpulseActor : public ARigidBodyBase
{
public:
    //## BEGIN PROPS RB_RadialImpulseActor
    class UDrawSphereComponent* RenderComponent;
    class URB_RadialImpulseComponent* ImpulseComponent;
    BYTE ImpulseCount;
    SCRIPT_ALIGN;
    //## END PROPS RB_RadialImpulseActor

    DECLARE_CLASS(ARB_RadialImpulseActor,ARigidBodyBase,0,Engine)
#if WITH_EDITOR
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
#endif
};

class ARB_Thruster : public ARigidBodyBase
{
public:
    //## BEGIN PROPS RB_Thruster
    BITFIELD bThrustEnabled:1;
    FLOAT ThrustStrength;
    //## END PROPS RB_Thruster

    DECLARE_CLASS(ARB_Thruster,ARigidBodyBase,0,Engine)
	virtual UBOOL Tick( FLOAT DeltaSeconds, ELevelTick TickType );
};

struct FWorldAttractorData
{
    BITFIELD bEnabled:1;
    SCRIPT_ALIGN;
    FVector Location;
    BYTE FalloffType;
    FLOAT FalloffExponent;
    FLOAT Range;
    FLOAT Strength;

    /** Constructors */
    FWorldAttractorData() {}
    FWorldAttractorData(EEventParm)
    {
        appMemzero(this, sizeof(FWorldAttractorData));
    }
};

class AWorldAttractor : public AActor
{
public:
    //## BEGIN PROPS WorldAttractor
    BITFIELD bEnabled:1;
    FLOAT LoopDuration;
    FLOAT CurrentTime;
    BYTE FalloffType;
    SCRIPT_ALIGN;
    struct FMatineeRawDistributionFloat FalloffExponent;
    struct FMatineeRawDistributionFloat Range;
    struct FMatineeRawDistributionFloat Strength;
    FLOAT CollisionRadius;
    struct FMatineeRawDistributionFloat DragCoefficient;
    struct FMatineeRawDistributionFloat DragRadius;
    //## END PROPS WorldAttractor

    DECLARE_CLASS(AWorldAttractor,AActor,0,Engine)
	/**
	 *  Override these to manage the list of AWorldAttractor instances.  These will call either RegisterAttractor or
	 *  UnregisterAttractor as necessary and then call the base class implementation.
	 */
	virtual void Spawned();
	virtual void PostLoad();
	/** ticks the actor
	 * @return TRUE if the actor was ticked, FALSE if it was aborted (e.g. because it's in stasis)
	 */
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	virtual void BeginDestroy();
	virtual void Serialize(FArchive& Ar);
	void SetZone( UBOOL bTest, UBOOL bForceRefresh );

	/**
	 *  Get the attraction data at the provided time.
	 *  @param Time This is time relative to whatever the calling function desires (particle life, emitter life, matinee start, etc.)
	 *  @param Data Returned data for the given time.
	 */
	void GetAttractorDataAtTime(const FLOAT Time, FWorldAttractorData& Data);

	/**
	 *  Generate the attraction velocity to add to an actor's current velocity.
	 *  @param CurrentLocation The location of the actor at the start of this tick.
	 *  @param CurrentTime This is time relative to whatever the calling function desires (particle life, emitter life, matinee start, etc.)
	 *  @param DeltaTime This is the time since the last update call.
	 *  @param ParticleBoundingRadius Used to calculate drag.
	 *  @returns The velocity to add to the actor's current velocity.
	 */
	FVector GetVelocityForAttraction(const FVector CurrentLocation, const FLOAT CurrentTime, const FLOAT DeltaTime, const FLOAT ParticleBoundingRadius = 0.0f);

	/**
	 *  Tests for a collision and if there is a collision the actions in the array are executed on the particle.
	 *  @param ParticleEmitter The particle emitter that owns the particle to test.
	 *  @param ParticleIndex Used to look up the particle in the emitter instance.
	 *  @returns TRUE if the particle was affected by one of the actions.
	 */
	UBOOL HandleParticleCollision(FParticleEmitterInstance* ParticleEmitter, INT ParticleIndex);
};

class URB_ConstraintDrawComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS RB_ConstraintDrawComponent
    class UMaterialInterface* LimitMaterial;
    //## END PROPS RB_ConstraintDrawComponent

    DECLARE_CLASS(URB_ConstraintDrawComponent,UPrimitiveComponent,0,Engine)
	// Primitive Component interface
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	
	/**
	 * Update the bounds of the component.
	 */
	virtual void UpdateBounds(); 

	/** 
	 * Retrieves the materials used in this component 
	 * 
	 * @param OutMaterials	The list of used materials.
	 */
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const; 
};

class URB_RadialImpulseComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS RB_RadialImpulseComponent
    BYTE ImpulseFalloff;
    FLOAT ImpulseStrength;
    FLOAT ImpulseRadius;
    BITFIELD bVelChange:1;
    BITFIELD bCauseFracture:1;
    class UDrawSphereComponent* PreviewSphere;
    //## END PROPS RB_RadialImpulseComponent

    virtual void FireImpulse(FVector Origin);
    DECLARE_FUNCTION(execFireImpulse)
    {
        P_GET_STRUCT(FVector,Origin);
        P_FINISH;
        this->FireImpulse(Origin);
    }
    DECLARE_CLASS(URB_RadialImpulseComponent,UPrimitiveComponent,0,Engine)
protected:
	// UActorComponent interface.
	virtual void Attach();
public:
	/** Update the component's bounds */
	virtual void UpdateBounds();
};

class URB_Handle : public UActorComponent
{
public:
    //## BEGIN PROPS RB_Handle
    class UPrimitiveComponent* GrabbedComponent;
    FName GrabbedBoneName;
    INT SceneIndex;
    BITFIELD bInHardware:1;
    BITFIELD bRotationConstrained:1;
    BITFIELD bInterpolating:1;
    SCRIPT_ALIGN;
    class NxJoint* HandleData;
    class NxActor* KinActorData;
    FLOAT LinearDamping;
    FLOAT LinearStiffness;
    FVector LinearStiffnessScale3D;
    FVector LinearDampingScale3D;
    FLOAT AngularDamping;
    FLOAT AngularStiffness;
    FVector Destination;
    FVector StepSize;
    FVector Location;
    //## END PROPS RB_Handle

    virtual void GrabComponent(class UPrimitiveComponent* Component,FName InBoneName,FVector GrabLocation,UBOOL bConstrainRotation);
    virtual void ReleaseComponent();
    virtual void SetLocation(FVector NewLocation);
    virtual void SetSmoothLocation(FVector NewLocation,FLOAT MoveTime);
    virtual void UpdateSmoothLocation(const FVector& NewLocation);
    virtual void SetOrientation(const FQuat& NewOrientation);
    virtual FQuat GetOrientation();
    DECLARE_FUNCTION(execGrabComponent)
    {
        P_GET_OBJECT(UPrimitiveComponent,Component);
        P_GET_NAME(InBoneName);
        P_GET_STRUCT(FVector,GrabLocation);
        P_GET_UBOOL(bConstrainRotation);
        P_FINISH;
        this->GrabComponent(Component,InBoneName,GrabLocation,bConstrainRotation);
    }
    DECLARE_FUNCTION(execReleaseComponent)
    {
        P_FINISH;
        this->ReleaseComponent();
    }
    DECLARE_FUNCTION(execSetLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_FINISH;
        this->SetLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetSmoothLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_GET_FLOAT(MoveTime);
        P_FINISH;
        this->SetSmoothLocation(NewLocation,MoveTime);
    }
    DECLARE_FUNCTION(execUpdateSmoothLocation)
    {
        P_GET_STRUCT_REF(FVector,NewLocation);
        P_FINISH;
        this->UpdateSmoothLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetOrientation)
    {
        P_GET_STRUCT_REF(FQuat,NewOrientation);
        P_FINISH;
        this->SetOrientation(NewOrientation);
    }
    DECLARE_FUNCTION(execGetOrientation)
    {
        P_FINISH;
        *(FQuat*)Result=this->GetOrientation();
    }
    DECLARE_CLASS(URB_Handle,UActorComponent,0,Engine)
protected:
	// UActorComponent interface.
	virtual void Attach();
	virtual void Detach( UBOOL bWillReattach = FALSE );
	virtual void Tick(FLOAT DeltaTime);
public:
	virtual void TermComponentRBPhys(FRBPhysScene* InScene);

	// URB_Handle interface
};

class URB_Spring : public UActorComponent
{
public:
    //## BEGIN PROPS RB_Spring
    class UPrimitiveComponent* Component1;
    FName BoneName1;
    class UPrimitiveComponent* Component2;
    FName BoneName2;
    INT SceneIndex;
    BITFIELD bInHardware:1;
    BITFIELD bEnableForceMassRatio:1;
    SCRIPT_ALIGN;
    FPointer SpringData;
    FLOAT TimeSinceActivation;
    FLOAT MinBodyMass;
    FLOAT SpringSaturateDist;
    FLOAT SpringMaxForce;
    FLOAT MaxForceMassRatio;
    FInterpCurveFloat SpringMaxForceTimeScale;
    FLOAT DampSaturateVel;
    FLOAT DampMaxForce;
    //## END PROPS RB_Spring

    virtual void SetComponents(class UPrimitiveComponent* InComponent1,FName InBoneName1,FVector Position1,class UPrimitiveComponent* InComponent2,FName InBoneName2,FVector Position2);
    virtual void Clear();
    DECLARE_FUNCTION(execSetComponents)
    {
        P_GET_OBJECT(UPrimitiveComponent,InComponent1);
        P_GET_NAME(InBoneName1);
        P_GET_STRUCT(FVector,Position1);
        P_GET_OBJECT(UPrimitiveComponent,InComponent2);
        P_GET_NAME(InBoneName2);
        P_GET_STRUCT(FVector,Position2);
        P_FINISH;
        this->SetComponents(InComponent1,InBoneName1,Position1,InComponent2,InBoneName2,Position2);
    }
    DECLARE_FUNCTION(execClear)
    {
        P_FINISH;
        this->Clear();
    }
    DECLARE_CLASS(URB_Spring,UActorComponent,0,Engine)
	// ActorComponent interface

	virtual void Tick(FLOAT DeltaTime);
	virtual void TermComponentRBPhys(FRBPhysScene* InScene);
};

class USVehicleSimBase : public UActorComponent
{
public:
    //## BEGIN PROPS SVehicleSimBase
    FLOAT WheelSuspensionStiffness;
    FLOAT WheelSuspensionDamping;
    FLOAT WheelSuspensionBias;
    FLOAT WheelLongExtremumSlip;
    FLOAT WheelLongExtremumValue;
    FLOAT WheelLongAsymptoteSlip;
    FLOAT WheelLongAsymptoteValue;
    FLOAT WheelLatExtremumSlip;
    FLOAT WheelLatExtremumValue;
    FLOAT WheelLatAsymptoteSlip;
    FLOAT WheelLatAsymptoteValue;
    FLOAT WheelInertia;
    BITFIELD bWheelSpeedOverride:1;
    BITFIELD bClampedFrictionModel:1;
    BITFIELD bAutoDrive:1;
    FLOAT AutoDriveSteer;
    //## END PROPS SVehicleSimBase

    DECLARE_CLASS(USVehicleSimBase,UActorComponent,0,Engine)
	virtual void ProcessCarInput(ASVehicle* Vehicle) {}
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime) {}

#if WITH_NOVODEX
	virtual void SetNxWheelShapeParams(class NxWheelShape* WheelShape, class USVehicleWheel* VW, FLOAT LongGripScale=1.f, FLOAT LatGripScale=1.f);
	virtual void SetNxWheelShapeTireForceFunctions(class NxWheelShape* WheelShape, class USVehicleWheel* VW, FLOAT LongGripScale=1.f, FLOAT LatGripScale=1.f);
#endif

	/** Returns a float representative of the vehcile's engine output. */
	virtual FLOAT GetEngineOutput(ASVehicle* Vehicle) { return 0.0f; }
};

class USVehicleSimCar : public USVehicleSimBase
{
public:
    //## BEGIN PROPS SVehicleSimCar
    FLOAT ChassisTorqueScale;
    FInterpCurveFloat MaxSteerAngleCurve;
    FLOAT SteerSpeed;
    FLOAT ReverseThrottle;
    FLOAT EngineBrakeFactor;
    FLOAT MaxBrakeTorque;
    FLOAT StopThreshold;
    BITFIELD bIsDriving:1;
    FLOAT ActualSteering;
    FLOAT TimeSinceThrottle;
    //## END PROPS SVehicleSimCar

    DECLARE_CLASS(USVehicleSimCar,USVehicleSimBase,0,Engine)
	// SVehicleSimBase interface.
	virtual void ProcessCarInput(ASVehicle* Vehicle);
	virtual void UpdateHandbrake(ASVehicle* Vehicle);
};

class USVehicleSimTank : public USVehicleSimCar
{
public:
    //## BEGIN PROPS SVehicleSimTank
    FLOAT LeftTrackVel;
    FLOAT RightTrackVel;
    FLOAT LeftTrackTorque;
    FLOAT RightTrackTorque;
    FLOAT MaxEngineTorque;
    FLOAT EngineDamping;
    FLOAT InsideTrackTorqueFactor;
    FLOAT SteeringLatStiffnessFactor;
    FLOAT TurnInPlaceThrottle;
    FLOAT TurnMaxGripReduction;
    FLOAT TurnGripScaleRate;
    BITFIELD bTurnInPlaceOnSteer:1;
    SCRIPT_ALIGN;
    //## END PROPS SVehicleSimTank

    DECLARE_CLASS(USVehicleSimTank,USVehicleSimCar,0,Engine)
	// SVehicleSimBase interface.
	virtual void ProcessCarInput(ASVehicle* Vehicle);
	virtual void UpdateVehicle(ASVehicle* Vehicle, FLOAT DeltaTime);
	virtual void ApplyWheels(FLOAT InLeftTrackVel, FLOAT InRightTrackVel, ASVehicle* Vehicle);
};

class UActorFactoryApexClothing : public UActorFactorySkeletalMesh
{
public:
    //## BEGIN PROPS ActorFactoryApexClothing
    TArrayNoInit<class UApexClothingAsset*> ClothingAssets;
    BYTE ClothingRBChannel;
    SCRIPT_ALIGN;
    FRBCollisionChannelContainer ClothingRBCollideWithChannels;
    //## END PROPS ActorFactoryApexClothing

    DECLARE_CLASS(UActorFactoryApexClothing,UActorFactorySkeletalMesh,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

struct FDamageParameters
{
    BYTE OverrideMode;
    FLOAT BaseDamage;
    FLOAT Radius;
    FLOAT Momentum;

    /** Constructors */
    FDamageParameters() {}
    FDamageParameters(EEventParm)
    {
        appMemzero(this, sizeof(FDamageParameters));
    }
};

struct FDamagePair
{
    FName DamageCauserName;
    struct FDamageParameters Params;

    /** Constructors */
    FDamagePair() {}
    FDamagePair(EEventParm)
    {
        appMemzero(this, sizeof(FDamagePair));
    }
};

class UApexDestructibleDamageParameters : public UObject
{
public:
    //## BEGIN PROPS ApexDestructibleDamageParameters
    TArrayNoInit<struct FDamagePair> DamageMap;
    //## END PROPS ApexDestructibleDamageParameters

    DECLARE_CLASS(UApexDestructibleDamageParameters,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UApexDestructibleDamageParameters)
};

class UFractureMaterial : public UObject
{
public:
    //## BEGIN PROPS FractureMaterial
    class UParticleSystem* FractureEffect;
    class USoundCue* FractureSound;
    //## END PROPS FractureMaterial

    DECLARE_CLASS(UFractureMaterial,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UFractureMaterial)
};

class URB_BodySetup : public UKMeshProps
{
public:
    //## BEGIN PROPS RB_BodySetup
    BYTE SleepFamily;
    FName BoneName;
    BITFIELD bFixed:1;
    BITFIELD bNoCollision:1;
    BITFIELD bBlockZeroExtent:1;
    BITFIELD bBlockNonZeroExtent:1;
    BITFIELD bEnableContinuousCollisionDetection:1;
    BITFIELD bAlwaysFullAnimWeight:1;
    BITFIELD bConsiderForBounds:1;
    class UPhysicalMaterial* PhysMaterial;
    FLOAT MassScale;
    TArrayNoInit<FPointer> CollisionGeom;
    TArrayNoInit<FVector> CollisionGeomScale3D;
    TArrayNoInit<FVector> PreCachedPhysScale;
    TArrayNoInit<FKCachedConvexData> PreCachedPhysData;
    INT PreCachedPhysDataVersion;
    //## END PROPS RB_BodySetup

    DECLARE_CLASS(URB_BodySetup,UKMeshProps,0,Engine)
	// UObject interface.
	virtual void PreSave();
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
	virtual void FinishDestroy();
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// URB_BodySetup interface.
	void	CopyBodyPropertiesFrom(class URB_BodySetup* fromSetup);
	void	ClearShapeCache();

	/** Pre-cache this mesh at all desired scales. */
	void PreCachePhysicsData();

	/*
	* Create and add a new physics collision representation to this body setup
	* @param Scale3D    - Scale at which this geometry should be created at
	* @param CachedData - Unreal description of the collision geometry to create
	* @param DebugName  - debug name to output
	* returns TRUE if successful
	*/
	UBOOL AddCollisionFromCachedData(const FVector& Scale3D, FKCachedConvexData* CachedData, const FString& DebugName);
};

class UPhysicalMaterial : public UObject
{
public:
    //## BEGIN PROPS PhysicalMaterial
    INT MaterialIndex;
    FLOAT Friction;
    FLOAT Restitution;
    BITFIELD bForceConeFriction:1;
    BITFIELD bEnableAnisotropicFriction:1;
    SCRIPT_ALIGN;
    FVector AnisoFrictionDir;
    FLOAT FrictionV;
    FLOAT Density;
    FLOAT AngularDamping;
    FLOAT LinearDamping;
    FLOAT MagneticResponse;
    FLOAT WindResponse;
    FLOAT ImpactThreshold;
    FLOAT ImpactReFireDelay;
    class UParticleSystem* ImpactEffect;
    class USoundCue* ImpactSound;
    FLOAT SlideThreshold;
    FLOAT SlideReFireDelay;
    class UParticleSystem* SlideEffect;
    class USoundCue* SlideSound;
    class USoundCue* FractureSoundExplosion;
    class USoundCue* FractureSoundSingle;
    class UPhysicalMaterial* Parent;
    class UPhysicalMaterialPropertyBase* PhysicalMaterialProperty;
    //## END PROPS PhysicalMaterial

    virtual struct FPhysEffectInfo FindPhysEffectInfo(BYTE Type);
    DECLARE_FUNCTION(execFindPhysEffectInfo)
    {
        P_GET_BYTE(Type);
        P_FINISH;
        *(struct FPhysEffectInfo*)Result=this->FindPhysEffectInfo(Type);
    }
    DECLARE_CLASS(UPhysicalMaterial,UObject,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void FinishDestroy();

	/**
     * This will fix any old PhysicalMaterials that were created in the PhysMaterial's outer instead
	 * of correctly inside the PhysMaterial.  This will allow "broken" PhysMaterials to be renamed.
	 **/
	virtual UBOOL Rename( const TCHAR* NewName=NULL, UObject* NewOuter=NULL, ERenameFlags Flags=REN_None );
};

class UPhysicalMaterialPropertyBase : public UObject
{
public:
    //## BEGIN PROPS PhysicalMaterialPropertyBase
    //## END PROPS PhysicalMaterialPropertyBase

    DECLARE_ABSTRACT_CLASS(UPhysicalMaterialPropertyBase,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPhysicalMaterialPropertyBase)
};

class UPhysicsAsset : public UObject
{
public:
    //## BEGIN PROPS PhysicsAsset
#if WITH_EDITORONLY_DATA
    class USkeletalMesh* DefaultSkelMesh;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<class URB_BodySetup*> BodySetup;
    TMap<FName, INT> BodySetupIndexMap;
    TArrayNoInit<INT> BoundsBodies;
    TArrayNoInit<class URB_ConstraintSetup*> ConstraintSetup;
    class UPhysicsAssetInstance* DefaultInstance;
    //## END PROPS PhysicsAsset

    INT FindBodyIndex(FName BodyName);
    DECLARE_FUNCTION(execFindBodyIndex)
    {
        P_GET_NAME(BodyName);
        P_FINISH;
        *(INT*)Result=this->FindBodyIndex(BodyName);
    }
    DECLARE_CLASS(UPhysicsAsset,UObject,0,Engine)
	// UObject interface
	virtual void PostLoad();

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	// Creates a Physics Asset using the supplied Skeletal Mesh as a starting point.
	UBOOL CreateFromSkeletalMesh( class USkeletalMesh* skelMesh, FPhysAssetCreateParams& Params );
	static void CreateCollisionFromBone( URB_BodySetup* bs, class USkeletalMesh* skelMesh, INT BoneIndex, FPhysAssetCreateParams& Params, TArray<struct FBoneVertInfo>& Infos );

	INT						FindControllingBodyIndex(class USkeletalMesh* skelMesh, INT BoneIndex);
	INT						FindConstraintIndex(FName ConstraintName);
	FName					FindConstraintBoneName(INT ConstraintIndex);

	/** Utility for getting indices of all bodies below (and including) the one with the supplied name. */
	void					GetBodyIndicesBelow(TArray<INT>& OutBodyIndices, FName InBoneName, USkeletalMesh* InSkelMesh);

	FBox					CalcAABB(class USkeletalMeshComponent* SkelComp);
	UBOOL					LineCheck(FCheckResult& Result, class USkeletalMeshComponent* SkelComp, const FVector& Start, const FVector& End, const FVector& Extent, UBOOL bOnlyPerPolyShapes);
	FCheckResult*			LineCheckAllInteractions( FMemStack& Mem, class USkeletalMeshComponent* SkelComp, const FVector& Start, const FVector& End, const FVector& Extent, UBOOL bPerPolyShapes );
	UBOOL					PointCheck(FCheckResult& Result, class USkeletalMeshComponent* SkelComp, const FVector& Location, const FVector& Extent);
	void					UpdateMassProps();

	// For PhAT only really...
	INT CreateNewBody(FName InBodyName);
	void DestroyBody(INT BodyIndex);

	INT CreateNewConstraint(FName InConstraintName, URB_ConstraintSetup* InConstraintSetup = NULL);
	void DestroyConstraint(INT ConstraintIndex);

	void BodyFindConstraints(INT BodyIndex, TArray<INT>& Constraints);
	void ClearShapeCaches();

	void UpdateBodyIndices();

	void WeldBodies(INT BaseBodyIndex, INT AddBodyIndex, USkeletalMeshComponent* SkelComp);

	void DrawCollision(class FPrimitiveDrawInterface* PDI, const USkeletalMesh* SkelMesh, const TArray<FBoneAtom>& SpaceBases, const FMatrix& LocalToWorld, FLOAT Scale);
	void DrawConstraints(class FPrimitiveDrawInterface* PDI, const USkeletalMesh* SkelMesh, const TArray<FBoneAtom>& SpaceBases, const FMatrix& LocalToWorld, FLOAT Scale);

	void FixOuters();

	/** Update the BoundsBodies array and cache the indices of bodies marked with bConsiderForBounds to BoundsBodies array. */
	void UpdateBoundsBodiesArray();

	/** Update the BodySetup Array Index Map.  */
	void UpdateBodySetupIndexMap();
};

class UPhysicsAssetInstance : public UObject
{
public:
    //## BEGIN PROPS PhysicsAssetInstance
    class AActor* Owner;
    INT RootBodyIndex;
    TArrayNoInit<class URB_BodyInstance*> Bodies;
    TArrayNoInit<class URB_ConstraintInstance*> Constraints;
    TMap<FRigidBodyIndexPair,UBOOL> CollisionDisableTable;
    FLOAT LinearSpringScale;
    FLOAT LinearDampingScale;
    FLOAT LinearForceLimitScale;
    FLOAT AngularSpringScale;
    FLOAT AngularDampingScale;
    FLOAT AngularForceLimitScale;
    BITFIELD bInitBodies:1;
    SCRIPT_ALIGN;
    //## END PROPS PhysicsAssetInstance

    void SetLinearDriveScale(FLOAT InLinearSpringScale,FLOAT InLinearDampingScale,FLOAT InLinearForceLimitScale);
    void SetAngularDriveScale(FLOAT InAngularSpringScale,FLOAT InAngularDampingScale,FLOAT InAngularForceLimitScale);
    FLOAT GetTotalMassBelowBone(FName InBoneName,class UPhysicsAsset* InAsset,class USkeletalMesh* InSkelMesh);
    void SetAllBodiesFixed(UBOOL bNewFixed);
    void SetNamedBodiesFixed(UBOOL bNewFixed,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMesh,UBOOL bSetOtherBodiesToComplement=FALSE,UBOOL bSkipFullAnimWeightBodies=FALSE);
    void ForceAllBodiesBelowUnfixed(const FName& InBoneName,class UPhysicsAsset* InAsset,class USkeletalMeshComponent* InSkelMesh,UBOOL InbInstanceAlwaysFullAnimWeight);
    void SetAllMotorsAngularPositionDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive,class USkeletalMeshComponent* SkelMesh=NULL,UBOOL bSkipFullAnimWeightBodies=FALSE);
    void SetAllMotorsAngularVelocityDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive,class USkeletalMeshComponent* SkelMeshComp,UBOOL bSkipFullAnimWeightBodies=FALSE);
    void SetAllMotorsAngularDriveParams(FLOAT InSpring,FLOAT InDamping,FLOAT InForceLimit,class USkeletalMeshComponent* SkelMesh=NULL,UBOOL bSkipFullAnimWeightBodies=FALSE);
    void SetNamedMotorsAngularPositionDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMeshComp,UBOOL bSetOtherBodiesToComplement=FALSE);
    void SetNamedMotorsAngularVelocityDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMeshComp,UBOOL bSetOtherBodiesToComplement=FALSE);
    void SetNamedRBBoneSprings(UBOOL bEnable,const TArray<FName>& BoneNames,FLOAT InBoneLinearSpring,FLOAT InBoneAngularSpring,class USkeletalMeshComponent* SkelMeshComp);
    void SetNamedBodiesBlockRigidBody(UBOOL bNewBlockRigidBody,const TArray<FName>& BoneNames,class USkeletalMeshComponent* SkelMesh);
    void SetFullAnimWeightBlockRigidBody(UBOOL bNewBlockRigidBody,class USkeletalMeshComponent* SkelMesh);
    void SetFullAnimWeightBonesFixed(UBOOL bNewFixed,class USkeletalMeshComponent* SkelMesh);
    class URB_BodyInstance* FindBodyInstance(FName BodyName,class UPhysicsAsset* InAsset);
    class URB_ConstraintInstance* FindConstraintInstance(FName ConName,class UPhysicsAsset* InAsset);
    DECLARE_FUNCTION(execSetLinearDriveScale)
    {
        P_GET_FLOAT(InLinearSpringScale);
        P_GET_FLOAT(InLinearDampingScale);
        P_GET_FLOAT(InLinearForceLimitScale);
        P_FINISH;
        this->SetLinearDriveScale(InLinearSpringScale,InLinearDampingScale,InLinearForceLimitScale);
    }
    DECLARE_FUNCTION(execSetAngularDriveScale)
    {
        P_GET_FLOAT(InAngularSpringScale);
        P_GET_FLOAT(InAngularDampingScale);
        P_GET_FLOAT(InAngularForceLimitScale);
        P_FINISH;
        this->SetAngularDriveScale(InAngularSpringScale,InAngularDampingScale,InAngularForceLimitScale);
    }
    DECLARE_FUNCTION(execGetTotalMassBelowBone)
    {
        P_GET_NAME(InBoneName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_GET_OBJECT(USkeletalMesh,InSkelMesh);
        P_FINISH;
        *(FLOAT*)Result=this->GetTotalMassBelowBone(InBoneName,InAsset,InSkelMesh);
    }
    DECLARE_FUNCTION(execSetAllBodiesFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_FINISH;
        this->SetAllBodiesFixed(bNewFixed);
    }
    DECLARE_FUNCTION(execSetNamedBodiesFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_GET_UBOOL_OPTX(bSetOtherBodiesToComplement,FALSE);
        P_GET_UBOOL_OPTX(bSkipFullAnimWeightBodies,FALSE);
        P_FINISH;
        this->SetNamedBodiesFixed(bNewFixed,BoneNames,SkelMesh,bSetOtherBodiesToComplement,bSkipFullAnimWeightBodies);
    }
    DECLARE_FUNCTION(execForceAllBodiesBelowUnfixed)
    {
        P_GET_NAME_REF(InBoneName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_GET_OBJECT(USkeletalMeshComponent,InSkelMesh);
        P_GET_UBOOL(InbInstanceAlwaysFullAnimWeight);
        P_FINISH;
        this->ForceAllBodiesBelowUnfixed(InBoneName,InAsset,InSkelMesh,InbInstanceAlwaysFullAnimWeight);
    }
    DECLARE_FUNCTION(execSetAllMotorsAngularPositionDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_GET_OBJECT_OPTX(USkeletalMeshComponent,SkelMesh,NULL);
        P_GET_UBOOL_OPTX(bSkipFullAnimWeightBodies,FALSE);
        P_FINISH;
        this->SetAllMotorsAngularPositionDrive(bEnableSwingDrive,bEnableTwistDrive,SkelMesh,bSkipFullAnimWeightBodies);
    }
    DECLARE_FUNCTION(execSetAllMotorsAngularVelocityDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_GET_UBOOL_OPTX(bSkipFullAnimWeightBodies,FALSE);
        P_FINISH;
        this->SetAllMotorsAngularVelocityDrive(bEnableSwingDrive,bEnableTwistDrive,SkelMeshComp,bSkipFullAnimWeightBodies);
    }
    DECLARE_FUNCTION(execSetAllMotorsAngularDriveParams)
    {
        P_GET_FLOAT(InSpring);
        P_GET_FLOAT(InDamping);
        P_GET_FLOAT(InForceLimit);
        P_GET_OBJECT_OPTX(USkeletalMeshComponent,SkelMesh,NULL);
        P_GET_UBOOL_OPTX(bSkipFullAnimWeightBodies,FALSE);
        P_FINISH;
        this->SetAllMotorsAngularDriveParams(InSpring,InDamping,InForceLimit,SkelMesh,bSkipFullAnimWeightBodies);
    }
    DECLARE_FUNCTION(execSetNamedMotorsAngularPositionDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_GET_UBOOL_OPTX(bSetOtherBodiesToComplement,FALSE);
        P_FINISH;
        this->SetNamedMotorsAngularPositionDrive(bEnableSwingDrive,bEnableTwistDrive,BoneNames,SkelMeshComp,bSetOtherBodiesToComplement);
    }
    DECLARE_FUNCTION(execSetNamedMotorsAngularVelocityDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_GET_UBOOL_OPTX(bSetOtherBodiesToComplement,FALSE);
        P_FINISH;
        this->SetNamedMotorsAngularVelocityDrive(bEnableSwingDrive,bEnableTwistDrive,BoneNames,SkelMeshComp,bSetOtherBodiesToComplement);
    }
    DECLARE_FUNCTION(execSetNamedRBBoneSprings)
    {
        P_GET_UBOOL(bEnable);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_FLOAT(InBoneLinearSpring);
        P_GET_FLOAT(InBoneAngularSpring);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMeshComp);
        P_FINISH;
        this->SetNamedRBBoneSprings(bEnable,BoneNames,InBoneLinearSpring,InBoneAngularSpring,SkelMeshComp);
    }
    DECLARE_FUNCTION(execSetNamedBodiesBlockRigidBody)
    {
        P_GET_UBOOL(bNewBlockRigidBody);
        P_GET_TARRAY(FName,BoneNames);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_FINISH;
        this->SetNamedBodiesBlockRigidBody(bNewBlockRigidBody,BoneNames,SkelMesh);
    }
    DECLARE_FUNCTION(execSetFullAnimWeightBlockRigidBody)
    {
        P_GET_UBOOL(bNewBlockRigidBody);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_FINISH;
        this->SetFullAnimWeightBlockRigidBody(bNewBlockRigidBody,SkelMesh);
    }
    DECLARE_FUNCTION(execSetFullAnimWeightBonesFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_GET_OBJECT(USkeletalMeshComponent,SkelMesh);
        P_FINISH;
        this->SetFullAnimWeightBonesFixed(bNewFixed,SkelMesh);
    }
    DECLARE_FUNCTION(execFindBodyInstance)
    {
        P_GET_NAME(BodyName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_FINISH;
        *(class URB_BodyInstance**)Result=this->FindBodyInstance(BodyName,InAsset);
    }
    DECLARE_FUNCTION(execFindConstraintInstance)
    {
        P_GET_NAME(ConName);
        P_GET_OBJECT(UPhysicsAsset,InAsset);
        P_FINISH;
        *(class URB_ConstraintInstance**)Result=this->FindConstraintInstance(ConName,InAsset);
    }
    DECLARE_CLASS(UPhysicsAssetInstance,UObject,0,Engine)
	// UObject interface
	virtual void			Serialize(FArchive& Ar);

	// UPhysicsAssetInstance interface
	void					InitInstance(class USkeletalMeshComponent* SkelComp, class UPhysicsAsset* PhysAsset, UBOOL bFixed, FRBPhysScene* InRBScene);
	UBOOL					TermInstance(FRBPhysScene* Scene);

	/** Terminate physics on all bodies below the named bone */
	void					TermBodiesBelow(FName ParentBoneName, class USkeletalMeshComponent* SkelComp);
	/** Enable/Disable collision on all bodies below the named bone */
	void					EnableCollisionBodiesBelow(UBOOL bEnable, FName ParentBoneName, class USkeletalMeshComponent* SkelComp);

	void					DisableCollision(class URB_BodyInstance* BodyA, class URB_BodyInstance* BodyB);
	void					EnableCollision(class URB_BodyInstance* BodyA, class URB_BodyInstance* BodyB);
};

class UPhysicsLODVerticalEmitter : public UObject
{
public:
    //## BEGIN PROPS PhysicsLODVerticalEmitter
    INT ParticlePercentage;
    //## END PROPS PhysicsLODVerticalEmitter

    DECLARE_CLASS(UPhysicsLODVerticalEmitter,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    NO_DEFAULT_CONSTRUCTOR(UPhysicsLODVerticalEmitter)
};

class URB_BodyInstance : public UObject
{
public:
    //## BEGIN PROPS RB_BodyInstance
    class UPrimitiveComponent* OwnerComponent;
    INT BodyIndex;
    FVector Velocity;
    FVector PreviousVelocity;
    INT SceneIndex;
    FPointer BodyData;
    FPointer BoneSpring;
    FPointer BoneSpringKinActor;
    BITFIELD bEnableBoneSpringLinear:1;
    BITFIELD bEnableBoneSpringAngular:1;
    BITFIELD bDisableOnOverextension:1;
    BITFIELD bNotifyOwnerOnOverextension:1;
    BITFIELD bTeleportOnOverextension:1;
    BITFIELD bUseKinActorForBoneSpring:1;
    BITFIELD bMakeSpringToBaseCollisionComponent:1;
    BITFIELD bOnlyCollideWithPawns:1;
    BITFIELD bEnableCollisionResponse:1;
    BITFIELD bPushBody:1;
    BITFIELD bForceUnfixed:1;
    BITFIELD bInstanceAlwaysFullAnimWeight:1;
    FLOAT BoneLinearSpring;
    FLOAT BoneLinearDamping;
    FLOAT BoneAngularSpring;
    FLOAT BoneAngularDamping;
    FLOAT OverextensionThreshold;
    FLOAT CustomGravityFactor;
    FLOAT LastEffectPlayedTime;
    class UPhysicalMaterial* PhysMaterialOverride;
    FLOAT ContactReportForceThreshold;
    FLOAT InstanceMassScale;
    FLOAT InstanceDampingScale;
    //## END PROPS RB_BodyInstance

    FLOAT GetBodyMass();
    void SetFixed(UBOOL bNewFixed);
    UBOOL IsFixed();
    UBOOL IsValidBodyInstance();
    class UPhysicsAssetInstance* GetPhysicsAssetInstance();
    FMatrix GetUnrealWorldTM();
    FVector GetUnrealWorldVelocity();
    FVector GetUnrealWorldAngularVelocity();
    FVector GetUnrealWorldVelocityAtPoint(FVector Point);
    void EnableBoneSpring(UBOOL bInEnableLinear,UBOOL bInEnableAngular,const FMatrix& InBoneTarget);
    void SetBoneSpringParams(FLOAT InLinearSpring,FLOAT InLinearDamping,FLOAT InAngularSpring,FLOAT InAngularDamping);
    void SetBoneSpringTarget(const FMatrix& InBoneTarget,UBOOL bTeleport);
    void SetBlockRigidBody(UBOOL bNewBlockRigidBody);
    void SetPhysMaterialOverride(class UPhysicalMaterial* NewPhysMaterial);
    void EnableCollisionResponse(UBOOL bEnableResponse);
    void SetContactReportForceThreshold(FLOAT Threshold);
    void UpdateMassProperties(class URB_BodySetup* Setup);
    void UpdateDampingProperties();
    DECLARE_FUNCTION(execGetBodyMass)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetBodyMass();
    }
    DECLARE_FUNCTION(execSetFixed)
    {
        P_GET_UBOOL(bNewFixed);
        P_FINISH;
        this->SetFixed(bNewFixed);
    }
    DECLARE_FUNCTION(execIsFixed)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsFixed();
    }
    DECLARE_FUNCTION(execIsValidBodyInstance)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsValidBodyInstance();
    }
    DECLARE_FUNCTION(execGetPhysicsAssetInstance)
    {
        P_FINISH;
        *(class UPhysicsAssetInstance**)Result=this->GetPhysicsAssetInstance();
    }
    DECLARE_FUNCTION(execGetUnrealWorldTM)
    {
        P_FINISH;
        *(FMatrix*)Result=this->GetUnrealWorldTM();
    }
    DECLARE_FUNCTION(execGetUnrealWorldVelocity)
    {
        P_FINISH;
        *(FVector*)Result=this->GetUnrealWorldVelocity();
    }
    DECLARE_FUNCTION(execGetUnrealWorldAngularVelocity)
    {
        P_FINISH;
        *(FVector*)Result=this->GetUnrealWorldAngularVelocity();
    }
    DECLARE_FUNCTION(execGetUnrealWorldVelocityAtPoint)
    {
        P_GET_STRUCT(FVector,Point);
        P_FINISH;
        *(FVector*)Result=this->GetUnrealWorldVelocityAtPoint(Point);
    }
    DECLARE_FUNCTION(execEnableBoneSpring)
    {
        P_GET_UBOOL(bInEnableLinear);
        P_GET_UBOOL(bInEnableAngular);
        P_GET_STRUCT_REF(FMatrix,InBoneTarget);
        P_FINISH;
        this->EnableBoneSpring(bInEnableLinear,bInEnableAngular,InBoneTarget);
    }
    DECLARE_FUNCTION(execSetBoneSpringParams)
    {
        P_GET_FLOAT(InLinearSpring);
        P_GET_FLOAT(InLinearDamping);
        P_GET_FLOAT(InAngularSpring);
        P_GET_FLOAT(InAngularDamping);
        P_FINISH;
        this->SetBoneSpringParams(InLinearSpring,InLinearDamping,InAngularSpring,InAngularDamping);
    }
    DECLARE_FUNCTION(execSetBoneSpringTarget)
    {
        P_GET_STRUCT_REF(FMatrix,InBoneTarget);
        P_GET_UBOOL(bTeleport);
        P_FINISH;
        this->SetBoneSpringTarget(InBoneTarget,bTeleport);
    }
    DECLARE_FUNCTION(execSetBlockRigidBody)
    {
        P_GET_UBOOL(bNewBlockRigidBody);
        P_FINISH;
        this->SetBlockRigidBody(bNewBlockRigidBody);
    }
    DECLARE_FUNCTION(execSetPhysMaterialOverride)
    {
        P_GET_OBJECT(UPhysicalMaterial,NewPhysMaterial);
        P_FINISH;
        this->SetPhysMaterialOverride(NewPhysMaterial);
    }
    DECLARE_FUNCTION(execEnableCollisionResponse)
    {
        P_GET_UBOOL(bEnableResponse);
        P_FINISH;
        this->EnableCollisionResponse(bEnableResponse);
    }
    DECLARE_FUNCTION(execSetContactReportForceThreshold)
    {
        P_GET_FLOAT(Threshold);
        P_FINISH;
        this->SetContactReportForceThreshold(Threshold);
    }
    DECLARE_FUNCTION(execUpdateMassProperties)
    {
        P_GET_OBJECT(URB_BodySetup,Setup);
        P_FINISH;
        this->UpdateMassProperties(Setup);
    }
    DECLARE_FUNCTION(execUpdateDampingProperties)
    {
        P_FINISH;
        this->UpdateDampingProperties();
    }
    DECLARE_CLASS(URB_BodyInstance,UObject,0,Engine)
	// Object interface
	virtual void FinishDestroy();

	// RB_BodyInstance interface
	void InitBody(class URB_BodySetup* setup, const FMatrix& transform, const FVector& Scale3D, UBOOL bFixed, UPrimitiveComponent* PrimComp, FRBPhysScene* InRBScene);
	UBOOL TermBody(FRBPhysScene* Scene);

	FVector GetCOMPosition();
	void DrawCOMPosition( FPrimitiveDrawInterface* PDI, FLOAT COMRenderSize, const FColor& COMRenderColor );

	/** Utility for copying properties from one BodyInstance to another. */
	void CopyBodyInstancePropertiesFrom(URB_BodyInstance* FromInst);

	UPhysicalMaterial* GetPhysicalMaterial();

#if WITH_NOVODEX
	class NxActor* GetNxActor();
	void UpdatePhysMaterialOverride();
#endif
};

class URB_ConstraintInstance : public UObject
{
public:
    //## BEGIN PROPS RB_ConstraintInstance
    class AActor* Owner;
    class UPrimitiveComponent* OwnerComponent;
    INT ConstraintIndex;
    INT SceneIndex;
    BITFIELD bInHardware:1;
    BITFIELD bLinearXPositionDrive:1;
    BITFIELD bLinearXVelocityDrive:1;
    BITFIELD bLinearYPositionDrive:1;
    BITFIELD bLinearYVelocityDrive:1;
    BITFIELD bLinearZPositionDrive:1;
    BITFIELD bLinearZVelocityDrive:1;
    BITFIELD bSwingPositionDrive:1;
    BITFIELD bSwingVelocityDrive:1;
    BITFIELD bTwistPositionDrive:1;
    BITFIELD bTwistVelocityDrive:1;
    BITFIELD bAngularSlerpDrive:1;
    BITFIELD bTerminated:1;
    SCRIPT_ALIGN;
    class NxJoint* ConstraintData;
    FVector LinearPositionTarget;
    FVector LinearVelocityTarget;
    FLOAT LinearDriveSpring;
    FLOAT LinearDriveDamping;
    FLOAT LinearDriveForceLimit;
    FQuat AngularPositionTarget;
    FVector AngularVelocityTarget;
    FLOAT AngularDriveSpring;
    FLOAT AngularDriveDamping;
    FLOAT AngularDriveForceLimit;
    FPointer DummyKinActor;
    //## END PROPS RB_ConstraintInstance

    void InitConstraint(class UPrimitiveComponent* PrimComp1,class UPrimitiveComponent* PrimComp2,class URB_ConstraintSetup* Setup,FLOAT Scale,class AActor* InOwner,class UPrimitiveComponent* InPrimComp,UBOOL bMakeKinForBody1);
    class UPhysicsAssetInstance* GetPhysicsAssetInstance();
    FVector GetConstraintLocation();
    void SetLinearPositionDrive(UBOOL bEnableXDrive,UBOOL bEnableYDrive,UBOOL bEnableZDrive);
    void SetLinearVelocityDrive(UBOOL bEnableXDrive,UBOOL bEnableYDrive,UBOOL bEnableZDrive);
    void SetAngularPositionDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive);
    void SetAngularVelocityDrive(UBOOL bEnableSwingDrive,UBOOL bEnableTwistDrive);
    void SetLinearPositionTarget(FVector InPosTarget);
    void SetLinearVelocityTarget(FVector InVelTarget);
    void SetLinearDriveParams(FLOAT InSpring,FLOAT InDamping,FLOAT InForceLimit);
    void SetAngularPositionTarget(const FQuat& InPosTarget);
    void SetAngularVelocityTarget(FVector InVelTarget);
    void SetAngularDriveParams(FLOAT InSpring,FLOAT InDamping,FLOAT InForceLimit);
    void SetAngularDOFLimitScale(FLOAT InSwing1LimitScale,FLOAT InSwing2LimitScale,FLOAT InTwistLimitScale,class URB_ConstraintSetup* InSetup);
    void SetLinearLimitSize(FLOAT NewLimitSize);
    void MoveKinActorTransform(FMatrix& NewTM);
    DECLARE_FUNCTION(execInitConstraint)
    {
        P_GET_OBJECT(UPrimitiveComponent,PrimComp1);
        P_GET_OBJECT(UPrimitiveComponent,PrimComp2);
        P_GET_OBJECT(URB_ConstraintSetup,Setup);
        P_GET_FLOAT(Scale);
        P_GET_OBJECT(AActor,InOwner);
        P_GET_OBJECT(UPrimitiveComponent,InPrimComp);
        P_GET_UBOOL(bMakeKinForBody1);
        P_FINISH;
        this->InitConstraint(PrimComp1,PrimComp2,Setup,Scale,InOwner,InPrimComp,bMakeKinForBody1);
    }
    DECLARE_FUNCTION(execTermConstraint);
    DECLARE_FUNCTION(execGetPhysicsAssetInstance)
    {
        P_FINISH;
        *(class UPhysicsAssetInstance**)Result=this->GetPhysicsAssetInstance();
    }
    DECLARE_FUNCTION(execGetConstraintLocation)
    {
        P_FINISH;
        *(FVector*)Result=this->GetConstraintLocation();
    }
    DECLARE_FUNCTION(execSetLinearPositionDrive)
    {
        P_GET_UBOOL(bEnableXDrive);
        P_GET_UBOOL(bEnableYDrive);
        P_GET_UBOOL(bEnableZDrive);
        P_FINISH;
        this->SetLinearPositionDrive(bEnableXDrive,bEnableYDrive,bEnableZDrive);
    }
    DECLARE_FUNCTION(execSetLinearVelocityDrive)
    {
        P_GET_UBOOL(bEnableXDrive);
        P_GET_UBOOL(bEnableYDrive);
        P_GET_UBOOL(bEnableZDrive);
        P_FINISH;
        this->SetLinearVelocityDrive(bEnableXDrive,bEnableYDrive,bEnableZDrive);
    }
    DECLARE_FUNCTION(execSetAngularPositionDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_FINISH;
        this->SetAngularPositionDrive(bEnableSwingDrive,bEnableTwistDrive);
    }
    DECLARE_FUNCTION(execSetAngularVelocityDrive)
    {
        P_GET_UBOOL(bEnableSwingDrive);
        P_GET_UBOOL(bEnableTwistDrive);
        P_FINISH;
        this->SetAngularVelocityDrive(bEnableSwingDrive,bEnableTwistDrive);
    }
    DECLARE_FUNCTION(execSetLinearPositionTarget)
    {
        P_GET_STRUCT(FVector,InPosTarget);
        P_FINISH;
        this->SetLinearPositionTarget(InPosTarget);
    }
    DECLARE_FUNCTION(execSetLinearVelocityTarget)
    {
        P_GET_STRUCT(FVector,InVelTarget);
        P_FINISH;
        this->SetLinearVelocityTarget(InVelTarget);
    }
    DECLARE_FUNCTION(execSetLinearDriveParams)
    {
        P_GET_FLOAT(InSpring);
        P_GET_FLOAT(InDamping);
        P_GET_FLOAT(InForceLimit);
        P_FINISH;
        this->SetLinearDriveParams(InSpring,InDamping,InForceLimit);
    }
    DECLARE_FUNCTION(execSetAngularPositionTarget)
    {
        P_GET_STRUCT_REF(FQuat,InPosTarget);
        P_FINISH;
        this->SetAngularPositionTarget(InPosTarget);
    }
    DECLARE_FUNCTION(execSetAngularVelocityTarget)
    {
        P_GET_STRUCT(FVector,InVelTarget);
        P_FINISH;
        this->SetAngularVelocityTarget(InVelTarget);
    }
    DECLARE_FUNCTION(execSetAngularDriveParams)
    {
        P_GET_FLOAT(InSpring);
        P_GET_FLOAT(InDamping);
        P_GET_FLOAT(InForceLimit);
        P_FINISH;
        this->SetAngularDriveParams(InSpring,InDamping,InForceLimit);
    }
    DECLARE_FUNCTION(execSetAngularDOFLimitScale)
    {
        P_GET_FLOAT(InSwing1LimitScale);
        P_GET_FLOAT(InSwing2LimitScale);
        P_GET_FLOAT(InTwistLimitScale);
        P_GET_OBJECT(URB_ConstraintSetup,InSetup);
        P_FINISH;
        this->SetAngularDOFLimitScale(InSwing1LimitScale,InSwing2LimitScale,InTwistLimitScale,InSetup);
    }
    DECLARE_FUNCTION(execSetLinearLimitSize)
    {
        P_GET_FLOAT(NewLimitSize);
        P_FINISH;
        this->SetLinearLimitSize(NewLimitSize);
    }
    DECLARE_FUNCTION(execMoveKinActorTransform)
    {
        P_GET_STRUCT_REF(FMatrix,NewTM);
        P_FINISH;
        this->MoveKinActorTransform(NewTM);
    }
    DECLARE_CLASS(URB_ConstraintInstance,UObject,0,Engine)
	// Object interface
	virtual void FinishDestroy();

	// RB_ConstraintInstance interface

	UBOOL TermConstraint(FRBPhysScene* Scene, UBOOL bFireBrokenEvent);

	void CopyInstanceParamsFrom(class URB_ConstraintInstance* fromInstance);
};

struct FLinearDOFSetup
{
    BYTE bLimited;
    FLOAT LimitSize;

    /** Constructors */
    FLinearDOFSetup() {}
    FLinearDOFSetup(EEventParm)
    {
        appMemzero(this, sizeof(FLinearDOFSetup));
    }
};

class URB_ConstraintSetup : public UObject
{
public:
    //## BEGIN PROPS RB_ConstraintSetup
    FName JointName;
    FName ConstraintBone1;
    FName ConstraintBone2;
    FVector Pos1;
    FVector PriAxis1;
    FVector SecAxis1;
    FVector Pos2;
    FVector PriAxis2;
    FVector SecAxis2;
    FVector PulleyPivot1;
    FVector PulleyPivot2;
    BITFIELD bEnableProjection:1;
    BITFIELD bLinearLimitSoft:1;
    BITFIELD bLinearBreakable:1;
    BITFIELD bSwingLimited:1;
    BITFIELD bTwistLimited:1;
    BITFIELD bSwingLimitSoft:1;
    BITFIELD bTwistLimitSoft:1;
    BITFIELD bAngularBreakable:1;
    BITFIELD bIsPulley:1;
    BITFIELD bMaintainMinDistance:1;
    SCRIPT_ALIGN;
    struct FLinearDOFSetup LinearXSetup;
    struct FLinearDOFSetup LinearYSetup;
    struct FLinearDOFSetup LinearZSetup;
    FLOAT LinearLimitStiffness;
    FLOAT LinearLimitDamping;
    FLOAT LinearBreakThreshold;
    FLOAT Swing1LimitAngle;
    FLOAT Swing2LimitAngle;
    FLOAT TwistLimitAngle;
    FLOAT SwingLimitStiffness;
    FLOAT SwingLimitDamping;
    FLOAT TwistLimitStiffness;
    FLOAT TwistLimitDamping;
    FLOAT AngularBreakThreshold;
    FLOAT PulleyRatio;
    //## END PROPS RB_ConstraintSetup

    DECLARE_CLASS(URB_ConstraintSetup,UObject,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// Get/SetRefFrameMatrix only used in PhAT
	FMatrix GetRefFrameMatrix(INT BodyIndex);
	void SetRefFrameMatrix(INT BodyIndex, const FMatrix& RefFrame);

	void CopyConstraintGeometryFrom(class URB_ConstraintSetup* fromSetup);
	void CopyConstraintParamsFrom(class URB_ConstraintSetup* fromSetup);

	void DrawConstraint(class FPrimitiveDrawInterface* PDI, 
		FLOAT Scale, FLOAT LimitDrawScale, UBOOL bDrawLimits, UBOOL bDrawSelected, UMaterialInterface* LimitMaterial,
		const FMatrix& Con1Frame, const FMatrix& Con2Frame, UBOOL bDrawAsPoint);
};

class URB_BSJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_BSJointSetup
    //## END PROPS RB_BSJointSetup

    DECLARE_CLASS(URB_BSJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_BSJointSetup)
};

class URB_DistanceJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_DistanceJointSetup
    //## END PROPS RB_DistanceJointSetup

    DECLARE_CLASS(URB_DistanceJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_DistanceJointSetup)
};

class URB_HingeSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_HingeSetup
    //## END PROPS RB_HingeSetup

    DECLARE_CLASS(URB_HingeSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_HingeSetup)
};

class URB_PrismaticSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_PrismaticSetup
    //## END PROPS RB_PrismaticSetup

    DECLARE_CLASS(URB_PrismaticSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_PrismaticSetup)
};

class URB_PulleyJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_PulleyJointSetup
    //## END PROPS RB_PulleyJointSetup

    DECLARE_CLASS(URB_PulleyJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_PulleyJointSetup)
};

class URB_SkelJointSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_SkelJointSetup
    //## END PROPS RB_SkelJointSetup

    DECLARE_CLASS(URB_SkelJointSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_SkelJointSetup)
};

class URB_StayUprightSetup : public URB_ConstraintSetup
{
public:
    //## BEGIN PROPS RB_StayUprightSetup
    //## END PROPS RB_StayUprightSetup

    DECLARE_CLASS(URB_StayUprightSetup,URB_ConstraintSetup,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(URB_StayUprightSetup)
};

class USVehicleWheel : public UComponent
{
public:
    //## BEGIN PROPS SVehicleWheel
    FLOAT Steer;
    FLOAT MotorTorque;
    FLOAT BrakeTorque;
    FLOAT ChassisTorque;
    BITFIELD bPoweredWheel:1;
    BITFIELD bHoverWheel:1;
    BITFIELD bCollidesVehicles:1;
    BITFIELD bCollidesPawns:1;
    BITFIELD bIsSquealing:1;
    BITFIELD bWheelOnGround:1;
    FLOAT SteerFactor;
    FName SkelControlName;
    class USkelControlWheel* WheelControl;
    FName BoneName;
    FVector BoneOffset;
    FLOAT WheelRadius;
    FLOAT SuspensionTravel;
    FLOAT SuspensionSpeed;
    class UParticleSystem* WheelParticleSystem;
    BYTE Side;
    FLOAT LongSlipFactor;
    FLOAT LatSlipFactor;
    FLOAT HandbrakeLongSlipFactor;
    FLOAT HandbrakeLatSlipFactor;
    FLOAT ParkedSlipFactor;
    FVector WheelPosition;
    FLOAT SpinVel;
    FLOAT LongSlipRatio;
    FLOAT LatSlipAngle;
    FVector ContactNormal;
    FVector LongDirection;
    FVector LatDirection;
    FLOAT ContactForce;
    FLOAT LongImpulse;
    FLOAT LatImpulse;
    FLOAT DesiredSuspensionPosition;
    FLOAT SuspensionPosition;
    FLOAT CurrentRotation;
    FPointer WheelShape;
    INT WheelMaterialIndex;
    class UClass* WheelPSCClass;
    class UParticleSystemComponent* WheelParticleComp;
    FName SlipParticleParamName;
    //## END PROPS SVehicleWheel

    DECLARE_CLASS(USVehicleWheel,UComponent,0,Engine)
#if WITH_NOVODEX
	class NxWheelShape* GetNxWheelShape()
	{
		return (NxWheelShape*)WheelShape;
	}
#endif

	/** @return whether this wheel wants a particle component attached to it */
	virtual UBOOL WantsParticleComponent();
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_PHYSICS_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AKActor,-1,execResolveRBState);
AUTOGENERATE_FUNCTION(AKActor,-1,execGetKActorPhysMaterial);
AUTOGENERATE_FUNCTION(AKActorFromStatic,-1,execMakeDynamic);
AUTOGENERATE_FUNCTION(AKActorFromStatic,-1,execMakeStatic);
AUTOGENERATE_FUNCTION(AKActorFromStatic,-1,execDisablePrecomputedLighting);
AUTOGENERATE_FUNCTION(AKActorSpawnable,-1,execResetComponents);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execHasWheelsOnGround);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execInitVehicleRagdoll);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execSetWheelCollision);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execIsSleeping);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execAddTorque);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execAddImpulse);
AUTOGENERATE_FUNCTION(ASVehicle,-1,execAddForce);
AUTOGENERATE_FUNCTION(ARB_ConstraintActor,-1,execTermConstraint);
AUTOGENERATE_FUNCTION(ARB_ConstraintActor,-1,execInitConstraint);
AUTOGENERATE_FUNCTION(ARB_ConstraintActor,-1,execSetDisableCollision);
AUTOGENERATE_FUNCTION(ARB_LineImpulseActor,-1,execFireLineImpulse);
AUTOGENERATE_FUNCTION(URB_RadialImpulseComponent,-1,execFireImpulse);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execGetOrientation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execSetOrientation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execUpdateSmoothLocation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execSetSmoothLocation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execSetLocation);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execReleaseComponent);
AUTOGENERATE_FUNCTION(URB_Handle,-1,execGrabComponent);
AUTOGENERATE_FUNCTION(URB_Spring,-1,execClear);
AUTOGENERATE_FUNCTION(URB_Spring,-1,execSetComponents);
AUTOGENERATE_FUNCTION(UPhysicalMaterial,-1,execFindPhysEffectInfo);
AUTOGENERATE_FUNCTION(UPhysicsAsset,-1,execFindBodyIndex);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execFindConstraintInstance);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execFindBodyInstance);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetFullAnimWeightBonesFixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetFullAnimWeightBlockRigidBody);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedBodiesBlockRigidBody);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedRBBoneSprings);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedMotorsAngularVelocityDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedMotorsAngularPositionDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllMotorsAngularDriveParams);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllMotorsAngularVelocityDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllMotorsAngularPositionDrive);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execForceAllBodiesBelowUnfixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetNamedBodiesFixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAllBodiesFixed);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execGetTotalMassBelowBone);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetAngularDriveScale);
AUTOGENERATE_FUNCTION(UPhysicsAssetInstance,-1,execSetLinearDriveScale);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execUpdateDampingProperties);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execUpdateMassProperties);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetContactReportForceThreshold);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execEnableCollisionResponse);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetPhysMaterialOverride);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetBlockRigidBody);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetBoneSpringTarget);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetBoneSpringParams);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execEnableBoneSpring);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetUnrealWorldVelocityAtPoint);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetUnrealWorldAngularVelocity);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetUnrealWorldVelocity);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetUnrealWorldTM);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetPhysicsAssetInstance);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execIsValidBodyInstance);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execIsFixed);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execSetFixed);
AUTOGENERATE_FUNCTION(URB_BodyInstance,-1,execGetBodyMass);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execMoveKinActorTransform);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearLimitSize);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularDOFLimitScale);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularDriveParams);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularVelocityTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularPositionTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearDriveParams);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearVelocityTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearPositionTarget);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularVelocityDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetAngularPositionDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearVelocityDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execSetLinearPositionDrive);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execGetConstraintLocation);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execGetPhysicsAssetInstance);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execTermConstraint);
AUTOGENERATE_FUNCTION(URB_ConstraintInstance,-1,execInitConstraint);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_PHYSICS_NATIVE_DEFS
#define ENGINE_PHYSICS_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_PHYSICS \
	AKActor::StaticClass(); \
	GNativeLookupFuncs.Set(FName("KActor"), GEngineAKActorNatives); \
	AKActorFromStatic::StaticClass(); \
	GNativeLookupFuncs.Set(FName("KActorFromStatic"), GEngineAKActorFromStaticNatives); \
	AKActorSpawnable::StaticClass(); \
	GNativeLookupFuncs.Set(FName("KActorSpawnable"), GEngineAKActorSpawnableNatives); \
	AKAsset::StaticClass(); \
	ASVehicle::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SVehicle"), GEngineASVehicleNatives); \
	ARB_ConstraintActor::StaticClass(); \
	GNativeLookupFuncs.Set(FName("RB_ConstraintActor"), GEngineARB_ConstraintActorNatives); \
	ARB_LineImpulseActor::StaticClass(); \
	GNativeLookupFuncs.Set(FName("RB_LineImpulseActor"), GEngineARB_LineImpulseActorNatives); \
	ARB_RadialImpulseActor::StaticClass(); \
	ARB_Thruster::StaticClass(); \
	AWorldAttractor::StaticClass(); \
	URB_ConstraintDrawComponent::StaticClass(); \
	URB_RadialImpulseComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("RB_RadialImpulseComponent"), GEngineURB_RadialImpulseComponentNatives); \
	URB_Handle::StaticClass(); \
	GNativeLookupFuncs.Set(FName("RB_Handle"), GEngineURB_HandleNatives); \
	URB_Spring::StaticClass(); \
	GNativeLookupFuncs.Set(FName("RB_Spring"), GEngineURB_SpringNatives); \
	USVehicleSimBase::StaticClass(); \
	USVehicleSimCar::StaticClass(); \
	USVehicleSimTank::StaticClass(); \
	UActorFactoryApexClothing::StaticClass(); \
	UApexDestructibleDamageParameters::StaticClass(); \
	UFractureMaterial::StaticClass(); \
	URB_BodySetup::StaticClass(); \
	UPhysicalMaterial::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PhysicalMaterial"), GEngineUPhysicalMaterialNatives); \
	UPhysicalMaterialPropertyBase::StaticClass(); \
	UPhysicsAsset::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PhysicsAsset"), GEngineUPhysicsAssetNatives); \
	UPhysicsAssetInstance::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PhysicsAssetInstance"), GEngineUPhysicsAssetInstanceNatives); \
	UPhysicsLODVerticalEmitter::StaticClass(); \
	URB_BodyInstance::StaticClass(); \
	GNativeLookupFuncs.Set(FName("RB_BodyInstance"), GEngineURB_BodyInstanceNatives); \
	URB_ConstraintInstance::StaticClass(); \
	GNativeLookupFuncs.Set(FName("RB_ConstraintInstance"), GEngineURB_ConstraintInstanceNatives); \
	URB_ConstraintSetup::StaticClass(); \
	URB_BSJointSetup::StaticClass(); \
	URB_DistanceJointSetup::StaticClass(); \
	URB_HingeSetup::StaticClass(); \
	URB_PrismaticSetup::StaticClass(); \
	URB_PulleyJointSetup::StaticClass(); \
	URB_SkelJointSetup::StaticClass(); \
	URB_StayUprightSetup::StaticClass(); \
	USVehicleWheel::StaticClass(); \

#endif // ENGINE_PHYSICS_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineAKActorNatives[] = 
{ 
	MAP_NATIVE(AKActor, execResolveRBState)
	MAP_NATIVE(AKActor, execGetKActorPhysMaterial)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAKActorFromStaticNatives[] = 
{ 
	MAP_NATIVE(AKActorFromStatic, execMakeDynamic)
	MAP_NATIVE(AKActorFromStatic, execMakeStatic)
	MAP_NATIVE(AKActorFromStatic, execDisablePrecomputedLighting)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAKActorSpawnableNatives[] = 
{ 
	MAP_NATIVE(AKActorSpawnable, execResetComponents)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineASVehicleNatives[] = 
{ 
	MAP_NATIVE(ASVehicle, execHasWheelsOnGround)
	MAP_NATIVE(ASVehicle, execInitVehicleRagdoll)
	MAP_NATIVE(ASVehicle, execSetWheelCollision)
	MAP_NATIVE(ASVehicle, execIsSleeping)
	MAP_NATIVE(ASVehicle, execAddTorque)
	MAP_NATIVE(ASVehicle, execAddImpulse)
	MAP_NATIVE(ASVehicle, execAddForce)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineARB_ConstraintActorNatives[] = 
{ 
	MAP_NATIVE(ARB_ConstraintActor, execTermConstraint)
	MAP_NATIVE(ARB_ConstraintActor, execInitConstraint)
	MAP_NATIVE(ARB_ConstraintActor, execSetDisableCollision)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineARB_LineImpulseActorNatives[] = 
{ 
	MAP_NATIVE(ARB_LineImpulseActor, execFireLineImpulse)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineURB_RadialImpulseComponentNatives[] = 
{ 
	MAP_NATIVE(URB_RadialImpulseComponent, execFireImpulse)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineURB_HandleNatives[] = 
{ 
	MAP_NATIVE(URB_Handle, execGetOrientation)
	MAP_NATIVE(URB_Handle, execSetOrientation)
	MAP_NATIVE(URB_Handle, execUpdateSmoothLocation)
	MAP_NATIVE(URB_Handle, execSetSmoothLocation)
	MAP_NATIVE(URB_Handle, execSetLocation)
	MAP_NATIVE(URB_Handle, execReleaseComponent)
	MAP_NATIVE(URB_Handle, execGrabComponent)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineURB_SpringNatives[] = 
{ 
	MAP_NATIVE(URB_Spring, execClear)
	MAP_NATIVE(URB_Spring, execSetComponents)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUPhysicalMaterialNatives[] = 
{ 
	MAP_NATIVE(UPhysicalMaterial, execFindPhysEffectInfo)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUPhysicsAssetNatives[] = 
{ 
	MAP_NATIVE(UPhysicsAsset, execFindBodyIndex)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUPhysicsAssetInstanceNatives[] = 
{ 
	MAP_NATIVE(UPhysicsAssetInstance, execFindConstraintInstance)
	MAP_NATIVE(UPhysicsAssetInstance, execFindBodyInstance)
	MAP_NATIVE(UPhysicsAssetInstance, execSetFullAnimWeightBonesFixed)
	MAP_NATIVE(UPhysicsAssetInstance, execSetFullAnimWeightBlockRigidBody)
	MAP_NATIVE(UPhysicsAssetInstance, execSetNamedBodiesBlockRigidBody)
	MAP_NATIVE(UPhysicsAssetInstance, execSetNamedRBBoneSprings)
	MAP_NATIVE(UPhysicsAssetInstance, execSetNamedMotorsAngularVelocityDrive)
	MAP_NATIVE(UPhysicsAssetInstance, execSetNamedMotorsAngularPositionDrive)
	MAP_NATIVE(UPhysicsAssetInstance, execSetAllMotorsAngularDriveParams)
	MAP_NATIVE(UPhysicsAssetInstance, execSetAllMotorsAngularVelocityDrive)
	MAP_NATIVE(UPhysicsAssetInstance, execSetAllMotorsAngularPositionDrive)
	MAP_NATIVE(UPhysicsAssetInstance, execForceAllBodiesBelowUnfixed)
	MAP_NATIVE(UPhysicsAssetInstance, execSetNamedBodiesFixed)
	MAP_NATIVE(UPhysicsAssetInstance, execSetAllBodiesFixed)
	MAP_NATIVE(UPhysicsAssetInstance, execGetTotalMassBelowBone)
	MAP_NATIVE(UPhysicsAssetInstance, execSetAngularDriveScale)
	MAP_NATIVE(UPhysicsAssetInstance, execSetLinearDriveScale)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineURB_BodyInstanceNatives[] = 
{ 
	MAP_NATIVE(URB_BodyInstance, execUpdateDampingProperties)
	MAP_NATIVE(URB_BodyInstance, execUpdateMassProperties)
	MAP_NATIVE(URB_BodyInstance, execSetContactReportForceThreshold)
	MAP_NATIVE(URB_BodyInstance, execEnableCollisionResponse)
	MAP_NATIVE(URB_BodyInstance, execSetPhysMaterialOverride)
	MAP_NATIVE(URB_BodyInstance, execSetBlockRigidBody)
	MAP_NATIVE(URB_BodyInstance, execSetBoneSpringTarget)
	MAP_NATIVE(URB_BodyInstance, execSetBoneSpringParams)
	MAP_NATIVE(URB_BodyInstance, execEnableBoneSpring)
	MAP_NATIVE(URB_BodyInstance, execGetUnrealWorldVelocityAtPoint)
	MAP_NATIVE(URB_BodyInstance, execGetUnrealWorldAngularVelocity)
	MAP_NATIVE(URB_BodyInstance, execGetUnrealWorldVelocity)
	MAP_NATIVE(URB_BodyInstance, execGetUnrealWorldTM)
	MAP_NATIVE(URB_BodyInstance, execGetPhysicsAssetInstance)
	MAP_NATIVE(URB_BodyInstance, execIsValidBodyInstance)
	MAP_NATIVE(URB_BodyInstance, execIsFixed)
	MAP_NATIVE(URB_BodyInstance, execSetFixed)
	MAP_NATIVE(URB_BodyInstance, execGetBodyMass)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineURB_ConstraintInstanceNatives[] = 
{ 
	MAP_NATIVE(URB_ConstraintInstance, execMoveKinActorTransform)
	MAP_NATIVE(URB_ConstraintInstance, execSetLinearLimitSize)
	MAP_NATIVE(URB_ConstraintInstance, execSetAngularDOFLimitScale)
	MAP_NATIVE(URB_ConstraintInstance, execSetAngularDriveParams)
	MAP_NATIVE(URB_ConstraintInstance, execSetAngularVelocityTarget)
	MAP_NATIVE(URB_ConstraintInstance, execSetAngularPositionTarget)
	MAP_NATIVE(URB_ConstraintInstance, execSetLinearDriveParams)
	MAP_NATIVE(URB_ConstraintInstance, execSetLinearVelocityTarget)
	MAP_NATIVE(URB_ConstraintInstance, execSetLinearPositionTarget)
	MAP_NATIVE(URB_ConstraintInstance, execSetAngularVelocityDrive)
	MAP_NATIVE(URB_ConstraintInstance, execSetAngularPositionDrive)
	MAP_NATIVE(URB_ConstraintInstance, execSetLinearVelocityDrive)
	MAP_NATIVE(URB_ConstraintInstance, execSetLinearPositionDrive)
	MAP_NATIVE(URB_ConstraintInstance, execGetConstraintLocation)
	MAP_NATIVE(URB_ConstraintInstance, execGetPhysicsAssetInstance)
	MAP_NATIVE(URB_ConstraintInstance, execTermConstraint)
	MAP_NATIVE(URB_ConstraintInstance, execInitConstraint)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(AKActor,KActor,ImpactEffectComponent)
VERIFY_CLASS_OFFSET_NODIE(AKActor,KActor,InitialRotation)
VERIFY_CLASS_SIZE_NODIE(AKActor)
VERIFY_CLASS_OFFSET_NODIE(AKActorFromStatic,KActorFromStatic,MyStaticMeshActor)
VERIFY_CLASS_OFFSET_NODIE(AKActorFromStatic,KActorFromStatic,MaxImpulseSpeed)
VERIFY_CLASS_SIZE_NODIE(AKActorFromStatic)
VERIFY_CLASS_SIZE_NODIE(AKActorSpawnable)
VERIFY_CLASS_OFFSET_NODIE(AKAsset,KAsset,SkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(AKAsset,KAsset,ReplicatedPhysAsset)
VERIFY_CLASS_SIZE_NODIE(AKAsset)
VERIFY_CLASS_OFFSET_NODIE(ASVehicle,SVehicle,SimObj)
VERIFY_CLASS_OFFSET_NODIE(ASVehicle,SVehicle,RadialImpulseScaling)
VERIFY_CLASS_SIZE_NODIE(ASVehicle)
VERIFY_CLASS_OFFSET_NODIE(ARB_ConstraintActor,RB_ConstraintActor,ConstraintActor1)
VERIFY_CLASS_OFFSET_NODIE(ARB_ConstraintActor,RB_ConstraintActor,PulleyPivotActor2)
VERIFY_CLASS_SIZE_NODIE(ARB_ConstraintActor)
VERIFY_CLASS_OFFSET_NODIE(ARB_LineImpulseActor,RB_LineImpulseActor,ImpulseStrength)
VERIFY_CLASS_OFFSET_NODIE(ARB_LineImpulseActor,RB_LineImpulseActor,ImpulseCount)
VERIFY_CLASS_SIZE_NODIE(ARB_LineImpulseActor)
VERIFY_CLASS_OFFSET_NODIE(ARB_RadialImpulseActor,RB_RadialImpulseActor,RenderComponent)
VERIFY_CLASS_OFFSET_NODIE(ARB_RadialImpulseActor,RB_RadialImpulseActor,ImpulseCount)
VERIFY_CLASS_SIZE_NODIE(ARB_RadialImpulseActor)
VERIFY_CLASS_OFFSET_NODIE(ARB_Thruster,RB_Thruster,ThrustStrength)
VERIFY_CLASS_SIZE_NODIE(ARB_Thruster)
VERIFY_CLASS_OFFSET_NODIE(AWorldAttractor,WorldAttractor,LoopDuration)
VERIFY_CLASS_OFFSET_NODIE(AWorldAttractor,WorldAttractor,DragRadius)
VERIFY_CLASS_SIZE_NODIE(AWorldAttractor)
VERIFY_CLASS_OFFSET_NODIE(URB_ConstraintDrawComponent,RB_ConstraintDrawComponent,LimitMaterial)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintDrawComponent)
VERIFY_CLASS_OFFSET_NODIE(URB_RadialImpulseComponent,RB_RadialImpulseComponent,ImpulseFalloff)
VERIFY_CLASS_OFFSET_NODIE(URB_RadialImpulseComponent,RB_RadialImpulseComponent,PreviewSphere)
VERIFY_CLASS_SIZE_NODIE(URB_RadialImpulseComponent)
VERIFY_CLASS_OFFSET_NODIE(URB_Handle,RB_Handle,GrabbedComponent)
VERIFY_CLASS_OFFSET_NODIE(URB_Handle,RB_Handle,Location)
VERIFY_CLASS_SIZE_NODIE(URB_Handle)
VERIFY_CLASS_OFFSET_NODIE(URB_Spring,RB_Spring,Component1)
VERIFY_CLASS_OFFSET_NODIE(URB_Spring,RB_Spring,DampMaxForce)
VERIFY_CLASS_SIZE_NODIE(URB_Spring)
VERIFY_CLASS_OFFSET_NODIE(USVehicleSimBase,SVehicleSimBase,WheelSuspensionStiffness)
VERIFY_CLASS_OFFSET_NODIE(USVehicleSimBase,SVehicleSimBase,AutoDriveSteer)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimBase)
VERIFY_CLASS_OFFSET_NODIE(USVehicleSimCar,SVehicleSimCar,ChassisTorqueScale)
VERIFY_CLASS_OFFSET_NODIE(USVehicleSimCar,SVehicleSimCar,TimeSinceThrottle)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimCar)
VERIFY_CLASS_OFFSET_NODIE(USVehicleSimTank,SVehicleSimTank,LeftTrackVel)
VERIFY_CLASS_OFFSET_NODIE(USVehicleSimTank,SVehicleSimTank,TurnGripScaleRate)
VERIFY_CLASS_SIZE_NODIE(USVehicleSimTank)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryApexClothing,ActorFactoryApexClothing,ClothingAssets)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryApexClothing,ActorFactoryApexClothing,ClothingRBCollideWithChannels)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryApexClothing)
VERIFY_CLASS_OFFSET_NODIE(UApexDestructibleDamageParameters,ApexDestructibleDamageParameters,DamageMap)
VERIFY_CLASS_SIZE_NODIE(UApexDestructibleDamageParameters)
VERIFY_CLASS_OFFSET_NODIE(UFractureMaterial,FractureMaterial,FractureEffect)
VERIFY_CLASS_OFFSET_NODIE(UFractureMaterial,FractureMaterial,FractureSound)
VERIFY_CLASS_SIZE_NODIE(UFractureMaterial)
VERIFY_CLASS_OFFSET_NODIE(URB_BodySetup,RB_BodySetup,SleepFamily)
VERIFY_CLASS_OFFSET_NODIE(URB_BodySetup,RB_BodySetup,PreCachedPhysDataVersion)
VERIFY_CLASS_SIZE_NODIE(URB_BodySetup)
VERIFY_CLASS_OFFSET_NODIE(UPhysicalMaterial,PhysicalMaterial,MaterialIndex)
VERIFY_CLASS_OFFSET_NODIE(UPhysicalMaterial,PhysicalMaterial,PhysicalMaterialProperty)
VERIFY_CLASS_SIZE_NODIE(UPhysicalMaterial)
VERIFY_CLASS_SIZE_NODIE(UPhysicalMaterialPropertyBase)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UPhysicsAsset,PhysicsAsset,DefaultSkelMesh)
#else
VERIFY_CLASS_OFFSET_NODIE(UPhysicsAsset,PhysicsAsset,BodySetup)
#endif
VERIFY_CLASS_OFFSET_NODIE(UPhysicsAsset,PhysicsAsset,DefaultInstance)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAsset)
VERIFY_CLASS_OFFSET_NODIE(UPhysicsAssetInstance,PhysicsAssetInstance,Owner)
VERIFY_CLASS_OFFSET_NODIE(UPhysicsAssetInstance,PhysicsAssetInstance,AngularForceLimitScale)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAssetInstance)
VERIFY_CLASS_OFFSET_NODIE(UPhysicsLODVerticalEmitter,PhysicsLODVerticalEmitter,ParticlePercentage)
VERIFY_CLASS_SIZE_NODIE(UPhysicsLODVerticalEmitter)
VERIFY_CLASS_OFFSET_NODIE(URB_BodyInstance,RB_BodyInstance,OwnerComponent)
VERIFY_CLASS_OFFSET_NODIE(URB_BodyInstance,RB_BodyInstance,InstanceDampingScale)
VERIFY_CLASS_SIZE_NODIE(URB_BodyInstance)
VERIFY_CLASS_OFFSET_NODIE(URB_ConstraintInstance,RB_ConstraintInstance,Owner)
VERIFY_CLASS_OFFSET_NODIE(URB_ConstraintInstance,RB_ConstraintInstance,DummyKinActor)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintInstance)
VERIFY_CLASS_OFFSET_NODIE(URB_ConstraintSetup,RB_ConstraintSetup,JointName)
VERIFY_CLASS_OFFSET_NODIE(URB_ConstraintSetup,RB_ConstraintSetup,PulleyRatio)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintSetup)
VERIFY_CLASS_SIZE_NODIE(URB_BSJointSetup)
VERIFY_CLASS_SIZE_NODIE(URB_DistanceJointSetup)
VERIFY_CLASS_SIZE_NODIE(URB_HingeSetup)
VERIFY_CLASS_SIZE_NODIE(URB_PrismaticSetup)
VERIFY_CLASS_SIZE_NODIE(URB_PulleyJointSetup)
VERIFY_CLASS_SIZE_NODIE(URB_SkelJointSetup)
VERIFY_CLASS_SIZE_NODIE(URB_StayUprightSetup)
VERIFY_CLASS_OFFSET_NODIE(USVehicleWheel,SVehicleWheel,Steer)
VERIFY_CLASS_OFFSET_NODIE(USVehicleWheel,SVehicleWheel,SlipParticleParamName)
VERIFY_CLASS_SIZE_NODIE(USVehicleWheel)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
