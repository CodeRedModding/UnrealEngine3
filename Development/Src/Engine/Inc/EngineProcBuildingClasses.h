/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_PROCBUILDING_ENUMS
#define INCLUDED_ENGINE_PROCBUILDING_ENUMS 1

enum EBuildingStatsBrowserColumns
{
    BSBC_Name               =0,
    BSBC_Ruleset            =1,
    BSBC_NumStaticMeshComps =2,
    BSBC_NumInstancedStaticMeshComps=3,
    BSBC_NumInstancedTris   =4,
    BSBC_LightmapMemBytes   =5,
    BSBC_ShadowmapMemBytes  =6,
    BSBC_LODDiffuseMemBytes =7,
    BSBC_LODLightingMemBytes=8,
    BSBC_MAX                =9,
};
#define FOREACH_ENUM_EBUILDINGSTATSBROWSERCOLUMNS(op) \
    op(BSBC_Name) \
    op(BSBC_Ruleset) \
    op(BSBC_NumStaticMeshComps) \
    op(BSBC_NumInstancedStaticMeshComps) \
    op(BSBC_NumInstancedTris) \
    op(BSBC_LightmapMemBytes) \
    op(BSBC_ShadowmapMemBytes) \
    op(BSBC_LODDiffuseMemBytes) \
    op(BSBC_LODLightingMemBytes) 
enum EPBCornerType
{
    EPBC_Default            =0,
    EPBC_Chamfer            =1,
    EPBC_Round              =2,
    EPBC_MAX                =3,
};
#define FOREACH_ENUM_EPBCORNERTYPE(op) \
    op(EPBC_Default) \
    op(EPBC_Chamfer) \
    op(EPBC_Round) 
enum EScopeEdge
{
    EPSA_Top                =0,
    EPSA_Bottom             =1,
    EPSA_Left               =2,
    EPSA_Right              =3,
    EPSA_None               =4,
    EPSA_MAX                =5,
};
#define FOREACH_ENUM_ESCOPEEDGE(op) \
    op(EPSA_Top) \
    op(EPSA_Bottom) \
    op(EPSA_Left) \
    op(EPSA_Right) \
    op(EPSA_None) 
enum EProcBuildingAxis
{
    EPBAxis_X               =0,
    EPBAxis_Z               =1,
    EPBAxis_MAX             =2,
};
#define FOREACH_ENUM_EPROCBUILDINGAXIS(op) \
    op(EPBAxis_X) \
    op(EPBAxis_Z) 
enum EProcBuildingEdge
{
    EPBE_Top                =0,
    EPBE_Bottom             =1,
    EPBE_Left               =2,
    EPBE_Right              =3,
    EPBE_MAX                =4,
};
#define FOREACH_ENUM_EPROCBUILDINGEDGE(op) \
    op(EPBE_Top) \
    op(EPBE_Bottom) \
    op(EPBE_Left) \
    op(EPBE_Right) 

#endif // !INCLUDED_ENGINE_PROCBUILDING_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_PROCBUILDING_CLASSES
#define INCLUDED_ENGINE_PROCBUILDING_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

#define UCONST_PROCBUILDING_VERSION 1
#define UCONST_ROOF_MINZ 0.7

struct FPBScope2D
{
    FMatrix ScopeFrame;
    FLOAT DimX;
    FLOAT DimZ;

		/** Draws this scope using the World line batcher */
		void DrawScope(const FColor& DrawColor, const FMatrix& BuildingToWorld, UBOOL bPersistant);
		
		/** Offset the origin of this scope in its local reference frame. */
		void OffsetLocal(const FVector& LocalOffset);

		/** Returns locaiton of the middle point of this scope */
		FVector GetCenter();
	
};

struct FPBScopeProcessInfo
{
    class AProcBuilding* OwningBuilding;
    class UProcBuildingRuleset* Ruleset;
    FName RulesetVariation;
    BITFIELD bGenerateLODPoly:1;
    BITFIELD bPartOfNonRect:1;
    SCRIPT_ALIGN;

		/** Initializing constructor */
		FPBScopeProcessInfo(INT Init)
		{
			OwningBuilding = NULL;
			Ruleset = NULL;
			RulesetVariation = NAME_None;
			bGenerateLODPoly = TRUE;
			bPartOfNonRect = FALSE;
		}
	
};

struct FPBFaceUVInfo
{
    FVector2D Offset;
    FVector2D Size;

    /** Constructors */
    FPBFaceUVInfo() {}
    FPBFaceUVInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPBFaceUVInfo));
    }
};

struct FPBEdgeInfo
{
    FVector EdgeEnd;
    FVector EdgeStart;
    INT ScopeAIndex;
    BYTE ScopeAEdge;
    INT ScopeBIndex;
    BYTE ScopeBEdge;
    FLOAT EdgeAngle;

    /** Constructors */
    FPBEdgeInfo() {}
    FPBEdgeInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPBEdgeInfo));
    }
};

struct FPBMeshCompInfo
{
    class UStaticMeshComponent* MeshComp;
    INT TopLevelScopeIndex;

    /** Constructors */
    FPBMeshCompInfo() {}
    FPBMeshCompInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPBMeshCompInfo));
    }
};

struct FPBFracMeshCompInfo
{
    class UFracturedStaticMeshComponent* FracMeshComp;
    INT TopLevelScopeIndex;

    /** Constructors */
    FPBFracMeshCompInfo() {}
    FPBFracMeshCompInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPBFracMeshCompInfo));
    }
};

struct FPBMaterialParam
{
    FName ParamName;
    FLinearColor Color;

    /** Constructors */
    FPBMaterialParam() {}
    FPBMaterialParam(EEventParm)
    {
        appMemzero(this, sizeof(FPBMaterialParam));
    }
};

struct FPBMemUsageInfo
{
    class AProcBuilding* Building;
    class UProcBuildingRuleset* Ruleset;
    INT NumStaticMeshComponent;
    INT NumInstancedStaticMeshComponents;
    INT NumInstancedTris;
    INT LightmapMemBytes;
    INT ShadowmapMemBytes;
    INT LODDiffuseMemBytes;
    INT LODLightingMemBytes;

		FPBMemUsageInfo(INT Init)
		{
			appMemzero(this, sizeof(FPBMemUsageInfo));
		}

		/** Add the supplied info to this one */
		void AddInfo(FPBMemUsageInfo& Info);

		/** Return comma-separated string indicating names of each category */
		static FString GetHeaderString();

		/** Returns a comma-separated string version of the info in this struct. */
		FString GetString();

		/** Get column data  */
		FString GetColumnDataString( INT Column ) const;

		/** */
		INT GetColumnData( INT Column) const;

		/** */
		INT Compare( const FPBMemUsageInfo& Other, INT SortIndex ) const;
	
};

class AProcBuilding : public AVolume
{
public:
    //## BEGIN PROPS ProcBuilding
#if WITH_EDITORONLY_DATA
    class UProcBuildingRuleset* Ruleset;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<struct FPBMeshCompInfo> BuildingMeshCompInfos;
    TArrayNoInit<struct FPBFracMeshCompInfo> BuildingFracMeshCompInfos;
    class UStaticMeshComponent* SimpleMeshComp;
    BITFIELD bGenerateRoofMesh:1;
    BITFIELD bGenerateFloorMesh:1;
    BITFIELD bApplyRulesToRoof:1;
    BITFIELD bApplyRulesToFloor:1;
    BITFIELD bSplitWallsAtRoofLevels:1;
    BITFIELD bSplitWallsAtWallEdges:1;
    BITFIELD bQuickEdited:1;
    BITFIELD bBuildingBrushCollision:1;
    BITFIELD bDebugDrawEdgeInfo:1;
    BITFIELD bDebugDrawScopes:1;
    TArrayNoInit<class UStaticMeshComponent*> LODMeshComps;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<struct FPBFaceUVInfo> LODMeshUVInfos;
    TArrayNoInit<struct FPBScope2D> TopLevelScopes;
#endif // WITH_EDITORONLY_DATA
    INT NumMeshedTopLevelScopes;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<struct FPBFaceUVInfo> TopLevelScopeUVInfos;
    TArrayNoInit<struct FPBScopeProcessInfo> TopLevelScopeInfos;
    TArrayNoInit<struct FPBEdgeInfo> EdgeInfos;
#endif // WITH_EDITORONLY_DATA
    FLOAT MaxFacadeZ;
    FLOAT MinFacadeZ;
    TArrayNoInit<class AProcBuilding*> OverlappingBuildings;
    FLOAT SimpleMeshMassiveLODDistance;
    FLOAT RenderToTexturePullBackAmount;
    INT RoofLightmapRes;
    INT NonRectWallLightmapRes;
#if WITH_EDITORONLY_DATA
    FLOAT LODRenderToTextureScale;
#endif // WITH_EDITORONLY_DATA
    FName ParamSwatchName;
    TArrayNoInit<struct FPBMaterialParam> BuildingMaterialParams;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class UMaterialInstanceConstant*> BuildingMatParamMICs;
#endif // WITH_EDITORONLY_DATA
    class AStaticMeshActor* LowLODPersistentActor;
    class UStaticMeshComponent* CurrentSimpleMeshComp;
    class AActor* CurrentSimpleMeshActor;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class AProcBuilding*> AttachedBuildings;
#endif // WITH_EDITORONLY_DATA
    INT BuildingInstanceVersion;
    //## END PROPS ProcBuilding

    virtual void ClearBuildingMeshes();
    virtual TArray<class UStaticMeshComponent*> FindComponentsForTopLevelScope(INT TopLevelScopeIndex);
    virtual class AProcBuilding* GetBaseMostBuilding();
    virtual void GetAllGroupedProcBuildings(TArray<class AProcBuilding*>& OutSet);
    virtual void BreakFractureComponent(class UFracturedStaticMeshComponent* Comp,FVector BoxMin,FVector BoxMax);
    virtual INT FindEdgeForTopLevelScope(INT TopLevelScopeIndex,BYTE Edge);
    DECLARE_FUNCTION(execClearBuildingMeshes)
    {
        P_FINISH;
        this->ClearBuildingMeshes();
    }
    DECLARE_FUNCTION(execFindComponentsForTopLevelScope)
    {
        P_GET_INT(TopLevelScopeIndex);
        P_FINISH;
        *(TArray<class UStaticMeshComponent*>*)Result=this->FindComponentsForTopLevelScope(TopLevelScopeIndex);
    }
    DECLARE_FUNCTION(execGetBaseMostBuilding)
    {
        P_FINISH;
        *(class AProcBuilding**)Result=this->GetBaseMostBuilding();
    }
    DECLARE_FUNCTION(execGetAllGroupedProcBuildings)
    {
        P_GET_TARRAY_REF(class AProcBuilding*,OutSet);
        P_FINISH;
        this->GetAllGroupedProcBuildings(OutSet);
    }
    DECLARE_FUNCTION(execBreakFractureComponent)
    {
        P_GET_OBJECT(UFracturedStaticMeshComponent,Comp);
        P_GET_STRUCT(FVector,BoxMin);
        P_GET_STRUCT(FVector,BoxMax);
        P_FINISH;
        this->BreakFractureComponent(Comp,BoxMin,BoxMax);
    }
    DECLARE_FUNCTION(execFindEdgeForTopLevelScope)
    {
        P_GET_INT(TopLevelScopeIndex);
        P_GET_BYTE(Edge);
        P_FINISH;
        *(INT*)Result=this->FindEdgeForTopLevelScope(TopLevelScopeIndex,Edge);
    }
    DECLARE_CLASS(AProcBuilding,AVolume,0,Engine)
	virtual void PostLoad();	
	virtual void PostCrossLevelFixup();
	virtual void SetZone( UBOOL bTest, UBOOL bForceRefresh );

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostEditImport();
	
	virtual void PostScriptDestroyed();

	/** Called after using geom mode to edit thie brush's geometry */
	virtual void PostEditBrush();
	
	virtual void ClearCrossLevelReferences();

	virtual void SetBase(AActor *NewBase, FVector NewFloor = FVector(0,0,1), INT bNotifyActor=1, USkeletalMeshComponent* SkelComp=NULL, FName BoneName=NAME_None );

	/** Find other buildings that are grouped on, or overlap, this one */
	void FindOverlappingBuildings(TArray<AProcBuilding*>& OutOverlappingBuildings);
	
	/** Update TopLevelScopes/TopLevelScopeInfos arrays based on brush, and all buildings based on this one. Also outputs any polygons needed to fill in 'holes', in actor space. */
	void UpdateTopLevelScopes(TArray<AProcBuilding*> GroupBuildings, TArray<FPoly>& OutHighDetailPolys, TArray<FPoly>& OutLowDetailPolys);
	
	/** Update the internal EdgeInfos array, using the ToplevelScopes array. Only scope-scope edges currently. */
	void UpdateEdgeInfos();

	/** Before we save, if the LOQ quad material points to another package, we NULL it out */
	void ClearLODQuadMaterial();

	/**
	 * After saving (when it was NULLed) or loading (after NULL was loaded), we reset any
	 * LOD Quad materials that should be pointing to another level, we reset it to the 
	 * RTT mateial on the low LOD mesh
	 */
	void ResetLODQuadMaterial();

	/** In PreSave, the LODQuad material pointers are NULLed out, this will fix them up again */
	static void FixupProcBuildingLODQuadsAfterSave();
	
	/** Returns TRUE if this building would like to set some additional params on MICs applied to it */
	UBOOL HasBuildingParamsForMIC();
	
	/** Set any building-wide optional MIC params on the supplied MIC. */
	void SetBuildingMaterialParamsOnMIC(UMaterialInstanceConstant* InMIC);

	/** 
	 *  Util for finding getting an MIC with the supplied parent, and parameters set correctly for this building. 
	 *  Will either return one from the cache, or create a new one and set params if not found.
	 */
	UMaterialInstanceConstant* GetBuildingParamMIC(AProcBuilding* ScopeBuilding, UMaterialInterface* ParentMat);

	/** Get the ruleset used for this building volume. Will look at this override, and then base building if none set. */
	UProcBuildingRuleset* GetRuleset();

	/** Update brush color, to indicate whether this is the 'base' building of a group */
	void UpdateBuildingBrushColor();

	// EDITOR

	/** Draw face->edge information in 3D viewport */
	void DrawDebugEdgeInfo(const FSceneView* View, FViewport* Viewport, FPrimitiveDrawInterface* PDI);

	/** Draw scopes in 3D viewport */
	void DrawDebugScopes(const FSceneView* View, FViewport* Viewport, FPrimitiveDrawInterface* PDI);

	/** Get information about the amount of memory used by this building for various things */
	FPBMemUsageInfo GetBuildingMemUsageInfo();
};

class AProcBuilding_SimpleLODActor : public AStaticMeshActor
{
public:
    //## BEGIN PROPS ProcBuilding_SimpleLODActor
    //## END PROPS ProcBuilding_SimpleLODActor

    DECLARE_CLASS(AProcBuilding_SimpleLODActor,AStaticMeshActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AProcBuilding_SimpleLODActor)
};

struct FPBRuleLink
{
    class UPBRuleNodeBase* NextRule;
    FName LinkName;
#if WITH_EDITORONLY_DATA
    INT DrawY;
#endif // WITH_EDITORONLY_DATA

    /** Constructors */
    FPBRuleLink() {}
    FPBRuleLink(EEventParm)
    {
        appMemzero(this, sizeof(FPBRuleLink));
    }
};

class UPBRuleNodeBase : public UObject
{
public:
    //## BEGIN PROPS PBRuleNodeBase
    TArrayNoInit<struct FPBRuleLink> NextRules;
#if WITH_EDITORONLY_DATA
    FStringNoInit Comment;
    INT RulePosX;
    INT RulePosY;
    INT InDrawY;
    INT DrawWidth;
    INT DrawHeight;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS PBRuleNodeBase

    DECLARE_ABSTRACT_CLASS(UPBRuleNodeBase,UObject,0,Engine)
	/** 
	 *  Perform this nodes rule on the supplied Scope, and then call next rule nodes 
	 *  @param InScope              2D region that this rule should process
	 *  @param TopLevelScopeIndex   Index into the TopLevelScopes array in the ProcBuilding actor that this scope comes from
	 *  @param BaseBuilding         Building that results of this proc building will become part of, root of attachment tree
	 *  @param ScopeBuilding        Building that the top-level scope originally comes from.
	 */
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent) {}
	
	/** Get list of all rule nodes that follow this one (including this one) */
	virtual void GetRuleNodes(TArray<UPBRuleNodeBase*>& OutRuleNodes);

	/** Function to return the top or bottom most corner rule below this rule in the graph */
	virtual class UPBRuleNodeCorner* GetCornerNode(UBOOL bTop, AProcBuilding* BaseBuilding, INT TopLevelScopeIndex);

	// Editor
	/** Util to try and fix up current connections based on an old set of connections, using connection name */
	void FixUpConnections(TArray<FPBRuleLink>& OldConnections);

	virtual FString GetRuleNodeTitle();
	virtual FColor GetRuleNodeTitleColor();
	virtual FString GetRuleNodeOutputName(INT ConnIndex);

	/** Called when an instance of this rule node is placed in Facade */
	virtual void RuleNodeCreated(UProcBuildingRuleset* Ruleset) {}

	virtual void DrawRuleNode(FLinkedObjectDrawHelper* InHelper, FViewport* Viewport, FCanvas* Canvas, UBOOL bSelected);

	/** Allows custom visualization drawing*/
	virtual FIntPoint GetVisualizationSize(void) { return FIntPoint::ZeroValue();}
	/**
	 * Custom visualization that can be specified per node
	 */
	virtual void DrawVisualization(FLinkedObjectDrawHelper* InHelper, FViewport* Viewport, FCanvas* Canvas, const FIntPoint& InDrawPosition) {}
	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);
};

struct FPBVariationInfo
{
    FName VariationName;
    BITFIELD bMeshOnTopOfFacePoly:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FPBVariationInfo() {}
    FPBVariationInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPBVariationInfo));
    }
};

struct FPBParamSwatch
{
    FName SwatchName;
    TArrayNoInit<struct FPBMaterialParam> Params;

    /** Constructors */
    FPBParamSwatch() {}
    FPBParamSwatch(EEventParm)
    {
        appMemzero(this, sizeof(FPBParamSwatch));
    }
};

class UProcBuildingRuleset : public UObject
{
public:
    //## BEGIN PROPS ProcBuildingRuleset
    class UPBRuleNodeBase* RootRule;
    BITFIELD bBeingEdited:1;
    BITFIELD bEnableInteriorTexture:1;
    BITFIELD bLODOnlyRoof:1;
    BITFIELD bPickRandomSwatch:1;
    class UMaterialInterface* DefaultRoofMaterial;
    class UMaterialInterface* DefaultFloorMaterial;
    class UMaterialInterface* DefaultNonRectWallMaterial;
    FLOAT RoofZOffset;
    FLOAT NotRoofZOffset;
    FLOAT FloorZOffset;
    FLOAT NotFloorZOffset;
    FLOAT RoofPolyInset;
    FLOAT FloorPolyInset;
    FLOAT BuildingLODSpecular;
    FLOAT RoofEdgeScopeRaise;
    class UTexture* LODCubemap;
    class UTexture* InteriorTexture;
    TArrayNoInit<struct FPBVariationInfo> Variations;
    TArrayNoInit<struct FPBParamSwatch> ParamSwatches;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class UPBRuleNodeComment*> Comments;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS ProcBuildingRuleset

    DECLARE_CLASS(UProcBuildingRuleset,UObject,0,Engine)
	/** Get the top- or bottom-most corner node in this ruleset. */
	UPBRuleNodeCorner* GetRulesetCornerNode(UBOOL bTop, AProcBuilding* BaseBuilding, INT TopLevelScopeIndex);

	/** Returns all rulesets ref'd by this ruleset (via SubRuleset node) */
	void GetReferencedRulesets(TArray<UProcBuildingRuleset*>& OutRulesets);

	/** Pick a random swatch name from this ruleset  */
	FName GetRandomSwatchName();

	/** Get the index of a swatch in the ParamSwatches array (INDEX_NONE if not present)  */
	INT GetSwatchIndexFromName(FName SearchName);
};

class UPBRuleNodeAlternate : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeAlternate
    BYTE RepeatAxis;
    FLOAT ASize;
    FLOAT BMaxSize;
    BITFIELD bInvertPatternOrder:1;
    BITFIELD bEqualSizeAB:1;
    SCRIPT_ALIGN;
    //## END PROPS PBRuleNodeAlternate

    DECLARE_CLASS(UPBRuleNodeAlternate,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
};

class UPBRuleNodeComment : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeComment
    INT SizeX;
    INT SizeY;
    INT BorderWidth;
    FColor BorderColor;
    BITFIELD bFilled:1;
    SCRIPT_ALIGN;
    FColor FillColor;
    //## END PROPS PBRuleNodeComment

    DECLARE_CLASS(UPBRuleNodeComment,UPBRuleNodeBase,0,Engine)
	virtual void DrawRuleNode(FLinkedObjectDrawHelper* InHelper, FViewport* Viewport, FCanvas* Canvas, UBOOL bSelected);
};

struct FRBCornerAngleInfo
{
    FLOAT Angle;
    FLOAT CornerSize;

    /** Constructors */
    FRBCornerAngleInfo() {}
    FRBCornerAngleInfo(EEventParm)
    {
        appMemzero(this, sizeof(FRBCornerAngleInfo));
    }
};

class UPBRuleNodeCorner : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeCorner
    FLOAT CornerSize;
    TArrayNoInit<struct FRBCornerAngleInfo> Angles;
    FLOAT FlatThreshold;
    BITFIELD bNoMeshForConcaveCorners:1;
    BITFIELD bUseAdjacentRulesetForRightGap:1;
    SCRIPT_ALIGN;
    BYTE CornerType;
    FLOAT CornerShapeOffset;
    INT RoundTesselation;
    FLOAT RoundCurvature;
    //## END PROPS PBRuleNodeCorner

    DECLARE_CLASS(UPBRuleNodeCorner,UPBRuleNodeBase,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	virtual class UPBRuleNodeCorner* GetCornerNode(UBOOL bTop, AProcBuilding* BaseBuilding, INT TopLevelScopeIndex);

	// Editor
	virtual FString GetRuleNodeTitle();	
	virtual FColor GetRuleNodeTitleColor();
	virtual void RuleNodeCreated(UProcBuildingRuleset* Ruleset);

	/** Update the NextRules array based on the Angles array */
	void UpdateRuleConnectors();	

	/** For a given angle, return the size that this corner node will use on the left of the face */
	FLOAT GetCornerSizeForAngle(FLOAT EdgeAngle);
};

class UPBRuleNodeCycle : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeCycle
    BYTE RepeatAxis;
    FLOAT RepeatSize;
    INT CycleSize;
    BITFIELD bFixRepeatSize:1;
    SCRIPT_ALIGN;
    //## END PROPS PBRuleNodeCycle

    DECLARE_CLASS(UPBRuleNodeCycle,UPBRuleNodeBase,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);	

	// Editor
	virtual FString GetRuleNodeTitle();	

	// PBRuleNodeCycle
	/** Util to regenerate the outputs, base on CycleSize */
	void UpdateOutputs();
};

struct FRBEdgeAngleInfo
{
    FLOAT Angle;

    /** Constructors */
    FRBEdgeAngleInfo() {}
    FRBEdgeAngleInfo(EEventParm)
    {
        appMemzero(this, sizeof(FRBEdgeAngleInfo));
    }
};

class UPBRuleNodeEdgeAngle : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeEdgeAngle
    BYTE Edge;
    TArrayNoInit<struct FRBEdgeAngleInfo> Angles;
    //## END PROPS PBRuleNodeEdgeAngle

    DECLARE_CLASS(UPBRuleNodeEdgeAngle,UPBRuleNodeBase,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	

	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
	virtual FString GetRuleNodeOutputName(INT ConnIndex);
	
	
	// PBRuleNodeEdgeAngle interface

	/** Update the NextRules array based on the Angles array */
	void UpdateRuleConnectors();
};

class UPBRuleNodeEdgeMesh : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeEdgeMesh
    FLOAT FlatThreshold;
    FLOAT MainXPullIn;
    //## END PROPS PBRuleNodeEdgeMesh

    DECLARE_CLASS(UPBRuleNodeEdgeMesh,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);	
};

class UPBRuleNodeExtractTopBottom : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeExtractTopBottom
    FLOAT ExtractTopZ;
    FLOAT ExtractNotTopZ;
    FLOAT ExtractBottomZ;
    FLOAT ExtractNotBottomZ;
    //## END PROPS PBRuleNodeExtractTopBottom

    DECLARE_CLASS(UPBRuleNodeExtractTopBottom,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	virtual class UPBRuleNodeCorner* GetCornerNode(UBOOL bTop, AProcBuilding* BaseBuilding, INT TopLevelScopeIndex);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
};

class UPBRuleNodeLODQuad : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeLODQuad
    FLOAT MassiveLODDistanceScale;
    //## END PROPS PBRuleNodeLODQuad

    DECLARE_CLASS(UPBRuleNodeLODQuad,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
};

struct FBuildingMatOverrides
{
    TArrayNoInit<class UMaterialInterface*> MaterialOptions;

    /** Constructors */
    FBuildingMatOverrides() {}
    FBuildingMatOverrides(EEventParm)
    {
        appMemzero(this, sizeof(FBuildingMatOverrides));
    }
};

struct FBuildingMeshInfo
{
    class UStaticMesh* Mesh;
    FLOAT DimX;
    FLOAT DimZ;
    FLOAT Chance;
    class UDistributionVector* Translation;
    class UDistributionVector* Rotation;
    BITFIELD bMeshScaleTranslation:1;
    BITFIELD bOverrideMeshLightMapRes:1;
    INT OverriddenMeshLightMapRes;
    TArrayNoInit<class UMaterialInterface*> MaterialOverrides;
    TArrayNoInit<struct FBuildingMatOverrides> SectionOverrides;

		FBuildingMeshInfo() {}
		FBuildingMeshInfo(EEventParm)
		{
			appMemzero(this, sizeof(FBuildingMeshInfo));
		}
		void InitToDefaults()
		{
			appMemzero(this, sizeof(FBuildingMeshInfo));
			DimX=512.f;
			DimZ=512.f;
			Chance=1.f;
			OverriddenMeshLightMapRes=32;
		}
		FBuildingMeshInfo(ENativeConstructor)
		{
			InitToDefaults();
		}	

		/** Get a set of overrides, one for each section, by picking from each SectionOverrides struct. CAn be random, or first for each section */
		TArray<UMaterialInterface*> GetMaterialOverrides(UBOOL bRandom) const;
	
};

class UPBRuleNodeMesh : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeMesh
    TArrayNoInit<struct FBuildingMeshInfo> BuildingMeshes;
    struct FBuildingMeshInfo PartialOccludedBuildingMesh;
    BITFIELD bDoOcclusionTest:1;
    BITFIELD bBlockAll:1;
    SCRIPT_ALIGN;
    //## END PROPS PBRuleNodeMesh

    virtual INT PickRandomBuildingMesh();
    DECLARE_FUNCTION(execPickRandomBuildingMesh)
    {
        P_FINISH;
        *(INT*)Result=this->PickRandomBuildingMesh();
    }
    DECLARE_CLASS(UPBRuleNodeMesh,UPBRuleNodeBase,0,Engine)
	virtual void PostLoad();

	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
	virtual FColor GetRuleNodeTitleColor();

	/** Allows custom visualization drawing*/
	virtual FIntPoint GetVisualizationSize(void);
	/**
	 * Custom visualization that can be specified per node
	 */
	virtual void DrawVisualization(FLinkedObjectDrawHelper* InHelper, FViewport* Viewport, FCanvas* Canvas, const FIntPoint& InDrawPosition);
	

private:
	/**
	 * Render function that retrieves the thumbnail from the mesh and draws it in the grid
	 */
	void DrawPreviewMesh (FLinkedObjectDrawHelper* InHelper, FViewport* Viewport, FCanvas* Canvas, const FBuildingMeshInfo& MeshInfo, const FIntPoint& InDrawPosition, const INT InRow, const INT InCol, const FColor& BorderColor);

	// PBRuleNodeMesh	
};

class UPBRuleNodeOcclusion : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeOcclusion
    //## END PROPS PBRuleNodeOcclusion

    DECLARE_CLASS(UPBRuleNodeOcclusion,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
};

class UPBRuleNodeQuad : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeQuad
    class UMaterialInterface* Material;
    FLOAT RepeatMaxSizeX;
    FLOAT RepeatMaxSizeZ;
    INT QuadLightmapRes;
    FLOAT YOffset;
    BITFIELD bDisableMaterialRepeat:1;
    SCRIPT_ALIGN;
    //## END PROPS PBRuleNodeQuad

    DECLARE_CLASS(UPBRuleNodeQuad,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
	virtual FColor GetRuleNodeTitleColor();	
};

class UPBRuleNodeRandom : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeRandom
    INT NumOutputs;
    INT MinNumExecuted;
    INT MaxNumExecuted;
    //## END PROPS PBRuleNodeRandom

    DECLARE_CLASS(UPBRuleNodeRandom,UPBRuleNodeBase,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
};

class UPBRuleNodeRepeat : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeRepeat
    BYTE RepeatAxis;
    FLOAT RepeatMaxSize;
    //## END PROPS PBRuleNodeRepeat

    DECLARE_CLASS(UPBRuleNodeRepeat,UPBRuleNodeBase,0,Engine)
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
};

class UPBRuleNodeSize : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeSize
    BYTE SizeAxis;
    FLOAT DecisionSize;
    BITFIELD bUseTopLevelScopeSize:1;
    SCRIPT_ALIGN;
    //## END PROPS PBRuleNodeSize

    DECLARE_CLASS(UPBRuleNodeSize,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
};

struct FRBSplitInfo
{
    BITFIELD bFixSize:1;
    FLOAT FixedSize;
    FLOAT ExpandRatio;
    FName SplitName;

    /** Constructors */
    FRBSplitInfo() {}
    FRBSplitInfo(EEventParm)
    {
        appMemzero(this, sizeof(FRBSplitInfo));
    }
};

class UPBRuleNodeSplit : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeSplit
    BYTE SplitAxis;
    TArrayNoInit<struct FRBSplitInfo> SplitSetup;
    //## END PROPS PBRuleNodeSplit

    DECLARE_CLASS(UPBRuleNodeSplit,UPBRuleNodeBase,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	

	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
	virtual FString GetRuleNodeOutputName(INT ConnIndex);
		
	
	// PBRuleNodeSplit interface

	/** Util to output array of size SplitSetup.Num(), indicating how to split a certain size using the splitting rules */
	TArray<FLOAT> CalcSplitSizes(FLOAT TotalSize);

	/** Update the NextRules array based on the RBSplitInfo array */
	void UpdateRuleConnectors();
};

class UPBRuleNodeSubRuleset : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeSubRuleset
    class UProcBuildingRuleset* SubRuleset;
    //## END PROPS PBRuleNodeSubRuleset

    DECLARE_CLASS(UPBRuleNodeSubRuleset,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	virtual class UPBRuleNodeCorner* GetCornerNode(UBOOL bTop, AProcBuilding* BaseBuilding, INT TopLevelScopeIndex);

	// Editor
	virtual FString GetRuleNodeTitle();	
	virtual FColor GetRuleNodeTitleColor();
};

class UPBRuleNodeTransform : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeTransform
    class UDistributionVector* Translation;
    class UDistributionVector* Rotation;
    class UDistributionVector* Scale;
    //## END PROPS PBRuleNodeTransform

    DECLARE_CLASS(UPBRuleNodeTransform,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
};

class UPBRuleNodeVariation : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeVariation
    BITFIELD bVariationOfScopeOnLeft:1;
    SCRIPT_ALIGN;
    //## END PROPS PBRuleNodeVariation

    DECLARE_CLASS(UPBRuleNodeVariation,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeVariation interface
	virtual void RegenVariationOutputs(UProcBuildingRuleset* Ruleset);
	INT GetVariationOutputIndex(AProcBuilding* BaseBuilding, INT TopLevelScopeIndex);

	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);	
	virtual class UPBRuleNodeCorner* GetCornerNode(UBOOL bTop, AProcBuilding* BaseBuilding, INT TopLevelScopeIndex);

	// Editor
	virtual FString GetRuleNodeTitle();	
	virtual void RuleNodeCreated(UProcBuildingRuleset* Ruleset);
};

class UPBRuleNodeWindowWall : public UPBRuleNodeBase
{
public:
    //## BEGIN PROPS PBRuleNodeWindowWall
    FLOAT CellMaxSizeX;
    FLOAT CellMaxSizeZ;
    FLOAT WindowSizeX;
    FLOAT WindowSizeZ;
    FLOAT WindowPosX;
    FLOAT WindowPosZ;
    BITFIELD bScaleWindowWithCell:1;
    FLOAT YOffset;
    class UMaterialInterface* Material;
    //## END PROPS PBRuleNodeWindowWall

    DECLARE_CLASS(UPBRuleNodeWindowWall,UPBRuleNodeBase,0,Engine)
	// PBRuleNodeBase interface
	virtual void ProcessScope(FPBScope2D& InScope, INT TopLevelScopeIndex, AProcBuilding* BaseBuilding, AProcBuilding* ScopeBuilding, UStaticMeshComponent* LODParent);
	
	// Editor
	virtual FString GetRuleNodeTitle();	
	virtual FColor GetRuleNodeTitleColor();	
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_PROCBUILDING_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AProcBuilding,-1,execFindEdgeForTopLevelScope);
AUTOGENERATE_FUNCTION(AProcBuilding,-1,execBreakFractureComponent);
AUTOGENERATE_FUNCTION(AProcBuilding,-1,execGetAllGroupedProcBuildings);
AUTOGENERATE_FUNCTION(AProcBuilding,-1,execGetBaseMostBuilding);
AUTOGENERATE_FUNCTION(AProcBuilding,-1,execFindComponentsForTopLevelScope);
AUTOGENERATE_FUNCTION(AProcBuilding,-1,execClearBuildingMeshes);
AUTOGENERATE_FUNCTION(UPBRuleNodeMesh,-1,execPickRandomBuildingMesh);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_PROCBUILDING_NATIVE_DEFS
#define ENGINE_PROCBUILDING_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_PROCBUILDING \
	AProcBuilding::StaticClass(); \
	GNativeLookupFuncs.Set(FName("ProcBuilding"), GEngineAProcBuildingNatives); \
	AProcBuilding_SimpleLODActor::StaticClass(); \
	UPBRuleNodeBase::StaticClass(); \
	UPBRuleNodeAlternate::StaticClass(); \
	UPBRuleNodeComment::StaticClass(); \
	UPBRuleNodeCorner::StaticClass(); \
	UPBRuleNodeCycle::StaticClass(); \
	UPBRuleNodeEdgeAngle::StaticClass(); \
	UPBRuleNodeEdgeMesh::StaticClass(); \
	UPBRuleNodeExtractTopBottom::StaticClass(); \
	UPBRuleNodeLODQuad::StaticClass(); \
	UPBRuleNodeMesh::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PBRuleNodeMesh"), GEngineUPBRuleNodeMeshNatives); \
	UPBRuleNodeOcclusion::StaticClass(); \
	UPBRuleNodeQuad::StaticClass(); \
	UPBRuleNodeRandom::StaticClass(); \
	UPBRuleNodeRepeat::StaticClass(); \
	UPBRuleNodeSize::StaticClass(); \
	UPBRuleNodeSplit::StaticClass(); \
	UPBRuleNodeSubRuleset::StaticClass(); \
	UPBRuleNodeTransform::StaticClass(); \
	UPBRuleNodeVariation::StaticClass(); \
	UPBRuleNodeWindowWall::StaticClass(); \
	UProcBuildingRuleset::StaticClass(); \

#endif // ENGINE_PROCBUILDING_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineAProcBuildingNatives[] = 
{ 
	MAP_NATIVE(AProcBuilding, execFindEdgeForTopLevelScope)
	MAP_NATIVE(AProcBuilding, execBreakFractureComponent)
	MAP_NATIVE(AProcBuilding, execGetAllGroupedProcBuildings)
	MAP_NATIVE(AProcBuilding, execGetBaseMostBuilding)
	MAP_NATIVE(AProcBuilding, execFindComponentsForTopLevelScope)
	MAP_NATIVE(AProcBuilding, execClearBuildingMeshes)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUPBRuleNodeMeshNatives[] = 
{ 
	MAP_NATIVE(UPBRuleNodeMesh, execPickRandomBuildingMesh)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AProcBuilding,ProcBuilding,Ruleset)
#else
VERIFY_CLASS_OFFSET_NODIE(AProcBuilding,ProcBuilding,BuildingMeshCompInfos)
#endif
VERIFY_CLASS_OFFSET_NODIE(AProcBuilding,ProcBuilding,BuildingInstanceVersion)
VERIFY_CLASS_SIZE_NODIE(AProcBuilding)
VERIFY_CLASS_SIZE_NODIE(AProcBuilding_SimpleLODActor)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeBase,PBRuleNodeBase,NextRules)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeBase,PBRuleNodeBase,DrawHeight)
#endif
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeBase)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeAlternate,PBRuleNodeAlternate,RepeatAxis)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeAlternate,PBRuleNodeAlternate,BMaxSize)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeAlternate)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeComment,PBRuleNodeComment,SizeX)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeComment,PBRuleNodeComment,FillColor)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeComment)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeCorner,PBRuleNodeCorner,CornerSize)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeCorner,PBRuleNodeCorner,RoundCurvature)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeCorner)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeCycle,PBRuleNodeCycle,RepeatAxis)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeCycle,PBRuleNodeCycle,CycleSize)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeCycle)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeEdgeAngle,PBRuleNodeEdgeAngle,Edge)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeEdgeAngle,PBRuleNodeEdgeAngle,Angles)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeEdgeAngle)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeEdgeMesh,PBRuleNodeEdgeMesh,FlatThreshold)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeEdgeMesh,PBRuleNodeEdgeMesh,MainXPullIn)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeEdgeMesh)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeExtractTopBottom,PBRuleNodeExtractTopBottom,ExtractTopZ)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeExtractTopBottom,PBRuleNodeExtractTopBottom,ExtractNotBottomZ)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeExtractTopBottom)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeLODQuad,PBRuleNodeLODQuad,MassiveLODDistanceScale)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeLODQuad)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeMesh,PBRuleNodeMesh,BuildingMeshes)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeMesh,PBRuleNodeMesh,PartialOccludedBuildingMesh)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeMesh)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeOcclusion)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeQuad,PBRuleNodeQuad,Material)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeQuad,PBRuleNodeQuad,YOffset)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeQuad)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeRandom,PBRuleNodeRandom,NumOutputs)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeRandom,PBRuleNodeRandom,MaxNumExecuted)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeRandom)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeRepeat,PBRuleNodeRepeat,RepeatAxis)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeRepeat,PBRuleNodeRepeat,RepeatMaxSize)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeRepeat)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeSize,PBRuleNodeSize,SizeAxis)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeSize,PBRuleNodeSize,DecisionSize)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeSize)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeSplit,PBRuleNodeSplit,SplitAxis)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeSplit,PBRuleNodeSplit,SplitSetup)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeSplit)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeSubRuleset,PBRuleNodeSubRuleset,SubRuleset)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeSubRuleset)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeTransform,PBRuleNodeTransform,Translation)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeTransform,PBRuleNodeTransform,Scale)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeTransform)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeVariation)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeWindowWall,PBRuleNodeWindowWall,CellMaxSizeX)
VERIFY_CLASS_OFFSET_NODIE(UPBRuleNodeWindowWall,PBRuleNodeWindowWall,Material)
VERIFY_CLASS_SIZE_NODIE(UPBRuleNodeWindowWall)
VERIFY_CLASS_OFFSET_NODIE(UProcBuildingRuleset,ProcBuildingRuleset,RootRule)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UProcBuildingRuleset,ProcBuildingRuleset,Comments)
#else
VERIFY_CLASS_OFFSET_NODIE(UProcBuildingRuleset,ProcBuildingRuleset,ParamSwatches)
#endif
VERIFY_CLASS_SIZE_NODIE(UProcBuildingRuleset)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
