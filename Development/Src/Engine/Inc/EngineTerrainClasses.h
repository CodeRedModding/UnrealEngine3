/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_TERRAIN_ENUMS
#define INCLUDED_ENGINE_TERRAIN_ENUMS 1

enum ELandscapeSetupErrors
{
    LSE_None                =0,
    LSE_NoLandscapeInfo     =1,
    LSE_CollsionXY          =2,
    LSE_NoLayerInfo         =3,
    LSE_MAX                 =4,
};
#define FOREACH_ENUM_ELANDSCAPESETUPERRORS(op) \
    op(LSE_None) \
    op(LSE_NoLandscapeInfo) \
    op(LSE_CollsionXY) \
    op(LSE_NoLayerInfo) 
enum ELandscapeGizmoType
{
    LGT_None                =0,
    LGT_Height              =1,
    LGT_Weight              =2,
    LGT_MAX                 =3,
};
#define FOREACH_ENUM_ELANDSCAPEGIZMOTYPE(op) \
    op(LGT_None) \
    op(LGT_Height) \
    op(LGT_Weight) 
enum ETerrainMappingType
{
    TMT_Auto                =0,
    TMT_XY                  =1,
    TMT_XZ                  =2,
    TMT_YZ                  =3,
    TMT_MAX                 =4,
};
#define FOREACH_ENUM_ETERRAINMAPPINGTYPE(op) \
    op(TMT_Auto) \
    op(TMT_XY) \
    op(TMT_XZ) \
    op(TMT_YZ) 

#endif // !INCLUDED_ENGINE_TERRAIN_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_TERRAIN_CLASSES
#define INCLUDED_ENGINE_TERRAIN_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct FLandscapeWeightmapUsage
{
    class ULandscapeComponent* ChannelUsage[4];

		// tor
		FLandscapeWeightmapUsage()
		{
			ChannelUsage[0] = NULL;
			ChannelUsage[1] = NULL;
			ChannelUsage[2] = NULL;
			ChannelUsage[3] = NULL;
		}

		// Serializer
		friend FArchive& operator<<( FArchive& Ar, FLandscapeWeightmapUsage& U );

		INT FreeChannelCount() const
		{
			return	((ChannelUsage[0] == NULL) ? 1 : 0) + 
					((ChannelUsage[1] == NULL) ? 1 : 0) + 
					((ChannelUsage[2] == NULL) ? 1 : 0) + 
					((ChannelUsage[3] == NULL) ? 1 : 0);
		}
	
};

struct FLandscapeLayerStruct
{
    class ULandscapeLayerInfoObject* LayerInfoObj;
#if WITH_EDITORONLY_DATA
    class UMaterialInstanceConstant* ThumbnailMIC;
    class ALandscapeProxy* Owner;
    INT DebugColorChannel;
#endif // WITH_EDITORONLY_DATA
    BITFIELD bSelected:1;
#if WITH_EDITORONLY_DATA
    FStringNoInit SourceFilePath;
#else
    SCRIPT_ALIGN;
#endif // WITH_EDITORONLY_DATA

		FLandscapeLayerStruct(ULandscapeLayerInfoObject* InLayerInfo, class ALandscapeProxy* InProxy, const TCHAR* InFilePath)
#if WITH_EDITORONLY_DATA
		: SourceFilePath(E_ForceInit)
#endif
		{
			LayerInfoObj = InLayerInfo;
#if WITH_EDITORONLY_DATA
			ThumbnailMIC = NULL;
			DebugColorChannel = 0;
			bSelected = FALSE;
			Owner = InProxy;
			SourceFilePath = InFilePath;
#endif
		}
	
};

class ALandscapeProxy : public AInfo
{
public:
    //## BEGIN PROPS LandscapeProxy
    FGuid LandscapeGuid;
    INT MaxLODLevel;
    class UPhysicalMaterial* DefaultPhysMaterial;
    FLOAT StreamingDistanceMultiplier;
    class UMaterialInterface* LandscapeMaterial;
    FLOAT LODDistanceFactor;
    TArrayNoInit<class ULandscapeComponent*> LandscapeComponents;
    TArrayNoInit<class ULandscapeHeightfieldCollisionComponent*> CollisionComponents;
    TMap< FString ,class UMaterialInstanceConstant* > MaterialInstanceConstantMap;
    TMap< UTexture2D*,struct FLandscapeWeightmapUsage > WeightmapUsageMap;
    FLOAT StaticLightingResolution;
    class ALandscape* LandscapeActor;
    BITFIELD bIsProxy:1;
    BITFIELD bIsSetup:1;
    BITFIELD bResetup:1;
    BITFIELD bIsMovingToLevel:1;
    SCRIPT_ALIGN;
    FLightmassPrimitiveSettings LightmassSettings;
    INT CollisionMipLevel;
    INT MobileLODBias;
    TArrayNoInit<struct FLandscapeLayerStruct> LayerInfoObjs;
    INT ComponentSizeQuads;
    INT SubsectionSizeQuads;
    INT NumSubsections;
    //## END PROPS LandscapeProxy

    DECLARE_CLASS(ALandscapeProxy,AInfo,0,Engine)
	// AActor interface
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
	virtual void ClearComponents();
	virtual void InitRBPhys();

	virtual class ALandscape* GetLandscapeActor();

	virtual FGuid* GetGuid() { return &LandscapeGuid; }

	// Cross level things...
	virtual void ClearCrossLevelReferences();

#if WITH_EDITOR
	ULandscapeLayerInfoObject* GetLayerInfo(const TCHAR* LayerName, UPackage* Package = NULL, const TCHAR* SourceFilePath = NULL);
	ULandscapeInfo* GetLandscapeInfo(UBOOL bSpawnNewActor = TRUE);

	virtual void PostScriptDestroyed();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PreSave();
	virtual void InitRBPhysEditor();

	virtual void PreEditUndo();
	virtual void PostEditUndo();
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostEditImport();

	virtual UMaterialInterface* GetLandscapeMaterial() const;

	// Called before editor copy, TRUE allow export
	virtual UBOOL ShouldExport();
	// Called before editor paste, TRUE allow import
	virtual UBOOL ShouldImport(FString* ActorPropString, UBOOL IsMovingLevel);
	virtual UBOOL GetSelectedComponents(TArray<UObject*>& SelectedObjects);

	void RemoveInvalidWeightmaps();
	void ChangedPhysMaterial();

	virtual void UpdateLandscapeActor(class ALandscape* Landscape, UBOOL bSearchForActor = TRUE);
	UBOOL IsValidLandscapeActor(class ALandscape* Landscape);
	void GetSharedProperties(class ALandscape* Landscape);

	static void RestoreLandscapeAfterSave();
#endif

	// UObject interface
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
	virtual void PostLoad();

#if !PS3
	void ChangeLODDistanceFactor(FLOAT InLODDistanceFactor);
#endif
};

struct FLandscapeLayerInfo
{
    FName LayerName;
    FLOAT Hardness;
    BITFIELD bNoWeightBlend:1;
    class UPhysicalMaterial* PhysMaterial;
#if WITH_EDITORONLY_DATA
    class UMaterialInstanceConstant* ThumbnailMIC;
#endif // WITH_EDITORONLY_DATA
    BITFIELD bSelected:1;
#if WITH_EDITORONLY_DATA
    INT DebugColorChannel;
    FStringNoInit LayerSourceFile;
#else
    SCRIPT_ALIGN;
#endif // WITH_EDITORONLY_DATA

		// tor
		FLandscapeLayerInfo(FName InName, FLOAT InHardness=0.5f, UBOOL InNoWeightBlend=FALSE, const TCHAR* SourceFile=NULL)
		:	LayerName(InName)
		,	Hardness(InHardness)
		,	bNoWeightBlend(InNoWeightBlend)
		,	PhysMaterial(NULL)
#if WITH_EDITORONLY_DATA
		,	ThumbnailMIC(NULL)
		,	bSelected(FALSE)
		,	DebugColorChannel(0)
		,	LayerSourceFile(E_ForceInit)
#endif // WITH_EDITORONLY_DATA
		{
#if WITH_EDITORONLY_DATA
			LayerSourceFile = SourceFile;
#endif // WITH_EDITORONLY_DATA
		}

		// for TArray::FindItemIndexByKey
		UBOOL operator==( const FLandscapeLayerInfo& Other ) const
		{
			return LayerName == Other.LayerName;
		}
	
};

class ALandscape : public ALandscapeProxy
{
public:
    //## BEGIN PROPS Landscape
    TArrayNoInit<FName> LayerNames_DEPRECATED;
    TArrayNoInit<struct FLandscapeLayerInfo> LayerInfos_DEPRECATED;
    //## END PROPS Landscape

    DECLARE_CLASS(ALandscape,ALandscapeProxy,0,Engine)
	// Make a key for XYtoComponentMap
	static QWORD MakeKey( INT X, INT Y ) { return ((QWORD)(*(DWORD*)(&X)) << 32) | (*(DWORD*)(&Y) & 0xffffffff); }
	static void UnpackKey( QWORD Key, INT& OutX, INT& OutY ) { *(DWORD*)(&OutX) = (Key >> 32); *(DWORD*)(&OutY) = Key&0xffffffff; }

	virtual class ALandscape* GetLandscapeActor();
	virtual void ClearComponents();

	static FName DataWeightmapName; 
#if WITH_EDITOR
	virtual void PreSave();
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);

	// ALandscape interface
	UBOOL ImportFromOldTerrain(class ATerrain* OldTerrain);
	void Import(INT VertsX, INT VertsY, INT ComponentSizeQuads, INT NumSubsections, INT SubsectionSizeQuads, WORD* HeightData, const TCHAR* HeightmapFileName, TArray<FLandscapeLayerInfo> ImportLayerInfos, BYTE* AlphaDataPointers[] );
	virtual void UpdateLandscapeActor(class ALandscape* Landscape, UBOOL bSearchForActor = TRUE);

	virtual UMaterialInterface* GetLandscapeMaterial() const;
	UBOOL HasAllComponent(); // determine all component is in this actor

	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent);
	virtual void PostEditMove(UBOOL bFinished);

	// Include Components with overlapped vertices
	static void CalcComponentIndicesOverlap(const INT X1, const INT Y1, const INT X2, const INT Y2, const INT ComponentSizeQuads, 
		INT& ComponentIndexX1, INT& ComponentIndexY1, INT& ComponentIndexX2, INT& ComponentIndexY2);

	// Exclude Components with overlapped vertices
	static void CalcComponentIndices(const INT X1, const INT Y1, const INT X2, const INT Y2, const INT ComponentSizeQuads, 
		INT& ComponentIndexX1, INT& ComponentIndexY1, INT& ComponentIndexX2, INT& ComponentIndexY2);

	static void SplitHeightmap(ULandscapeComponent* Comp, UBOOL bMoveToCurrentLevel = FALSE);

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();

	void UpdateOldLayerInfo();
#endif
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
	virtual void PostLoad();
};

struct FCachedTerrainMaterialArray
{
    TArrayNoInit<FTerrainMaterialResource*> CachedMaterials;

    /** Constructors */
    FCachedTerrainMaterialArray() {}
    FCachedTerrainMaterialArray(EEventParm)
    {
        appMemzero(this, sizeof(FCachedTerrainMaterialArray));
    }
};

class ATerrain : public AInfo
{
public:
    //## BEGIN PROPS Terrain
    TArrayNoInit<FTerrainHeight> Heights;
    TArrayNoInit<FTerrainInfoData> InfoData;
    TArrayNoInit<FTerrainLayer> Layers;
    INT NormalMapLayer;
    TArrayNoInit<FTerrainDecoLayer> DecoLayers;
    TArrayNoInit<FAlphaMap> AlphaMaps;
    TArrayNoInit<class UTerrainComponent*> TerrainComponents;
    INT NumSectionsX;
    INT NumSectionsY;
    TArrayNoInit<FTerrainWeightedMaterial> WeightedMaterials;
    TArrayNoInit<class UTerrainWeightMapTexture*> WeightedTextureMaps;
    INT MaxTesselationLevel;
    INT MinTessellationLevel;
    FLOAT TesselationDistanceScale;
    FLOAT TessellationCheckDistance;
    INT CollisionTesselationLevel;
    struct FCachedTerrainMaterialArray CachedTerrainMaterials[2];
    INT NumVerticesX;
    INT NumVerticesY;
    INT NumPatchesX;
    INT NumPatchesY;
    INT MaxComponentSize;
    INT StaticLightingResolution;
    BITFIELD bIsOverridingLightResolution:1;
    BITFIELD bBilinearFilterLightmapGeneration:1;
    BITFIELD bCastShadow:1;
    BITFIELD bForceDirectLightMap:1;
    BITFIELD bCastDynamicShadow:1;
    BITFIELD bEnableSpecular:1;
    BITFIELD bBlockRigidBody:1;
    BITFIELD bAllowRigidBodyUnderneath:1;
    BITFIELD bAcceptsDynamicLights:1;
    BITFIELD bMorphingEnabled:1;
    BITFIELD bMorphingGradientsEnabled:1;
    BITFIELD bLocked:1;
    BITFIELD bHeightmapLocked:1;
    BITFIELD bShowingCollision:1;
    BITFIELD bUseWorldOriginTextureUVs:1;
    BITFIELD bShowWireframe:1;
    class UPhysicalMaterial* TerrainPhysMaterialOverride;
    FLightingChannelContainer LightingChannels;
    FLightmassPrimitiveSettings LightmassSettings;
    FRenderCommandFence* ReleaseResourcesFence;
    INT EditorTessellationLevel;
    TArrayNoInit<FSelectedTerrainVertex> SelectedVertices;
    FColor WireframeColor;
#if WITH_EDITORONLY_DATA
    FGuid LightingGuid;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS Terrain

    void CalcLayerBounds();
    DECLARE_FUNCTION(execCalcLayerBounds)
    {
        P_FINISH;
        this->CalcLayerBounds();
    }
    DECLARE_CLASS(ATerrain,AInfo,0,Engine)
    // UObject interface

	virtual void Serialize(FArchive& Ar);
	virtual void PreEditChange(UProperty* PropertyThatChanged);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditMove(UBOOL bFinished);

protected:
	void HandleLegacyTextureReferences();
public:

	virtual void PostLoad();

	/**
	 * @return		Sum of the size of textures referenced by this material.
	 */
	virtual INT GetResourceSize();

	/**
	 *	Called before the Actor is saved.
	 */
	virtual void PreSave();
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();

	virtual void ClearWeightMaps();
	virtual void TouchWeightMapResources();

	/**
	 * Callback used to allow object register its direct object references that are not already covered by
	 * the token stream.
	 *
	 * @param ObjectArray	array to add referenced objects to via AddReferencedObject
	 */
	void AddReferencedObjects( TArray<UObject*>& ObjectArray );

	// AActor interface

	virtual void Spawned();
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);

	virtual void InitRBPhys();
	virtual void TermRBPhys(FRBPhysScene* Scene);

	virtual const FGuid& GetLightingGuid() const
	{
#if WITH_EDITORONLY_DATA
		return LightingGuid;
#else
		static const FGuid NullGuid( 0, 0, 0, 0 );
		return NullGuid; 
#endif // WITH_EDITORONLY_DATA
	}

	virtual void SetLightingGuid()
	{
#if WITH_EDITORONLY_DATA
		LightingGuid = appCreateGuid();
#endif // WITH_EDITORONLY_DATA
	}

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();

	/**
	 * Function that is called from CheckForErrors - specifically checks for material errors.
	 */
	void CheckForMaterialErrors();
#endif
	virtual void ClearComponents();

	/** Called by the lighting system to allow actors to order their components for deterministic lighting */
	virtual void OrderComponentsForDeterministicLighting();

protected:
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:
	virtual void UpdatePatchBounds(INT MinX,INT MinY,INT MaxX,INT MaxY);

	void WeldEdgesToOtherTerrains();

	virtual UBOOL ActorLineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);

	// CompactAlphaMaps - Cleans up alpha maps that are no longer used.

	void CompactAlphaMaps();

	// CacheWeightMaps - Generates the weightmaps from the layer stack and filtered materials.

	void CacheWeightMaps(INT MinX,INT MinY,INT MaxX,INT MaxY);

	// CacheDecorations - Generates a set of decoration components for an area of the terrain.
	void CacheDecorations(INT MinX,INT MinY,INT MaxX,INT MaxY);

	// UpdateRenderData - Updates the weightmaps, displacements, decorations, vertex buffers and bounds when the heightmap, an alphamap or a terrain property changes.
	void UpdateRenderData(INT MinX,INT MinY,INT MaxX,INT MaxY);

	/** updates decoration components to account for terrain/layer property changes */
	void UpdateDecorationComponents();

	/** Clamps the vertex index to a valid vertex index (0 to NumVerticesX - 1, 0 to NumVerticesY - 1) that can be used to address the vertex collection.
	 * An invalid vertex index is something like (-1,-1) which would cause an array out of bounds exception.
	 *
	 * @param	OutX	The clamped X coordinate.
	 * @param	OutY	The clamped Y coordinate.
	 */
	void ClampVertexIndex(INT& OutX, INT& OutY) const;

	/**
	 * Allocates and initializes resolution dependent persistent data. (height-map, alpha-map, components)
	 * Keeps the old height-map and alpha-map data, cropping and extending as necessary.
	 * Uses DesiredSizeX, DesiredSizeY to determine the desired resolution.
	 * DesiredSectionSize determines the size of the components the terrain is split into.
	 */
	void Allocate();

	/**
	  * Recreates all the components
	  */
	void RecreateComponents();

	/**
	 *	Split a terrain along the X or Y axis
	 *	Returns the new terrain if successful
	 */
	ATerrain* SplitTerrain( UBOOL SplitOnXAxis, INT RemainingPatches );
	void SplitTerrainPreview( class FPrimitiveDrawInterface* PDI, UBOOL SplitOnXAxis, INT RemainingPatches );

	/**
	 *	Merges this terrain with another specified terrain if possible
	 *	Returns success TRUE/FALSE
	 */
	UBOOL MergeTerrain( ATerrain* Other );
	UBOOL MergeTerrainPreview( class FPrimitiveDrawInterface* PDI, ATerrain* Other );

	/**
	 *	Add or remove sectors to the terrain
	 *
	 *	@param	CountX		The number of sectors in the X-direction. If negative,
	 *						they will go to the left, otherwise to the right.
	 *	@param	CountY		The number of sectors in the Y-direction. If negative,
	 *						they will go to the bottom, otherwise to the top.
	 *	@param	bRemove		If TRUE, remove the sectors, otherwise add them.
	 *
	 *	@return	UBOOL		TRUE if successful.
	 */
	UBOOL AddRemoveSectors(INT CountX, INT CountY, UBOOL bRemove);

	// Internal functions for adding/removing sectos
	void StoreOldData(TArray<FTerrainHeight>& OldHeights, TArray<FTerrainInfoData>& OldInfoData, TArray<FAlphaMap>& OldAlphaMaps);
	void SetupSizeData();
	UBOOL AddSectors_X(INT Count);
	UBOOL AddSectors_Y(INT Count);
	UBOOL RemoveSectors_X(INT Count);
	UBOOL RemoveSectors_Y(INT Count);

	// Data access.

	//
	//	ATerrain::Height
	//
	inline const WORD& Height(INT X,INT Y) const
	{
		X = Clamp(X,0,NumVerticesX - 1);
		Y = Clamp(Y,0,NumVerticesY - 1);
		return Heights(Y * NumVerticesX + X).Value;
	}

	//
	//	ATerrain::Height
	//
	inline WORD& Height(INT X,INT Y)
	{
		X = Clamp(X,0,NumVerticesX - 1);
		Y = Clamp(Y,0,NumVerticesY - 1);
		return Heights(Y * NumVerticesX + X).Value;
	}

	inline WORD BilinearHeight(FLOAT fX,FLOAT fY)
	{
		INT X = appFloor(fX);
		INT Y = appFloor(fY);
		FLOAT tx = fX - (FLOAT)X;
		FLOAT ty = fY - (FLOAT)Y;

		return appRound(
				Lerp(
				Lerp( (FLOAT)Height(X,Y), (FLOAT)Height(X+1,Y), tx),
				Lerp( (FLOAT)Height(X,Y+1), (FLOAT)Height(X+1,Y+1), tx),
				ty) );
	}

	inline FTerrainInfoData* GetInfoData(INT X, INT Y)
	{
		X = Clamp(X, 0, NumVerticesX - 1);
		Y = Clamp(Y, 0, NumVerticesY - 1);

		return &(InfoData(Y * NumVerticesX + X));
	}

	inline const FTerrainInfoData* GetInfoData(INT X, INT Y) const
	{
		X = Clamp(X, 0, NumVerticesX - 1);
		Y = Clamp(Y, 0, NumVerticesY - 1);

		return &(InfoData(Y * NumVerticesX + X));
	}

	inline UBOOL IsTerrainQuadVisible(INT X, INT Y) const
	{
		const FTerrainInfoData* TheInfoData = GetInfoData(X, Y);
		checkSlow(TheInfoData);
		return TheInfoData->IsVisible();
	}

	inline UBOOL IsTerrainQuadFlipped(INT X, INT Y) const
	{
		const FTerrainInfoData* TheInfoData = GetInfoData(X, Y);
		checkSlow(TheInfoData);
		return TheInfoData->IsOrientationFlipped();
	}

	/**
	 *	Returns TRUE is the component at the given X,Y has ANY patches contained in are visible.
	 */
	UBOOL IsTerrainComponentVisible(INT InBaseX, INT InBaseY, INT InSizeX, INT InSizeY);
	UBOOL IsTerrainComponentVisible(UTerrainComponent* InComponent);

	FVector GetLocalVertex(INT X,INT Y) const; // Returns a vertex in actor-local space.
	FVector GetWorldVertex(INT X,INT Y) const; // Returns a vertex in world space.

	FTerrainPatch GetPatch(INT X,INT Y) const;
	FVector GetCollisionVertex(const FTerrainPatch& Patch,UINT PatchX,UINT PatchY,UINT SubX,UINT SubY,UINT TesselationLevel) const;

	BYTE Alpha(INT AlphaMapIndex,INT X,INT Y) const;		// If AlphaMapIndex == INDEX_NONE, returns 0.
	BYTE& Alpha(INT& AlphaMapIndex,INT X,INT Y);			// If AlphaMapIndex == INDEX_NONE, creates a new alphamap and places the index in AlphaMapIndex.

	/**
	* Returns a cached terrain material containing a given set of weighted materials.
	* Generates a new entry if not found
	*
	* @param Mask - bitmask combination of weight materials to be used
	* @param bIsTerrainResource - [out] TRUE if the material resource returned is a terrain material, FALSE if fallback
	* @return terrain material resource render proxy or error material render proxy
	*/
	FMaterialRenderProxy* GetCachedMaterial(const FTerrainMaterialMask& Mask, UBOOL& bIsTerrainResource);

	/**
	* Creates new cached terrain material entry if it doesn't exist for the given mask
	*
	* @param Mask - bitmask combination of weight materials to be used
	* @return new terrain material resource
	*/
	FTerrainMaterialResource* GenerateCachedMaterial(const FTerrainMaterialMask& Mask);

	/**
	 *	RetrieveReleaseResourcesFence
	 *
	 *	This function will grab the ReleaseResourcesFence.
	 *	If it is NULL, it will create one.
	 *	Should be used when a fence is required.
	 *
	 *	@return FRenderCommandFence		The ReleaseResourcesFence returned.
	 */
	FRenderCommandFence* RetrieveReleaseResourcesFence()
	{
		if (ReleaseResourcesFence == NULL)
		{
			ReleaseResourcesFence = ::new FRenderCommandFence();
			check(ReleaseResourcesFence);
		}
		return ReleaseResourcesFence;
	}

	/**
	 *	GetReleaseResourcesFence
	 *
	 *	This function will grab the current ReleaseResourcesFence.
	 *	Should be used when a fence should be checked if it has been created previously.
	 *
	 *	@return FRenderCommandFence		The ReleaseResourcesFence returned.
	 */
	FRenderCommandFence* GetReleaseResourcesFence()
	{
		return ReleaseResourcesFence;
	}

	/**
	 *	FreeReleaseResourcesFence
	 *
	 *	This function will free the current ReleaseResourcesFence.
	 *	Should be used when a fence should be checked if it has been created previously.
	 *
	 *	@return FRenderCommandFence		The ReleaseResourcesFence returned.
	 */
	void FreeReleaseResourcesFence()
	{
		if (ReleaseResourcesFence != NULL)
		{
			delete ReleaseResourcesFence;
			ReleaseResourcesFence = NULL;
		}
	}

	/**
	 *	MaterialUpdateCallback
	 *
	 *	Called when materials are edited to propagate the change to terrain materials.
	 *
	 *	@param	InMaterial		The material that was edited.
	 *
	 */
	static void MaterialUpdateCallback(UMaterial* InMaterial);

	/**
	 *	BuildCollisionData
	 *
	 *	Helper function to force the re-building of the collision date.
	 */
	void BuildCollisionData();

	/**
	 *	RecacheMaterials
	 *
	 *	Helper function that tosses the cached materials and regenerates them.
	 */
	void RecacheMaterials();

	/**
	 *	UpdateLayerSetup
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InSetup		The layer setup to update.
	 */
	void UpdateLayerSetup(UTerrainLayerSetup* InSetup);

	/**
	 *	RemoveLayerSetup
	 *
	 *	Editor function for removing altered materials/layers
	 *
	 *	@param	InSetup		The layer setup to remove.
	 */
	void RemoveLayerSetup(UTerrainLayerSetup* InSetup);

	/**
	 *	UpdateTerrainMaterial
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InTMat		The terrain material to update.
	 */
	void UpdateTerrainMaterial(UTerrainMaterial* InTMat);

	/**
	 *	RemoveTerrainMaterial
	 *
	 *	Editor function for removing altered materials/layers
	 *
	 *	@param	InTMat		The terrain material to Remove.
	 */
	void RemoveTerrainMaterial(UTerrainMaterial* InTMat);

	/**
	 *	UpdateMaterialInstance
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InMatInst	The material instance to update.
	 */
	void UpdateMaterialInstance(UMaterialInterface* InMatInst);

	/**
	 *	UpdateCachedMaterial
	 *
	 *	Editor function for updating altered materials/layers
	 *
	 *	@param	InMat		The material instance to update.
	 */
	void UpdateCachedMaterial(UMaterial* InMat);

	/**
	 *	RemoveCachedMaterial
	 *
	 *	Editor function for removing altered materials/layers
	 *
	 *	@param	InMat		The material instance to remove.
	 */
	void RemoveCachedMaterial(UMaterial* InMat);

	/**
	 *	Tessellate the terrain up in detail
	 *	Also used for converting old terrain to the new hi-res model
	 *
	 *	REQUIRES UPDATING TERRAIN MATERIAL MAPPING SCALES BY HAND!
	 *
	 *	@param	InTessellationlevel		The tessellation level to increase it to
	 *
	 *	@return	UBOOL					TRUE if successful
	 */
	UBOOL TessellateTerrainUp(INT InTessellationlevel = 2, UBOOL bRegenerateComponents = TRUE);

	/**
	 *	Tessellate the terrain down in detail.
	 *	Will remove patches while retaining the 'shape' of the terrain.
	 *
	 *	REQUIRES UPDATING TERRAIN MATERIAL MAPPING SCALES BY HAND!
	 */
	UBOOL TessellateTerrainDown();

	/**
	 *	GetClosestVertex
	 *
	 *	Determine the vertex that is closest to the given location.
	 *	Used for drawing tool items.
	 *
	 *	@param	InLocation		FVector representing the location caller is interested in
	 *	@param	OutVertex		FVector the function will fill in
	 *	@param	bConstrained	If TRUE, then select the closest according to editor tessellation level
	 *
	 *	@return	UBOOL			TRUE indicates the point was found and OutVertex is valid.
	 *							FALSE indicates the point was not contained within the terrain.
	 */
	UBOOL GetClosestVertex(const FVector& InLocation, FVector& OutVertex, UBOOL bConstrained = FALSE);

	/**
	 *	GetClosestLocalSpaceVertex
	 *
	 *	Determine the vertex that is closest to the given location in local space.
	 *	The returned position is also in local space.
	 *	Used for drawing tool items.
	 *
	 *	@param	InLocation		FVector representing the location caller is interested in
	 *	@param	OutVertex		FVector the function will fill in
	 *	@param	bConstrained	If TRUE, then select the closest according to editor tessellation level
	 *
	 *	@return	UBOOL			TRUE indicates the point was found and OutVertex is valid.
	 *							FALSE indicates the point was not contained within the terrain.
	 */
	UBOOL GetClosestLocalSpaceVertex(const FVector& InLocation, FVector& OutVertex, UBOOL bConstrained = FALSE);

	/**
	 *	ShowCollisionCallback
	 *
	 *	Called when SHOW terrain collision is toggled.
	 *
	 *	@param	bShow		Whether to show it or not.
	 *
	 */
	static void ShowCollisionCallback(UBOOL bShow);

	/**
	 *	Show/Hide terrain collision overlay
	 *
	 *	@param	bShow				Show or hide
	 */
	void ShowCollisionOverlay(UBOOL bShow);

	/**
	 *	Update the given selected vertex in the list.
	 *	If the vertex is not present, then add it to the list (provided Weight > 0)
	 *
	 *	@param	X
	 *	@param	Y
	 *	@param	Weight
	 *
	 */
	void UpdateSelectedVertex(INT X, INT Y, FLOAT Weight);

	/**
	 *	Internal function for getting a selected vertex from the list
	 */
	INT FindSelectedVertexInList(INT X, INT Y, FSelectedTerrainVertex*& SelectedVert);

	/**
	 *	Clear all selected vertices
	 */
	void ClearSelectedVertexList();

	/**
	 *	Retrieve the component(s) that contain the given vertex point
	 *	The components will be added (using AddUniqueItem) to the supplied array.
	 *
	 *	@param	X				The X position of interest
	 *	@param	Y				The Y position of interest
	 *	@param	ComponentList	The array to add found components to
	 *
	 *	@return	UBOOL			TRUE if any components were found.
	 *							FALSE if none were found
	 */
	UBOOL GetComponentsAtXY(INT X, INT Y, TArray<UTerrainComponent*>& ComponentList);

	/**
	 *	Recache the visibility flags - used when changing tessellation levels.
	 */
	void RecacheVisibilityFlags();

	/**
	 * Get the array of cached terrain material resource 
	 */
	FORCEINLINE TArrayNoInit<FTerrainMaterialResource*>& GetCachedTerrainMaterials()
	{
		return CachedTerrainMaterials[MSQ_TERRAIN].CachedMaterials;
	}

	/**
	 * Delete the entries in the cached terrain materials
	 */
	void ClearCachedTerrainMaterials();

	/**
	* Compiles material resources for the current platform if the shader map for that resource didn't already exist.
	*
	* @param ShaderPlatform - platform to compile for
	* @param bFlushExistingShaderMaps - forces a compile, removes existing shader maps from shader cache.
	*/
	void CacheResourceShaders(EShaderPlatform ShaderPlatform, UBOOL bFlushExistingShaderMaps=FALSE);
};

class ALandscapeGizmoActor : public AActor
{
public:
    //## BEGIN PROPS LandscapeGizmoActor
#if WITH_EDITORONLY_DATA
    FLOAT Width;
    FLOAT Height;
    FLOAT LengthZ;
    FLOAT MarginZ;
    FLOAT MinRelativeZ;
    FLOAT RelativeScaleZ;
    class ULandscapeInfo* TargetLandscapeInfo;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS LandscapeGizmoActor

    DECLARE_CLASS(ALandscapeGizmoActor,AActor,0,Engine)
#if WITH_EDITOR
	virtual void Duplicate(ALandscapeGizmoActor* Gizmo); 
	//virtual void EditorApplyTranslation(const FVector& DeltaTranslation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
#endif
};

struct FGizmoSelectData
{
#if WITH_EDITORONLY_DATA
    FLOAT Ratio;
    FLOAT HeightData;
    TMap< FName, FLOAT > WeightDataMap;
#endif // WITH_EDITORONLY_DATA

		FGizmoSelectData()
			#if WITH_EDITORONLY_DATA
			: Ratio(0.f), HeightData(0.f)
			#endif
		{
		}
	
};

class ALandscapeGizmoActiveActor : public ALandscapeGizmoActor
{
public:
    //## BEGIN PROPS LandscapeGizmoActiveActor
#if WITH_EDITORONLY_DATA
    BYTE DataType;
#endif // WITH_EDITORONLY_DATA
    TMap< QWORD, FGizmoSelectData > SelectedData;
#if WITH_EDITORONLY_DATA
    class UTexture2D* GizmoTexture;
    FVector2D TextureScale;
    TArrayNoInit<FVector> SampledHeight;
    TArrayNoInit<FVector> SampledNormal;
    INT SampleSizeX;
    INT SampleSizeY;
    FLOAT CachedWidth;
    FLOAT CachedHeight;
    FLOAT CachedScaleXY;
    FVector FrustumVerts[8];
    class UMaterial* GizmoMaterial;
    class UMaterialInstance* GizmoDataMaterial;
    class UMaterial* GizmoMeshMaterial;
    class UMaterial* GizmoMeshMaterial2;
    TArrayNoInit<FName> LayerNames;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS LandscapeGizmoActiveActor

    DECLARE_CLASS(ALandscapeGizmoActiveActor,ALandscapeGizmoActor,0,Engine)
#if WITH_EDITOR
	// UObject interface.
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	// AActor interface.
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostLoad();

	ALandscapeGizmoActor* SpawnGizmoActor();

	virtual void Serialize(FArchive& Ar);
	void ClearGizmoData();
	void FitToSelection();
	void FitMinMaxHeight();
	void SetTargetLandscape(ULandscapeInfo* LandscapeInfo);

	void CalcNormal();
	void SampleData(INT SizeX, INT SizeY);

	void ExportToClipboard();
	void ImportFromClipboard();
	void Import(INT VertsX, INT VertsY, WORD* HeightData, TArray<FName> ImportLayerNames, BYTE* LayerDataPointers[] );
	void Export(INT Index, TArray<FString>& Filenames);

	FLOAT GetNormalizedHeight(WORD LandscapeHeight);
	FLOAT GetLandscapeHeight(FLOAT NormalizedHeight);

	FLOAT GetWidth() { return Width * DrawScale * DrawScale3D.X; }
	FLOAT GetHeight() { return Height * DrawScale * DrawScale3D.Y; }
	FLOAT GetLength() { return LengthZ * DrawScale * DrawScale3D.Z; }

	void SetLength(FLOAT WorldLength) { LengthZ = WorldLength / (DrawScale * DrawScale3D.Z); }

	static const INT DataTexSize;
private:
	FORCEINLINE FLOAT GetWorldHeight(FLOAT NormalizedHeight);
#endif
};

struct FWeightmapLayerAllocationInfo
{
    FName LayerName;
    BYTE WeightmapTextureIndex;
    BYTE WeightmapTextureChannel;
    SCRIPT_ALIGN;

		FWeightmapLayerAllocationInfo(FName InLayerName)
		:	LayerName(InLayerName)
		,	WeightmapTextureIndex(255)	// Indicates an invalid allocation
		,	WeightmapTextureChannel(255)
		{}
	
};

class ULandscapeComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LandscapeComponent
    INT SectionBaseX;
    INT SectionBaseY;
    INT ComponentSizeQuads;
    INT SubsectionSizeQuads;
    INT NumSubsections;
    class UMaterialInterface* OverrideMaterial;
    class UMaterialInstanceConstant* MaterialInstance;
    TArrayNoInit<struct FWeightmapLayerAllocationInfo> WeightmapLayerAllocations;
    TArrayNoInit<class UTexture2D*> WeightmapTextures;
    FVector4 WeightmapScaleBias;
    FLOAT WeightmapSubsectionOffset;
    FVector4 HeightmapScaleBias;
    class UTexture2D* HeightmapTexture;
    FBoxSphereBounds CachedBoxSphereBounds;
    FBox CachedLocalBox;
#if WITH_EDITORONLY_DATA
    FGuid LightingGuid;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<class UShadowMap2D*> ShadowMaps;
    TArrayNoInit<FGuid> IrrelevantLights;
    FLightMapRef LightMap;
    struct FLandscapeEditToolRenderData* EditToolRenderData;
    INT CollisionMipLevel;
    void* PlatformData;
    INT PlatformDataSize;
    BITFIELD bNeedPostUndo:1;
    INT ForcedLOD;
    BYTE NeighborLOD[8];
    BYTE NeighborLODBias[8];
    INT LODBias;
    //## END PROPS LandscapeComponent

    DECLARE_CLASS(ULandscapeComponent,UPrimitiveComponent,0,Engine)
	// UObject interface
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
#if WITH_EDITOR
	virtual void PostLoad();
	virtual void PostEditImport();
	virtual void PostEditUndo();
	virtual void PostRename();

	// Register ourselves with the actor.
	ELandscapeSetupErrors SetupActor(UBOOL bForce = FALSE);

	virtual void Attach();
#endif

	// UPrimitiveComponent interface
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const;
	virtual void UpdateBounds();
	void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual INT GetNumElements() const { return 1; }
	virtual UMaterialInterface* GetElementMaterial(INT MaterialIndex) const { return MaterialInstance; }
	virtual void SetElementMaterial(INT ElementIndex, UMaterialInterface* InMaterial);

#if WITH_EDITOR
	class ULandscapeInfo* GetLandscapeInfo(UBOOL bSpawnNewActor = TRUE) const;
	virtual void GetStaticLightingInfo(FStaticLightingPrimitiveInfo& OutPrimitiveInfo,const TArray<ULightComponent*>& InRelevantLights,const FLightingBuildOptions& Options);
	virtual UBOOL GetLightMapResolution( INT& Width, INT& Height ) const;
	virtual void GetStaticTriangles(FPrimitiveTriangleDefinitionInterface* PTDI) const;
	void DeleteLayer(FName LayerName, struct FLandscapeEditDataInterface* LandscapeEdit);
	void GeneratePlatformData( UE3::EPlatformType Platform, void*& NewPlatformData, INT& NewPlatformDataSize, UTexture2D*& NewWeightTexture ) const;
#endif
	virtual void InvalidateLightingCache();
	/**
	 *	Requests whether the component will use texture, vertex or no lightmaps.
	 *
	 *	@return	ELightMapInteractionType		The type of lightmap interaction the component will use.
	 */
	virtual ELightMapInteractionType GetStaticLightingType() const	{ return LMIT_Texture;	}
	virtual void GetStreamingTextureInfo(TArray<FStreamingTexturePrimitiveInfo>& OutStreamingTextures) const;

	// Decal
	void GenerateDecalRenderData(FDecalState* Decal, TArray< FDecalRenderData* >& OutDecalRenderDatas) const;

	// ULandscapeComponent Interface

	/** Return's the landscape actor associated with this component. */
	class ALandscape* GetLandscapeActor() const;
	class ALandscapeProxy* GetLandscapeProxy() const;
	TMap< UTexture2D*,struct FLandscapeWeightmapUsage >& GetWeightmapUsageMap();

	virtual const FGuid& GetLightingGuid() const
	{
#if WITH_EDITORONLY_DATA
		return LightingGuid;
#else
		static const FGuid NullGuid( 0, 0, 0, 0 );
		return NullGuid; 
#endif // WITH_EDITORONLY_DATA
	}

	virtual void SetLightingGuid()
	{
#if WITH_EDITORONLY_DATA
		LightingGuid = appCreateGuid();
#endif // WITH_EDITORONLY_DATA
	}

#if WITH_EDITOR
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** Initialize the landscape component */
	void Init(INT InBaseX,INT InBaseY,INT InComponentSizeQuads, INT InNumSubsections,INT InSubsectionSizeQuads);

	/**
	 * Recalculate cached bounds using height values.
	 */
	void UpdateCachedBounds();

	/**
	 * Update the MaterialInstance parameters to match the layer and weightmaps for this component
	 * Creates the MaterialInstance if it doesn't exist.
	 */
	void UpdateMaterialInstances();

	/**
	 * Generate mipmaps for height and tangent data.
	 * @param HeightmapTextureMipData - array of pointers to the locked mip data. 
	 *           This should only include the mips that are generated directly from this component's data
	 *           ie where each subsection has at least 2 vertices.
	 */
	void GenerateHeightmapMips(TArray<FColor*>& HeightmapTextureMipData, INT ComponentX1=0, INT ComponentY1=0, INT ComponentX2=MAXINT, INT ComponentY2=MAXINT,struct FLandscapeTextureDataInfo* TextureDataInfo=NULL);

	/**
	 * Generates empty mipmaps for weightmap
	 */
	static void CreateEmptyTextureMips(UTexture2D* Texture, UBOOL bClear = FALSE);

	/**
	 * Generate mipmaps for weightmap
	 * Assumes all weightmaps are unique to this component.
	 * @param WeightmapTextureBaseMipData: array of pointers to each of the weightmaps' base locked mip data.
	 */
	template<typename DataType>
	static void GenerateMipsTempl(INT InNumSubsections, INT InSubsectionSizeQuads, UTexture2D* WeightmapTexture, DataType* BaseMipData);
	static void GenerateWeightmapMips(INT InNumSubsections, INT InSubsectionSizeQuads, UTexture2D* WeightmapTexture, FColor* BaseMipData);
	static void GenerateDataMips(INT InNumSubsections, INT InSubsectionSizeQuads, UTexture2D* WeightmapTexture, BYTE* BaseMipData);

	/**
	 * Update mipmaps for existing weightmap texture
	 */
	template<typename DataType>
	static void UpdateMipsTempl(INT InNumSubsections, INT InSubsectionSizeQuads, UTexture2D* WeightmapTexture, TArray<DataType*>& WeightmapTextureMipData, INT ComponentX1=0, INT ComponentY1=0, INT ComponentX2=MAXINT, INT ComponentY2=MAXINT, struct FLandscapeTextureDataInfo* TextureDataInfo=NULL);
	static void UpdateWeightmapMips(INT InNumSubsections, INT InSubsectionSizeQuads, UTexture2D* WeightmapTexture, TArray<FColor*>& WeightmapTextureMipData, INT ComponentX1=0, INT ComponentY1=0, INT ComponentX2=MAXINT, INT ComponentY2=MAXINT, struct FLandscapeTextureDataInfo* TextureDataInfo=NULL);
	static void UpdateDataMips(INT InNumSubsections, INT InSubsectionSizeQuads, UTexture2D* Texture, TArray<BYTE*>& TextureMipData, INT ComponentX1=0, INT ComponentY1=0, INT ComponentX2=MAXINT, INT ComponentY2=MAXINT, struct FLandscapeTextureDataInfo* TextureDataInfo=NULL);

	/**
	 * Creates or updates collision component height data
	 * @param HeightmapTextureMipData: heightmap data
	 * @param ComponentX1, ComponentY1, ComponentX2, ComponentY2: region to update
	 * @param Whether to update bounds from render component.
	 */
	void UpdateCollisionHeightData(FColor* HeightmapTextureMipData, INT ComponentX1=0, INT ComponentY1=0, INT ComponentX2=MAXINT, INT ComponentY2=MAXINT, UBOOL bUpdateBounds=FALSE, UBOOL bRebuild=FALSE);

	/**
	 * Updates collision component dominant layer data
	 * @param WeightmapTextureMipData: weightmap data
	 * @param ComponentX1, ComponentY1, ComponentX2, ComponentY2: region to update
	 * @param Whether to update bounds from render component.
	 */
	void UpdateCollisionLayerData(TArray<FColor*>& WeightmapTextureMipData, INT ComponentX1=0, INT ComponentY1=0, INT ComponentX2=MAXINT, INT ComponentY2=MAXINT);

	/**
	 * Updates collision component dominant layer data for the whole component, locking and unlocking the weightmap textures.
	 */
	void UpdateCollisionLayerData();

	/**
	 * Creates weightmaps for this component for the layers specified in the WeightmapLayerAllocations array
	 */
	void ReallocateWeightmaps(struct FLandscapeEditDataInterface* DataInterface=NULL);

	/**
	 * Generate a key for this component's layer allocations to use with MaterialInstanceConstantMap.
	 */
	UMaterialInterface* GetLandscapeMaterial() const;
	FString GetLayerAllocationKey() const;
	void GetLayerDebugColorKey(INT& R, INT& G, INT& B) const;

	void RemoveInvalidWeightmaps();

	virtual void ExportCustomProperties(FOutputDevice& Out, UINT Indent);
	virtual void ImportCustomProperties(const TCHAR* SourceText, FFeedbackContext* Warn);

	void InitHeightmapData(TArray<FColor>& Heights, UBOOL bUpdateCollision);
	void InitWeightmapData(TArray<FName>& LayerNames, TArray<TArray<BYTE> >& Weights);

	FLOAT GetLayerWeightAtLocation( const FVector& InLocation, FName InLayerName, TArray<BYTE>* LayerCache=NULL );

	/** Return the LandscapeHeightfieldCollisionComponent matching this component */
	ULandscapeHeightfieldCollisionComponent* GetCollisionComponent() const;
#endif

	friend class FLandscapeComponentSceneProxy;
	friend struct FLandscapeComponentDataInterface;

	INT GetLODBias(FLOAT HeightThreshold); // Calculate LOD Bias based on heightmap complexity
	void SetLOD(UBOOL bForced, INT InLODValue);
};

class ULandscapeGizmoRenderComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LandscapeGizmoRenderComponent
    //## END PROPS LandscapeGizmoRenderComponent

    DECLARE_CLASS(ULandscapeGizmoRenderComponent,UPrimitiveComponent,0,Engine)
	/**
	 * Creates a new scene proxy for the path rendering component.
	 * @return	Pointer to the FLandscapeGizmoSceneProxy
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
};

class ULandscapeHeightfieldCollisionComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LandscapeHeightfieldCollisionComponent
    FWordBulkData CollisionHeightData;
    TArrayNoInit<FName> ComponentLayers;
    FByteBulkData DominantLayerData;
    INT SectionBaseX;
    INT SectionBaseY;
    INT CollisionSizeQuads;
    FLOAT CollisionScale;
    TArrayNoInit<BYTE> CollisionQuadFlags;
    TArrayNoInit<class UPhysicalMaterial*> PhysicalMaterials;
    class NxHeightField* RBHeightfield;
    FBoxSphereBounds CachedBoxSphereBounds;
    BITFIELD bIncludeHoles:1;
    BITFIELD bHeightFieldDataHasHole:1;
    SCRIPT_ALIGN;
    //## END PROPS LandscapeHeightfieldCollisionComponent

    DECLARE_CLASS(ULandscapeHeightfieldCollisionComponent,UPrimitiveComponent,0,Engine)
	enum ECollisionQuadFlags
	{
		QF_PhysicalMaterialMask = 63,	// Mask value for the physical material index, stored in the lower 6 bits.
		QF_EdgeTurned = 64,				// This quad's diagonal has been turned.
		QF_NoCollision = 128,			// This quad has no collision.
	};

	// UPrimitiveComponent interface.
	virtual void UpdateBounds();
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void InitComponentRBPhys(UBOOL bFixed);
	virtual UBOOL PointCheck(FCheckResult& Result,const FVector& Location,const FVector& Extent,DWORD TraceFlags);
	virtual UBOOL LineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);

	// UObject Interface
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
#if WITH_EDITOR
	virtual void ExportCustomProperties(FOutputDevice& Out, UINT Indent);
	virtual void ImportCustomProperties(const TCHAR* SourceText, FFeedbackContext* Warn);
	virtual void PostEditImport();
	virtual void PostEditUndo();
	virtual void PreSave();

	// Register ourselves with the actor.
	ELandscapeSetupErrors SetupActor(UBOOL bForce = FALSE);
	void PostLoad();

	// Update Collision object for add LandscapeComponent tool
	void UpdateAddCollisions(UBOOL bForceUpdate = FALSE);

	/** Return the LandscapeComponent matching this collision component */
	class ULandscapeComponent* GetLandscapeComponent() const;

	class ULandscapeInfo* GetLandscapeInfo(UBOOL bSpawnNewActor = TRUE) const;

	/** Return a list of collision triangles in world space */
	void GetCollisionTriangles( TArray<FVector>& OutTriangleVerts );

#endif

	/** Returns the landscape actor associated with this component. */
	class ALandscape* GetLandscapeActor() const;
	class ALandscapeProxy* GetLandscapeProxy() const;

	/** Recreate heightfield and restart physics */
	void RecreateHeightfield(UBOOL bUpdateAddCollision = TRUE);
};

class UTerrainComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS TerrainComponent
    TArrayNoInit<class UShadowMap2D*> ShadowMaps;
    TArrayNoInit<FGuid> IrrelevantLights;
    struct FTerrainObject* TerrainObject;
    INT SectionBaseX;
    INT SectionBaseY;
    INT SectionSizeX;
    INT SectionSizeY;
    INT TrueSectionSizeX;
    INT TrueSectionSizeY;
    FLightMapRef LightMap;
    TArrayNoInit<FTerrainPatchBounds> PatchBounds;
    TArrayNoInit<FTerrainMaterialMask> BatchMaterials;
    INT FullBatch;
    FTerrainBVTree BVTree;
    TArrayNoInit<FVector> CollisionVertices;
    class NxHeightField* RBHeightfield;
    BITFIELD bDisplayCollisionLevel:1;
    SCRIPT_ALIGN;
    //## END PROPS TerrainComponent

    DECLARE_CLASS(UTerrainComponent,UPrimitiveComponent,0,Engine)
	/**
	 * Builds the collision data for this terrain
	 */
	void BuildCollisionData(void);

	/**
	 * @return Whether or not the collision data for this component is dirty.
	 */
	UBOOL IsCollisionDataDirty() const
	{
		// @todo: Replace this with a proper flag, this is only a stub function right now.

		return TRUE;
	}

	// UObject interface.

	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	virtual void Serialize( FArchive& Ar );
	virtual void PostLoad();
	virtual void FinishDestroy();
	/**
	* @return		Sum of the size of textures referenced by this material.
	*/
	virtual INT GetResourceSize();

	/**
	 * Rebuilds the collision data for saving
	 */
	virtual void PreSave(void);

	// UPrimitiveComponent interface.

	virtual UBOOL PointCheck(FCheckResult& Result,const FVector& Location,const FVector& Extent,DWORD TraceFlags);
	virtual UBOOL LineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);
	virtual void UpdateBounds();
	
	/** 
	 * Retrieves the materials used in this component 
	 * 
	 * @param OutMaterials	The list of used materials.
	 */
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const;

	virtual void InitComponentRBPhys(UBOOL bFixed);

	/**
	 * Returns the MAX number of triangle this component will render.
	 *
	 *	@return	UINT		Maximum number of triangle that could be rendered.
	 */
	virtual UINT GetMaxTriangleCount( ) const;

	/**
	 * Returns the lightmap resolution used for this primivite instnace in the case of it supporting texture light/ shadow maps.
	 * 0 if not supported or no static shadowing.
	 *
	 * @param	Width	[out]	Width of light/shadow map
	 * @param	Height	[out]	Height of light/shadow map
	 *
	 * @return	UBOOL			TRUE if LightMap values are padded, FALSE if not
	 */
	virtual UBOOL GetLightMapResolution( INT& Width, INT& Height ) const;

	/**
	 *	Returns the static lightmap resolution used for this primitive.
	 *	0 if not supported or no static shadowing.
	 *
	 * @return	INT		The StaticLightmapResolution for the component
	 */
	virtual INT GetStaticLightMapResolution() const;

	/**
	 * Returns the light and shadow map memory for this primite in its out variables.
	 *
	 * Shadow map memory usage is per light whereof lightmap data is independent of number of lights, assuming at least one.
	 *
	 * @param [out] LightMapMemoryUsage		Memory usage in bytes for light map (either texel or vertex) data
	 * @param [out]	ShadowMapMemoryUsage	Memory usage in bytes for shadow map (either texel or vertex) data
	 */
	virtual void GetLightAndShadowMapMemoryUsage( INT& LightMapMemoryUsage, INT& ShadowMapMemoryUsage ) const;

	/**
	 *  Retrieve various actor metrics depending on the provided type.  All of
	 *  these will total the values for this component.
	 *
	 *  @param MetricsType The type of metric to calculate.
	 *
	 *  METRICS_VERTS    - Get the number of vertices.
	 *  METRICS_TRIS     - Get the number of triangles.
	 *  METRICS_SECTIONS - Get the number of sections.
	 *
	 *  @return INT The total of the given type for this component.
	 */
	virtual INT GetActorMetrics(EActorMetricsType MetricsType);

	friend struct FTerrainObject;
	friend class FTerrainComponentSceneProxy;

	// UActorComponent interface.
protected:
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );

	/**
	* Only valid for cases when the primitive will be reattached
	* @return	TRUE if the base primitive component should handle reattaching decals when the primitive is attached
	*/
	virtual UBOOL AllowDecalAutomaticReAttach() const
	{
		// always detach decals for terrain since we trigger a manual reattach
		return FALSE;
	}

public:
	virtual void InvalidateLightingCache();

	// UPrimitiveComponent interface.
	virtual void GenerateDecalRenderData(class FDecalState* Decal, TArray< FDecalRenderData* >& OutDecalRenderDatas) const;
	virtual void GetStaticLightingInfo(FStaticLightingPrimitiveInfo& OutPrimitiveInfo,const TArray<ULightComponent*>& InRelevantLights,const FLightingBuildOptions& Options);
	/**
	 *	Requests whether the component will use texture, vertex or no lightmaps.
	 *
	 *	@return	ELightMapInteractionType		The type of lightmap interaction the component will use.
	 */
	virtual ELightMapInteractionType GetStaticLightingType() const	{ return LMIT_Texture;	}
	virtual void GetStaticTriangles(FPrimitiveTriangleDefinitionInterface* PTDI) const;
	virtual void GetStreamingTextureInfo(TArray<FStreamingTexturePrimitiveInfo>& OutStreamingTextures) const;

	// Init

	void Init(INT InBaseX,INT InBaseY,INT InSizeX,INT InSizeY,INT InTrueSizeX,INT InTrueSizeY);

	// UpdatePatchBounds

	void UpdatePatchBounds();

	/** builds/updates a list of unique blended material combinations used by quads in this terrain section and puts them in the PatchBatches array.
	 * Also updates FullBatch with the index of the mask for the full set.
	 */
	void UpdatePatchBatches();

	/** Return's the terrain actor associated with the terrain component. */
	class ATerrain* GetTerrain() const
	{
		return CastChecked<ATerrain>(GetOuter());
	}

	/** Returns a vertex in the component's local space. */
	FVector GetLocalVertex(INT X,INT Y) const;

	/** Returns a vertex in the component's local space. */
	FVector GetWorldVertex(INT X,INT Y) const;

	// 
	void RenderPatches(const FSceneView* View,FPrimitiveDrawInterface* PDI);

	/**
	 * Gets the terrain collision data needed to pass to Novodex or to the
	 * kDOP code. Note: this code generates vertices/indices based on the
	 * Terrain->CollisionTessellationLevel
	 *
	 * @param OutVertices		[out] The array that gets each vert in the terrain
	 * @param OutIndices		[out] The array that holds the generated indices
	 */
	void GetCollisionData(TArray<FVector>& OutVertices,TArray<INT>& OutIndices) const;

	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	UINT GetTriangleCount();
	UINT GetTriangleCountForDecal( UDecalComponent * DecalComponent );
};

struct FLandscapeAddCollision
{
#if WITH_EDITORONLY_DATA
    FVector Corners[4];
#endif // WITH_EDITORONLY_DATA

		FLandscapeAddCollision()
		{
#if WITH_EDITORONLY_DATA
			Corners[0] = Corners[1] = Corners[2] = Corners[3] = FVector(0.f, 0.f, 0.f);
#endif // WITH_EDITORONLY_DATA
		}
	
};

class ULandscapeInfo : public UObject
{
public:
    //## BEGIN PROPS LandscapeInfo
    FGuid LandscapeGuid;
    TMap< FName, struct FLandscapeLayerStruct* > LayerInfoMap;
    struct FLandscapeDataInterface* DataInterface;
    TMap< QWORD,class ULandscapeComponent* > XYtoComponentMap;
    TMap< QWORD,class ULandscapeHeightfieldCollisionComponent* > XYtoCollisionComponentMap;
    class ALandscapeProxy* LandscapeProxy;
    TMap< QWORD,struct FLandscapeAddCollision > XYtoAddCollisionMap;
    TSet<class ALandscapeProxy*> Proxies;
    TSet<class ULandscapeComponent*> SelectedComponents;
    TSet<class ULandscapeHeightfieldCollisionComponent*> SelectedCollisionComponents;
    TSet<class ULandscapeComponent*> SelectedRegionComponents;
    TMap< QWORD,FLOAT > SelectedRegion;
#if WITH_EDITORONLY_DATA
    FStringNoInit HeightmapFilePath;
#endif // WITH_EDITORONLY_DATA
    BITFIELD bIsValid:1;
    SCRIPT_ALIGN;
    //## END PROPS LandscapeInfo

    DECLARE_CLASS(ULandscapeInfo,UObject,0,Engine)
	void GetSharedProperties(ALandscapeProxy* Landscape);
#if WITH_EDITOR
	virtual void PreSave();
	virtual void PostEditUndo();
	
	struct FLandscapeDataInterface* GetDataInterface();

	void GetComponentsInRegion(INT X1, INT Y1, INT X2, INT Y2, TSet<ULandscapeComponent*>& OutComponents);
	UBOOL GetLandscapeExtent(INT& MinX, INT& MinY, INT& MaxX, INT& MaxY);
	void Export(TArray<FName>& Layernames, TArray<FString>& Filenames);
	UBOOL ReimportHeightmap(INT DataSize, const WORD* Data);
	UBOOL ReimportLayermap(FName LayerName, TArray<BYTE>& Data);
	ALandscape* ChangeComponentSetting(INT VertsX, INT VertsY, INT InNumSubsections, INT InSubsectionSizeQuads);

	UBOOL GetSelectedExtent(INT& MinX, INT& MinY, INT& MaxX, INT& MaxY);
	FVector GetLandscapeCenterPos(FLOAT& LengthZ, INT MinX = MAXINT, INT MinY = MAXINT, INT MaxX = MININT, INT MaxY = MININT);
	UBOOL IsValidPosition(INT X, INT Y);
	void DeleteLayer(FName LayerName);

	void UpdateDebugColorMaterial();

	// Used by all selection tool...
	void UpdateSelectedComponents(TSet<class ULandscapeComponent*>& NewComponents, UBOOL bIsComponentwise = TRUE);
	// Sort selected components based on location
	void SortSelectedComponents();
	void ClearSelectedRegion(UBOOL bIsComponentwise = TRUE);

	// Update Collision object for add LandscapeComponent tool
	void UpdateAllAddCollisions();
	void UpdateAddCollision(QWORD LandscapeKey, UBOOL bForceUpdate = FALSE);

	// Update LayerInfoMap
	UBOOL UpdateLayerInfoMap(ALandscapeProxy* Proxy = NULL, UBOOL bInvalidate = FALSE);

	void UpdateLODBias(FLOAT Threshold);

	void CheckValidate();
#endif

	// UObject interface
	virtual void Serialize(FArchive& Ar);
	virtual void BeginDestroy();
	virtual void PostLoad();
};

class ULandscapeLayerInfoObject : public UObject
{
public:
    //## BEGIN PROPS LandscapeLayerInfoObject
    FName LayerName;
    class UPhysicalMaterial* PhysMaterial;
    FLOAT Hardness;
    BITFIELD bNoWeightBlend:1;
    SCRIPT_ALIGN;
    //## END PROPS LandscapeLayerInfoObject

    DECLARE_CLASS(ULandscapeLayerInfoObject,UObject,0,Engine)
	UBOOL GetSharedProperties(FLandscapeLayerInfo* Info);
#if WITH_EDITOR
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();
#endif
};

class UTerrainWeightMapTexture : public UTexture2D
{
public:
    //## BEGIN PROPS TerrainWeightMapTexture
    class ATerrain* ParentTerrain;
    TArrayNoInit<struct FTerrainWeightedMaterial*> WeightedMaterials;
    //## END PROPS TerrainWeightMapTexture

    DECLARE_CLASS(UTerrainWeightMapTexture,UTexture2D,0,Engine)
    // UObject interface
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();

	/** 
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	void Initialize(ATerrain* InTerrain);
	void UpdateData();
};

class UTerrainLayerSetup : public UObject
{
public:
    //## BEGIN PROPS TerrainLayerSetup
    TArrayNoInit<FTerrainFilteredMaterial> Materials;
    //## END PROPS TerrainLayerSetup

    DECLARE_CLASS(UTerrainLayerSetup,UObject,0,Engine)
	/** returns the alpha that should be used in the weighting for the given material in this layer at the given world vertex
	 * @param Material the filtered material that is being weighted
	 * @param WorldVertex the world location of the vertex
	 * @return the alpha to use for weighting
	 */
	virtual FLOAT GetMaterialAlpha(const FTerrainFilteredMaterial* Material, const FVector& WorldVertex) { return Material->Alpha; }

	// UObject interface.

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	
	/**
	 * Called after serialization. Ensures that there are only 64 materials.
	 */
	virtual void PostLoad();
};

class UTerrainMaterial : public UObject
{
public:
    //## BEGIN PROPS TerrainMaterial
    FMatrix LocalToMapping;
    BYTE MappingType;
    FLOAT MappingScale;
    FLOAT MappingRotation;
    FLOAT MappingPanU;
    FLOAT MappingPanV;
    class UMaterialInterface* Material;
    class UTexture2D* DisplacementMap;
    FLOAT DisplacementScale;
    //## END PROPS TerrainMaterial

    DECLARE_CLASS(UTerrainMaterial,UObject,0,Engine)
	// UpdateMappingTransform

	void UpdateMappingTransform();

	// UObject interface.
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_TERRAIN_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(ATerrain,-1,execCalcLayerBounds);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_TERRAIN_NATIVE_DEFS
#define ENGINE_TERRAIN_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_TERRAIN \
	ALandscapeProxy::StaticClass(); \
	ALandscape::StaticClass(); \
	ATerrain::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Terrain"), GEngineATerrainNatives); \
	ALandscapeGizmoActor::StaticClass(); \
	ALandscapeGizmoActiveActor::StaticClass(); \
	ULandscapeComponent::StaticClass(); \
	ULandscapeGizmoRenderComponent::StaticClass(); \
	ULandscapeHeightfieldCollisionComponent::StaticClass(); \
	UTerrainComponent::StaticClass(); \
	ULandscapeInfo::StaticClass(); \
	ULandscapeLayerInfoObject::StaticClass(); \
	UTerrainWeightMapTexture::StaticClass(); \
	UTerrainLayerSetup::StaticClass(); \
	UTerrainMaterial::StaticClass(); \

#endif // ENGINE_TERRAIN_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineATerrainNatives[] = 
{ 
	MAP_NATIVE(ATerrain, execCalcLayerBounds)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(ALandscapeProxy,LandscapeProxy,LandscapeGuid)
VERIFY_CLASS_OFFSET_NODIE(ALandscapeProxy,LandscapeProxy,NumSubsections)
VERIFY_CLASS_SIZE_NODIE(ALandscapeProxy)
VERIFY_CLASS_OFFSET_NODIE(ALandscape,Landscape,LayerNames_DEPRECATED)
VERIFY_CLASS_OFFSET_NODIE(ALandscape,Landscape,LayerInfos_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(ALandscape)
VERIFY_CLASS_OFFSET_NODIE(ATerrain,Terrain,Heights)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(ATerrain,Terrain,LightingGuid)
#else
VERIFY_CLASS_OFFSET_NODIE(ATerrain,Terrain,WireframeColor)
#endif
VERIFY_CLASS_SIZE_NODIE(ATerrain)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(ALandscapeGizmoActor,LandscapeGizmoActor,Width)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(ALandscapeGizmoActor,LandscapeGizmoActor,TargetLandscapeInfo)
#endif
VERIFY_CLASS_SIZE_NODIE(ALandscapeGizmoActor)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(ALandscapeGizmoActiveActor,LandscapeGizmoActiveActor,DataType)
#else
VERIFY_CLASS_OFFSET_NODIE(ALandscapeGizmoActiveActor,LandscapeGizmoActiveActor,SelectedData)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(ALandscapeGizmoActiveActor,LandscapeGizmoActiveActor,LayerNames)
#endif
VERIFY_CLASS_SIZE_NODIE(ALandscapeGizmoActiveActor)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeComponent,LandscapeComponent,SectionBaseX)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeComponent,LandscapeComponent,LODBias)
VERIFY_CLASS_SIZE_NODIE(ULandscapeComponent)
VERIFY_CLASS_SIZE_NODIE(ULandscapeGizmoRenderComponent)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeHeightfieldCollisionComponent,LandscapeHeightfieldCollisionComponent,CollisionHeightData)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeHeightfieldCollisionComponent,LandscapeHeightfieldCollisionComponent,CachedBoxSphereBounds)
VERIFY_CLASS_SIZE_NODIE(ULandscapeHeightfieldCollisionComponent)
VERIFY_CLASS_OFFSET_NODIE(UTerrainComponent,TerrainComponent,ShadowMaps)
VERIFY_CLASS_OFFSET_NODIE(UTerrainComponent,TerrainComponent,RBHeightfield)
VERIFY_CLASS_SIZE_NODIE(UTerrainComponent)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeInfo,LandscapeInfo,LandscapeGuid)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(ULandscapeInfo,LandscapeInfo,HeightmapFilePath)
#else
VERIFY_CLASS_OFFSET_NODIE(ULandscapeInfo,LandscapeInfo,SelectedRegion)
#endif
VERIFY_CLASS_SIZE_NODIE(ULandscapeInfo)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeLayerInfoObject,LandscapeLayerInfoObject,LayerName)
VERIFY_CLASS_OFFSET_NODIE(ULandscapeLayerInfoObject,LandscapeLayerInfoObject,Hardness)
VERIFY_CLASS_SIZE_NODIE(ULandscapeLayerInfoObject)
VERIFY_CLASS_OFFSET_NODIE(UTerrainWeightMapTexture,TerrainWeightMapTexture,ParentTerrain)
VERIFY_CLASS_OFFSET_NODIE(UTerrainWeightMapTexture,TerrainWeightMapTexture,WeightedMaterials)
VERIFY_CLASS_SIZE_NODIE(UTerrainWeightMapTexture)
VERIFY_CLASS_OFFSET_NODIE(UTerrainLayerSetup,TerrainLayerSetup,Materials)
VERIFY_CLASS_SIZE_NODIE(UTerrainLayerSetup)
VERIFY_CLASS_OFFSET_NODIE(UTerrainMaterial,TerrainMaterial,LocalToMapping)
VERIFY_CLASS_OFFSET_NODIE(UTerrainMaterial,TerrainMaterial,DisplacementScale)
VERIFY_CLASS_SIZE_NODIE(UTerrainMaterial)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
