/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_GAMEENGINE_ENUMS
#define INCLUDED_ENGINE_GAMEENGINE_ENUMS 1

enum EHostMigrationProgress
{
    HostMigration_None      =0,
    HostMigration_FindingNewHost=1,
    HostMigration_MigratingAsHost=2,
    HostMigration_MigratingAsClient=3,
    HostMigration_ClientTravel=4,
    HostMigration_HostReadyToTravel=5,
    HostMigration_Failed    =6,
    HostMigration_MAX       =7,
};
#define FOREACH_ENUM_EHOSTMIGRATIONPROGRESS(op) \
    op(HostMigration_None) \
    op(HostMigration_FindingNewHost) \
    op(HostMigration_MigratingAsHost) \
    op(HostMigration_MigratingAsClient) \
    op(HostMigration_ClientTravel) \
    op(HostMigration_HostReadyToTravel) \
    op(HostMigration_Failed) 
enum EPreferredLightmapType
{
    EPLT_Default            =0,
    EPLT_Directional        =1,
    EPLT_Simple             =2,
    EPLT_MAX                =3,
};
#define FOREACH_ENUM_EPREFERREDLIGHTMAPTYPE(op) \
    op(EPLT_Default) \
    op(EPLT_Directional) \
    op(EPLT_Simple) 
enum EVisibilityAggressiveness
{
    VIS_LeastAggressive     =0,
    VIS_ModeratelyAggressive=1,
    VIS_MostAggressive      =2,
    VIS_Max                 =3,
};
#define FOREACH_ENUM_EVISIBILITYAGGRESSIVENESS(op) \
    op(VIS_LeastAggressive) \
    op(VIS_ModeratelyAggressive) \
    op(VIS_MostAggressive) 
enum EConsoleType
{
    CONSOLE_Any             =0,
    CONSOLE_Xbox360         =1,
    CONSOLE_PS3             =2,
    CONSOLE_Mobile          =3,
    CONSOLE_IPhone          =4,
    CONSOLE_Android         =5,
    CONSOLE_WiiU            =6,
    CONSOLE_Flash           =7,
    CONSOLE_MAX             =8,
};
#define FOREACH_ENUM_ECONSOLETYPE(op) \
    op(CONSOLE_Any) \
    op(CONSOLE_Xbox360) \
    op(CONSOLE_PS3) \
    op(CONSOLE_Mobile) \
    op(CONSOLE_IPhone) \
    op(CONSOLE_Android) \
    op(CONSOLE_WiiU) \
    op(CONSOLE_Flash) 
enum ENetMode
{
    NM_Standalone           =0,
    NM_DedicatedServer      =1,
    NM_ListenServer         =2,
    NM_Client               =3,
    NM_MAX                  =4,
};
#define FOREACH_ENUM_ENETMODE(op) \
    op(NM_Standalone) \
    op(NM_DedicatedServer) \
    op(NM_ListenServer) \
    op(NM_Client) 
enum ETransitionType
{
    TT_None                 =0,
    TT_Paused               =1,
    TT_Loading              =2,
    TT_Saving               =3,
    TT_Connecting           =4,
    TT_Precaching           =5,
    TT_MAX                  =6,
};
#define FOREACH_ENUM_ETRANSITIONTYPE(op) \
    op(TT_None) \
    op(TT_Paused) \
    op(TT_Loading) \
    op(TT_Saving) \
    op(TT_Connecting) \
    op(TT_Precaching) 
enum EFullyLoadPackageType
{
    FULLYLOAD_Map           =0,
    FULLYLOAD_Game_PreLoadClass=1,
    FULLYLOAD_Game_PostLoadClass=2,
    FULLYLOAD_Always        =3,
    FULLYLOAD_Mutator       =4,
    FULLYLOAD_MAX           =5,
};
#define FOREACH_ENUM_EFULLYLOADPACKAGETYPE(op) \
    op(FULLYLOAD_Map) \
    op(FULLYLOAD_Game_PreLoadClass) \
    op(FULLYLOAD_Game_PostLoadClass) \
    op(FULLYLOAD_Always) \
    op(FULLYLOAD_Mutator) 

#endif // !INCLUDED_ENGINE_GAMEENGINE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_GAMEENGINE_CLASSES
#define INCLUDED_ENGINE_GAMEENGINE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

#define UCONST_MAX_INSTANCES_PER_CLASS 5
#define UCONST_MAX_BOOKMARK_NUMBER 10

struct FNetViewer
{
    class APlayerController* InViewer;
    class AActor* Viewer;
    FVector ViewLocation;
    FVector ViewDir;

		FNetViewer(UNetConnection* InConnection, FLOAT DeltaSeconds);
	
};

struct FCompartmentRunList
{
    BITFIELD RigidBody:1;
    BITFIELD Fluid:1;
    BITFIELD Cloth:1;
    BITFIELD SoftBody:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FCompartmentRunList() {}
    FCompartmentRunList(EEventParm)
    {
        appMemzero(this, sizeof(FCompartmentRunList));
    }
};

struct FPhysXSimulationProperties
{
    BITFIELD bUseHardware:1;
    BITFIELD bFixedTimeStep:1;
    FLOAT TimeStep;
    INT MaxSubSteps;

    /** Constructors */
    FPhysXSimulationProperties() {}
    FPhysXSimulationProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXSimulationProperties));
    }
};

struct FPhysXSceneProperties
{
    struct FPhysXSimulationProperties PrimaryScene;
    struct FPhysXSimulationProperties CompartmentRigidBody;
    struct FPhysXSimulationProperties CompartmentFluid;
    struct FPhysXSimulationProperties CompartmentCloth;
    struct FPhysXSimulationProperties CompartmentSoftBody;

    /** Constructors */
    FPhysXSceneProperties() {}
    FPhysXSceneProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXSceneProperties));
    }
};

struct FApexModuleDestructibleSettings
{
    INT MaxChunkIslandCount;
    INT MaxShapeCount;
    INT MaxRrbActorCount;
    FLOAT MaxChunkSeparationLOD;
    BITFIELD bOverrideMaxChunkSeparationLOD:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FApexModuleDestructibleSettings() {}
    FApexModuleDestructibleSettings(EEventParm)
    {
        appMemzero(this, sizeof(FApexModuleDestructibleSettings));
    }
};

struct FPhysXEmitterVerticalProperties
{
    BITFIELD bDisableLod:1;
    INT ParticlesLodMin;
    INT ParticlesLodMax;
    INT PacketsPerPhysXParticleSystemMax;
    BITFIELD bApplyCylindricalPacketCulling:1;
    FLOAT SpawnLodVsFifoBias;

    /** Constructors */
    FPhysXEmitterVerticalProperties() {}
    FPhysXEmitterVerticalProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXEmitterVerticalProperties));
    }
};

struct FPhysXVerticalProperties
{
    struct FPhysXEmitterVerticalProperties Emitters;

    /** Constructors */
    FPhysXVerticalProperties() {}
    FPhysXVerticalProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXVerticalProperties));
    }
};

struct FWorldFractureSettings
{
    FLOAT ChanceOfPhysicsChunkOverride;
    BITFIELD bEnableChanceOfPhysicsChunkOverride:1;
    BITFIELD bLimitExplosionChunkSize:1;
    FLOAT MaxExplosionChunkSize;
    BITFIELD bLimitDamageChunkSize:1;
    FLOAT MaxDamageChunkSize;
    INT MaxNumFacturedChunksToSpawnInAFrame;
    FLOAT FractureExplosionVelScale;

    /** Constructors */
    FWorldFractureSettings() {}
    FWorldFractureSettings(EEventParm)
    {
        appMemzero(this, sizeof(FWorldFractureSettings));
    }
};

struct FScreenMessageString
{
    QWORD Key;
    FString ScreenMessage;
    FColor DisplayColor;
    FLOAT TimeToDisplay;
    FLOAT CurrentTimeDisplayed;

    /** Constructors */
    FScreenMessageString()
    : TimeToDisplay(0)
    , CurrentTimeDisplayed(0)
    {}
    FScreenMessageString(EEventParm)
    {
        appMemzero(this, sizeof(FScreenMessageString));
    }
};

struct FLightmassWorldInfoSettings
{
    FLOAT StaticLightingLevelScale;
    INT NumIndirectLightingBounces;
    FColor EnvironmentColor;
    FLOAT EnvironmentIntensity;
    BITFIELD bEnableAdvancedEnvironmentColor:1;
    SCRIPT_ALIGN;
    FColor EnvironmentSunColor;
    FLOAT EnvironmentSunIntensity;
    FLOAT EnvironmentLightTerminatorAngle;
    FVector EnvironmentLightDirection;
    FLOAT EmissiveBoost;
    FLOAT DiffuseBoost;
    FLOAT SpecularBoost;
    FLOAT IndirectNormalInfluenceBoost;
    BITFIELD bUseAmbientOcclusion:1;
    BITFIELD bEnableImageReflectionShadowing:1;
    FLOAT DirectIlluminationOcclusionFraction;
    FLOAT IndirectIlluminationOcclusionFraction;
    FLOAT OcclusionExponent;
    FLOAT FullyOccludedSamplesFraction;
    FLOAT MaxOcclusionDistance;
    BITFIELD bVisualizeMaterialDiffuse:1;
    BITFIELD bVisualizeAmbientOcclusion:1;
    BITFIELD bCompressShadowmap:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FLightmassWorldInfoSettings() {}
    FLightmassWorldInfoSettings(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassWorldInfoSettings));
    }
};

struct FNavMeshPathConstraintCacheDatum
{
    INT ListIdx;
    class UNavMeshPathConstraint* List[5];

    /** Constructors */
    FNavMeshPathConstraintCacheDatum() {}
    FNavMeshPathConstraintCacheDatum(EEventParm)
    {
        appMemzero(this, sizeof(FNavMeshPathConstraintCacheDatum));
    }
};

struct FNavMeshPathGoalEvaluatorCacheDatum
{
    INT ListIdx;
    class UNavMeshPathGoalEvaluator* List[5];

    /** Constructors */
    FNavMeshPathGoalEvaluatorCacheDatum() {}
    FNavMeshPathGoalEvaluatorCacheDatum(EEventParm)
    {
        appMemzero(this, sizeof(FNavMeshPathGoalEvaluatorCacheDatum));
    }
};

struct FHostMigrationState
{
    BYTE HostMigrationProgress;
    FLOAT HostMigrationElapsedTime;
    FLOAT HostMigrationTravelCountdown;
    FStringNoInit HostMigrationTravelURL;
    BITFIELD bHostMigrationEnabled:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FHostMigrationState() {}
    FHostMigrationState(EEventParm)
    {
        appMemzero(this, sizeof(FHostMigrationState));
    }
};

struct WorldInfo_eventNotifyHostMigrationStateChanged_Parms
{
    BYTE NewState;
    BYTE OldState;
    WorldInfo_eventNotifyHostMigrationStateChanged_Parms(EEventParm)
    {
    }
};
struct WorldInfo_eventCanBeginHostMigration_Parms
{
    UBOOL ReturnValue;
    WorldInfo_eventCanBeginHostMigration_Parms(EEventParm)
    {
    }
};
struct WorldInfo_eventServerTravel_Parms
{
    FString URL;
    UBOOL bAbsolute;
    UBOOL bShouldSkipGameNotify;
    WorldInfo_eventServerTravel_Parms(EEventParm)
    {
    }
};
class AWorldInfo : public AZoneInfo
{
public:
    //## BEGIN PROPS WorldInfo
    struct FPostProcessSettings DefaultPostProcessSettings;
    class UPostProcessChain* WorldPostProcessChain;
    BITFIELD bPersistPostProcessToNextLevel:1;
    BITFIELD bFogEnabled:1;
    BITFIELD bBumpOffsetEnabled:1;
    BITFIELD bUseGammaCorrection:1;
    BITFIELD bMapNeedsLightingFullyRebuilt:1;
    BITFIELD bMapHasMultipleDominantLightsAffectingOnePrimitive:1;
    BITFIELD bMapHasPathingErrors:1;
    BITFIELD bRequestedBlockOnAsyncLoading:1;
    BITFIELD bBegunPlay:1;
    BITFIELD bPlayersOnly:1;
    BITFIELD bPlayersOnlyPending:1;
    BITFIELD bSuspendAI:1;
    BITFIELD bDropDetail:1;
    BITFIELD bAggressiveLOD:1;
    BITFIELD bStartup:1;
    BITFIELD bPathsRebuilt:1;
    BITFIELD bHasPathNodes:1;
    BITFIELD bIsMenuLevel:1;
    BITFIELD bDebugPauseExecution:1;
    BITFIELD bDebugStepExecution:1;
    BITFIELD bUseConsoleInput:1;
    BITFIELD bMinimizeBSPSections:1;
    BITFIELD bNoDefaultInventoryForPlayer:1;
    BITFIELD bNoPathWarnings:1;
    BITFIELD bNoMobileMapWarnings:1;
    BITFIELD bHighPriorityLoading:1;
    BITFIELD bHighPriorityLoadingLocal:1;
    BITFIELD bUseProcBuildingRulesetOverride:1;
    BITFIELD bInteractiveMode:1;
    BITFIELD bSupportDoubleBufferedPhysics:1;
    BITFIELD bPhysicsIgnoreDeltaTime:1;
private:
    BITFIELD bEnableChanceOfPhysicsChunkOverride:1;
    BITFIELD bLimitExplosionChunkSize:1;
    BITFIELD bLimitDamageChunkSize:1;
public:
    BITFIELD bPrecomputeVisibility:1;
    BITFIELD bPlaceCellsOnSurfaces:1;
    BITFIELD bAllowTemporalAA:1;
    BITFIELD bUseGlobalIllumination:1;
    BITFIELD bForceNoPrecomputedLighting:1;
    BITFIELD bHaveActiveCrowd:1;
    BITFIELD bAllowHostMigration:1;
    BITFIELD bGameplayFramePause:1;
    FLOAT SquintModeKernelSize;
    class APostProcessVolume* HighestPriorityPostProcessVolume;
    struct FReverbSettings DefaultReverbSettings;
    FInteriorSettings DefaultAmbientZoneSettings;
    FLOAT FogStart;
    FLOAT FogEnd;
    FColor FogColor;
    FLOAT BumpEnd;
    class AReverbVolume* HighestPriorityReverbVolume;
    TArrayNoInit<class AMassiveLODOverrideVolume*> MassiveLODOverrideVolumes;
    TArrayNoInit<class APortalVolume*> PortalVolumes;
    TArrayNoInit<class AEnvironmentVolume*> EnvironmentVolumes;
    TArrayNoInit<class ULevelStreaming*> StreamingLevels;
    DOUBLE LastTimeUnbuiltLightingWasEncountered;
#if WITH_EDITORONLY_DATA
    class UBookMark* BookMarks[10];
    class UKismetBookMark* KismetBookMarks[10];
    TArrayNoInit<class UClipPadEntry*> ClipPadEntries;
#endif // WITH_EDITORONLY_DATA
    FLOAT TimeDilation;
    FLOAT DemoPlayTimeDilation;
    FLOAT TimeSeconds;
    FLOAT RealTimeSeconds;
    FLOAT AudioTimeSeconds;
    FLOAT DeltaSeconds;
    FLOAT PauseDelay;
    FLOAT RealTimeToUnPause;
    class APlayerReplicationInfo* Pauser;
#if WITH_EDITORONLY_DATA
    FStringNoInit VisibleGroups_DEPRECATED;
    FStringNoInit VisibleLayers;
#endif // WITH_EDITORONLY_DATA
    class UTexture2D* DefaultTexture;
    class UTexture2D* WireframeTexture;
    class UTexture2D* WhiteSquareTexture;
    class UTexture2D* LargeVertex;
    class UTexture2D* BSPVertex;
    TArrayNoInit<FString> DeferredExecs;
    class AGameReplicationInfo* GRI;
    BYTE NetMode;
    BYTE NextTravelType;
    BYTE VisibilityAggressiveness;
    BYTE PreferredLightmapType;
    BYTE LevelLightingQuality;
    FStringNoInit ComputerName;
    FStringNoInit EngineVersion;
    FStringNoInit MinNetVersion;
    class AGameInfo* Game;
    FLOAT StallZ;
    FLOAT WorldGravityZ;
    FLOAT DefaultGravityZ;
    FLOAT GlobalGravityZ;
    FLOAT RBPhysicsGravityScaling;
    class ANavigationPoint* NavigationPointList;
    class AController* ControllerList;
    class APawn* PawnList;
    class ACoverLink* CoverList;
    class APylon* PylonList;
    FLOAT MoveRepSize;
    TArrayNoInit<struct FNetViewer> ReplicationViewers;
    FStringNoInit NextURL;
    FLOAT NextSwitchCountdown;
    INT PackedLightAndShadowMapTextureSize;
    FVector DefaultColorScale;
    class UClass* DefaultGameType;
    TArrayNoInit<class UClass*> GameTypesSupportedOnThisMap;
#if WITH_EDITORONLY_DATA
    class UClass* GameTypeForPIE;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<class UObject*> ClientDestroyedActorContent;
    TArrayNoInit<FName> PreparingLevelNames;
    FName CommittedPersistentLevelName;
    class UObjectReferencer* PersistentMapForcedObjects;
    class UAudioComponent* MusicComp;
    struct FMusicTrackStruct CurrentMusicTrack;
    struct FMusicTrackStruct ReplicatedMusicTrack;
    FStringNoInit Title;
    FStringNoInit Author;
protected:
    class UMapInfo* MyMapInfo;
public:
    FStringNoInit EmitterPoolClassPath;
    class AEmitterPool* MyEmitterPool;
    FStringNoInit DecalManagerClassPath;
    class ADecalManager* MyDecalManager;
    FStringNoInit FractureManagerClassPath;
    class AFractureManager* MyFractureManager;
    FStringNoInit ParticleEventManagerClassPath;
    class AParticleEventManager* MyParticleEventManager;
    class UProcBuildingRuleset* ProcBuildingRulesetOverride;
    INT SkelMeshCompTickTagCount;
    FLOAT MaxPhysicsDeltaTime;
    INT MaxPhysicsSubsteps;
    struct FPhysXSceneProperties PhysicsProperties;
    TArrayNoInit<struct FCompartmentRunList> CompartmentRunFrames;
    FLOAT DefaultSkinWidth;
    FLOAT ApexLODResourceBudget;
    FLOAT ApexDestructionLODResourceValue;
    FLOAT ApexClothingLODResourceValue;
    struct FApexModuleDestructibleSettings DestructibleSettings;
    class UPhysicsLODVerticalEmitter* EmitterVertical;
    struct FPhysXVerticalProperties VerticalProperties;
    TArrayNoInit<class AWorldAttractor*> WorldAttractors;
private:
    FLOAT ChanceOfPhysicsChunkOverride;
    FLOAT MaxExplosionChunkSize;
    FLOAT MaxDamageChunkSize;
    FLOAT FractureExplosionVelScale;
    INT MaxNumFacturedChunksToSpawnInAFrame;
public:
    INT NumFacturedChunksSpawnedThisFrame;
    FLOAT FracturedMeshWeaponDamage;
    INT VisibilityCellSize;
    FLOAT CharacterLitIndirectBrightness;
    FLOAT CharacterLitIndirectContrastFactor;
    FLOAT CharacterShadowedIndirectBrightness;
    FLOAT CharacterShadowedIndirectContrastFactor;
    FLOAT CharacterLightingContrastFactor;
    class UTexture2D* ImageReflectionEnvironmentTexture;
    FLinearColor ImageReflectionEnvironmentColor;
    FLOAT ImageReflectionEnvironmentRotation;
    TMap<INT, FScreenMessageString> ScreenMessages;
    TArrayNoInit<struct FScreenMessageString> PriorityScreenMessages;
#if WITH_EDITORONLY_DATA
    INT MaxTrianglesPerLeaf;
    class UDEPRECATED_LightmassLevelSettings* LMLevelSettings_DEPRECATED;
    TMap< FGuid, class ULandscapeInfo* > LandscapeInfoMap;
#endif // WITH_EDITORONLY_DATA
    struct FLightmassWorldInfoSettings LightmassSettings;
    TMap< UClass*, FNavMeshPathConstraintCacheDatum > NavMeshPathConstraintCache;
    TMap< UClass*, FNavMeshPathGoalEvaluatorCacheDatum > NavMeshPathGoalEvaluatorCache;
    class ACrowdPopulationManagerBase* PopulationManager;
    struct FHostMigrationState PeerHostMigration;
    FLOAT HostMigrationTimeout;
    class APhysicsVolume* FirstPhysicsVolume;
    //## END PROPS WorldInfo

    virtual void ReleaseCachedConstraintsAndEvaluators();
    virtual class UNavMeshPathConstraint* GetNavMeshPathConstraintFromCache(class UClass* ConstraintClass,class UNavigationHandle* Requestor);
    virtual class UNavMeshPathGoalEvaluator* GetNavMeshPathGoalEvaluatorFromCache(class UClass* GoalEvalClass,class UNavigationHandle* Requestor);
    void AddOnScreenDebugMessage(INT Key,FLOAT TimeToDisplay,FColor DisplayColor,const FString& DebugMessage);
    void SetMusicVolume(FLOAT VolumeMultiplier);
    void UpdateMusicTrack(struct FMusicTrackStruct NewMusicTrack);
    virtual FLOAT GetGravityZ();
    class USequence* GetGameSequence() const;
    TArray<class USequence*> GetAllRootSequences() const;
    void SetLevelRBGravity(FVector NewGrav);
    virtual FString GetLocalURL() const;
    UBOOL IsDemoBuild() const;
    UBOOL IsConsoleBuild(BYTE ConsoleType=0) const;
    UBOOL IsWithGFx() const;
    UBOOL IsPlayInEditor() const;
    UBOOL IsPlayInPreview() const;
    UBOOL IsPlayInMobilePreview() const;
    void ForceGarbageCollection(UBOOL bFullPurge=FALSE);
    void VerifyNavList();
    virtual FString GetAddressURL() const;
    void NotifyMatchStarted(UBOOL bShouldActivateLevelStartupEvents=TRUE,UBOOL bShouldActivateLevelBeginningEvents=TRUE,UBOOL bShouldActivateLevelLoadedEvents=FALSE);
    void PrepareMapChange(const TArray<FName>& LevelNames);
    UBOOL IsPreparingMapChange();
    UBOOL IsMapChangeReady();
    void CancelPendingMapChange();
    void CommitMapChange();
    void SeamlessTravel(const FString& URL,UBOOL bAbsolute=FALSE,FGuid MapPackageGuid=FGuid(EC_EventParm));
    UBOOL IsInSeamlessTravel();
    void SetSeamlessTravelMidpointPause(UBOOL bNowPaused);
    class UMapInfo* GetMapInfo();
    void SetMapInfo(class UMapInfo* NewMapInfo);
    FString GetMapName(UBOOL bIncludePrefix=FALSE);
    BYTE GetDetailMode();
    UBOOL IsRecordingDemo();
    UBOOL IsPlayingDemo();
    void GetDemoFrameInfo(INT* CurrentFrame=NULL,INT* TotalFrames=NULL);
    UBOOL GetDemoRewindPoints(TArray<INT>& OutRewindPoints);
    void DoMemoryTracking();
    struct FWorldFractureSettings GetWorldFractureSettings() const;
    class AWorldInfo* GetWorldInfo();
    class AEnvironmentVolume* FindEnvironmentVolume(FVector TestLocation);
    virtual UBOOL BeginHostMigration();
    virtual void ToggleHostMigration(UBOOL bEnabled);
    void ClearObjectPools();
    DECLARE_FUNCTION(execReleaseCachedConstraintsAndEvaluators)
    {
        P_FINISH;
        this->ReleaseCachedConstraintsAndEvaluators();
    }
    DECLARE_FUNCTION(execGetNavMeshPathConstraintFromCache)
    {
        P_GET_OBJECT(UClass,ConstraintClass);
        P_GET_OBJECT(UNavigationHandle,Requestor);
        P_FINISH;
        *(class UNavMeshPathConstraint**)Result=this->GetNavMeshPathConstraintFromCache(ConstraintClass,Requestor);
    }
    DECLARE_FUNCTION(execGetNavMeshPathGoalEvaluatorFromCache)
    {
        P_GET_OBJECT(UClass,GoalEvalClass);
        P_GET_OBJECT(UNavigationHandle,Requestor);
        P_FINISH;
        *(class UNavMeshPathGoalEvaluator**)Result=this->GetNavMeshPathGoalEvaluatorFromCache(GoalEvalClass,Requestor);
    }
    DECLARE_FUNCTION(execAddOnScreenDebugMessage)
    {
        P_GET_INT(Key);
        P_GET_FLOAT(TimeToDisplay);
        P_GET_STRUCT(FColor,DisplayColor);
        P_GET_STR(DebugMessage);
        P_FINISH;
        this->AddOnScreenDebugMessage(Key,TimeToDisplay,DisplayColor,DebugMessage);
    }
    DECLARE_FUNCTION(execIsMenuLevel);
    DECLARE_FUNCTION(execSetMusicVolume)
    {
        P_GET_FLOAT(VolumeMultiplier);
        P_FINISH;
        this->SetMusicVolume(VolumeMultiplier);
    }
    DECLARE_FUNCTION(execUpdateMusicTrack)
    {
        P_GET_STRUCT_INIT(struct FMusicTrackStruct,NewMusicTrack);
        P_FINISH;
        this->UpdateMusicTrack(NewMusicTrack);
    }
    DECLARE_FUNCTION(execGetGameSequence)
    {
        P_FINISH;
        *(class USequence**)Result=this->GetGameSequence();
    }
    DECLARE_FUNCTION(execGetAllRootSequences)
    {
        P_FINISH;
        *(TArray<class USequence*>*)Result=this->GetAllRootSequences();
    }
    DECLARE_FUNCTION(execSetLevelRBGravity)
    {
        P_GET_STRUCT(FVector,NewGrav);
        P_FINISH;
        this->SetLevelRBGravity(NewGrav);
    }
    DECLARE_FUNCTION(execGetLocalURL)
    {
        P_FINISH;
        *(FString*)Result=this->GetLocalURL();
    }
    DECLARE_FUNCTION(execIsDemoBuild)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsDemoBuild();
    }
    DECLARE_FUNCTION(execIsConsoleBuild)
    {
        P_GET_BYTE_OPTX(ConsoleType,0);
        P_FINISH;
        *(UBOOL*)Result=this->IsConsoleBuild(ConsoleType);
    }
    DECLARE_FUNCTION(execIsWithGFx)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsWithGFx();
    }
    DECLARE_FUNCTION(execIsPlayInEditor)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsPlayInEditor();
    }
    DECLARE_FUNCTION(execIsPlayInPreview)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsPlayInPreview();
    }
    DECLARE_FUNCTION(execIsPlayInMobilePreview)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsPlayInMobilePreview();
    }
    DECLARE_FUNCTION(execForceGarbageCollection)
    {
        P_GET_UBOOL_OPTX(bFullPurge,FALSE);
        P_FINISH;
        this->ForceGarbageCollection(bFullPurge);
    }
    DECLARE_FUNCTION(execVerifyNavList)
    {
        P_FINISH;
        this->VerifyNavList();
    }
    DECLARE_FUNCTION(execGetAddressURL)
    {
        P_FINISH;
        *(FString*)Result=this->GetAddressURL();
    }
    DECLARE_FUNCTION(execAllNavigationPoints);
    DECLARE_FUNCTION(execRadiusNavigationPoints);
    DECLARE_FUNCTION(execNavigationPointCheck);
    DECLARE_FUNCTION(execAllControllers);
    DECLARE_FUNCTION(execAllPawns);
    DECLARE_FUNCTION(execAllClientConnections);
    DECLARE_FUNCTION(execNotifyMatchStarted)
    {
        P_GET_UBOOL_OPTX(bShouldActivateLevelStartupEvents,TRUE);
        P_GET_UBOOL_OPTX(bShouldActivateLevelBeginningEvents,TRUE);
        P_GET_UBOOL_OPTX(bShouldActivateLevelLoadedEvents,FALSE);
        P_FINISH;
        this->NotifyMatchStarted(bShouldActivateLevelStartupEvents,bShouldActivateLevelBeginningEvents,bShouldActivateLevelLoadedEvents);
    }
    DECLARE_FUNCTION(execPrepareMapChange)
    {
        P_GET_TARRAY_REF(FName,LevelNames);
        P_FINISH;
        this->PrepareMapChange(LevelNames);
    }
    DECLARE_FUNCTION(execIsPreparingMapChange)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsPreparingMapChange();
    }
    DECLARE_FUNCTION(execIsMapChangeReady)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsMapChangeReady();
    }
    DECLARE_FUNCTION(execCancelPendingMapChange)
    {
        P_FINISH;
        this->CancelPendingMapChange();
    }
    DECLARE_FUNCTION(execCommitMapChange)
    {
        P_FINISH;
        this->CommitMapChange();
    }
    DECLARE_FUNCTION(execSeamlessTravel)
    {
        P_GET_STR(URL);
        P_GET_UBOOL_OPTX(bAbsolute,FALSE);
        P_GET_STRUCT_OPTX(FGuid,MapPackageGuid,FGuid(EC_EventParm));
        P_FINISH;
        this->SeamlessTravel(URL,bAbsolute,MapPackageGuid);
    }
    DECLARE_FUNCTION(execIsInSeamlessTravel)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsInSeamlessTravel();
    }
    DECLARE_FUNCTION(execSetSeamlessTravelMidpointPause)
    {
        P_GET_UBOOL(bNowPaused);
        P_FINISH;
        this->SetSeamlessTravelMidpointPause(bNowPaused);
    }
    DECLARE_FUNCTION(execGetMapInfo)
    {
        P_FINISH;
        *(class UMapInfo**)Result=this->GetMapInfo();
    }
    DECLARE_FUNCTION(execSetMapInfo)
    {
        P_GET_OBJECT(UMapInfo,NewMapInfo);
        P_FINISH;
        this->SetMapInfo(NewMapInfo);
    }
    DECLARE_FUNCTION(execGetMapName)
    {
        P_GET_UBOOL_OPTX(bIncludePrefix,FALSE);
        P_FINISH;
        *(FString*)Result=this->GetMapName(bIncludePrefix);
    }
    DECLARE_FUNCTION(execGetDetailMode)
    {
        P_FINISH;
        *(BYTE*)Result=this->GetDetailMode();
    }
    DECLARE_FUNCTION(execIsRecordingDemo)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsRecordingDemo();
    }
    DECLARE_FUNCTION(execIsPlayingDemo)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsPlayingDemo();
    }
    DECLARE_FUNCTION(execGetDemoFrameInfo)
    {
        P_GET_INT_OPTX_REF(CurrentFrame,0);
        P_GET_INT_OPTX_REF(TotalFrames,0);
        P_FINISH;
        this->GetDemoFrameInfo(pCurrentFrame ? &CurrentFrame : NULL,pTotalFrames ? &TotalFrames : NULL);
    }
    DECLARE_FUNCTION(execGetDemoRewindPoints)
    {
        P_GET_TARRAY_REF(INT,OutRewindPoints);
        P_FINISH;
        *(UBOOL*)Result=this->GetDemoRewindPoints(OutRewindPoints);
    }
    DECLARE_FUNCTION(execDoMemoryTracking)
    {
        P_FINISH;
        this->DoMemoryTracking();
    }
    DECLARE_FUNCTION(execGetWorldFractureSettings)
    {
        P_FINISH;
        *(struct FWorldFractureSettings*)Result=this->GetWorldFractureSettings();
    }
    DECLARE_FUNCTION(execGetWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=this->GetWorldInfo();
    }
    DECLARE_FUNCTION(execFindEnvironmentVolume)
    {
        P_GET_STRUCT(FVector,TestLocation);
        P_FINISH;
        *(class AEnvironmentVolume**)Result=this->FindEnvironmentVolume(TestLocation);
    }
    DECLARE_FUNCTION(execBeginHostMigration)
    {
        P_FINISH;
        *(UBOOL*)Result=this->BeginHostMigration();
    }
    DECLARE_FUNCTION(execToggleHostMigration)
    {
        P_GET_UBOOL(bEnabled);
        P_FINISH;
        this->ToggleHostMigration(bEnabled);
    }
    DECLARE_FUNCTION(execClearObjectPools)
    {
        P_FINISH;
        this->ClearObjectPools();
    }
    void eventNotifyHostMigrationStateChanged(BYTE NewState,BYTE OldState)
    {
        WorldInfo_eventNotifyHostMigrationStateChanged_Parms Parms(EC_EventParm);
        Parms.NewState=NewState;
        Parms.OldState=OldState;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyHostMigrationStateChanged),&Parms);
    }
    UBOOL eventCanBeginHostMigration()
    {
        WorldInfo_eventCanBeginHostMigration_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_CanBeginHostMigration),&Parms);
        return Parms.ReturnValue;
    }
    void eventServerTravel(const FString& URL,UBOOL bAbsolute=FALSE,UBOOL bShouldSkipGameNotify=FALSE)
    {
        WorldInfo_eventServerTravel_Parms Parms(EC_EventParm);
        Parms.URL=URL;
        Parms.bAbsolute=bAbsolute ? FIRST_BITFIELD : FALSE;
        Parms.bShouldSkipGameNotify=bShouldSkipGameNotify ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerTravel),&Parms);
    }
    DECLARE_CLASS(AWorldInfo,AZoneInfo,0|CLASS_Config|CLASS_NativeReplication,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	// UObject interface.

	/**
	 * Called when a property on this object has been modified externally
	 *
	 * @param PropertyThatChanged the property that was modified
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();

	/**
	 * Called after GWorld has been set. Used to load, but not associate, all
	 * levels in the world in the Editor and at least create linkers in the game.
	 * Should only be called against GWorld::PersistentLevel's WorldInfo.
	 */
	void LoadSecondaryLevels();

	/** Utility for returning the ULevelStreaming object for a particular sub-level, specified by package name */
	ULevelStreaming* GetLevelStreamingForPackageName(FName PackageName);

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	// Level functions
	void SetZone( UBOOL bTest, UBOOL bForceRefresh );
	void SetVolumes();
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	APhysicsVolume* GetDefaultPhysicsVolume();
	APhysicsVolume* GetPhysicsVolume(const FVector& Loc, AActor *A, UBOOL bUseTouch);
	FLOAT GetRBGravityZ();

	/**
	 * Finds the post process settings to use for a given view location, taking into account the world's default
	 * settings and the post process volumes in the world.
	 * @param	ViewLocation			Current view location.
	 * @param	bUseVolumes				Whether to use the world's post process volumes
	 * @param	OutPostProcessSettings	Upon return, the post process settings for a camera at ViewLocation.
	 * @return	If the settings came from a post process volume, the post process volume is returned.
	 */
	APostProcessVolume* GetPostProcessSettings(const FVector& ViewLocation,UBOOL bUseVolumes,FPostProcessSettings& OutPostProcessSettings);

	/** Checks whether temporal AA is allowed. */
	UBOOL GetAllowTemporalAA() const;

	FLinearColor GetEnvironmentColor() const;

	/**
	 * Finds the reverb settings to use for a given view location, taking into account the world's default
	 * settings and the reverb volumes in the world.
	 *
	 * @param	ViewLocation			Current view location.
	 * @param	OutReverbSettings		[out] Upon return, the reverb settings for a camera at ViewLocation.
	 * @param	OutInteriorSettings		[out] Upon return, the interior settings for a camera at ViewLocation.
	 * @return							If the settings came from a reverb volume, the reverb volume's object index is returned.
	 */
	INT GetAudioSettings( const FVector& ViewLocation, struct FReverbSettings* OutReverbSettings, struct FInteriorSettings* OutInteriorSettings );

	/**
	 * Finds the portal volume actor at a given location
	 */
	APortalVolume* GetPortalVolume( const FVector& Location );

	/** Returns TRUE if the given position is inside any AMassiveLODOverrideVolume in the world. */
	UBOOL IsInsideMassiveLODVolume(const FVector& Location) const;

	/**
	 * Remap sound locations through portals
	 */
	FVector RemapLocationThroughPortals( const FVector& SourceLocation, const FVector& ListenerLocation );

	/**
	 * Sets bMapNeedsLightingFullyRebuild to the specified value.  Marks the worldinfo package dirty if the value changed.
	 *
	 * @param	bInMapNeedsLightingFullyRebuild			The new value.
	 */
	void SetMapNeedsLightingFullyRebuilt(UBOOL bInMapNeedsLightingFullyRebuild);

	/**
     * @return Whether or not we can spawn more fractured chunks this frame
	 **/
	UBOOL CanSpawnMoreFracturedChunksThisFrame() const;

	/**
	* Determines whether a map is the default local map.
	*
	* @param	MapName	if specified, checks whether MapName is the default local map; otherwise, checks the currently loaded map.
	*
	* @return	TRUE if the map is the default local (or front-end) map.
	*/
	UBOOL IsMenuLevel( FString MapName=TEXT("") );

	/** Add a string to the On-screen debug message system */
    void AddOnScreenDebugMessage(QWORD Key,FLOAT TimeToDisplay,FColor DisplayColor,const FString& DebugMessage);

	/** Retrieve the message for the given key */
	UBOOL OnScreenDebugMessageExists(QWORD Key);

	/**
	 * overidden to track references of pooled path constraints
	 */
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );

	/** 
     * Update the current host migration progress
	 * 
	 * @param NewState current host migration state to set 
	 */
	void UpdateHostMigrationState(EHostMigrationProgress NewState);

	/**
	 *  Registers an attractor and returns TRUE if it was added successfully.
	 */
	UBOOL RegisterAttractor(AWorldAttractor* Attractor);

	/**
	 *  Unregisters an attractor and returns TRUE if it was already registered and removed.
	 */
	UBOOL UnregisterAttractor(AWorldAttractor* Attractor);

	typedef TIndexedContainerIterator< TArray<AWorldAttractor*> > AWorldAttractorIter;

	/**
	 *  Gets a non-const iterator for the list of attractors.
	 */
	AWorldAttractorIter GetAttractorIter();
};

struct DownloadableContentEnumerator_eventOnFindDLCComplete_Parms
{
    DownloadableContentEnumerator_eventOnFindDLCComplete_Parms(EEventParm)
    {
    }
};
class UDownloadableContentEnumerator : public UObject
{
public:
    //## BEGIN PROPS DownloadableContentEnumerator
    TArrayNoInit<struct FOnlineContent> DLCBundles;
    FStringNoInit DLCRootDir;
    TArrayNoInit<FScriptDelegate> FindDLCDelegates;
    FScriptDelegate __OnFindDLCComplete__Delegate;
    //## END PROPS DownloadableContentEnumerator

    virtual void FindDLC();
    virtual void DeleteDLC(const FString& DLCName);
    virtual void InstallDLC(const FString& DLCName);
    virtual void TriggerFindDLCDelegates();
    DECLARE_FUNCTION(execFindDLC)
    {
        P_FINISH;
        this->FindDLC();
    }
    DECLARE_FUNCTION(execDeleteDLC)
    {
        P_GET_STR(DLCName);
        P_FINISH;
        this->DeleteDLC(DLCName);
    }
    DECLARE_FUNCTION(execInstallDLC)
    {
        P_GET_STR(DLCName);
        P_FINISH;
        this->InstallDLC(DLCName);
    }
    DECLARE_FUNCTION(execTriggerFindDLCDelegates)
    {
        P_FINISH;
        this->TriggerFindDLCDelegates();
    }
    void delegateOnFindDLCComplete()
    {
        ProcessDelegate(ENGINE_OnFindDLCComplete,&__OnFindDLCComplete__Delegate,NULL);
    }
    DECLARE_CLASS(UDownloadableContentEnumerator,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDownloadableContentEnumerator)
};

struct DownloadableContentManager_eventOnRefreshComplete_Parms
{
    DownloadableContentManager_eventOnRefreshComplete_Parms(EEventParm)
    {
    }
};
struct DownloadableContentManager_eventInit_Parms
{
    DownloadableContentManager_eventInit_Parms(EEventParm)
    {
    }
};
class UDownloadableContentManager : public UObject
{
public:
    //## BEGIN PROPS DownloadableContentManager
    TArrayNoInit<struct FDLCConfigCacheChanges*> DLCConfigCacheChanges;
    TArrayNoInit<FString> InstalledDLC;
    TMap<FName,FString> NonPackageFilePathMap;
    TArrayNoInit<class UClass*> ClassesToReload;
    TArrayNoInit<class UObject*> ObjectsToReload;
    TArrayNoInit<FString> QueuedFullyLoadPackageInis;
    class UGameEngine* GameEngine;
    FScriptDelegate __OnRefreshComplete__Delegate;
    //## END PROPS DownloadableContentManager

    virtual UBOOL InstallDLC(const struct FOnlineContent& DLCBundle);
    virtual void InstallDLCs(const TArray<struct FOnlineContent>& DLCBundles);
    virtual void ClearDLC();
    virtual UBOOL GetDLCNonPackageFilePath(FName NonPackageFileName,FString& Path);
    virtual void AddSectionToObjectList(const FString& Section);
    virtual void MarkPerObjectConfigPendingKill(const FString& Section);
    virtual void UpdateObjectLists();
    virtual void InstallPackages(const struct FOnlineContent& DLCBundle);
    virtual void InstallNonPackageFiles(const struct FOnlineContent& DLCBundle);
    virtual void AddPackagesToFullyLoad(const FString& Filename);
    DECLARE_FUNCTION(execInstallDLC)
    {
        P_GET_STRUCT_INIT_REF(struct FOnlineContent,DLCBundle);
        P_FINISH;
        *(UBOOL*)Result=this->InstallDLC(DLCBundle);
    }
    DECLARE_FUNCTION(execInstallDLCs)
    {
        P_GET_TARRAY_REF(struct FOnlineContent,DLCBundles);
        P_FINISH;
        this->InstallDLCs(DLCBundles);
    }
    DECLARE_FUNCTION(execClearDLC)
    {
        P_FINISH;
        this->ClearDLC();
    }
    DECLARE_FUNCTION(execGetDLCNonPackageFilePath)
    {
        P_GET_NAME(NonPackageFileName);
        P_GET_STR_REF(Path);
        P_FINISH;
        *(UBOOL*)Result=this->GetDLCNonPackageFilePath(NonPackageFileName,Path);
    }
    DECLARE_FUNCTION(execAddSectionToObjectList)
    {
        P_GET_STR(Section);
        P_FINISH;
        this->AddSectionToObjectList(Section);
    }
    DECLARE_FUNCTION(execMarkPerObjectConfigPendingKill)
    {
        P_GET_STR(Section);
        P_FINISH;
        this->MarkPerObjectConfigPendingKill(Section);
    }
    DECLARE_FUNCTION(execUpdateObjectLists)
    {
        P_FINISH;
        this->UpdateObjectLists();
    }
    DECLARE_FUNCTION(execInstallPackages)
    {
        P_GET_STRUCT_INIT_REF(struct FOnlineContent,DLCBundle);
        P_FINISH;
        this->InstallPackages(DLCBundle);
    }
    DECLARE_FUNCTION(execInstallNonPackageFiles)
    {
        P_GET_STRUCT_INIT_REF(struct FOnlineContent,DLCBundle);
        P_FINISH;
        this->InstallNonPackageFiles(DLCBundle);
    }
    DECLARE_FUNCTION(execAddPackagesToFullyLoad)
    {
        P_GET_STR(Filename);
        P_FINISH;
        this->AddPackagesToFullyLoad(Filename);
    }
    void delegateOnRefreshComplete()
    {
        ProcessDelegate(ENGINE_OnRefreshComplete,&__OnRefreshComplete__Delegate,NULL);
    }
    void eventInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Init),NULL);
    }
    DECLARE_CLASS(UDownloadableContentManager,UObject,0,Engine)
	/**
	 * Creates a map of all the non package files contained in the DLC
	 *
	 * @param DLCBundle the DLC bundle being processed
	 */
	void InstallNonPackages(const FOnlineContent& DLCBundle);

#if PS3 // PS3 DLC has to be signed
	/**
	 * Adds any SHA hashes to the file hashes for this bundle
	 *
	 * @param DLCBundle the DLC bundle being processed
	 */
	void InstallSHAFiles(const FOnlineContent& DLCBundle);
#endif

	/**
	 * Process all INI files and our current loc language
	 *
	 * @param DLCBundle the DLC bundle being processed
	 */
	void InstallIniLocFiles(const FOnlineContent& DLCBundle);

	/**
	 * Parses the specified section for the key/value set to use for fully loading
	 *
	 * @param LoadType the type of package loading to use
	 * @param Section the INI section to parse
	 * @param KeyOne the key to parse
	 * @param KeyN the sub keys to parse
	 * @param FileName the file name to parse the information from
	 */
	void AddPackagesToFullyLoad(EFullyLoadPackageType LoadType,const TCHAR* Section,const TCHAR* KeyOne,const TCHAR* KeyN,const TCHAR* FileName);

	/**
	 * For a given DLC ini/loc file, it determines the list of sections in the INI/loc file that are touched
	 * so that it can determine which ones to replace during unloading and which to remove altogether
	 *
	 * @param FileName the name of the DLC ini/loc file to parse for section changes
	 * @param OutSectionsIncluded gets the list of modified/added sections
	 */
	void GetListOfSectionNames(const TCHAR* FileName,TArray<FString>& OutSectionsIncluded);

	/**
	 * Builds the set of changes needed to undo this DLC's config changes/additions
	 *
	 * @param ConfigFileName the name of the DLC ini/loc file to build the undo set for
	 * @param SectionsIncluded the list of modified/added sections
	 */
	void BuildDLCConfigCacheUndo(const TCHAR* ConfigFileName,const TArray<FString>& SectionsIncluded);
};

struct FStatColorMapEntry
{
    FLOAT In;
    FColor Out;

    /** Constructors */
    FStatColorMapEntry() {}
    FStatColorMapEntry(EEventParm)
    {
        appMemzero(this, sizeof(FStatColorMapEntry));
    }
};

struct FStatColorMapping
{
    FStringNoInit StatName;
    TArrayNoInit<struct FStatColorMapEntry> ColorMap;
    BITFIELD DisableBlend:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FStatColorMapping() {}
    FStatColorMapping(EEventParm)
    {
        appMemzero(this, sizeof(FStatColorMapping));
    }
};

struct FDropNoteInfo
{
    FVector Location;
    FRotator Rotation;
    FStringNoInit Comment;

    /** Constructors */
    FDropNoteInfo() {}
    FDropNoteInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDropNoteInfo));
    }
};

class UEngine : public USubsystem
{
public:
    //## BEGIN PROPS Engine
    class UFont* TinyFont;
    FStringNoInit TinyFontName;
    class UFont* SmallFont;
    FStringNoInit SmallFontName;
    class UFont* MediumFont;
    FStringNoInit MediumFontName;
    class UFont* LargeFont;
    FStringNoInit LargeFontName;
    class UFont* SubtitleFont;
    FStringNoInit SubtitleFontName;
    TArrayNoInit<class UFont*> AdditionalFonts;
    TArrayNoInit<FString> AdditionalFontNames;
    class UClass* ConsoleClass;
    FStringNoInit ConsoleClassName;
    class UClass* GameViewportClientClass;
    FStringNoInit GameViewportClientClassName;
    class UClass* DataStoreClientClass;
    FStringNoInit DataStoreClientClassName;
    class UClass* LocalPlayerClass;
    FStringNoInit LocalPlayerClassName;
    class UMaterial* DefaultMaterial;
    FStringNoInit DefaultMaterialName;
    class UMaterial* DefaultDecalMaterial;
    FStringNoInit DefaultDecalMaterialName;
    class UTexture* DefaultTexture;
    FStringNoInit DefaultTextureName;
    class UMaterial* WireframeMaterial;
    FStringNoInit WireframeMaterialName;
    class UMaterial* EmissiveTexturedMaterial;
    FStringNoInit EmissiveTexturedMaterialName;
    class UMaterial* GeomMaterial;
    FStringNoInit GeomMaterialName;
    class UMaterial* DefaultFogVolumeMaterial;
    FStringNoInit DefaultFogVolumeMaterialName;
    class UMaterial* TickMaterial;
    FStringNoInit TickMaterialName;
    class UMaterial* CrossMaterial;
    FStringNoInit CrossMaterialName;
    class UMaterial* LevelColorationLitMaterial;
    FStringNoInit LevelColorationLitMaterialName;
    class UMaterial* LevelColorationUnlitMaterial;
    FStringNoInit LevelColorationUnlitMaterialName;
    class UMaterial* LightingTexelDensityMaterial;
    FStringNoInit LightingTexelDensityName;
    class UMaterial* ShadedLevelColorationLitMaterial;
    FStringNoInit ShadedLevelColorationLitMaterialName;
    class UMaterial* ShadedLevelColorationUnlitMaterial;
    FStringNoInit ShadedLevelColorationUnlitMaterialName;
    class UMaterial* RemoveSurfaceMaterial;
    FStringNoInit RemoveSurfaceMaterialName;
    class UMaterial* VertexColorMaterial;
    FStringNoInit VertexColorMaterialName;
    class UMaterial* VertexColorViewModeMaterial_ColorOnly;
    FStringNoInit VertexColorViewModeMaterialName_ColorOnly;
    class UMaterial* VertexColorViewModeMaterial_AlphaAsColor;
    FStringNoInit VertexColorViewModeMaterialName_AlphaAsColor;
    class UMaterial* VertexColorViewModeMaterial_RedOnly;
    FStringNoInit VertexColorViewModeMaterialName_RedOnly;
    class UMaterial* VertexColorViewModeMaterial_GreenOnly;
    FStringNoInit VertexColorViewModeMaterialName_GreenOnly;
    class UMaterial* VertexColorViewModeMaterial_BlueOnly;
    FStringNoInit VertexColorViewModeMaterialName_BlueOnly;
    class UMaterial* HeatmapMaterial;
    FStringNoInit HeatmapMaterialName;
    class UMaterial* BoneWeightMaterial;
    FStringNoInit BoneWeightMaterialName;
    class UMaterial* TangentColorMaterial;
    FStringNoInit TangentColorMaterialName;
    class UMaterial* MobileEmulationMasterMaterial;
    FStringNoInit MobileEmulationMasterMaterialName;
    class UMaterial* ProcBuildingSimpleMaterial;
    FStringNoInit ProcBuildingSimpleMaterialName;
    class UStaticMesh* BuildingQuadStaticMesh;
    FStringNoInit BuildingQuadStaticMeshName;
    FLOAT ProcBuildingLODColorTexelsPerWorldUnit;
    FLOAT ProcBuildingLODLightingTexelsPerWorldUnit;
    INT MaxProcBuildingLODColorTextureSize;
    INT MaxProcBuildingLODLightingTextureSize;
    BITFIELD UseProcBuildingLODTextureCropping:1;
    BITFIELD ForcePowerOfTwoProcBuildingLODTextures:1;
    BITFIELD bCombineSimilarMappings:1;
    BITFIELD bRenderLightMapDensityGrayscale:1;
    BITFIELD bScreenshotRequested:1;
    BITFIELD bUseSound:1;
    BITFIELD bUseBackgroundLevelStreaming:1;
    BITFIELD bSubtitlesEnabled:1;
    BITFIELD bSubtitlesForcedOff:1;
    BITFIELD bSmoothFrameRate:1;
    BITFIELD bCheckForMultiplePawnsSpawnedInAFrame:1;
    BITFIELD bShouldGenerateSimpleLightmaps:1;
    BITFIELD bForceStaticTerrain:1;
    BITFIELD bForceCPUSkinning:1;
    BITFIELD bUsePostProcessEffects:1;
    BITFIELD bOnScreenKismetWarnings:1;
    BITFIELD bEnableKismetLogging:1;
    BITFIELD bAllowMatureLanguage:1;
    BITFIELD bDisablePhysXHardwareSupport:1;
    BITFIELD bPauseOnLossOfFocus:1;
    BITFIELD bCheckParticleRenderSize:1;
    BITFIELD bEnableColorClear:1;
    BITFIELD bAreConstraintsDirty:1;
    BITFIELD bHasPendingGlobalReattach:1;
    BITFIELD bEnableOnScreenDebugMessages:1;
    BITFIELD bEnableOnScreenDebugMessagesDisplay:1;
    BITFIELD bSuppressMapWarnings:1;
    BITFIELD bCookSeparateSharedMPGameContent:1;
    BITFIELD bUseRecastNavMesh:1;
    BITFIELD bDisableAILogging:1;
    BITFIELD bUseNormalMapsForSimpleLightMaps:1;
    BITFIELD bStartWithMatineeCapture:1;
    BITFIELD bCompressMatineeCapture:1;
    BITFIELD bLockReadOnlyLevels:1;
    FLOAT MaxRMSDForCombiningMappings;
    INT ImageReflectionTextureSize;
    FLinearColor LightingOnlyBrightness;
    TArrayNoInit<FColor> LightComplexityColors;
    TArrayNoInit<FLinearColor> ShaderComplexityColors;
    FLOAT MaxPixelShaderAdditiveComplexityCount;
    FLOAT MinTextureDensity;
    FLOAT IdealTextureDensity;
    FLOAT MaxTextureDensity;
    FLOAT MinLightMapDensity;
    FLOAT IdealLightMapDensity;
    FLOAT MaxLightMapDensity;
    FLOAT RenderLightMapDensityGrayscaleScale;
    FLOAT RenderLightMapDensityColorScale;
    FLinearColor LightMapDensityVertexMappedColor;
    FLinearColor LightMapDensitySelectedColor;
    TArrayNoInit<struct FStatColorMapping> StatColorMappings;
    class UMaterial* EditorBrushMaterial;
    FStringNoInit EditorBrushMaterialName;
    class UPhysicalMaterial* DefaultPhysMaterial;
    FStringNoInit DefaultPhysMaterialName;
    class UPhysicalMaterial* LandscapeHolePhysMaterial;
    FStringNoInit LandscapeHolePhysMaterialName;
    class UApexDestructibleDamageParameters* ApexDamageParams;
    FStringNoInit ApexDamageParamsName;
    class UMaterial* TerrainErrorMaterial;
    FStringNoInit TerrainErrorMaterialName;
    INT TerrainMaterialMaxTextureCount;
    INT TerrainTessellationCheckCount;
    FLOAT TerrainTessellationCheckDistance;
    class UClass* OnlineSubsystemClass;
    FStringNoInit DefaultOnlineSubsystemName;
private:
    class UPostProcessChain* DefaultPostProcess;
    FStringNoInit DefaultPostProcessName;
public:
    class UPostProcessChain* ThumbnailSkeletalMeshPostProcess;
    FStringNoInit ThumbnailSkeletalMeshPostProcessName;
    class UPostProcessChain* ThumbnailParticleSystemPostProcess;
    FStringNoInit ThumbnailParticleSystemPostProcessName;
    class UPostProcessChain* ThumbnailMaterialPostProcess;
    FStringNoInit ThumbnailMaterialPostProcessName;
    class UPostProcessChain* DefaultUIScenePostProcess;
    FStringNoInit DefaultUIScenePostProcessName;
    class UMaterial* DefaultUICaretMaterial;
    FStringNoInit DefaultUICaretMaterialName;
    class UMaterial* SceneCaptureReflectActorMaterial;
    FStringNoInit SceneCaptureReflectActorMaterialName;
    class UMaterial* SceneCaptureCubeActorMaterial;
    FStringNoInit SceneCaptureCubeActorMaterialName;
    class UTexture2D* ScreenDoorNoiseTexture;
    FStringNoInit ScreenDoorNoiseTextureName;
    class UTexture2D* ImageGrainNoiseTexture;
    FStringNoInit ImageGrainNoiseTextureName;
    class UTexture2D* RandomAngleTexture;
    FStringNoInit RandomAngleTextureName;
    class UTexture2D* RandomNormalTexture;
    FStringNoInit RandomNormalTextureName;
    class UTexture2D* RandomMirrorDiscTexture;
    FStringNoInit RandomMirrorDiscTextureName;
    class UTexture* WeightMapPlaceholderTexture;
    FStringNoInit WeightMapPlaceholderTextureName;
    class UTexture2D* LightMapDensityTexture;
    FStringNoInit LightMapDensityTextureName;
    class UTexture2D* LightMapDensityNormal;
    FStringNoInit LightMapDensityNormalName;
    class USoundNodeWave* DefaultSound;
    FStringNoInit DefaultSoundName;
    FLOAT TimeBetweenPurgingPendingKillObjects;
    class UClient* Client;
    TArray<class ULocalPlayer*> GamePlayers;
    class UGameViewportClient* GameViewport;
    TArray<FString> DeferredCommands;
    INT TickCycles;
    INT GameCycles;
    INT ClientCycles;
    FLOAT MaxSmoothedFrameRate;
    FLOAT MinSmoothedFrameRate;
    INT NumPawnsAllowedToBeSpawnedInAFrame;
    class FRemoteControlExec* RemoteControlExec;
    class FMobileMaterialEmulator* MobileMaterialEmulator;
    FColor C_WorldBox;
    FColor C_BrushWire;
    FColor C_AddWire;
    FColor C_SubtractWire;
    FColor C_SemiSolidWire;
    FColor C_NonSolidWire;
    FColor C_WireBackground;
    FColor C_ScaleBoxHi;
    FColor C_VolumeCollision;
    FColor C_BSPCollision;
    FColor C_OrthoBackground;
    FColor C_Volume;
    FColor C_BrushShape;
    FLOAT StreamingDistanceFactor;
    FStringNoInit ScoutClassName;
    BYTE TransitionType;
    FStringNoInit TransitionDescription;
    FStringNoInit TransitionGameType;
    FLOAT MeshLODRange;
    FLOAT CameraRotationThreshold;
    FLOAT CameraTranslationThreshold;
    FLOAT PrimitiveProbablyVisibleTime;
    FLOAT PercentUnoccludedRequeries;
    FLOAT MaxOcclusionPixelsFraction;
    INT MaxFluidNumVerts;
    FLOAT FluidSimulationTimeLimit;
    INT MaxParticleResize;
    INT MaxParticleResizeWarn;
    INT MaxParticleVertexMemory;
    INT MaxParticleSpriteCount;
    INT MaxParticleSubUVCount;
    INT BeginUPTryCount;
    TArrayNoInit<struct FDropNoteInfo> PendingDroppedNotes;
    FStringNoInit DynamicCoverMeshComponentName;
    FLOAT NetClientTicksPerSecond;
    FLOAT MaxTrackedOcclusionIncrement;
    FLOAT TrackedOcclusionStepSize;
    FLinearColor DefaultSelectedMaterialColor;
    FLinearColor DefaultHoveredMaterialColor;
    FLinearColor SelectedMaterialColor;
    FLinearColor UnselectedMaterialColor;
    TArrayNoInit<FName> IgnoreSimulatedFuncWarnings;
private:
    INT ScreenSaverInhibitorSemaphore;
    FRunnableThread* ScreenSaverInhibitor;
public:
    class UTranslationContext* GlobalTranslationContext;
    DOUBLE LoadingMovieStartTime;
    FStringNoInit MatineeCaptureName;
    FStringNoInit MatineePackageCaptureName;
    FStringNoInit VisibleLevelsForMatineeCapture;
    INT MatineeCaptureFPS;
    INT MatineeCaptureType;
    //## END PROPS Engine

    UBOOL IsEditor();
    UBOOL IsGame();
    class AWorldInfo* GetCurrentWorldInfo();
    FString GetBuildDate();
    FString GetDeviceUUID();
    FLOAT GetOSVersion();
    FString GetDevicePushNotificationToken();
    FString BuildBugSubmissionString(const FString& BugField,const FString& BugFieldData);
    UBOOL HasNetworkConnection();
    class UFont* GetTinyFont();
    class UFont* GetSmallFont();
    class UFont* GetMediumFont();
    class UFont* GetLargeFont();
    class UFont* GetSubtitleFont();
    class UFont* GetAdditionalFont(INT AdditionalFontIndex);
    UBOOL IsSplitScreen();
    UBOOL IsStereoscopic3D();
    UBOOL IsUsingES2Renderer();
    class UAudioDevice* GetAudioDevice();
    FString GetLastMovieName();
    UBOOL PlayLoadMapMovie();
    void StopMovie(UBOOL bDelayStopUntilGameHasRendered);
    void RemoveAllOverlays();
    void AddOverlay(class UFont* Font,const FString& Text,FLOAT X,FLOAT Y,FLOAT ScaleX,FLOAT ScaleY,UBOOL bIsCentered);
    void AddOverlayWrapped(class UFont* Font,const FString& Text,FLOAT X,FLOAT Y,FLOAT ScaleX,FLOAT ScaleY,FLOAT WrapWidth);
    UBOOL IsRealDStereoEnabled();
    class UEngine* GetEngine();
    class UPostProcessChain* GetDefaultPostProcessChain();
    class UPostProcessChain* GetWorldPostProcessChain();
    void AddTextureStreamingSlaveLoc(FVector InLoc,FLOAT BoostFactor,UBOOL bOverrideLocation,FLOAT OverrideDuration);
    UBOOL BasicSaveObject(class UObject* Obj,const FString& PathName,UBOOL bIsSaveGame,INT Version,UBOOL bEncrypt=FALSE);
    UBOOL BasicLoadObject(class UObject* Obj,const FString& PathName,UBOOL bIsSaveGame,INT Version);
    void LaunchURL(const FString& URL);
    UBOOL GetSystemSettingBool(const FString& SettingName);
    INT GetSystemSettingInt(const FString& SettingName);
    FLOAT GetSystemSettingFloat(const FString& SettingName);
    DECLARE_FUNCTION(execIsEditor)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsEditor();
    }
    DECLARE_FUNCTION(execIsGame)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsGame();
    }
    DECLARE_FUNCTION(execGetCurrentWorldInfo)
    {
        P_FINISH;
        *(class AWorldInfo**)Result=this->GetCurrentWorldInfo();
    }
    DECLARE_FUNCTION(execGetBuildDate)
    {
        P_FINISH;
        *(FString*)Result=this->GetBuildDate();
    }
    DECLARE_FUNCTION(execGetDeviceUUID)
    {
        P_FINISH;
        *(FString*)Result=this->GetDeviceUUID();
    }
    DECLARE_FUNCTION(execGetOSVersion)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetOSVersion();
    }
    DECLARE_FUNCTION(execGetDevicePushNotificationToken)
    {
        P_FINISH;
        *(FString*)Result=this->GetDevicePushNotificationToken();
    }
    DECLARE_FUNCTION(execBuildBugSubmissionString)
    {
        P_GET_STR(BugField);
        P_GET_STR(BugFieldData);
        P_FINISH;
        *(FString*)Result=this->BuildBugSubmissionString(BugField,BugFieldData);
    }
    DECLARE_FUNCTION(execHasNetworkConnection)
    {
        P_FINISH;
        *(UBOOL*)Result=this->HasNetworkConnection();
    }
    DECLARE_FUNCTION(execGetTinyFont)
    {
        P_FINISH;
        *(class UFont**)Result=this->GetTinyFont();
    }
    DECLARE_FUNCTION(execGetSmallFont)
    {
        P_FINISH;
        *(class UFont**)Result=this->GetSmallFont();
    }
    DECLARE_FUNCTION(execGetMediumFont)
    {
        P_FINISH;
        *(class UFont**)Result=this->GetMediumFont();
    }
    DECLARE_FUNCTION(execGetLargeFont)
    {
        P_FINISH;
        *(class UFont**)Result=this->GetLargeFont();
    }
    DECLARE_FUNCTION(execGetSubtitleFont)
    {
        P_FINISH;
        *(class UFont**)Result=this->GetSubtitleFont();
    }
    DECLARE_FUNCTION(execGetAdditionalFont)
    {
        P_GET_INT(AdditionalFontIndex);
        P_FINISH;
        *(class UFont**)Result=this->GetAdditionalFont(AdditionalFontIndex);
    }
    DECLARE_FUNCTION(execIsSplitScreen)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsSplitScreen();
    }
    DECLARE_FUNCTION(execIsStereoscopic3D)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsStereoscopic3D();
    }
    DECLARE_FUNCTION(execIsUsingES2Renderer)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsUsingES2Renderer();
    }
    DECLARE_FUNCTION(execGetAudioDevice)
    {
        P_FINISH;
        *(class UAudioDevice**)Result=this->GetAudioDevice();
    }
    DECLARE_FUNCTION(execGetLastMovieName)
    {
        P_FINISH;
        *(FString*)Result=this->GetLastMovieName();
    }
    DECLARE_FUNCTION(execPlayLoadMapMovie)
    {
        P_FINISH;
        *(UBOOL*)Result=this->PlayLoadMapMovie();
    }
    DECLARE_FUNCTION(execStopMovie)
    {
        P_GET_UBOOL(bDelayStopUntilGameHasRendered);
        P_FINISH;
        this->StopMovie(bDelayStopUntilGameHasRendered);
    }
    DECLARE_FUNCTION(execRemoveAllOverlays)
    {
        P_FINISH;
        this->RemoveAllOverlays();
    }
    DECLARE_FUNCTION(execAddOverlay)
    {
        P_GET_OBJECT(UFont,Font);
        P_GET_STR(Text);
        P_GET_FLOAT(X);
        P_GET_FLOAT(Y);
        P_GET_FLOAT(ScaleX);
        P_GET_FLOAT(ScaleY);
        P_GET_UBOOL(bIsCentered);
        P_FINISH;
        this->AddOverlay(Font,Text,X,Y,ScaleX,ScaleY,bIsCentered);
    }
    DECLARE_FUNCTION(execAddOverlayWrapped)
    {
        P_GET_OBJECT(UFont,Font);
        P_GET_STR(Text);
        P_GET_FLOAT(X);
        P_GET_FLOAT(Y);
        P_GET_FLOAT(ScaleX);
        P_GET_FLOAT(ScaleY);
        P_GET_FLOAT(WrapWidth);
        P_FINISH;
        this->AddOverlayWrapped(Font,Text,X,Y,ScaleX,ScaleY,WrapWidth);
    }
    DECLARE_FUNCTION(execIsRealDStereoEnabled)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsRealDStereoEnabled();
    }
    DECLARE_FUNCTION(execGetEngine)
    {
        P_FINISH;
        *(class UEngine**)Result=this->GetEngine();
    }
    DECLARE_FUNCTION(execGetDefaultPostProcessChain)
    {
        P_FINISH;
        *(class UPostProcessChain**)Result=this->GetDefaultPostProcessChain();
    }
    DECLARE_FUNCTION(execGetWorldPostProcessChain)
    {
        P_FINISH;
        *(class UPostProcessChain**)Result=this->GetWorldPostProcessChain();
    }
    DECLARE_FUNCTION(execAddTextureStreamingSlaveLoc)
    {
        P_GET_STRUCT(FVector,InLoc);
        P_GET_FLOAT(BoostFactor);
        P_GET_UBOOL(bOverrideLocation);
        P_GET_FLOAT(OverrideDuration);
        P_FINISH;
        this->AddTextureStreamingSlaveLoc(InLoc,BoostFactor,bOverrideLocation,OverrideDuration);
    }
    DECLARE_FUNCTION(execBasicSaveObject)
    {
        P_GET_OBJECT(UObject,Obj);
        P_GET_STR(PathName);
        P_GET_UBOOL(bIsSaveGame);
        P_GET_INT(Version);
        P_GET_UBOOL_OPTX(bEncrypt,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->BasicSaveObject(Obj,PathName,bIsSaveGame,Version,bEncrypt);
    }
    DECLARE_FUNCTION(execBasicLoadObject)
    {
        P_GET_OBJECT(UObject,Obj);
        P_GET_STR(PathName);
        P_GET_UBOOL(bIsSaveGame);
        P_GET_INT(Version);
        P_FINISH;
        *(UBOOL*)Result=this->BasicLoadObject(Obj,PathName,bIsSaveGame,Version);
    }
    DECLARE_FUNCTION(execLaunchURL)
    {
        P_GET_STR(URL);
        P_FINISH;
        this->LaunchURL(URL);
    }
    DECLARE_FUNCTION(execGetSystemSettingBool)
    {
        P_GET_STR(SettingName);
        P_FINISH;
        *(UBOOL*)Result=this->GetSystemSettingBool(SettingName);
    }
    DECLARE_FUNCTION(execGetSystemSettingInt)
    {
        P_GET_STR(SettingName);
        P_FINISH;
        *(INT*)Result=this->GetSystemSettingInt(SettingName);
    }
    DECLARE_FUNCTION(execGetSystemSettingFloat)
    {
        P_GET_STR(SettingName);
        P_FINISH;
        *(FLOAT*)Result=this->GetSystemSettingFloat(SettingName);
    }
    DECLARE_ABSTRACT_CLASS(UEngine,USubsystem,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	// Constructors.
	UEngine();
	void StaticConstructor();

	// UObject interface.
	virtual void FinishDestroy();

	// UEngine interface.
	virtual void Init();

	/**
	 * Called at shutdown, just before the exit purge.
	 */
	virtual void PreExit() {}

	virtual UBOOL Exec( const TCHAR* Cmd, FOutputDevice& Out=*GLog );
	virtual void Tick( FLOAT DeltaSeconds ) PURE_VIRTUAL(UEngine::Tick,);
	virtual void SetClientTravel( const TCHAR* NextURL, ETravelType TravelType ) PURE_VIRTUAL(UEngine::SetClientTravel,);
	virtual FLOAT GetMaxTickRate( FLOAT /*DeltaTime*/, UBOOL bAllowFrameRateSmoothing = TRUE );
	virtual void SetProgress( EProgressMessageType MessageType, const FString& Title, const FString& Message );

	/**
	 * Called by Exec. Memory related execs.
	 */
	UBOOL ExecMemFunctions( const TCHAR* Cmd, FOutputDevice& Out=*GLog );

	/**
	 * Called by Exec. Threading related execs.
	 */
	UBOOL ExecThreadFunctions( const TCHAR* Cmd, FOutputDevice& Out=*GLog );

	/**
	 * Pauses / unpauses the game-play when focus of the game's window gets lost / gained.
	 * @param EnablePause TRUE to pause; FALSE to unpause the game
	 */
	virtual void OnLostFocusPause( UBOOL EnablePause );

#if DO_CHARTING
	/**
	 * Ticks the FPS chart.
	 *
	 * @param DeltaSeconds	Time in seconds passed since last tick.
	 */
	virtual void TickFPSChart( FLOAT DeltaSeconds );

	/**
	 * Ticks the Memory chart.
	 *
	 * @param DeltaSeconds	Time in seconds passed since last tick.
	 */
	virtual void TickMemoryChart( FLOAT DeltaSeconds );

	/**
	 * Resets the FPS chart data.
	 */
	virtual void ResetFPSChart();

	/**
	 * Dumps the FPS chart information to the passed in archive.
	 *
	 * @param	bForceDump	Whether to dump even if FPS chart info is not enabled.
	 */
	virtual void DumpFPSChart( UBOOL bForceDump = FALSE );

	/** Dumps info on DistanceFactor used for rendering SkeletalMeshComponents during the game. */
	virtual void DumpDistanceFactorChart();

	/**
 	 * Resets the Memory chart data.
	 */
	virtual void ResetMemoryChart();

	/**
	 * Dumps the Memory chart information to various places.
	 *
	 * @param	bForceDump	Whether to dump even if no info has been captured yet (will force an update in that case).
	 */
	virtual void DumpMemoryChart( UBOOL bForceDump = FALSE );


private:
	/**
	 * Dumps the FPS chart information to HTML.
	 */
	virtual void DumpFPSChartToHTML( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames, UBOOL bOutputToGlobalLog );

	/**
	 * Dumps the FPS chart information to the log.
	 */
	virtual void DumpFPSChartToLog( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames );

	/**
	 * Dumps the FPS chart information to the special stats log file.
	 */
	virtual void DumpFPSChartToStatsLog( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames );

	/**
	 * Dumps the frame times information to the special stats log file.
	 */
	virtual void DumpFrameTimesToStatsLog( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames );

	/**
	 * Dumps the Memory chart information to HTML.
	 */
	virtual void DumpMemoryChartToHTML( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames, UBOOL bOutputToGlobalLog );

	/**
	 * Dumps the Memory chart information to the log.
	 */
	virtual void DumpMemoryChartToLog( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames );

	/**
	 * Dumps the Memory chart information to the special stats log file.
	 */
	virtual void DumpMemoryChartToStatsLog( FLOAT TotalTime, FLOAT DeltaTime, INT NumFrames );

#endif // DO_CHARTING

public:

	/**
	 * Spawns any registered server actors
	 */
	virtual void SpawnServerActors(void)
	{
	}

	/**
	 * Loads all Engine object references from their corresponding config entries.
	 */
	void InitializeObjectReferences();

	/**
	 * Construct a UNetDriver object based on an .ini setting
	 *
	 * @return The created NetDriver object, or NULL if it fails
	 */
	virtual class UNetDriver* ConstructNetDriver()
	{
		return NULL;
	}

	/**
	 * Clean up the GameViewport
	 */
	void CleanupGameViewport();

	/** Get some viewport. Will be GameViewport in game, and one of the editor viewport windows in editor. */
	virtual FViewport* GetAViewport();

	/**
	 * Allows the editor to accept or reject the drawing of wireframe brush shapes based on mode and tool.
	 */
	virtual UBOOL ShouldDrawBrushWireframe( class AActor* InActor ) { return TRUE; }

	/**
	 * Issued by code requesting that decals be reattached.
	 */
	virtual void IssueDecalUpdateRequest() {}

	/**
	 * Returns whether or not the map build in progressed was cancelled by the user.
	 */
	virtual UBOOL GetMapBuildCancelled() const
	{
		return FALSE;
	}

	/**
	 * Sets the flag that states whether or not the map build was cancelled.
	 *
	 * @param InCancelled	New state for the cancelled flag.
	 */
	virtual void SetMapBuildCancelled( UBOOL InCancelled )
	{
		// Intentionally empty.
	}

	/**
	 * Computes a color to use for property coloration for the given object.
	 *
	 * @param	Object		The object for which to compute a property color.
	 * @param	OutColor	[out] The returned color.
	 * @return				TRUE if a color was successfully set on OutColor, FALSE otherwise.
	 */
	virtual UBOOL GetPropertyColorationColor(class UObject* Object, FColor& OutColor);

	/** Uses StatColorMappings to find a color for this stat's value. */
	UBOOL GetStatValueColoration(const FString& StatName, FLOAT Value, FColor& OutColor);

	/**
	 * @return TRUE if selection of translucent objects in perspective viewports is allowed
	 */
	virtual UBOOL AllowSelectTranslucent() const
	{
		// The editor may override this to disallow translucent selection based on user preferences
		return TRUE;
	}

	/**
	 * @return TRUE if only editor-visible levels should be loaded in Play-In-Editor sessions
	 */
	virtual UBOOL OnlyLoadEditorVisibleLevelsInPIE() const
	{
		// The editor may override this to apply the user's preference state
		return TRUE;
	}

	/**
	 * Enables or disables the ScreenSaver (PC only)
	 *
	 * @param bEnable	If TRUE the enable the screen saver, if FALSE disable it.
	 */
	void EnableScreenSaver( UBOOL bEnable );

	/**
	 * Get the index of the provided sprite category
	 *
	 * @param	InSpriteCategory	Sprite category to get the index of
	 *
	 * @return	Index of the provided sprite category, if possible; INDEX_NONE otherwise
	 */
	virtual INT GetSpriteCategoryIndex( const FName& InSpriteCategory )
	{
		// The editor may override this to handle sprite categories as necessary
		return INDEX_NONE;
	}


	/**
	 * Trips a bool in engine side code to signal a screenshot request on next frame
	 */
	void SetRequestScreenshot();

	/**
	 * Starts playing a loading movie from memory.
	 * Keeps track of the total time fullscreen movies are playing to cover loading.
	 *
	 * @param MovieName		Name of the movie to play in its entirety
	 */
	void PlayLoadingMovie( const TCHAR* MovieName );

protected:
	/**
	 * Handles freezing/unfreezing of rendering
	 */
	virtual void ProcessToggleFreezeCommand()
	{
		// Intentionally empty.
	}

	/**
	 * Handles frezing/unfreezing of streaming
	 */
	 virtual void ProcessToggleFreezeStreamingCommand()
	 {
		// Intentionally empty.
	 }

	 /**
	  * Updates all physics constraint actor joint locations.
	  */
	 virtual void UpdateConstraintActors();
};

struct FURL
{
    FString Protocol;
    FString Host;
    INT Port;
    FString Map;
    TArray<FString> Op;
    FString Portal;
    INT Valid;


	// Statics.
	static FString DefaultProtocol;
	static FString DefaultName;
	static FString DefaultMap;
	static FString DefaultLocalMap;
	static FString DefaultLocalOptions;
	static FString DefaultTransitionMap; // map used as in-between for seamless travel
	static FString DefaultHost;
	static FString DefaultPortal;
	static FString DefaultMapExt;
	static FString DefaultSaveExt;
	/** Additional map extension to look for when parsing urls for map loading */
	static FString AdditionalMapExt;
	static INT DefaultPort;
	/** port to listen for new client peer connections */
	static INT DefaultPeerPort;
	static UBOOL bDefaultsInitialized;

	// Constructors.
	FURL( const TCHAR* Filename=NULL );
	FURL( FURL* Base, const TCHAR* TextURL, ETravelType Type );
	static void StaticInit();
	static void StaticExit();

	/**
	 * Static: Removes any special URL characters from the specified string
	 *
	 * @param Str String to be filtered
	 */
	static void FilterURLString( FString& Str );


	// Functions.
	UBOOL IsInternal() const;
	UBOOL IsLocalInternal() const;
	UBOOL HasOption( const TCHAR* Test ) const;
	const TCHAR* GetOption( const TCHAR* Match, const TCHAR* Default ) const;
	void LoadURLConfig( const TCHAR* Section, const TCHAR* Filename=NULL );
	void SaveURLConfig( const TCHAR* Section, const TCHAR* Item, const TCHAR* Filename=NULL ) const;
	void AddOption( const TCHAR* Str );
	void RemoveOption( const TCHAR* Key, const TCHAR* Section = NULL, const TCHAR* Filename = NULL);
	FString String( UBOOL FullyQualified=0 ) const;
	friend FArchive& operator<<( FArchive& Ar, FURL& U );

	// Operators.
	UBOOL operator==( const FURL& Other ) const;

};

struct FLevelStreamingStatus
{
    FName PackageName;
    BITFIELD bShouldBeLoaded:1;
    BITFIELD bShouldBeVisible:1;
    SCRIPT_ALIGN;

		/** Constructors */
		FLevelStreamingStatus(FName InPackageName, UBOOL bInShouldBeLoaded, UBOOL bInShouldBeVisible)
		: PackageName(InPackageName), bShouldBeLoaded(bInShouldBeLoaded), bShouldBeVisible(bInShouldBeVisible)
		{}
		FLevelStreamingStatus()
		{}
    		FLevelStreamingStatus(EEventParm)
		{
			appMemzero(this, sizeof(FLevelStreamingStatus));
		}
	
};

struct FFullyLoadedPackagesInfo
{
    BYTE FullyLoadType;
    FStringNoInit Tag;
    TArrayNoInit<FName> PackagesToLoad;
    TArrayNoInit<class UObject*> LoadedObjects;

    /** Constructors */
    FFullyLoadedPackagesInfo() {}
    FFullyLoadedPackagesInfo(EEventParm)
    {
        appMemzero(this, sizeof(FFullyLoadedPackagesInfo));
    }
};

struct FNamedNetDriver
{
    FName NetDriverName;
    class UNetDriver* NetDriver;

    /** Constructors */
    FNamedNetDriver() {}
    FNamedNetDriver(EEventParm)
    {
        appMemzero(this, sizeof(FNamedNetDriver));
    }
};

struct FAnimTag
{
    FStringNoInit Tag;
    TArrayNoInit<FString> Contains;

    /** Constructors */
    FAnimTag() {}
    FAnimTag(EEventParm)
    {
        appMemzero(this, sizeof(FAnimTag));
    }
};

class UGameEngine : public UEngine
{
public:
    //## BEGIN PROPS GameEngine
    class UPendingLevel* GPendingLevel;
    FStringNoInit PendingLevelPlayerControllerClassName;
    struct FURL LastURL;
    struct FURL LastRemoteURL;
    TArrayNoInit<FString> ServerActors;
    FStringNoInit TravelURL;
    BYTE TravelType;
    SCRIPT_ALIGN;
    BITFIELD bWorldWasLoadedThisTick:1;
    BITFIELD bCheckForMovieCapture:1;
    BITFIELD bTriggerPostLoadMap:1;
    BITFIELD bStartedLoadMapMovie:1;
    BITFIELD bShouldCommitPendingMapChange:1;
    BITFIELD bClearAnimSetLinkupCachesOnLoadMap:1;
    BITFIELD bEnableSecondaryDisplay:1;
    BITFIELD bEnableSecondaryViewport:1;
    class UOnlineSubsystem* OnlineSubsystem;
    class UDownloadableContentEnumerator* DLCEnumerator;
    FStringNoInit DownloadableContentEnumeratorClassName;
    class UDownloadableContentManager* DLCManager;
    FStringNoInit DownloadableContentManagerClassName;
    TArrayNoInit<FName> LevelsToLoadForPendingMapChange;
    TArrayNoInit<class ULevel*> LoadedLevelsForPendingMapChange;
    FStringNoInit PendingMapChangeFailureDescription;
    FLOAT MaxDeltaTime;
    FStringNoInit SecondaryViewportClientClassName;
    TArray<class UScriptViewportClient*> SecondaryViewportClients;
    TArray<FViewportFrame*> SecondaryViewportFrames;
    TArrayNoInit<struct FLevelStreamingStatus> PendingLevelStreamingStatusUpdates;
    TArrayNoInit<class UObjectReferencer*> ObjectReferencers;
    TArrayNoInit<struct FFullyLoadedPackagesInfo> PackagesToFullyLoad;
    TArrayNoInit<struct FNamedNetDriver> NamedNetDrivers;
    TArrayNoInit<struct FAnimTag> AnimTags;
    //## END PROPS GameEngine

    UBOOL CreateNamedNetDriver(FName NetDriverName);
    void DestroyNamedNetDriver(FName NetDriverName);
    DECLARE_FUNCTION(execCreateNamedNetDriver)
    {
        P_GET_NAME(NetDriverName);
        P_FINISH;
        *(UBOOL*)Result=this->CreateNamedNetDriver(NetDriverName);
    }
    DECLARE_FUNCTION(execDestroyNamedNetDriver)
    {
        P_GET_NAME(NetDriverName);
        P_FINISH;
        this->DestroyNamedNetDriver(NetDriverName);
    }
    DECLARE_FUNCTION(execGetOnlineSubsystem);
    DECLARE_FUNCTION(execGetDLCEnumerator);
    DECLARE_FUNCTION(execGetDLCManager);
    DECLARE_FUNCTION(execHasSecondaryScreenActive);
    DECLARE_CLASS(UGameEngine,UEngine,0|CLASS_Transient|CLASS_Config,Engine)

	// Constructors.
	UGameEngine();

	/**
	 * Redraws all viewports.
	 *
	 * @param	bShouldPresent	Whether we want this frame to be presented
	 */
	void RedrawViewports( UBOOL bShouldPresent = TRUE );
	
	/**
	 * Called to allow overloading by child engines
	 */
	virtual void LoadMapRedrawViewports(void)
	{
		RedrawViewports();
	}

	// UObject interface.
	void FinishDestroy();

	// UEngine interface.
	void Init();

	/**
	 * Called at shutdown, just before the exit purge.
	 */
	virtual void PreExit();

	virtual void Tick( FLOAT DeltaSeconds );
	UBOOL Exec( const TCHAR* Cmd, FOutputDevice& Ar=*GLog );
	void SetClientTravel( const TCHAR* NextURL, ETravelType TravelType );
	virtual FLOAT GetMaxTickRate( FLOAT DeltaTime, UBOOL bAllowFrameRateSmoothing = TRUE );
	virtual void SetProgress( EProgressMessageType MessageType, const FString& Title, const FString& Message );

	/**
	 * Handles freezing/unfreezing of rendering
	 */
	virtual void ProcessToggleFreezeCommand();

	/**
	 * Handles frezing/unfreezing of streaming
	 */
	 virtual void ProcessToggleFreezeStreamingCommand();

	// UGameEngine interface.
	virtual UBOOL Browse( FURL URL, FString& Error );
	virtual UBOOL LoadMap( const FURL& URL, class UPendingLevel* Pending, FString& Error );
	virtual void PostLoadMap();
	virtual void CancelPending();

	/**
	 * Spawns all of the registered server actors
	 */
	virtual void SpawnServerActors(void);

	/**
	 * Construct a UNetDriver object based on an .ini setting
	 *
	 * @return The created NetDriver object, or NULL if it fails
	 */
	virtual class UNetDriver* ConstructNetDriver();

	/**
	 * Returns the online subsystem object. Returns null if GEngine isn't a
	 * game engine
	 */
	static UOnlineSubsystem* GetOnlineSubsystem(void);

	/**
	 * Creates the online subsystem that was specified in UEngine's
	 * OnlineSubsystemClass. This function is virtual so that licensees
	 * can provide their own version without modifying Epic code.
	 */
	virtual void InitOnlineSubsystem(void);

	/**
	 * Creates the specified objects for dealing with DLC.
	 */
	void InitGameSingletonObjects(void);

	/**
	 * @return the DLC enumerator, or null if GEngine isn't a game engine
	 */
	static UDownloadableContentEnumerator* GetDLCEnumerator(void)
	{
		UGameEngine* GameEngine = Cast<UGameEngine>(GEngine);
		if (GameEngine)
		{
			return GameEngine->DLCEnumerator;
		}
		return NULL;
	}

	/**
	 * @return the DLC manager, or null if GEngine isn't a game engine
	 */
	static UDownloadableContentManager* GetDLCManager(void)
	{
		UGameEngine* GameEngine = Cast<UGameEngine>(GEngine);
		if (GameEngine)
		{
			return GameEngine->DLCManager;
		}
		return NULL;
	}

	/**
	 * @return TRUE, if the GEngine is a game engine and has any secondary screens active
	 */
	static UBOOL HasSecondaryScreenActive(void)
	{
		UGameEngine* GameEngine = Cast<UGameEngine>(GEngine);
		if (GameEngine)
		{
			check(GameEngine->SecondaryViewportClients.Num() == GameEngine->SecondaryViewportFrames.Num());
			return (GameEngine->SecondaryViewportFrames.Num() > 0 ? TRUE : FALSE);
		}
		return FALSE;
	}

	// Async map change/ persistent level transition code.

	/**
	 * Prepares the engine for a map change by pre-loading level packages in the background.
	 *
	 * @param	LevelNames	Array of levels to load in the background; the first level in this
	 *						list is assumed to be the new "persistent" one.
	 *
	 * @return	TRUE if all packages were in the package file cache and the operation succeeded,
	 *			FALSE otherwise. FALSE as a return value also indicates that the code has given
	 *			up.
	 */
	UBOOL PrepareMapChange(const TArray<FName>& LevelNames);

	/**
	 * Returns the failure description in case of a failed map change request.
	 *
	 * @return	Human readable failure description in case of failure, empty string otherwise
	 */
	FString GetMapChangeFailureDescription();

	/**
	 * Returns whether we are currently preparing for a map change or not.
	 *
	 * @return TRUE if we are preparing for a map change, FALSE otherwise
	 */
	UBOOL IsPreparingMapChange();

	/**
	 * Returns whether the prepared map change is ready for commit having called.
	 *
	 * @return TRUE if we're ready to commit the map change, FALSE otherwise
	 */
	UBOOL IsReadyForMapChange();

	/**
	 * Finalizes the pending map change that was being kicked off by PrepareMapChange.
	 *
	 * @return	TRUE if successful, FALSE if there were errors (use GetMapChangeFailureDescription
	 *			for error description)
	 */
	UBOOL CommitMapChange();

	/**
	 * Commit map change if requested and map change is pending. Called every frame.
	 */
	void ConditionalCommitMapChange();

	/**
	 * Cancels pending map change.
	 */
	void CancelPendingMapChange();

	/**
	 * Adds a map/package array pair for pacakges to load at LoadMap
	 *
	 * @param FullyLoadType When to load the packages (based on map, gametype, etc)
	 * @param Tag Map/game for which the packages need to be loaded
	 * @param Packages List of package names to fully load when the map is loaded
	 * @param bLoadPackagesForCurrentMap If TRUE, the packages for the currently loaded map will be loaded now
	 */
	void AddPackagesToFullyLoad(EFullyLoadPackageType FullyLoadType, const FString& Tag, const TArray<FName>& Packages, UBOOL bLoadPackagesForCurrentMap);

	/**
	 * Empties the PerMapPackages array, and removes any currently loaded packages from the Root
	 */
	void CleanupAllPackagesToFullyLoad();

	/**
	 * Loads the PerMapPackages for the given map, and adds them to the RootSet
	 *
	 * @param FullyLoadType When to load the packages (based on map, gametype, etc)
	 * @param Tag Name of the map/game to load packages for
	 */
	void LoadPackagesFully(EFullyLoadPackageType FullyLoadType, const FString& Tag);

	/**
	 * Removes the PerMapPackages from the RootSet
	 *
	 * @param FullyLoadType When to load the packages (based on map, gametype, etc)
	 * @param Tag Name of the map/game to cleanup packages for
	 */
	void CleanupPackagesToFullyLoad(EFullyLoadPackageType FullyLoadType, const FString& Tag);

	/**
	 * Finds a UNetDriver based on its name.
	 *
	 * @param NetDriverName The name associated with the driver to find.
	 *
	 * @return A pointer to the UNetDriver that was found, or NULL if it wasn't found.
	 */
	UNetDriver* FindNamedNetDriver(FName NetDriverName);

	/**
	 * Creates a new FViewportFrame with a viewport client of class SecondaryViewportClientClassName
	 */
	void CreateSecondaryViewport(UINT SizeX, UINT SizeY);

	/**
	 * Closes all secondary viewports opened with CreateSecondaryViewport
	 */
	void CloseSecondaryViewports();
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_GAMEENGINE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AWorldInfo,-1,execClearObjectPools);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execToggleHostMigration);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execBeginHostMigration);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execFindEnvironmentVolume);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetWorldInfo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetWorldFractureSettings);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execDoMemoryTracking);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetDemoRewindPoints);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetDemoFrameInfo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsPlayingDemo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsRecordingDemo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetDetailMode);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetMapName);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execSetMapInfo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetMapInfo);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execSetSeamlessTravelMidpointPause);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsInSeamlessTravel);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execSeamlessTravel);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execCommitMapChange);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execCancelPendingMapChange);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsMapChangeReady);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsPreparingMapChange);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execPrepareMapChange);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execNotifyMatchStarted);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execAllClientConnections);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execAllPawns);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execAllControllers);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execNavigationPointCheck);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execRadiusNavigationPoints);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execAllNavigationPoints);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetAddressURL);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execVerifyNavList);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execForceGarbageCollection);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsPlayInMobilePreview);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsPlayInPreview);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsPlayInEditor);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsWithGFx);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsConsoleBuild);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsDemoBuild);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetLocalURL);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execSetLevelRBGravity);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetAllRootSequences);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetGameSequence);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetGravityZ);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execUpdateMusicTrack);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execSetMusicVolume);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execIsMenuLevel);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execAddOnScreenDebugMessage);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetNavMeshPathGoalEvaluatorFromCache);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execGetNavMeshPathConstraintFromCache);
AUTOGENERATE_FUNCTION(AWorldInfo,-1,execReleaseCachedConstraintsAndEvaluators);
AUTOGENERATE_FUNCTION(UDownloadableContentEnumerator,-1,execTriggerFindDLCDelegates);
AUTOGENERATE_FUNCTION(UDownloadableContentEnumerator,-1,execInstallDLC);
AUTOGENERATE_FUNCTION(UDownloadableContentEnumerator,-1,execDeleteDLC);
AUTOGENERATE_FUNCTION(UDownloadableContentEnumerator,-1,execFindDLC);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execAddPackagesToFullyLoad);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execInstallNonPackageFiles);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execInstallPackages);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execUpdateObjectLists);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execMarkPerObjectConfigPendingKill);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execAddSectionToObjectList);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execGetDLCNonPackageFilePath);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execClearDLC);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execInstallDLCs);
AUTOGENERATE_FUNCTION(UDownloadableContentManager,-1,execInstallDLC);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetSystemSettingFloat);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetSystemSettingInt);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetSystemSettingBool);
AUTOGENERATE_FUNCTION(UEngine,-1,execLaunchURL);
AUTOGENERATE_FUNCTION(UEngine,-1,execBasicLoadObject);
AUTOGENERATE_FUNCTION(UEngine,-1,execBasicSaveObject);
AUTOGENERATE_FUNCTION(UEngine,-1,execAddTextureStreamingSlaveLoc);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetWorldPostProcessChain);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetDefaultPostProcessChain);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetEngine);
AUTOGENERATE_FUNCTION(UEngine,-1,execIsRealDStereoEnabled);
AUTOGENERATE_FUNCTION(UEngine,-1,execAddOverlayWrapped);
AUTOGENERATE_FUNCTION(UEngine,-1,execAddOverlay);
AUTOGENERATE_FUNCTION(UEngine,-1,execRemoveAllOverlays);
AUTOGENERATE_FUNCTION(UEngine,-1,execStopMovie);
AUTOGENERATE_FUNCTION(UEngine,-1,execPlayLoadMapMovie);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetLastMovieName);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetAudioDevice);
AUTOGENERATE_FUNCTION(UEngine,-1,execIsUsingES2Renderer);
AUTOGENERATE_FUNCTION(UEngine,-1,execIsStereoscopic3D);
AUTOGENERATE_FUNCTION(UEngine,-1,execIsSplitScreen);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetAdditionalFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetSubtitleFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetLargeFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetMediumFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetSmallFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetTinyFont);
AUTOGENERATE_FUNCTION(UEngine,-1,execHasNetworkConnection);
AUTOGENERATE_FUNCTION(UEngine,-1,execBuildBugSubmissionString);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetDevicePushNotificationToken);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetOSVersion);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetDeviceUUID);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetBuildDate);
AUTOGENERATE_FUNCTION(UEngine,-1,execGetCurrentWorldInfo);
AUTOGENERATE_FUNCTION(UEngine,-1,execIsGame);
AUTOGENERATE_FUNCTION(UEngine,-1,execIsEditor);
AUTOGENERATE_FUNCTION(UGameEngine,-1,execHasSecondaryScreenActive);
AUTOGENERATE_FUNCTION(UGameEngine,-1,execGetDLCManager);
AUTOGENERATE_FUNCTION(UGameEngine,-1,execGetDLCEnumerator);
AUTOGENERATE_FUNCTION(UGameEngine,-1,execGetOnlineSubsystem);
AUTOGENERATE_FUNCTION(UGameEngine,-1,execDestroyNamedNetDriver);
AUTOGENERATE_FUNCTION(UGameEngine,-1,execCreateNamedNetDriver);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_GAMEENGINE_NATIVE_DEFS
#define ENGINE_GAMEENGINE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_GAMEENGINE \
	AWorldInfo::StaticClass(); \
	GNativeLookupFuncs.Set(FName("WorldInfo"), GEngineAWorldInfoNatives); \
	UDownloadableContentEnumerator::StaticClass(); \
	GNativeLookupFuncs.Set(FName("DownloadableContentEnumerator"), GEngineUDownloadableContentEnumeratorNatives); \
	UDownloadableContentManager::StaticClass(); \
	GNativeLookupFuncs.Set(FName("DownloadableContentManager"), GEngineUDownloadableContentManagerNatives); \
	UEngine::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Engine"), GEngineUEngineNatives); \
	UGameEngine::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameEngine"), GEngineUGameEngineNatives); \

#endif // ENGINE_GAMEENGINE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineAWorldInfoNatives[] = 
{ 
	MAP_NATIVE(AWorldInfo, execClearObjectPools)
	MAP_NATIVE(AWorldInfo, execToggleHostMigration)
	MAP_NATIVE(AWorldInfo, execBeginHostMigration)
	MAP_NATIVE(AWorldInfo, execFindEnvironmentVolume)
	MAP_NATIVE(AWorldInfo, execGetWorldInfo)
	MAP_NATIVE(AWorldInfo, execGetWorldFractureSettings)
	MAP_NATIVE(AWorldInfo, execDoMemoryTracking)
	MAP_NATIVE(AWorldInfo, execGetDemoRewindPoints)
	MAP_NATIVE(AWorldInfo, execGetDemoFrameInfo)
	MAP_NATIVE(AWorldInfo, execIsPlayingDemo)
	MAP_NATIVE(AWorldInfo, execIsRecordingDemo)
	MAP_NATIVE(AWorldInfo, execGetDetailMode)
	MAP_NATIVE(AWorldInfo, execGetMapName)
	MAP_NATIVE(AWorldInfo, execSetMapInfo)
	MAP_NATIVE(AWorldInfo, execGetMapInfo)
	MAP_NATIVE(AWorldInfo, execSetSeamlessTravelMidpointPause)
	MAP_NATIVE(AWorldInfo, execIsInSeamlessTravel)
	MAP_NATIVE(AWorldInfo, execSeamlessTravel)
	MAP_NATIVE(AWorldInfo, execCommitMapChange)
	MAP_NATIVE(AWorldInfo, execCancelPendingMapChange)
	MAP_NATIVE(AWorldInfo, execIsMapChangeReady)
	MAP_NATIVE(AWorldInfo, execIsPreparingMapChange)
	MAP_NATIVE(AWorldInfo, execPrepareMapChange)
	MAP_NATIVE(AWorldInfo, execNotifyMatchStarted)
	MAP_NATIVE(AWorldInfo, execAllClientConnections)
	MAP_NATIVE(AWorldInfo, execAllPawns)
	MAP_NATIVE(AWorldInfo, execAllControllers)
	MAP_NATIVE(AWorldInfo, execNavigationPointCheck)
	MAP_NATIVE(AWorldInfo, execRadiusNavigationPoints)
	MAP_NATIVE(AWorldInfo, execAllNavigationPoints)
	MAP_NATIVE(AWorldInfo, execGetAddressURL)
	MAP_NATIVE(AWorldInfo, execVerifyNavList)
	MAP_NATIVE(AWorldInfo, execForceGarbageCollection)
	MAP_NATIVE(AWorldInfo, execIsPlayInMobilePreview)
	MAP_NATIVE(AWorldInfo, execIsPlayInPreview)
	MAP_NATIVE(AWorldInfo, execIsPlayInEditor)
	MAP_NATIVE(AWorldInfo, execIsWithGFx)
	MAP_NATIVE(AWorldInfo, execIsConsoleBuild)
	MAP_NATIVE(AWorldInfo, execIsDemoBuild)
	MAP_NATIVE(AWorldInfo, execGetLocalURL)
	MAP_NATIVE(AWorldInfo, execSetLevelRBGravity)
	MAP_NATIVE(AWorldInfo, execGetAllRootSequences)
	MAP_NATIVE(AWorldInfo, execGetGameSequence)
	MAP_NATIVE(AWorldInfo, execGetGravityZ)
	MAP_NATIVE(AWorldInfo, execUpdateMusicTrack)
	MAP_NATIVE(AWorldInfo, execSetMusicVolume)
	MAP_NATIVE(AWorldInfo, execIsMenuLevel)
	MAP_NATIVE(AWorldInfo, execAddOnScreenDebugMessage)
	MAP_NATIVE(AWorldInfo, execGetNavMeshPathGoalEvaluatorFromCache)
	MAP_NATIVE(AWorldInfo, execGetNavMeshPathConstraintFromCache)
	MAP_NATIVE(AWorldInfo, execReleaseCachedConstraintsAndEvaluators)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUDownloadableContentEnumeratorNatives[] = 
{ 
	MAP_NATIVE(UDownloadableContentEnumerator, execTriggerFindDLCDelegates)
	MAP_NATIVE(UDownloadableContentEnumerator, execInstallDLC)
	MAP_NATIVE(UDownloadableContentEnumerator, execDeleteDLC)
	MAP_NATIVE(UDownloadableContentEnumerator, execFindDLC)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUDownloadableContentManagerNatives[] = 
{ 
	MAP_NATIVE(UDownloadableContentManager, execAddPackagesToFullyLoad)
	MAP_NATIVE(UDownloadableContentManager, execInstallNonPackageFiles)
	MAP_NATIVE(UDownloadableContentManager, execInstallPackages)
	MAP_NATIVE(UDownloadableContentManager, execUpdateObjectLists)
	MAP_NATIVE(UDownloadableContentManager, execMarkPerObjectConfigPendingKill)
	MAP_NATIVE(UDownloadableContentManager, execAddSectionToObjectList)
	MAP_NATIVE(UDownloadableContentManager, execGetDLCNonPackageFilePath)
	MAP_NATIVE(UDownloadableContentManager, execClearDLC)
	MAP_NATIVE(UDownloadableContentManager, execInstallDLCs)
	MAP_NATIVE(UDownloadableContentManager, execInstallDLC)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUEngineNatives[] = 
{ 
	MAP_NATIVE(UEngine, execGetSystemSettingFloat)
	MAP_NATIVE(UEngine, execGetSystemSettingInt)
	MAP_NATIVE(UEngine, execGetSystemSettingBool)
	MAP_NATIVE(UEngine, execLaunchURL)
	MAP_NATIVE(UEngine, execBasicLoadObject)
	MAP_NATIVE(UEngine, execBasicSaveObject)
	MAP_NATIVE(UEngine, execAddTextureStreamingSlaveLoc)
	MAP_NATIVE(UEngine, execGetWorldPostProcessChain)
	MAP_NATIVE(UEngine, execGetDefaultPostProcessChain)
	MAP_NATIVE(UEngine, execGetEngine)
	MAP_NATIVE(UEngine, execIsRealDStereoEnabled)
	MAP_NATIVE(UEngine, execAddOverlayWrapped)
	MAP_NATIVE(UEngine, execAddOverlay)
	MAP_NATIVE(UEngine, execRemoveAllOverlays)
	MAP_NATIVE(UEngine, execStopMovie)
	MAP_NATIVE(UEngine, execPlayLoadMapMovie)
	MAP_NATIVE(UEngine, execGetLastMovieName)
	MAP_NATIVE(UEngine, execGetAudioDevice)
	MAP_NATIVE(UEngine, execIsUsingES2Renderer)
	MAP_NATIVE(UEngine, execIsStereoscopic3D)
	MAP_NATIVE(UEngine, execIsSplitScreen)
	MAP_NATIVE(UEngine, execGetAdditionalFont)
	MAP_NATIVE(UEngine, execGetSubtitleFont)
	MAP_NATIVE(UEngine, execGetLargeFont)
	MAP_NATIVE(UEngine, execGetMediumFont)
	MAP_NATIVE(UEngine, execGetSmallFont)
	MAP_NATIVE(UEngine, execGetTinyFont)
	MAP_NATIVE(UEngine, execHasNetworkConnection)
	MAP_NATIVE(UEngine, execBuildBugSubmissionString)
	MAP_NATIVE(UEngine, execGetDevicePushNotificationToken)
	MAP_NATIVE(UEngine, execGetOSVersion)
	MAP_NATIVE(UEngine, execGetDeviceUUID)
	MAP_NATIVE(UEngine, execGetBuildDate)
	MAP_NATIVE(UEngine, execGetCurrentWorldInfo)
	MAP_NATIVE(UEngine, execIsGame)
	MAP_NATIVE(UEngine, execIsEditor)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUGameEngineNatives[] = 
{ 
	MAP_NATIVE(UGameEngine, execHasSecondaryScreenActive)
	MAP_NATIVE(UGameEngine, execGetDLCManager)
	MAP_NATIVE(UGameEngine, execGetDLCEnumerator)
	MAP_NATIVE(UGameEngine, execGetOnlineSubsystem)
	MAP_NATIVE(UGameEngine, execDestroyNamedNetDriver)
	MAP_NATIVE(UGameEngine, execCreateNamedNetDriver)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(AWorldInfo,WorldInfo,DefaultPostProcessSettings)
VERIFY_CLASS_OFFSET_NODIE(AWorldInfo,WorldInfo,FirstPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(AWorldInfo)
VERIFY_CLASS_OFFSET_NODIE(UDownloadableContentEnumerator,DownloadableContentEnumerator,DLCBundles)
VERIFY_CLASS_OFFSET_NODIE(UDownloadableContentEnumerator,DownloadableContentEnumerator,__OnFindDLCComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UDownloadableContentEnumerator)
VERIFY_CLASS_OFFSET_NODIE(UDownloadableContentManager,DownloadableContentManager,DLCConfigCacheChanges)
VERIFY_CLASS_OFFSET_NODIE(UDownloadableContentManager,DownloadableContentManager,__OnRefreshComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UDownloadableContentManager)
VERIFY_CLASS_OFFSET_NODIE(UEngine,Engine,TinyFont)
VERIFY_CLASS_OFFSET_NODIE(UEngine,Engine,MatineeCaptureType)
VERIFY_CLASS_SIZE_NODIE(UEngine)
VERIFY_CLASS_OFFSET_NODIE(UGameEngine,GameEngine,GPendingLevel)
VERIFY_CLASS_OFFSET_NODIE(UGameEngine,GameEngine,AnimTags)
VERIFY_CLASS_SIZE_NODIE(UGameEngine)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
