/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_SPEEDTREE_ENUMS
#define INCLUDED_ENGINE_SPEEDTREE_ENUMS 1

enum ESpeedTreeMeshType
{
    STMT_MinMinusOne        =0,
    STMT_Branches1          =1,
    STMT_Branches2          =2,
    STMT_Fronds             =3,
    STMT_LeafCards          =4,
    STMT_LeafMeshes         =5,
    STMT_Billboards         =6,
    STMT_Max                =7,
};
#define FOREACH_ENUM_ESPEEDTREEMESHTYPE(op) \
    op(STMT_MinMinusOne) \
    op(STMT_Branches1) \
    op(STMT_Branches2) \
    op(STMT_Fronds) \
    op(STMT_LeafCards) \
    op(STMT_LeafMeshes) \
    op(STMT_Billboards) 

#endif // !INCLUDED_ENGINE_SPEEDTREE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_SPEEDTREE_CLASSES
#define INCLUDED_ENGINE_SPEEDTREE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class ASpeedTreeActor : public AActor
{
public:
    //## BEGIN PROPS SpeedTreeActor
    class USpeedTreeComponent* SpeedTreeComponent;
    //## END PROPS SpeedTreeActor

    DECLARE_CLASS(ASpeedTreeActor,AActor,0,Engine)
public:
	// AActor interface.
	/**
	* Function that gets called from within Map_Check to allow this actor to check itself
	* for any potential errors and register them with map check dialog.
	*/
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

struct FSpeedTreeStaticLight
{
    FGuid Guid;
    class UShadowMap1D* BranchShadowMap;
    class UShadowMap1D* FrondShadowMap;
    class UShadowMap1D* LeafMeshShadowMap;
    class UShadowMap1D* LeafCardShadowMap;
    class UShadowMap1D* BillboardShadowMap;

    /** Constructors */
    FSpeedTreeStaticLight() {}
    FSpeedTreeStaticLight(EEventParm)
    {
        appMemzero(this, sizeof(FSpeedTreeStaticLight));
    }
};

class USpeedTreeComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS SpeedTreeComponent
    class USpeedTree* SpeedTree;
    BITFIELD bUseLeafCards:1;
    BITFIELD bUseLeafMeshes:1;
    BITFIELD bUseBranches:1;
    BITFIELD bUseFronds:1;
    BITFIELD bUseBillboards:1;
    FLOAT Lod3DStart;
    FLOAT Lod3DEnd;
    FLOAT LodBillboardStart;
    FLOAT LodBillboardEnd;
    FLOAT LodLevelOverride;
    class UMaterialInterface* Branch1Material;
    class UMaterialInterface* Branch2Material;
    class UMaterialInterface* FrondMaterial;
    class UMaterialInterface* LeafCardMaterial;
    class UMaterialInterface* LeafMeshMaterial;
    class UMaterialInterface* BillboardMaterial;
#if WITH_EDITORONLY_DATA
    class UTexture2D* SpeedTreeIcon;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<struct FSpeedTreeStaticLight> StaticLights;
    FLightMapRef BranchLightMap;
    FLightMapRef FrondLightMap;
    FLightMapRef LeafMeshLightMap;
    FLightMapRef LeafCardLightMap;
    FLightMapRef BillboardLightMap;
    FMatrix RotationOnlyMatrix;
    FLightmassPrimitiveSettings LightmassSettings;
    //## END PROPS SpeedTreeComponent

    virtual class UMaterialInterface* GetMaterial(BYTE MeshType) const;
    virtual void SetMaterial(BYTE MeshType,class UMaterialInterface* Material);
    DECLARE_FUNCTION(execGetMaterial)
    {
        P_GET_BYTE(MeshType);
        P_FINISH;
        *(class UMaterialInterface**)Result=this->GetMaterial(MeshType);
    }
    DECLARE_FUNCTION(execSetMaterial)
    {
        P_GET_BYTE(MeshType);
        P_GET_OBJECT(UMaterialInterface,Material);
        P_FINISH;
        this->SetMaterial(MeshType,Material);
    }
    DECLARE_CLASS(USpeedTreeComponent,UPrimitiveComponent,0,Engine)
	// UPrimitiveComponent interface
#if WITH_SPEEDTREE
	virtual void UpdateBounds();
	FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void GetStaticLightingInfo(FStaticLightingPrimitiveInfo& OutPrimitiveInfo,const TArray<ULightComponent*>& InRelevantLights,const FLightingBuildOptions& Options);
	
	/**
	* Returns the light and shadow map memory for this primite in its out variables.
	*
	* Shadow map memory usage is per light whereof lightmap data is independent of number of lights, assuming at least one.
	*
	* @param [out] LightMapMemoryUsage		Memory usage in bytes for light map (either texel or vertex) data
	* @param [out]	ShadowMapMemoryUsage	Memory usage in bytes for shadow map (either texel or vertex) data
	*/
	virtual void GetLightAndShadowMapMemoryUsage( INT& LightMapMemoryUsage, INT& ShadowMapMemoryUsage ) const;

	/** 
	 * Retrieves the materials used in this component 
	 * 
	 * @param OutMaterials	The list of used materials.
	 */
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const;

	/**
	 *	Requests whether the component will use texture, vertex or no lightmaps.
	 *
	 *	@return	ELightMapInteractionType		The type of lightmap interaction the component will use.
	 */
	virtual ELightMapInteractionType GetStaticLightingType() const	{ return LMIT_Vertex;	}
	virtual	void InvalidateLightingCache();
	virtual void GetStreamingTextureInfo(TArray<FStreamingTexturePrimitiveInfo>& OutStreamingTextures) const;

	virtual	UBOOL PointCheck(FCheckResult& cResult, const FVector& cLocation, const FVector& cExtent, DWORD dwTraceFlags);
	virtual UBOOL LineCheck(FCheckResult& cResult, const FVector& cEnd, const FVector& cStart, const FVector& cExtent, DWORD dwTraceFlags);
#if WITH_NOVODEX
	virtual void InitComponentRBPhys(UBOOL bFixed);
#endif
#endif

	// UActorComponent interface
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual UBOOL IsValidComponent() const;

	// UComponent interface.
	virtual UBOOL AreNativePropertiesIdenticalTo(UComponent* Other) const;

	// UObject interface.
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();
	virtual	void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditUndo();
};

class USpeedTreeActorFactory : public UActorFactory
{
public:
    //## BEGIN PROPS SpeedTreeActorFactory
    class USpeedTree* SpeedTree;
    //## END PROPS SpeedTreeActorFactory

    DECLARE_CLASS(USpeedTreeActorFactory,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor*	CreateActor(const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData);
	
	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Used to determine if we should add to context menu for example.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString	GetMenuName();
};

class USpeedTreeComponentFactory : public UPrimitiveComponentFactory
{
public:
    //## BEGIN PROPS SpeedTreeComponentFactory
    class USpeedTreeComponent* SpeedTreeComponent;
    //## END PROPS SpeedTreeComponentFactory

    DECLARE_CLASS(USpeedTreeComponentFactory,UPrimitiveComponentFactory,0,Engine)
	virtual UBOOL FactoryIsValid( ) 
	{ 
		return SpeedTreeComponent != NULL && Super::FactoryIsValid( ); 
	}
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter);
};

class USpeedTree : public UObject
{
public:
    //## BEGIN PROPS SpeedTree
private:
    BITFIELD bLegacySpeedTree:1;
    SCRIPT_ALIGN;
public:
    class FSpeedTreeResourceHelper* SRH;
    FLOAT LeafStaticShadowOpacity;
    class UMaterialInterface* Branch1Material;
    class UMaterialInterface* Branch2Material;
    class UMaterialInterface* FrondMaterial;
    class UMaterialInterface* LeafCardMaterial;
    class UMaterialInterface* LeafMeshMaterial;
    class UMaterialInterface* BillboardMaterial;
    FLOAT WindStrength;
    FVector WindDirection;
#if WITH_EDITORONLY_DATA
    FGuid LightingGuid;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS SpeedTree

    DECLARE_CLASS(USpeedTree,UObject,0,Engine)
	void StaticConstructor(void);

	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();
	virtual void FinishDestroy();
	
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();

	virtual	INT	GetResourceSize(void);
	virtual	FString	GetDetailedDescription( INT InIndex );
	virtual FString	GetDesc(void);
	
	UBOOL IsInitialized() const;
	UBOOL IsLegacySpeedTree() const { return bLegacySpeedTree; }

	virtual const FGuid& GetLightingGuid() const
	{
#if WITH_EDITORONLY_DATA
		return LightingGuid;
#else
		static const FGuid NullGuid( 0, 0, 0, 0 );
		return NullGuid; 
#endif // WITH_EDITORONLY_DATA
	}

	virtual void SetLightingGuid()
	{
#if WITH_EDITORONLY_DATA
		LightingGuid = appCreateGuid();
#endif // WITH_EDITORONLY_DATA
	}
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_SPEEDTREE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(USpeedTreeComponent,-1,execSetMaterial);
AUTOGENERATE_FUNCTION(USpeedTreeComponent,-1,execGetMaterial);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_SPEEDTREE_NATIVE_DEFS
#define ENGINE_SPEEDTREE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_SPEEDTREE \
	ASpeedTreeActor::StaticClass(); \
	USpeedTreeComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SpeedTreeComponent"), GEngineUSpeedTreeComponentNatives); \
	USpeedTreeActorFactory::StaticClass(); \
	USpeedTreeComponentFactory::StaticClass(); \
	USpeedTree::StaticClass(); \

#endif // ENGINE_SPEEDTREE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineUSpeedTreeComponentNatives[] = 
{ 
	MAP_NATIVE(USpeedTreeComponent, execSetMaterial)
	MAP_NATIVE(USpeedTreeComponent, execGetMaterial)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(ASpeedTreeActor,SpeedTreeActor,SpeedTreeComponent)
VERIFY_CLASS_SIZE_NODIE(ASpeedTreeActor)
VERIFY_CLASS_OFFSET_NODIE(USpeedTreeComponent,SpeedTreeComponent,SpeedTree)
VERIFY_CLASS_OFFSET_NODIE(USpeedTreeComponent,SpeedTreeComponent,LightmassSettings)
VERIFY_CLASS_SIZE_NODIE(USpeedTreeComponent)
VERIFY_CLASS_OFFSET_NODIE(USpeedTreeActorFactory,SpeedTreeActorFactory,SpeedTree)
VERIFY_CLASS_SIZE_NODIE(USpeedTreeActorFactory)
VERIFY_CLASS_OFFSET_NODIE(USpeedTreeComponentFactory,SpeedTreeComponentFactory,SpeedTreeComponent)
VERIFY_CLASS_SIZE_NODIE(USpeedTreeComponentFactory)
VERIFY_CLASS_OFFSET_NODIE(USpeedTree,SpeedTree,SRH)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(USpeedTree,SpeedTree,LightingGuid)
#else
VERIFY_CLASS_OFFSET_NODIE(USpeedTree,SpeedTree,WindDirection)
#endif
VERIFY_CLASS_SIZE_NODIE(USpeedTree)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
