/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_PARTICLE_ENUMS
#define INCLUDED_ENGINE_PARTICLE_ENUMS 1

enum EParticleSystemOcclusionBoundsMethod
{
    EPSOBM_None             =0,
    EPSOBM_ParticleBounds   =1,
    EPSOBM_CustomBounds     =2,
    EPSOBM_MAX              =3,
};
#define FOREACH_ENUM_EPARTICLESYSTEMOCCLUSIONBOUNDSMETHOD(op) \
    op(EPSOBM_None) \
    op(EPSOBM_ParticleBounds) \
    op(EPSOBM_CustomBounds) 
enum ParticleSystemLODMethod
{
    PARTICLESYSTEMLODMETHOD_Automatic=0,
    PARTICLESYSTEMLODMETHOD_DirectSet=1,
    PARTICLESYSTEMLODMETHOD_ActivateAutomatic=2,
    PARTICLESYSTEMLODMETHOD_MAX=3,
};
#define FOREACH_ENUM_PARTICLESYSTEMLODMETHOD(op) \
    op(PARTICLESYSTEMLODMETHOD_Automatic) \
    op(PARTICLESYSTEMLODMETHOD_DirectSet) \
    op(PARTICLESYSTEMLODMETHOD_ActivateAutomatic) 
enum EParticleSystemUpdateMode
{
    EPSUM_RealTime          =0,
    EPSUM_FixedTime         =1,
    EPSUM_MAX               =2,
};
#define FOREACH_ENUM_EPARTICLESYSTEMUPDATEMODE(op) \
    op(EPSUM_RealTime) \
    op(EPSUM_FixedTime) 
enum EParticleEventType
{
    EPET_Any                =0,
    EPET_Spawn              =1,
    EPET_Death              =2,
    EPET_Collision          =3,
    EPET_WorldAttractorCollision=4,
    EPET_Kismet             =5,
    EPET_MAX                =6,
};
#define FOREACH_ENUM_EPARTICLEEVENTTYPE(op) \
    op(EPET_Any) \
    op(EPET_Spawn) \
    op(EPET_Death) \
    op(EPET_Collision) \
    op(EPET_WorldAttractorCollision) \
    op(EPET_Kismet) 
enum ParticleReplayState
{
    PRS_Disabled            =0,
    PRS_Capturing           =1,
    PRS_Replaying           =2,
    PRS_MAX                 =3,
};
#define FOREACH_ENUM_PARTICLEREPLAYSTATE(op) \
    op(PRS_Disabled) \
    op(PRS_Capturing) \
    op(PRS_Replaying) 
enum EParticleSysParamType
{
    PSPT_None               =0,
    PSPT_Scalar             =1,
    PSPT_ScalarRand         =2,
    PSPT_Vector             =3,
    PSPT_VectorRand         =4,
    PSPT_Color              =5,
    PSPT_Actor              =6,
    PSPT_Material           =7,
    PSPT_MAX                =8,
};
#define FOREACH_ENUM_EPARTICLESYSPARAMTYPE(op) \
    op(PSPT_None) \
    op(PSPT_Scalar) \
    op(PSPT_ScalarRand) \
    op(PSPT_Vector) \
    op(PSPT_VectorRand) \
    op(PSPT_Color) \
    op(PSPT_Actor) \
    op(PSPT_Material) 
enum EEmitterRenderMode
{
    ERM_Normal              =0,
    ERM_Point               =1,
    ERM_Cross               =2,
    ERM_None                =3,
    ERM_MAX                 =4,
};
#define FOREACH_ENUM_EEMITTERRENDERMODE(op) \
    op(ERM_Normal) \
    op(ERM_Point) \
    op(ERM_Cross) \
    op(ERM_None) 
enum EParticleSubUVInterpMethod
{
    PSUVIM_None             =0,
    PSUVIM_Linear           =1,
    PSUVIM_Linear_Blend     =2,
    PSUVIM_Random           =3,
    PSUVIM_Random_Blend     =4,
    PSUVIM_MAX              =5,
};
#define FOREACH_ENUM_EPARTICLESUBUVINTERPMETHOD(op) \
    op(PSUVIM_None) \
    op(PSUVIM_Linear) \
    op(PSUVIM_Linear_Blend) \
    op(PSUVIM_Random) \
    op(PSUVIM_Random_Blend) 
enum EParticleBurstMethod
{
    EPBM_Instant            =0,
    EPBM_Interpolated       =1,
    EPBM_MAX                =2,
};
#define FOREACH_ENUM_EPARTICLEBURSTMETHOD(op) \
    op(EPBM_Instant) \
    op(EPBM_Interpolated) 
enum EParticleScreenAlignment
{
    PSA_Square              =0,
    PSA_Rectangle           =1,
    PSA_Velocity            =2,
    PSA_TypeSpecific        =3,
    PSA_MAX                 =4,
};
#define FOREACH_ENUM_EPARTICLESCREENALIGNMENT(op) \
    op(PSA_Square) \
    op(PSA_Rectangle) \
    op(PSA_Velocity) \
    op(PSA_TypeSpecific) 
enum EParticleSourceSelectionMethod
{
    EPSSM_Random            =0,
    EPSSM_Sequential        =1,
    EPSSM_MAX               =2,
};
#define FOREACH_ENUM_EPARTICLESOURCESELECTIONMETHOD(op) \
    op(EPSSM_Random) \
    op(EPSSM_Sequential) 
enum EModuleType
{
    EPMT_General            =0,
    EPMT_TypeData           =1,
    EPMT_Beam               =2,
    EPMT_Trail              =3,
    EPMT_Spawn              =4,
    EPMT_Required           =5,
    EPMT_Event              =6,
    EPMT_MAX                =7,
};
#define FOREACH_ENUM_EMODULETYPE(op) \
    op(EPMT_General) \
    op(EPMT_TypeData) \
    op(EPMT_Beam) \
    op(EPMT_Trail) \
    op(EPMT_Spawn) \
    op(EPMT_Required) \
    op(EPMT_Event) 
enum ELocationBoneSocketDestSelectionMethod
{
    BONESOCKETDESTSEL_Sequential=0,
    BONESOCKETDESTSEL_Random=1,
    BONESOCKETDESTSEL_RandomExhaustive=2,
    BONESOCKETDESTSEL_BlendAll=3,
    BONESOCKETDESTSEL_MAX   =4,
};
#define FOREACH_ENUM_ELOCATIONBONESOCKETDESTSELECTIONMETHOD(op) \
    op(BONESOCKETDESTSEL_Sequential) \
    op(BONESOCKETDESTSEL_Random) \
    op(BONESOCKETDESTSEL_RandomExhaustive) \
    op(BONESOCKETDESTSEL_BlendAll) 
enum ELocationBoneSocketDestination
{
    BONESOCKETDEST_Bones    =0,
    BONESOCKETDEST_Sockets  =1,
    BONESOCKETDEST_MAX      =2,
};
#define FOREACH_ENUM_ELOCATIONBONESOCKETDESTINATION(op) \
    op(BONESOCKETDEST_Bones) \
    op(BONESOCKETDEST_Sockets) 
enum EBoneSocketAttractorFalloffType
{
    BSFOFF_Constant         =0,
    BSFOFF_Linear           =1,
    BSFOFF_Exponent         =2,
    BSFOFF_MAX              =3,
};
#define FOREACH_ENUM_EBONESOCKETATTRACTORFALLOFFTYPE(op) \
    op(BSFOFF_Constant) \
    op(BSFOFF_Linear) \
    op(BSFOFF_Exponent) 
enum EAttractorParticleSelectionMethod
{
    EAPSM_Random            =0,
    EAPSM_Sequential        =1,
    EAPSM_MAX               =2,
};
#define FOREACH_ENUM_EATTRACTORPARTICLESELECTIONMETHOD(op) \
    op(EAPSM_Random) \
    op(EAPSM_Sequential) 
enum EAttractorSkelVertSurfaceDestination
{
    VERTSURFACEDEST_Vert    =0,
    VERTSURFACEDEST_Surface =1,
    VERTSURFACEDEST_MAX     =2,
};
#define FOREACH_ENUM_EATTRACTORSKELVERTSURFACEDESTINATION(op) \
    op(VERTSURFACEDEST_Vert) \
    op(VERTSURFACEDEST_Surface) 
enum EVertSurfaceAttractorFalloffType
{
    VSFOFF_Constant         =0,
    VSFOFF_Linear           =1,
    VSFOFF_Exponent         =2,
    VSFOFF_MAX              =3,
};
#define FOREACH_ENUM_EVERTSURFACEATTRACTORFALLOFFTYPE(op) \
    op(VSFOFF_Constant) \
    op(VSFOFF_Linear) \
    op(VSFOFF_Exponent) 
enum Beam2SourceTargetTangentMethod
{
    PEB2STTM_Direct         =0,
    PEB2STTM_UserSet        =1,
    PEB2STTM_Distribution   =2,
    PEB2STTM_Emitter        =3,
    PEB2STTM_MAX            =4,
};
#define FOREACH_ENUM_BEAM2SOURCETARGETTANGENTMETHOD(op) \
    op(PEB2STTM_Direct) \
    op(PEB2STTM_UserSet) \
    op(PEB2STTM_Distribution) \
    op(PEB2STTM_Emitter) 
enum Beam2SourceTargetMethod
{
    PEB2STM_Default         =0,
    PEB2STM_UserSet         =1,
    PEB2STM_Emitter         =2,
    PEB2STM_Particle        =3,
    PEB2STM_Actor           =4,
    PEB2STM_MAX             =5,
};
#define FOREACH_ENUM_BEAM2SOURCETARGETMETHOD(op) \
    op(PEB2STM_Default) \
    op(PEB2STM_UserSet) \
    op(PEB2STM_Emitter) \
    op(PEB2STM_Particle) \
    op(PEB2STM_Actor) 
enum BeamModifierType
{
    PEB2MT_Source           =0,
    PEB2MT_Target           =1,
    PEB2MT_MAX              =2,
};
#define FOREACH_ENUM_BEAMMODIFIERTYPE(op) \
    op(PEB2MT_Source) \
    op(PEB2MT_Target) 
enum EParticleCameraOffsetUpdateMethod
{
    EPCOUM_DirectSet        =0,
    EPCOUM_Additive         =1,
    EPCOUM_Scalar           =2,
    EPCOUM_MAX              =3,
};
#define FOREACH_ENUM_EPARTICLECAMERAOFFSETUPDATEMETHOD(op) \
    op(EPCOUM_DirectSet) \
    op(EPCOUM_Additive) \
    op(EPCOUM_Scalar) 
enum EParticleCollisionComplete
{
    EPCC_Kill               =0,
    EPCC_Freeze             =1,
    EPCC_HaltCollisions     =2,
    EPCC_FreezeTranslation  =3,
    EPCC_FreezeRotation     =4,
    EPCC_FreezeMovement     =5,
    EPCC_MAX                =6,
};
#define FOREACH_ENUM_EPARTICLECOLLISIONCOMPLETE(op) \
    op(EPCC_Kill) \
    op(EPCC_Freeze) \
    op(EPCC_HaltCollisions) \
    op(EPCC_FreezeTranslation) \
    op(EPCC_FreezeRotation) \
    op(EPCC_FreezeMovement) 
enum ParticleAttractorActionType
{
    PAAT_None               =0,
    PAAT_Destroy            =1,
    PAAT_Freeze             =2,
    PAAT_Event              =3,
    PAAT_MAX                =4,
};
#define FOREACH_ENUM_PARTICLEATTRACTORACTIONTYPE(op) \
    op(PAAT_None) \
    op(PAAT_Destroy) \
    op(PAAT_Freeze) \
    op(PAAT_Event) 
enum ELocationBoneSocketSelectionMethod
{
    BONESOCKETSEL_Sequential=0,
    BONESOCKETSEL_Random    =1,
    BONESOCKETSEL_RandomExhaustive=2,
    BONESOCKETSEL_MAX       =3,
};
#define FOREACH_ENUM_ELOCATIONBONESOCKETSELECTIONMETHOD(op) \
    op(BONESOCKETSEL_Sequential) \
    op(BONESOCKETSEL_Random) \
    op(BONESOCKETSEL_RandomExhaustive) 
enum ELocationBoneSocketSource
{
    BONESOCKETSOURCE_Bones  =0,
    BONESOCKETSOURCE_Sockets=1,
    BONESOCKETSOURCE_MAX    =2,
};
#define FOREACH_ENUM_ELOCATIONBONESOCKETSOURCE(op) \
    op(BONESOCKETSOURCE_Bones) \
    op(BONESOCKETSOURCE_Sockets) 
enum ELocationEmitterSelectionMethod
{
    ELESM_Random            =0,
    ELESM_Sequential        =1,
    ELESM_MAX               =2,
};
#define FOREACH_ENUM_ELOCATIONEMITTERSELECTIONMETHOD(op) \
    op(ELESM_Random) \
    op(ELESM_Sequential) 
enum CylinderHeightAxis
{
    PMLPC_HEIGHTAXIS_X      =0,
    PMLPC_HEIGHTAXIS_Y      =1,
    PMLPC_HEIGHTAXIS_Z      =2,
    PMLPC_HEIGHTAXIS_MAX    =3,
};
#define FOREACH_ENUM_CYLINDERHEIGHTAXIS(op) \
    op(PMLPC_HEIGHTAXIS_X) \
    op(PMLPC_HEIGHTAXIS_Y) \
    op(PMLPC_HEIGHTAXIS_Z) 
enum ELocationSkelVertSurfaceSource
{
    VERTSURFACESOURCE_Vert  =0,
    VERTSURFACESOURCE_Surface=1,
    VERTSURFACESOURCE_MAX   =2,
};
#define FOREACH_ENUM_ELOCATIONSKELVERTSURFACESOURCE(op) \
    op(VERTSURFACESOURCE_Vert) \
    op(VERTSURFACESOURCE_Surface) 
enum ELocationStaticVertSurfaceSource
{
    VERTSTATICSURFACESOURCE_Vert=0,
    VERTSTATICSURFACESOURCE_Surface=1,
    VERTSTATICSURFACESOURCE_MAX=2,
};
#define FOREACH_ENUM_ELOCATIONSTATICVERTSURFACESOURCE(op) \
    op(VERTSTATICSURFACESOURCE_Vert) \
    op(VERTSTATICSURFACESOURCE_Surface) 
enum EOrbitChainMode
{
    EOChainMode_Add         =0,
    EOChainMode_Scale       =1,
    EOChainMode_Link        =2,
    EOChainMode_MAX         =3,
};
#define FOREACH_ENUM_EORBITCHAINMODE(op) \
    op(EOChainMode_Add) \
    op(EOChainMode_Scale) \
    op(EOChainMode_Link) 
enum EParticleAxisLock
{
    EPAL_NONE               =0,
    EPAL_X                  =1,
    EPAL_Y                  =2,
    EPAL_Z                  =3,
    EPAL_NEGATIVE_X         =4,
    EPAL_NEGATIVE_Y         =5,
    EPAL_NEGATIVE_Z         =6,
    EPAL_ROTATE_X           =7,
    EPAL_ROTATE_Y           =8,
    EPAL_ROTATE_Z           =9,
    EPAL_MAX                =10,
};
#define FOREACH_ENUM_EPARTICLEAXISLOCK(op) \
    op(EPAL_NONE) \
    op(EPAL_X) \
    op(EPAL_Y) \
    op(EPAL_Z) \
    op(EPAL_NEGATIVE_X) \
    op(EPAL_NEGATIVE_Y) \
    op(EPAL_NEGATIVE_Z) \
    op(EPAL_ROTATE_X) \
    op(EPAL_ROTATE_Y) \
    op(EPAL_ROTATE_Z) 
enum EEmitterDynamicParameterValue
{
    EDPV_UserSet            =0,
    EDPV_VelocityX          =1,
    EDPV_VelocityY          =2,
    EDPV_VelocityZ          =3,
    EDPV_VelocityMag        =4,
    EDPV_MAX                =5,
};
#define FOREACH_ENUM_EEMITTERDYNAMICPARAMETERVALUE(op) \
    op(EDPV_UserSet) \
    op(EDPV_VelocityX) \
    op(EDPV_VelocityY) \
    op(EDPV_VelocityZ) \
    op(EDPV_VelocityMag) 
enum EEmitterNormalsMode
{
    ENM_CameraFacing        =0,
    ENM_Spherical           =1,
    ENM_Cylindrical         =2,
    ENM_MAX                 =3,
};
#define FOREACH_ENUM_EEMITTERNORMALSMODE(op) \
    op(ENM_CameraFacing) \
    op(ENM_Spherical) \
    op(ENM_Cylindrical) 
enum EParticleSortMode
{
    PSORTMODE_None          =0,
    PSORTMODE_ViewProjDepth =1,
    PSORTMODE_DistanceToView=2,
    PSORTMODE_Age_OldestFirst=3,
    PSORTMODE_Age_NewestFirst=4,
    PSORTMODE_MAX           =5,
};
#define FOREACH_ENUM_EPARTICLESORTMODE(op) \
    op(PSORTMODE_None) \
    op(PSORTMODE_ViewProjDepth) \
    op(PSORTMODE_DistanceToView) \
    op(PSORTMODE_Age_OldestFirst) \
    op(PSORTMODE_Age_NewestFirst) 
enum ETrail2SourceMethod
{
    PET2SRCM_Default        =0,
    PET2SRCM_Particle       =1,
    PET2SRCM_Actor          =2,
    PET2SRCM_MAX            =3,
};
#define FOREACH_ENUM_ETRAIL2SOURCEMETHOD(op) \
    op(PET2SRCM_Default) \
    op(PET2SRCM_Particle) \
    op(PET2SRCM_Actor) 
enum ETrail2SpawnMethod
{
    PET2SM_Emitter          =0,
    PET2SM_Velocity         =1,
    PET2SM_Distance         =2,
    PET2SM_MAX              =3,
};
#define FOREACH_ENUM_ETRAIL2SPAWNMETHOD(op) \
    op(PET2SM_Emitter) \
    op(PET2SM_Velocity) \
    op(PET2SM_Distance) 
enum ETrailTaperMethod
{
    PETTM_None              =0,
    PETTM_Full              =1,
    PETTM_Partial           =2,
    PETTM_MAX               =3,
};
#define FOREACH_ENUM_ETRAILTAPERMETHOD(op) \
    op(PETTM_None) \
    op(PETTM_Full) \
    op(PETTM_Partial) 
enum EBeamEndPointMethod
{
    PEBEPM_Calculated       =0,
    PEBEPM_Distribution     =1,
    PEBEPM_Distribution_Constant=2,
    PEBEPM_MAX              =3,
};
#define FOREACH_ENUM_EBEAMENDPOINTMETHOD(op) \
    op(PEBEPM_Calculated) \
    op(PEBEPM_Distribution) \
    op(PEBEPM_Distribution_Constant) 
enum EBeamMethod
{
    PEBM_Distance           =0,
    PEBM_EndPoints          =1,
    PEBM_EndPoints_Interpolated=2,
    PEBM_UserSet_EndPoints  =3,
    PEBM_UserSet_EndPoints_Interpolated=4,
    PEBM_MAX                =5,
};
#define FOREACH_ENUM_EBEAMMETHOD(op) \
    op(PEBM_Distance) \
    op(PEBM_EndPoints) \
    op(PEBM_EndPoints_Interpolated) \
    op(PEBM_UserSet_EndPoints) \
    op(PEBM_UserSet_EndPoints_Interpolated) 
enum EBeamTaperMethod
{
    PEBTM_None              =0,
    PEBTM_Full              =1,
    PEBTM_Partial           =2,
    PEBTM_MAX               =3,
};
#define FOREACH_ENUM_EBEAMTAPERMETHOD(op) \
    op(PEBTM_None) \
    op(PEBTM_Full) \
    op(PEBTM_Partial) 
enum EBeam2Method
{
    PEB2M_Distance          =0,
    PEB2M_Target            =1,
    PEB2M_Branch            =2,
    PEB2M_MAX               =3,
};
#define FOREACH_ENUM_EBEAM2METHOD(op) \
    op(PEB2M_Distance) \
    op(PEB2M_Target) \
    op(PEB2M_Branch) 
enum EMeshCameraFacingOptions
{
    XAxisFacing_NoUp        =0,
    XAxisFacing_ZUp         =1,
    XAxisFacing_NegativeZUp =2,
    XAxisFacing_YUp         =3,
    XAxisFacing_NegativeYUp =4,
    LockedAxis_ZAxisFacing  =5,
    LockedAxis_NegativeZAxisFacing=6,
    LockedAxis_YAxisFacing  =7,
    LockedAxis_NegativeYAxisFacing=8,
    VelocityAligned_ZAxisFacing=9,
    VelocityAligned_NegativeZAxisFacing=10,
    VelocityAligned_YAxisFacing=11,
    VelocityAligned_NegativeYAxisFacing=12,
    EMeshCameraFacingOptions_MAX=13,
};
#define FOREACH_ENUM_EMESHCAMERAFACINGOPTIONS(op) \
    op(XAxisFacing_NoUp) \
    op(XAxisFacing_ZUp) \
    op(XAxisFacing_NegativeZUp) \
    op(XAxisFacing_YUp) \
    op(XAxisFacing_NegativeYUp) \
    op(LockedAxis_ZAxisFacing) \
    op(LockedAxis_NegativeZAxisFacing) \
    op(LockedAxis_YAxisFacing) \
    op(LockedAxis_NegativeYAxisFacing) \
    op(VelocityAligned_ZAxisFacing) \
    op(VelocityAligned_NegativeZAxisFacing) \
    op(VelocityAligned_YAxisFacing) \
    op(VelocityAligned_NegativeYAxisFacing) 
enum EMeshCameraFacingUpAxis
{
    CameraFacing_NoneUP     =0,
    CameraFacing_ZUp        =1,
    CameraFacing_NegativeZUp=2,
    CameraFacing_YUp        =3,
    CameraFacing_NegativeYUp=4,
    CameraFacing_MAX        =5,
};
#define FOREACH_ENUM_EMESHCAMERAFACINGUPAXIS(op) \
    op(CameraFacing_NoneUP) \
    op(CameraFacing_ZUp) \
    op(CameraFacing_NegativeZUp) \
    op(CameraFacing_YUp) \
    op(CameraFacing_NegativeYUp) 
enum EMeshScreenAlignment
{
    PSMA_MeshFaceCameraWithRoll=0,
    PSMA_MeshFaceCameraWithSpin=1,
    PSMA_MeshFaceCameraWithLockedAxis=2,
    PSMA_MAX                =3,
};
#define FOREACH_ENUM_EMESHSCREENALIGNMENT(op) \
    op(PSMA_MeshFaceCameraWithRoll) \
    op(PSMA_MeshFaceCameraWithSpin) \
    op(PSMA_MeshFaceCameraWithLockedAxis) 
enum EPhysXMeshRotationMethod
{
    PMRM_Disabled           =0,
    PMRM_Spherical          =1,
    PMRM_Box                =2,
    PMRM_LongBox            =3,
    PMRM_FlatBox            =4,
    PMRM_Velocity           =5,
    PMRM_MAX                =6,
};
#define FOREACH_ENUM_EPHYSXMESHROTATIONMETHOD(op) \
    op(PMRM_Disabled) \
    op(PMRM_Spherical) \
    op(PMRM_Box) \
    op(PMRM_LongBox) \
    op(PMRM_FlatBox) \
    op(PMRM_Velocity) 
enum ETrailsRenderAxisOption
{
    Trails_CameraUp         =0,
    Trails_SourceUp         =1,
    Trails_WorldUp          =2,
    Trails_MAX              =3,
};
#define FOREACH_ENUM_ETRAILSRENDERAXISOPTION(op) \
    op(Trails_CameraUp) \
    op(Trails_SourceUp) \
    op(Trails_WorldUp) 
enum EParticleLevelInfluenceType
{
    LIT_Never               =0,
    LIT_OutsidePhysicsVolumes=1,
    LIT_Always              =2,
    LIT_MAX                 =3,
};
#define FOREACH_ENUM_EPARTICLELEVELINFLUENCETYPE(op) \
    op(LIT_Never) \
    op(LIT_OutsidePhysicsVolumes) \
    op(LIT_Always) 
enum EPacketSizeMultiplier
{
    EPSM_4                  =0,
    EPSM_8                  =1,
    EPSM_16                 =2,
    EPSM_32                 =3,
    EPSM_64                 =4,
    EPSM_128                =5,
    EPSM_MAX                =6,
};
#define FOREACH_ENUM_EPACKETSIZEMULTIPLIER(op) \
    op(EPSM_4) \
    op(EPSM_8) \
    op(EPSM_16) \
    op(EPSM_32) \
    op(EPSM_64) \
    op(EPSM_128) 
enum ESimulationMethod
{
    ESM_SPH                 =0,
    ESM_NO_PARTICLE_INTERACTION=1,
    ESM_MIXED_MODE          =2,
    ESM_MAX                 =3,
};
#define FOREACH_ENUM_ESIMULATIONMETHOD(op) \
    op(ESM_SPH) \
    op(ESM_NO_PARTICLE_INTERACTION) \
    op(ESM_MIXED_MODE) 

#endif // !INCLUDED_ENGINE_PARTICLE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_PARTICLE_CLASSES
#define INCLUDED_ENGINE_PARTICLE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class AEmitterCameraLensEffectBase : public AEmitter
{
public:
    //## BEGIN PROPS EmitterCameraLensEffectBase
    class UParticleSystem* PS_CameraEffect;
    class UParticleSystem* PS_CameraEffectNonExtremeContent;
    FLOAT BaseFOV;
    FLOAT DistFromCamera;
    BITFIELD bAllowMultipleInstances:1;
    TArrayNoInit<class UClass*> EmittersToTreatAsSame;
    class ACamera* BaseCamera;
    //## END PROPS EmitterCameraLensEffectBase

    virtual void UpdateLocation(const FVector& CamLoc,const FRotator& CamRot,FLOAT CamFOVDeg);
    DECLARE_FUNCTION(execUpdateLocation)
    {
        P_GET_STRUCT_REF(FVector,CamLoc);
        P_GET_STRUCT_REF(FRotator,CamRot);
        P_GET_FLOAT(CamFOVDeg);
        P_FINISH;
        this->UpdateLocation(CamLoc,CamRot,CamFOVDeg);
    }
    DECLARE_ABSTRACT_CLASS(AEmitterCameraLensEffectBase,AEmitter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AEmitterCameraLensEffectBase)
};

struct ParticleEventManager_eventHandleParticleModuleEventSendToGame_Parms
{
    class UParticleModuleEventSendToGame* InEvent;
    FVector InCollideDirection;
    FVector InHitLocation;
    FVector InHitNormal;
    FName InBoneName;
    ParticleEventManager_eventHandleParticleModuleEventSendToGame_Parms(EEventParm)
    {
    }
};
class AParticleEventManager : public AActor
{
public:
    //## BEGIN PROPS ParticleEventManager
    //## END PROPS ParticleEventManager

    void eventHandleParticleModuleEventSendToGame(class UParticleModuleEventSendToGame* InEvent,const FVector& InCollideDirection,const FVector& InHitLocation,const FVector& InHitNormal,const FName& InBoneName)
    {
        ParticleEventManager_eventHandleParticleModuleEventSendToGame_Parms Parms(EC_EventParm);
        Parms.InEvent=InEvent;
        Parms.InCollideDirection=InCollideDirection;
        Parms.InHitLocation=InHitLocation;
        Parms.InHitNormal=InHitNormal;
        Parms.InBoneName=InBoneName;
        ProcessEvent(FindFunctionChecked(ENGINE_HandleParticleModuleEventSendToGame),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AParticleEventManager,AActor,0,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(AParticleEventManager)
};

struct FParticleSystemLOD
{
    BITFIELD bLit:1;
    SCRIPT_ALIGN;

	static FParticleSystemLOD CreateParticleSystemLOD()
	{
		FParticleSystemLOD NewLOD;
		NewLOD.bLit = FALSE;
		return NewLOD;
	}

};

struct FLODSoloTrack
{
    TArrayNoInit<BYTE> SoloEnableSetting;

    /** Constructors */
    FLODSoloTrack() {}
    FLODSoloTrack(EEventParm)
    {
        appMemzero(this, sizeof(FLODSoloTrack));
    }
};

class UParticleSystem : public UObject
{
public:
    //## BEGIN PROPS ParticleSystem
    BYTE SystemUpdateMode;
    BYTE LODMethod;
    BYTE OcclusionBoundsMethod;
    FLOAT UpdateTime_FPS;
    FLOAT UpdateTime_Delta;
    FLOAT WarmupTime;
    FLOAT WarmupTickRate;
    TArrayNoInit<class UParticleEmitter*> Emitters;
    class UParticleSystemComponent* PreviewComponent;
#if WITH_EDITORONLY_DATA
    FRotator ThumbnailAngle;
    FLOAT ThumbnailDistance;
    FLOAT ThumbnailWarmup;
#endif // WITH_EDITORONLY_DATA
    BITFIELD bLit_DEPRECATED:1;
    BITFIELD bOrientZAxisTowardCamera:1;
    BITFIELD bRegenerateLODDuplicate:1;
    BITFIELD bUseFixedRelativeBoundingBox:1;
    BITFIELD bShouldResetPeakCounts:1;
    BITFIELD bHasPhysics:1;
    BITFIELD bUseRealtimeThumbnail:1;
    BITFIELD ThumbnailImageOutOfDate:1;
    BITFIELD bSkipSpawnCountCheck:1;
    BITFIELD bUseDelayRange:1;
    class UInterpCurveEdSetup* CurveEdSetup;
    FLOAT LODDistanceCheckTime;
    TArrayNoInit<FLOAT> LODDistances;
#if WITH_EDITORONLY_DATA
    INT EditorLODSetting;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<struct FParticleSystemLOD> LODSettings;
    FBox FixedRelativeBoundingBox;
    FLOAT SecondsBeforeInactive;
#if WITH_EDITORONLY_DATA
    FStringNoInit FloorMesh;
    FVector FloorPosition;
    FRotator FloorRotation;
    FLOAT FloorScale;
    FVector FloorScale3D;
    FColor BackgroundColor;
    class UTexture2D* ThumbnailImage;
#endif // WITH_EDITORONLY_DATA
    FLOAT Delay;
    FLOAT DelayLow;
    FVector MacroUVPosition;
    FLOAT MacroUVRadius;
    FBox CustomOcclusionBounds;
    TArrayNoInit<struct FLODSoloTrack> SoloTracking;
    //## END PROPS ParticleSystem

    virtual BYTE GetCurrentLODMethod();
    virtual INT GetLODLevelCount();
    virtual FLOAT GetLODDistance(INT LODLevelIndex);
    virtual void SetCurrentLODMethod(BYTE InMethod);
    virtual UBOOL SetLODDistance(INT LODLevelIndex,FLOAT InDistance);
    virtual FLOAT GetMaxLifespan(FLOAT InComponentDelay);
    DECLARE_FUNCTION(execGetCurrentLODMethod)
    {
        P_FINISH;
        *(BYTE*)Result=this->GetCurrentLODMethod();
    }
    DECLARE_FUNCTION(execGetLODLevelCount)
    {
        P_FINISH;
        *(INT*)Result=this->GetLODLevelCount();
    }
    DECLARE_FUNCTION(execGetLODDistance)
    {
        P_GET_INT(LODLevelIndex);
        P_FINISH;
        *(FLOAT*)Result=this->GetLODDistance(LODLevelIndex);
    }
    DECLARE_FUNCTION(execSetCurrentLODMethod)
    {
        P_GET_BYTE(InMethod);
        P_FINISH;
        this->SetCurrentLODMethod(InMethod);
    }
    DECLARE_FUNCTION(execSetLODDistance)
    {
        P_GET_INT(LODLevelIndex);
        P_GET_FLOAT(InDistance);
        P_FINISH;
        *(UBOOL*)Result=this->SetLODDistance(LODLevelIndex,InDistance);
    }
    DECLARE_FUNCTION(execGetMaxLifespan)
    {
        P_GET_FLOAT(InComponentDelay);
        P_FINISH;
        *(FLOAT*)Result=this->GetMaxLifespan(InComponentDelay);
    }
    DECLARE_CLASS(UParticleSystem,UObject,0,Engine)
	// UObject interface.
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PreSave();
	virtual void PostLoad();

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	void UpdateColorModuleClampAlpha(class UParticleModuleColorBase* ColorModule);

	/**
	 *	CalculateMaxActiveParticleCounts
	 *	Determine the maximum active particles that could occur with each emitter.
	 *	This is to avoid reallocation during the life of the emitter.
	 *
	 *	@return	TRUE	if the numbers were determined for each emitter
	 *			FALSE	if not be determined
	 */
	virtual UBOOL		CalculateMaxActiveParticleCounts();
	
	/**
	 *	Retrieve the parameters associated with this particle system.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams used in the system
	 *	@param	ParticleParameterList	The list of ParticleParameter distributions used in the system
	 */
	void GetParametersUtilized(TArray<TArray<FString> >& ParticleSysParamList,
							   TArray<TArray<FString> >& ParticleParameterList);

	/**
	 *	Setup the soloing information... Obliterates all current soloing.
	 */
	void SetupSoloing();

	/**
	 *	Toggle the bIsSoloing flag on the given emitter.
	 *
	 *	@param	InEmitter		The emitter to toggle.
	 *
	 *	@return	UBOOL			TRUE if ANY emitters are set to soloing, FALSE if none are.
	 */
	UBOOL ToggleSoloing(class UParticleEmitter* InEmitter);

	/**
	 *	Turn soloing off completely - on every emitter
	 *
	 *	@return	UBOOL			TRUE if successful, FALSE if not.
	 */
	UBOOL TurnOffSoloing();

	/**
	 *	Editor helper function for setting the LOD validity flags used in Cascade.
	 */
	void SetupLODValidity();

#if WITH_EDITOR
	/**
	 *	Convert the given module to its randon seed variant.
	 *
	 *	@param	InEmitter				The emitter to convert
	 *	@param	InModuleIdx				The index of the module to convert
	 *	@param	InSeededClass			The seeded variant class
	 *	@param	bInUpdateModuleLists	If TRUE, update the module lists after the conversion
	 *
	 *	@return	UBOOL					TRUE if successful, FALSE if not
	 */
	UBOOL ConvertModuleToSeeded(UParticleEmitter* InEmitter, INT InModuleIdx, UClass* InSeededClass, UBOOL bInUpdateModuleLists);

	/**
	 *	Convert all the modules in this particle system to their random seed variant if available
	 *
	 *	@return	UBOOL			TRUE if successful, FALSE if not
	 */
	UBOOL ConvertAllModulesToSeeded();

	/**
	 *	Remove all duplicate modules.
	 *
	 *	@param	bInMarkForCooker	If TRUE, mark removed objects to not cook out.
	 *	@param	OutRemovedModules	Optional map to fill in w/ removed modules...
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	UBOOL RemoveAllDuplicateModules(UBOOL bInMarkForCooker, TMap<UObject*,UBOOL>* OutRemovedModules);

	/**
	 *	Update all emitter module lists
	 */
	void UpdateAllModuleLists();
#endif
};

struct FParticleEmitterInstanceMotionBlurInfo
{
    TMap<INT, struct FMeshElementMotionBlurInfo> ParticleMBInfoMap;

    /** Constructors */
    FParticleEmitterInstanceMotionBlurInfo() {}
    FParticleEmitterInstanceMotionBlurInfo(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEmitterInstanceMotionBlurInfo));
    }
};

struct FViewParticleEmitterInstanceMotionBlurInfo
{
    TMap<const struct FParticleMeshEmitterInstance*, struct FParticleEmitterInstanceMotionBlurInfo> EmitterInstanceMBInfoMap;

    /** Constructors */
    FViewParticleEmitterInstanceMotionBlurInfo() {}
    FViewParticleEmitterInstanceMotionBlurInfo(EEventParm)
    {
        appMemzero(this, sizeof(FViewParticleEmitterInstanceMotionBlurInfo));
    }
};

struct FParticleSysParam
{
    FName Name;
    BYTE ParamType;
    FLOAT Scalar;
    FLOAT Scalar_Low;
    FVector Vector;
    FVector Vector_Low;
    FColor Color;
    class AActor* Actor;
    class UMaterialInterface* Material;

    /** Constructors */
    FParticleSysParam() {}
    FParticleSysParam(EEventParm)
    {
        appMemzero(this, sizeof(FParticleSysParam));
    }
};

struct FParticleEventData
{
    INT Type;
    FName EventName;
    FLOAT EmitterTime;
    FVector Location;
    FVector Direction;
    FVector Velocity;

    /** Constructors */
    FParticleEventData() {}
    FParticleEventData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventData));
    }
};

struct FParticleEventSpawnData : public FParticleEventData
{

    /** Constructors */
    FParticleEventSpawnData() {}
    FParticleEventSpawnData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventSpawnData));
    }
};

struct FParticleEventDeathData : public FParticleEventData
{
    FLOAT ParticleTime;

    /** Constructors */
    FParticleEventDeathData() {}
    FParticleEventDeathData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventDeathData));
    }
};

struct FParticleEventCollideData : public FParticleEventData
{
    FLOAT ParticleTime;
    FVector Normal;
    FLOAT Time;
    INT Item;
    FName BoneName;

    /** Constructors */
    FParticleEventCollideData() {}
    FParticleEventCollideData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventCollideData));
    }
};

struct FParticleEventAttractorCollideData : public FParticleEventCollideData
{

    /** Constructors */
    FParticleEventAttractorCollideData() {}
    FParticleEventAttractorCollideData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventAttractorCollideData));
    }
};

struct FParticleEventKismetData : public FParticleEventData
{
    BITFIELD UsePSysCompLocation:1;
    SCRIPT_ALIGN;
    FVector Normal;

    /** Constructors */
    FParticleEventKismetData() {}
    FParticleEventKismetData(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEventKismetData));
    }
};

struct ParticleSystemComponent_eventOnSystemFinished_Parms
{
    class UParticleSystemComponent* PSystem;
    ParticleSystemComponent_eventOnSystemFinished_Parms(EEventParm)
    {
    }
};
class UParticleSystemComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS ParticleSystemComponent
    class UParticleSystem* Template;
    class UClass* LightEnvironmentClass;
    class AActor* LightEnvironmentSharedInstigator;
    INT MaxLightEnvironmentPooledReuses;
    TArrayNoInit<struct FParticleEmitterInstance*> EmitterInstances;
    TArrayNoInit<class UStaticMeshComponent*> SMComponents;
    TArrayNoInit<class UMaterialInterface*> SMMaterialInterfaces;
    TArrayNoInit<class USkeletalMeshComponent*> SkelMeshComponents;
    TArrayNoInit<struct FViewParticleEmitterInstanceMotionBlurInfo> ViewMBInfoArray;
    BITFIELD bAutoActivate:1;
    BITFIELD bWasCompleted:1;
    BITFIELD bSuppressSpawning:1;
    BITFIELD bWasDeactivated:1;
    BITFIELD bResetOnDetach:1;
    BITFIELD bUpdateOnDedicatedServer:1;
    BITFIELD bJustAttached:1;
    BITFIELD bIsActive:1;
    BITFIELD bHasBeenActivated:1;
    BITFIELD bWarmingUp:1;
    BITFIELD bIsCachedInPool:1;
    BITFIELD bOverrideLODMethod:1;
    BITFIELD bSkipUpdateDynamicDataDuringTick:1;
    BITFIELD bSkipBoundsUpdate:1;
    BITFIELD bUpdateComponentInTick:1;
    BITFIELD bDeferredBeamUpdate:1;
    BITFIELD bForcedInActive:1;
    BITFIELD bIsWarmingUp:1;
    BITFIELD bIsViewRelevanceDirty:1;
    BITFIELD bRecacheViewRelevance:1;
    BITFIELD bLODUpdatePending:1;
    BITFIELD bSkipSpawnCountCheck:1;
    TArrayNoInit<struct FParticleSysParam> InstanceParameters;
    FVector OldPosition;
    FVector PartSysVelocity;
    FLOAT WarmupTime;
    FLOAT WarmupTickRate;
private:
    INT LODLevel;
public:
    FLOAT SecondsBeforeInactive;
private:
    FLOAT TimeSinceLastForceUpdateTransform;
public:
    FLOAT MaxTimeBeforeForceUpdateTransform;
#if WITH_EDITORONLY_DATA
    INT EditorLODLevel;
    INT EditorDetailMode;
#endif // WITH_EDITORONLY_DATA
    FLOAT AccumTickTime;
    BYTE LODMethod;
    BYTE ReplayState;
    TArrayNoInit<FMaterialViewRelevance> CachedViewRelevanceFlags;
    TArrayNoInit<class UParticleSystemReplay*> ReplayClips;
    INT ReplayClipIDNumber;
    INT ReplayFrameIndex;
    FLOAT AccumLODDistanceCheckTime;
    TArrayNoInit<struct FParticleEventSpawnData> SpawnEvents;
    TArrayNoInit<struct FParticleEventDeathData> DeathEvents;
    TArrayNoInit<struct FParticleEventCollideData> CollisionEvents;
    TArrayNoInit<struct FParticleEventKismetData> KismetEvents;
    TArrayNoInit<struct FParticleEventAttractorCollideData> AttractorCollisionEvents;
    class FRenderCommandFence* ReleaseResourcesFence;
    FLOAT CustomTimeDilation;
    FLOAT EmitterDelay;
    FScriptDelegate __OnSystemFinished__Delegate;
    //## END PROPS ParticleSystemComponent

    void SetTemplate(class UParticleSystem* NewTemplate);
    void ActivateSystem(UBOOL bFlagAsJustAttached=FALSE);
    void DeactivateSystem();
    void KillParticlesForced();
    void KillParticlesInEmitter(FName InEmitterName);
    void SetSkipUpdateDynamicDataDuringTick(UBOOL bInSkipUpdateDynamicDataDuringTick);
    UBOOL GetSkipUpdateDynamicDataDuringTick();
    void SetSkipBoundsUpdate(UBOOL bInSkipBoundsUpdate);
    UBOOL GetSkipBoundsUpdate();
    virtual void SetKillOnDeactivate(INT EmitterIndex,UBOOL bKill);
    virtual void SetKillOnCompleted(INT EmitterIndex,UBOOL bKill);
    virtual void RewindEmitterInstance(INT EmitterIndex);
    virtual void RewindEmitterInstances();
    virtual void SetBeamType(INT EmitterIndex,INT NewMethod);
    virtual void SetBeamTessellationFactor(INT EmitterIndex,FLOAT NewFactor);
    virtual void SetBeamEndPoint(INT EmitterIndex,FVector NewEndPoint);
    virtual void SetBeamDistance(INT EmitterIndex,FLOAT Distance);
    virtual void SetBeamSourcePoint(INT EmitterIndex,FVector NewSourcePoint,INT SourceIndex);
    virtual void SetBeamSourceTangent(INT EmitterIndex,FVector NewTangentPoint,INT SourceIndex);
    virtual void SetBeamSourceStrength(INT EmitterIndex,FLOAT NewSourceStrength,INT SourceIndex);
    virtual void SetBeamTargetPoint(INT EmitterIndex,FVector NewTargetPoint,INT TargetIndex);
    virtual void SetBeamTargetTangent(INT EmitterIndex,FVector NewTangentPoint,INT TargetIndex);
    virtual void SetBeamTargetStrength(INT EmitterIndex,FLOAT NewTargetStrength,INT TargetIndex);
    virtual INT DetermineLODLevelForLocation(const FVector& EffectLocation);
    virtual FLOAT GetMaxLifespan();
    virtual UBOOL SystemHasCompleted();
    void SetLODLevel(INT InLODLevel);
    void SetEditorLODLevel(INT InLODLevel);
    INT GetLODLevel();
    INT GetEditorLODLevel();
    void SetFloatParameter(FName ParameterName,FLOAT Param);
    void SetFloatRandParameter(FName ParameterName,FLOAT Param,FLOAT ParamLow);
    void SetVectorParameter(FName ParameterName,FVector Param);
    void SetVectorRandParameter(FName ParameterName,const FVector& Param,const FVector& ParamLow);
    void SetColorParameter(FName ParameterName,FColor Param);
    void SetActorParameter(FName ParameterName,class AActor* Param);
    void SetMaterialParameter(FName ParameterName,class UMaterialInterface* Param);
    virtual UBOOL GetFloatParameter(const FName InName,FLOAT& OutFloat);
    virtual UBOOL GetVectorParameter(const FName InName,FVector& OutVector);
    virtual UBOOL GetColorParameter(const FName InName,FColor& OutColor);
    virtual UBOOL GetActorParameter(const FName InName,class AActor*& OutActor);
    virtual UBOOL GetMaterialParameter(const FName InName,class UMaterialInterface*& OutMaterial);
    void ClearParameter(FName ParameterName,BYTE ParameterType=0);
    void SetActive(UBOOL bNowActive,UBOOL bFlagAsJustAttached=FALSE);
    void ResetToDefaults();
    void SetStopSpawning(INT InEmitterIndex,UBOOL bInStopSpawning);
    DECLARE_FUNCTION(execSetTemplate)
    {
        P_GET_OBJECT(UParticleSystem,NewTemplate);
        P_FINISH;
        this->SetTemplate(NewTemplate);
    }
    DECLARE_FUNCTION(execActivateSystem)
    {
        P_GET_UBOOL_OPTX(bFlagAsJustAttached,FALSE);
        P_FINISH;
        this->ActivateSystem(bFlagAsJustAttached);
    }
    DECLARE_FUNCTION(execDeactivateSystem)
    {
        P_FINISH;
        this->DeactivateSystem();
    }
    DECLARE_FUNCTION(execKillParticlesForced)
    {
        P_FINISH;
        this->KillParticlesForced();
    }
    DECLARE_FUNCTION(execKillParticlesInEmitter)
    {
        P_GET_NAME(InEmitterName);
        P_FINISH;
        this->KillParticlesInEmitter(InEmitterName);
    }
    DECLARE_FUNCTION(execSetSkipUpdateDynamicDataDuringTick)
    {
        P_GET_UBOOL(bInSkipUpdateDynamicDataDuringTick);
        P_FINISH;
        this->SetSkipUpdateDynamicDataDuringTick(bInSkipUpdateDynamicDataDuringTick);
    }
    DECLARE_FUNCTION(execGetSkipUpdateDynamicDataDuringTick)
    {
        P_FINISH;
        *(UBOOL*)Result=this->GetSkipUpdateDynamicDataDuringTick();
    }
    DECLARE_FUNCTION(execSetSkipBoundsUpdate)
    {
        P_GET_UBOOL(bInSkipBoundsUpdate);
        P_FINISH;
        this->SetSkipBoundsUpdate(bInSkipBoundsUpdate);
    }
    DECLARE_FUNCTION(execGetSkipBoundsUpdate)
    {
        P_FINISH;
        *(UBOOL*)Result=this->GetSkipBoundsUpdate();
    }
    DECLARE_FUNCTION(execSetKillOnDeactivate)
    {
        P_GET_INT(EmitterIndex);
        P_GET_UBOOL(bKill);
        P_FINISH;
        this->SetKillOnDeactivate(EmitterIndex,bKill);
    }
    DECLARE_FUNCTION(execSetKillOnCompleted)
    {
        P_GET_INT(EmitterIndex);
        P_GET_UBOOL(bKill);
        P_FINISH;
        this->SetKillOnCompleted(EmitterIndex,bKill);
    }
    DECLARE_FUNCTION(execRewindEmitterInstance)
    {
        P_GET_INT(EmitterIndex);
        P_FINISH;
        this->RewindEmitterInstance(EmitterIndex);
    }
    DECLARE_FUNCTION(execRewindEmitterInstances)
    {
        P_FINISH;
        this->RewindEmitterInstances();
    }
    DECLARE_FUNCTION(execSetBeamType)
    {
        P_GET_INT(EmitterIndex);
        P_GET_INT(NewMethod);
        P_FINISH;
        this->SetBeamType(EmitterIndex,NewMethod);
    }
    DECLARE_FUNCTION(execSetBeamTessellationFactor)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(NewFactor);
        P_FINISH;
        this->SetBeamTessellationFactor(EmitterIndex,NewFactor);
    }
    DECLARE_FUNCTION(execSetBeamEndPoint)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewEndPoint);
        P_FINISH;
        this->SetBeamEndPoint(EmitterIndex,NewEndPoint);
    }
    DECLARE_FUNCTION(execSetBeamDistance)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(Distance);
        P_FINISH;
        this->SetBeamDistance(EmitterIndex,Distance);
    }
    DECLARE_FUNCTION(execSetBeamSourcePoint)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewSourcePoint);
        P_GET_INT(SourceIndex);
        P_FINISH;
        this->SetBeamSourcePoint(EmitterIndex,NewSourcePoint,SourceIndex);
    }
    DECLARE_FUNCTION(execSetBeamSourceTangent)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewTangentPoint);
        P_GET_INT(SourceIndex);
        P_FINISH;
        this->SetBeamSourceTangent(EmitterIndex,NewTangentPoint,SourceIndex);
    }
    DECLARE_FUNCTION(execSetBeamSourceStrength)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(NewSourceStrength);
        P_GET_INT(SourceIndex);
        P_FINISH;
        this->SetBeamSourceStrength(EmitterIndex,NewSourceStrength,SourceIndex);
    }
    DECLARE_FUNCTION(execSetBeamTargetPoint)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewTargetPoint);
        P_GET_INT(TargetIndex);
        P_FINISH;
        this->SetBeamTargetPoint(EmitterIndex,NewTargetPoint,TargetIndex);
    }
    DECLARE_FUNCTION(execSetBeamTargetTangent)
    {
        P_GET_INT(EmitterIndex);
        P_GET_STRUCT(FVector,NewTangentPoint);
        P_GET_INT(TargetIndex);
        P_FINISH;
        this->SetBeamTargetTangent(EmitterIndex,NewTangentPoint,TargetIndex);
    }
    DECLARE_FUNCTION(execSetBeamTargetStrength)
    {
        P_GET_INT(EmitterIndex);
        P_GET_FLOAT(NewTargetStrength);
        P_GET_INT(TargetIndex);
        P_FINISH;
        this->SetBeamTargetStrength(EmitterIndex,NewTargetStrength,TargetIndex);
    }
    DECLARE_FUNCTION(execDetermineLODLevelForLocation)
    {
        P_GET_STRUCT_REF(FVector,EffectLocation);
        P_FINISH;
        *(INT*)Result=this->DetermineLODLevelForLocation(EffectLocation);
    }
    DECLARE_FUNCTION(execGetMaxLifespan)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetMaxLifespan();
    }
    DECLARE_FUNCTION(execSystemHasCompleted)
    {
        P_FINISH;
        *(UBOOL*)Result=this->SystemHasCompleted();
    }
    DECLARE_FUNCTION(execSetLODLevel)
    {
        P_GET_INT(InLODLevel);
        P_FINISH;
        this->SetLODLevel(InLODLevel);
    }
    DECLARE_FUNCTION(execSetEditorLODLevel)
    {
        P_GET_INT(InLODLevel);
        P_FINISH;
        this->SetEditorLODLevel(InLODLevel);
    }
    DECLARE_FUNCTION(execGetLODLevel)
    {
        P_FINISH;
        *(INT*)Result=this->GetLODLevel();
    }
    DECLARE_FUNCTION(execGetEditorLODLevel)
    {
        P_FINISH;
        *(INT*)Result=this->GetEditorLODLevel();
    }
    DECLARE_FUNCTION(execSetFloatParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Param);
        P_FINISH;
        this->SetFloatParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetFloatRandParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_FLOAT(Param);
        P_GET_FLOAT(ParamLow);
        P_FINISH;
        this->SetFloatRandParameter(ParameterName,Param,ParamLow);
    }
    DECLARE_FUNCTION(execSetVectorParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT(FVector,Param);
        P_FINISH;
        this->SetVectorParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetVectorRandParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT_REF(FVector,Param);
        P_GET_STRUCT_REF(FVector,ParamLow);
        P_FINISH;
        this->SetVectorRandParameter(ParameterName,Param,ParamLow);
    }
    DECLARE_FUNCTION(execSetColorParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_STRUCT(FColor,Param);
        P_FINISH;
        this->SetColorParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetActorParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(AActor,Param);
        P_FINISH;
        this->SetActorParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execSetMaterialParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_OBJECT(UMaterialInterface,Param);
        P_FINISH;
        this->SetMaterialParameter(ParameterName,Param);
    }
    DECLARE_FUNCTION(execGetFloatParameter)
    {
        P_GET_NAME(InName);
        P_GET_FLOAT_REF(OutFloat);
        P_FINISH;
        *(UBOOL*)Result=this->GetFloatParameter(InName,OutFloat);
    }
    DECLARE_FUNCTION(execGetVectorParameter)
    {
        P_GET_NAME(InName);
        P_GET_STRUCT_REF(FVector,OutVector);
        P_FINISH;
        *(UBOOL*)Result=this->GetVectorParameter(InName,OutVector);
    }
    DECLARE_FUNCTION(execGetColorParameter)
    {
        P_GET_NAME(InName);
        P_GET_STRUCT_REF(FColor,OutColor);
        P_FINISH;
        *(UBOOL*)Result=this->GetColorParameter(InName,OutColor);
    }
    DECLARE_FUNCTION(execGetActorParameter)
    {
        P_GET_NAME(InName);
        P_GET_OBJECT_REF(AActor,OutActor);
        P_FINISH;
        *(UBOOL*)Result=this->GetActorParameter(InName,OutActor);
    }
    DECLARE_FUNCTION(execGetMaterialParameter)
    {
        P_GET_NAME(InName);
        P_GET_OBJECT_REF(UMaterialInterface,OutMaterial);
        P_FINISH;
        *(UBOOL*)Result=this->GetMaterialParameter(InName,OutMaterial);
    }
    DECLARE_FUNCTION(execClearParameter)
    {
        P_GET_NAME(ParameterName);
        P_GET_BYTE_OPTX(ParameterType,0);
        P_FINISH;
        this->ClearParameter(ParameterName,ParameterType);
    }
    DECLARE_FUNCTION(execSetActive)
    {
        P_GET_UBOOL(bNowActive);
        P_GET_UBOOL_OPTX(bFlagAsJustAttached,FALSE);
        P_FINISH;
        this->SetActive(bNowActive,bFlagAsJustAttached);
    }
    DECLARE_FUNCTION(execResetToDefaults)
    {
        P_FINISH;
        this->ResetToDefaults();
    }
    DECLARE_FUNCTION(execSetStopSpawning)
    {
        P_GET_INT(InEmitterIndex);
        P_GET_UBOOL(bInStopSpawning);
        P_FINISH;
        this->SetStopSpawning(InEmitterIndex,bInStopSpawning);
    }
    void delegateOnSystemFinished(class UParticleSystemComponent* PSystem)
    {
        ParticleSystemComponent_eventOnSystemFinished_Parms Parms(EC_EventParm);
        Parms.PSystem=PSystem;
        ProcessDelegate(ENGINE_OnSystemFinished,&__OnSystemFinished__Delegate,&Parms);
    }
    DECLARE_CLASS(UParticleSystemComponent,UPrimitiveComponent,0,Engine)
	// ActorComponent interface.
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	// UObject interface
	virtual void PostLoad();
	virtual void BeginDestroy();
	virtual void FinishDestroy();
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent);
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	// Collision Handling...
	virtual UBOOL SingleLineCheck(FCheckResult& Hit, AActor* SourceActor, const FVector& End, const FVector& Start, DWORD TraceFlags, const FVector& Extent);

protected:
	// UActorComponent interface.
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );
	virtual void UpdateLODInformation();

	/**
	 * Static: Supplied with a chunk of replay data, this method will create dynamic emitter data that can
	 * be used to render the particle system
	 *
	 * @param	EmitterInstance		Emitter instance this replay is playing on
	 * @param	EmitterReplayData	Incoming replay data of any time, cannot be NULL
	 * @param	bSelected			TRUE if the particle system is currently selected
	 *
	 * @return	The newly created dynamic data, or NULL on failure
	 */
	static FDynamicEmitterDataBase* CreateDynamicDataFromReplay( FParticleEmitterInstance* EmitterInstance, const FDynamicEmitterReplayDataBase* EmitterReplayData, UBOOL bSelected );

	/**
	 * Creates dynamic particle data for rendering the particle system this frame.  This function
	 * handle creation of dynamic data for regularly simulated particles, but also handles capture
	 * and playback of particle replay data.
	 *
	 * @return	Returns the dynamic data to render this frame
	 */
	FParticleDynamicData* CreateDynamicData();

	/** Orients the Z axis of the ParticleSystemComponent toward the camera while preserving the X axis direction */
	void OrientZAxisTowardCamera();
	
	/** 
	 * Returns the the correct LocalToWorld transform for this system if attached to a skeletal mesh
	 * @param	Transform		output transform if it exists
	 * @return					Returns true if the transform exists
	 */
	bool GetSkeletalMeshAttachmentTransform(FMatrix &Transform);

public:
	FORCEINLINE INT GetCurrentLODIndex() const
	{
		return LODLevel;
	}

	virtual void UpdateDynamicData();
	virtual void UpdateDynamicData(FParticleSystemSceneProxy* Proxy);
	virtual void UpdateViewRelevance(FParticleSystemSceneProxy* Proxy);

	// UPrimitiveComponent interface
	virtual void UpdateBounds();
	virtual void Tick(FLOAT DeltaTime);

	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void SetLightEnvironment(ULightEnvironmentComponent* NewLightEnvironment);

	/** 
	 * Retrieves the materials used in this component 
	 * 
	 * @param OutMaterials	The list of used materials.
	 */
	virtual void GetUsedMaterials( TArray<UMaterialInterface*>& OutMaterials ) const;

	/**
	 * Determine if the primitive supports motion blur velocity rendering by storing
	 * motion blur transform info at the MeshElement level.
	 *
	 * @return TRUE if the primitive supports motion blur velocity rendering in its generated meshes
	 */
	virtual UBOOL HasMotionBlurVelocityMeshes() const;

	/**
	 * Determine if the given LODLevel requires motion blur velocity rendering.
	 *
	 *	@param	InLODIndex	The index of LOD level of interest
	 *	@return TRUE		if the given LODLevel requires motion blur velocity rendering in its generated meshes
	 */
	virtual UBOOL LODLevelHasMotionBlurVelocityMeshes(INT InLODIndex) const;

	// UParticleSystemComponent interface
	virtual void InitParticles();
	void ResetParticles(UBOOL bEmptyInstances = FALSE);
	void ResetBurstLists();
	void UpdateInstances();
	UBOOL HasCompleted();

	void InitializeSystem();

#if USE_GAMEPLAY_PROFILER
    /** 
     * This function actually does the work for the GetProfilerAssetObject and is virtual.  
     * It should only be called from GetProfilerAssetObject as GetProfilerAssetObject is safe to call on NULL object pointers
     **/
	virtual UObject* GetProfilerAssetObjectInternal() const;
#endif

	/**
	 * This will return detail info about this specific object. (e.g. AudioComponent will return the name of the cue,
	 * ParticleSystemComponent will return the name of the ParticleSystem)  The idea here is that in many places
	 * you have a component of interest but what you really want is some characteristic that you can use to track
	 * down where it came from.  
	 * 
	 */
	virtual FString GetDetailedInfoInternal() const;

	/**
	 *	Cache the view-relevance for each emitter at each LOD level.
	 *
	 *	@param	NewTemplate		The UParticleSystem* to use as the template.
	 *							If NULL, use the currently set template.
	 */
	void CacheViewRelevanceFlags(class UParticleSystem* NewTemplate = NULL);

	/**
	*	DetermineLODLevel - determines the appropriate LOD level to utilize.
	*/
	INT DetermineLODLevel(const FSceneView* View);

	void	AutoPopulateInstanceProperties();

	void	FlushSMComponentsArray();

	/** Event reporting... */
	/** 
	 *	Record a spawning event. 
	 *
	 *	@param	InEventName			The name of the event that fired.
	 *	@param	InEmitterTime		The emitter time when the event fired.
	 *	@param	InLocation			The location of the particle when the event fired.
	 *	@param	InVelocity			The velocity of the particle when the event fired.
	 */
	void ReportEventSpawn(FName& InEventName, FLOAT InEmitterTime, 
		FVector& InLocation, FVector& InVelocity);
	/** 
	 *	Record a death event.
	 *
	 *	@param	InEventName			The name of the event that fired.
	 *	@param	InEmitterTime		The emitter time when the event fired.
	 *	@param	InLocation			The location of the particle when the event fired.
	 *	@param	InVelocity			The velocity of the particle when the event fired.
	 *	@param	InParticleTime		The relative life of the particle when the event fired.
	 */
	void ReportEventDeath(FName& InEventName, FLOAT InEmitterTime, 
		FVector& InLocation, FVector& InVelocity, FLOAT InParticleTime);
	/** 
	 *	Record a collision event.
	 *
	 *	@param	InEventName		The name of the event that fired.
	 *	@param	InEmitterTime	The emitter time when the event fired.
	 *	@param	InLocation		The location of the particle when the event fired.
	 *	@param	InDirection		The direction of the particle when the event fired.
	 *	@param	InVelocity		The velocity of the particle when the event fired.
	 *	@param	InParticleTime	The relative life of the particle when the event fired.
	 *	@param	InNormal		Normal vector of the collision in coordinate system of the returner. Zero=none.
	 *	@param	InTime			Time until hit, if line check.
	 *	@param	InItem			Primitive data item which was hit, INDEX_NONE=none.
	 *	@param	InBoneName		Name of bone we hit (for skeletal meshes).
	 */
	void ReportEventCollision(FName& InEventName, FLOAT InEmitterTime, FVector& InLocation, 
		FVector& InDirection, FVector& InVelocity, FLOAT InParticleTime, FVector& InNormal, 
		FLOAT InTime, INT InItem, FName& InBoneName);
	/** 
	 *	Record a world attractor collision event.
	 *
	 *	@param	InEventName		The name of the event that fired.
	 *	@param	InEmitterTime	The emitter time when the event fired.
	 *	@param	InLocation		The location of the particle when the event fired.
	 *	@param	InDirection		The direction of the particle when the event fired.
	 *	@param	InVelocity		The velocity of the particle when the event fired.
	 *	@param	InParticleTime	The relative life of the particle when the event fired.
	 *	@param	InNormal		Normal vector of the collision in coordinate system of the returner. Zero=none.
	 *	@param	InTime			Time until hit, if line check.
	 *	@param	InItem			Primitive data item which was hit, INDEX_NONE=none.
	 *	@param	InBoneName		Name of bone we hit (for skeletal meshes).
	 */
	void ReportEventAttractorCollision(FName& InEventName, FLOAT InEmitterTime, FVector& InLocation, 
		FVector& InDirection, FVector& InVelocity, FLOAT InParticleTime, FVector& InNormal, 
		FLOAT InTime, INT InItem, FName& InBoneName);
	/** 
	 *	Record a kismet event.
	 *
	 *	@param	InEventName				The name of the event that fired.
	 *	@param	InEmitterTime			The emitter time when the event fired.
	 *	@param	InLocation				The location of the particle when the event fired.
	 *	@param	InVelocity				The velocity of the particle when the event fired.
	 *	@param	bInUsePSysCompLocation	If TRUE, use the particle system component location as spawn location.
	 *	@param	InNormal				Normal vector of the collision in coordinate system of the returner. Zero=none.
	 */
	void ReportEventKismet(FName& InEventName, FLOAT InEmitterTime, FVector& InLocation, 
		FVector& InDirection, FVector& InVelocity, UBOOL bInUsePSysCompLocation, FVector& InNormal);


	/**
	 * Finds the replay clip of the specified ID number
	 *
	 * @return Returns the replay clip or NULL if none
	 */
	UParticleSystemReplay* FindReplayClipForIDNumber( const INT InClipIDNumber );

	/**
	 * Called by AnimNotify_Trails
	 *
	 * @param AnimNotifyData The AnimNotify_Trails which will have all of the various params on it
	 */
	void TrailsNotify(const UAnimNotify_Trails* AnimNotifyData);

	/**
	 * Called by AnimNotify_Trails
	 *
	 * @param AnimNotifyData The AnimNotify_Trails which will have all of the various params on it
	 */
	void TrailsNotifyTick(const UAnimNotify_Trails* AnimNotifyData);

	/**
	 * Called by AnimNotify_Trails
	 *
	 * @param AnimNotifyData The AnimNotify_Trails which will have all of the various params on it
	 */
	void TrailsNotifyEnd(const UAnimNotify_Trails* AnimNotifyData);
};

class UDistributionFloatParticleParameter : public UDistributionFloatParameterBase
{
public:
    //## BEGIN PROPS DistributionFloatParticleParameter
    //## END PROPS DistributionFloatParticleParameter

    DECLARE_CLASS(UDistributionFloatParticleParameter,UDistributionFloatParameterBase,0,Engine)
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FLOAT& OutFloat);
};

class UDistributionVectorParticleParameter : public UDistributionVectorParameterBase
{
public:
    //## BEGIN PROPS DistributionVectorParticleParameter
    //## END PROPS DistributionVectorParticleParameter

    DECLARE_CLASS(UDistributionVectorParticleParameter,UDistributionVectorParameterBase,0,Engine)
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FVector& OutVector);
};

class UParticleLODLevel : public UObject
{
public:
    //## BEGIN PROPS ParticleLODLevel
    INT Level;
    BITFIELD bEnabled:1;
    BITFIELD ConvertedModules:1;
    class UParticleModuleRequired* RequiredModule;
    TArrayNoInit<class UParticleModule*> Modules;
    class UParticleModule* TypeDataModule;
    class UParticleModuleSpawn* SpawnModule;
    class UParticleModuleEventGenerator* EventGenerator;
    TArrayNoInit<class UParticleModuleSpawnBase*> SpawningModules;
    TArrayNoInit<class UParticleModule*> SpawnModules;
    TArrayNoInit<class UParticleModule*> UpdateModules;
    TArrayNoInit<class UParticleModuleOrbit*> OrbitModules;
    TArrayNoInit<class UParticleModuleEventReceiverBase*> EventReceiverModules;
    INT PeakActiveParticles;
    //## END PROPS ParticleLODLevel

    DECLARE_CLASS(UParticleLODLevel,UObject,0,Engine)
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual void	PostLoad();
	virtual void	UpdateModuleLists();

	virtual UBOOL	GenerateFromLODLevel(UParticleLODLevel* SourceLODLevel, FLOAT Percentage, UBOOL bGenerateModuleData = TRUE);

	/**
	 *	CalculateMaxActiveParticleCount
	 *	Determine the maximum active particles that could occur with this emitter.
	 *	This is to avoid reallocation during the life of the emitter.
	 *
	 *	@return		The maximum active particle count for the LOD level.
	 */
	virtual INT	CalculateMaxActiveParticleCount();

	/**
	 *	Update to the new SpawnModule method
	 */
	void	ConvertToSpawnModule();
		
	/**
	 *	Return the index of the given module if it is contained in the LOD level
	 */
	INT		GetModuleIndex(UParticleModule* InModule);

	/**
	 *	Return the module at the given index if it is contained in the LOD level
	 */
	UParticleModule* GetModuleAtIndex(INT InIndex);

	/**
	 *	Sets the LOD 'Level' to the given value, properly updating the modules LOD validity settings.
	 */
	virtual void	SetLevelIndex(INT InLevelIndex);

	// For Cascade
	void	AddCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	void	RemoveCurvesFromEditor(UInterpCurveEdSetup* EdSetup);
	void	ChangeEditorColor(FColor& Color, UInterpCurveEdSetup* EdSetup);
	/**
	 *	Return TRUE if the given module is editable for this LOD level.
	 *	
	 *	@param	InModule	The module of interest.
	 *	@return	TRUE		If it is editable for this LOD level.
	 *			FALSE		If it is not.
	 */
	UBOOL	IsModuleEditable(UParticleModule* InModule);

};

struct FParticleBurst
{
    INT Count;
    INT CountLow;
    FLOAT Time;

    /** Constructors */
    FParticleBurst() {}
    FParticleBurst(EEventParm)
    {
        appMemzero(this, sizeof(FParticleBurst));
    }
};

class UParticleEmitter : public UObject
{
public:
    //## BEGIN PROPS ParticleEmitter
    FName EmitterName;
    INT SubUVDataOffset;
    BYTE EmitterRenderMode;
    SCRIPT_ALIGN;
#if WITH_EDITORONLY_DATA
    FColor EmitterEditorColor;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<class UParticleLODLevel*> LODLevels;
    BITFIELD ConvertedModules:1;
    BITFIELD bCollapsed:1;
    BITFIELD bIsSoloing:1;
    BITFIELD bCookedOut:1;
    INT PeakActiveParticles;
    INT InitialAllocationCount;
    FLOAT MediumDetailSpawnRateScale;
    //## END PROPS ParticleEmitter

    virtual FLOAT GetMaxLifespan(FLOAT InComponentDelay);
    DECLARE_FUNCTION(execGetMaxLifespan)
    {
        P_GET_FLOAT(InComponentDelay);
        P_FINISH;
        *(FLOAT*)Result=this->GetMaxLifespan(InComponentDelay);
    }
    DECLARE_ABSTRACT_CLASS(UParticleEmitter,UObject,0,Engine)
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual FParticleEmitterInstance* CreateInstance(UParticleSystemComponent* InComponent);

	virtual void SetToSensibleDefaults() {}

	virtual void PostLoad();
	virtual void UpdateModuleLists();

	void SetEmitterName(FName Name);
	FName& GetEmitterName();
	virtual	void						SetLODCount(INT LODCount);

	// For Cascade
	void	AddEmitterCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	void	RemoveEmitterCurvesFromEditor(UInterpCurveEdSetup* EdSetup);
	void	ChangeEditorColor(FColor& Color, UInterpCurveEdSetup* EdSetup);

	void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	// LOD
	INT					CreateLODLevel(INT LODLevel, UBOOL bGenerateModuleData = TRUE);
	UBOOL				IsLODLevelValid(INT LODLevel);

	/** GetCurrentLODLevel
	*	Returns the currently set LODLevel. Intended for game-time usage.
	*	Assumes that the given LODLevel will be in the [0..# LOD levels] range.
	*	
	*	@return NULL if the requested LODLevel is not valid.
	*			The pointer to the requested UParticleLODLevel if valid.
	*/
	FORCEINLINE UParticleLODLevel* GetCurrentLODLevel(FParticleEmitterInstance* Instance)
	{
#if CONSOLE
		return Instance->CurrentLODLevel;
#else
		// for the game (where we care about perf) we don't branch
		if (GIsGame == TRUE)
		{
			return Instance->CurrentLODLevel;
		}
		else
		{
			EditorUpdateCurrentLOD( Instance );
			return Instance->CurrentLODLevel;
		}
#endif // if CONSOLE
	}

	void EditorUpdateCurrentLOD(FParticleEmitterInstance* Instance);

	UParticleLODLevel*	GetLODLevel(INT LODLevel);
	
	virtual UBOOL		AutogenerateLowestLODLevel(UBOOL bDuplicateHighest = FALSE);
	
	/**
	 *	CalculateMaxActiveParticleCount
	 *	Determine the maximum active particles that could occur with this emitter.
	 *	This is to avoid reallocation during the life of the emitter.
	 *
	 *	@return	TRUE	if the number was determined
	 *			FALSE	if the number could not be determined
	 */
	virtual UBOOL		CalculateMaxActiveParticleCount();

	/**
	 *	Retrieve the parameters associated with this particle system.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams used in the system
	 *	@param	ParticleParameterList	The list of ParticleParameter distributions used in the system
	 */
	void GetParametersUtilized(TArray<FString>& ParticleSysParamList,
							   TArray<FString>& ParticleParameterList);
};

class UParticleSpriteEmitter : public UParticleEmitter
{
public:
    //## BEGIN PROPS ParticleSpriteEmitter
    //## END PROPS ParticleSpriteEmitter

    DECLARE_CLASS(UParticleSpriteEmitter,UParticleEmitter,0,Engine)
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual FParticleEmitterInstance* CreateInstance(UParticleSystemComponent* InComponent);
	virtual void SetToSensibleDefaults();
};

struct FParticleCurvePair
{
    FString CurveName;
    class UObject* CurveObject;

    /** Constructors */
    FParticleCurvePair()
    : CurveObject(NULL)
    {}
    FParticleCurvePair(EEventParm)
    {
        appMemzero(this, sizeof(FParticleCurvePair));
    }
};

struct FParticleRandomSeedInfo
{
    FName ParameterName;
    BITFIELD bGetSeedFromInstance:1;
    BITFIELD bInstanceSeedIsIndex:1;
    BITFIELD bResetSeedOnEmitterLooping:1;
    TArrayNoInit<INT> RandomSeeds;

		FORCEINLINE INT GetInstancePayloadSize() const
		{
			return ((RandomSeeds.Num() > 0) ? sizeof(FParticleRandomSeedInstancePayload) : 0);
		}
	
};

class UParticleModule : public UObject
{
public:
    //## BEGIN PROPS ParticleModule
    BITFIELD bSpawnModule:1;
    BITFIELD bUpdateModule:1;
    BITFIELD bFinalUpdateModule:1;
    BITFIELD bCurvesAsColor:1;
    BITFIELD b3DDrawMode:1;
    BITFIELD bSupported3DDrawMode:1;
    BITFIELD bEnabled:1;
    BITFIELD bEditable:1;
    BITFIELD LODDuplicate:1;
    BITFIELD bSupportsRandomSeed:1;
    BITFIELD bRequiresLoopingNotification:1;
    SCRIPT_ALIGN;
    BYTE LODValidity;
    SCRIPT_ALIGN;
#if WITH_EDITORONLY_DATA
    FColor ModuleEditorColor;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS ParticleModule

    DECLARE_ABSTRACT_CLASS(UParticleModule,UObject,0,Engine)
	virtual void	PostLoad();

	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called on an emitter when all other update operations have taken place
	 *	INCLUDING bounding box cacluations!
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	FinalUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	// For Cascade
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	
	/** 
	 *	Fill an array with each Object property that fulfills the FCurveEdInterface interface.
	 *
	 *	@param	OutCurve	The array that should be filled in.
	 */
	virtual void	GetCurveObjects(TArray<FParticleCurvePair>& OutCurves);
	/** 
	 *	Add all curve-editable Objects within this module to the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to use for adding curved.
	 */
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	/** 
	 *	Remove all curve-editable Objects within this module from the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to remove the curve from.
	 */
	void	RemoveModuleCurvesFromEditor(UInterpCurveEdSetup* EdSetup);
	/** 
	 *	Does the module contain curves?
	 *
	 *	@return	UBOOL		TRUE if it does, FALSE if not.
	 */
	UBOOL	ModuleHasCurves();
	/** 
	 *	Are the modules curves displayed in the curve editor?
	 *
	 *	@param	EdSetup		The CurveEd setup to check.
	 *
	 *	@return	UBOOL		TRUE if they are, FALSE if not.
	 */
	UBOOL	IsDisplayedInCurveEd(UInterpCurveEdSetup* EdSetup);
	/** 
	 *	Helper function for updating the curve editor when the module editor color changes.
	 *
	 *	@param	Color		The new color the module is using.
	 *	@param	EdSetup		The CurveEd setup for the module.
	 */
	void	ChangeEditorColor(FColor& Color, UInterpCurveEdSetup* EdSetup);

	/** 
	 *	Render the modules 3D visualization helper primitive.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the module.
	 *	@param	View		The scene view that is being rendered.
	 *	@param	PDI			The FPrimitiveDrawInterface to use for rendering.
	 */
	virtual void Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI)	{};

	/**
	 *	Retrieve the ModuleType of this module.
	 *
	 *	@return	EModuleType		The type of module this is.
	 */
	virtual EModuleType	GetModuleType() const	{	return EPMT_General;	}

	/**
	 *	Helper function used by the editor to auto-populate a placed AEmitter with any
	 *	instance parameters that are utilized.
	 *
	 *	@param	PSysComp		The particle system component to be populated.
	 */
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);
	
	/**
	 *	Helper function used by the editor to auto-generate LOD values from a source module
	 *	and a percentage value used to scale its values.
	 *
	 *	@param	SourceModule	The ParticleModule to utilize as the template.
	 *	@param	Percentage		The value to use when scaling the source values.
	 */
	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);

	/**
	 *	Conversion functions for distributions.
	 *	Used to setup new distributions to a percentage value of the source.
	 */
	/**
	 *	Store the given percentage of the SourceFloat distribution in the FloatDist
	 *
	 *	@param	FloatDist			The distribution to put the result into.
	 *	@param	SourceFloatDist		The distribution of use as the source.
	 *	@param	Percentage			The percentage of the source value to use [0..100]
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not.
	 */
	virtual UBOOL	ConvertFloatDistribution(UDistributionFloat* FloatDist, UDistributionFloat* SourceFloatDist, FLOAT Percentage);
	/**
	 *	Store the given percentage of the SourceVector distribution in the VectorDist
	 *
	 *	@param	VectorDist			The distribution to put the result into.
	 *	@param	SourceVectorDist	The distribution of use as the source.
	 *	@param	Percentage			The percentage of the source value to use [0..100]
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not.
	 */
	virtual UBOOL	ConvertVectorDistribution(UDistributionVector* VectorDist, UDistributionVector* SourceVectorDist, FLOAT Percentage);
	/**
	 *	Returns whether the module is SizeMultipleLife or not.
	 *
	 *	@return	UBOOL	TRUE if the module is a UParticleModuleSizeMultipleLife
	 *					FALSE if not
	 */
	virtual UBOOL   IsSizeMultiplyLife() { return FALSE; };

	/**
	 *	Returns whether the module supports the RandomSeed functionality
	 *
	 *	@return	UBOOL	TRUE if it supports it; FALSE if not
	 */
	UBOOL SupportsRandomSeed() const
	{
		return bSupportsRandomSeed;
	}

	/**
	 *	Returns whether the module requires notification when an emitter loops.
	 *
	 *	@return	UBOOL	TRUE if the module required looping notification
	 */
	UBOOL RequiresLoopingNotification() const
	{
		return bRequiresLoopingNotification;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner					The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner)
	{
	}

	/**
	 *	Comparison routine...
	 *	Intended for editor-use only, this function will return TRUE if the given
	 *	particle module settings are identical to the one the function is called on.
	 *
	 *	@param	InModule	The module to compare against.
	 *
	 *	@return	TRUE		If the modules have all the relevant settings the same.
	 *			FALSE		If they don't.
	 */
	virtual UBOOL	IsIdentical_Deprecated(const UParticleModule* InModule) const;

	/**
	 *	Used by the comparison routine to check for properties that are irrelevant.
	 *
	 *	@param	InPropName	The name of the property being checked.
	 *
	 *	@return	TRUE		If the property is relevant.
	 *			FALSE		If it isn't.
	 */
	virtual UBOOL	PropertyIsRelevantForIsIdentical_Deprecated(const FName& InPropName) const;

	/**
	 *	Generates a new module for LOD levels, setting the values appropriately.
	 *	Note that the module returned could simply be the module it was called on.
	 *
	 *	@param	SourceLODLevel		The source LODLevel
	 *	@param	DestLODLevel		The destination LODLevel
	 *	@param	Percentage			The percentage value that should be used when setting values
	 *
	 *	@return	UParticleModule*	The generated module, or this if percentage == 100.
	 */
	virtual UParticleModule* GenerateLODModule(UParticleLODLevel* SourceLODLevel, UParticleLODLevel* DestLODLevel, FLOAT Percentage, 
		UBOOL bGenerateModuleData, UBOOL bForceModuleConstruction = FALSE);

	/**
	 *	Returns TRUE if the results of LOD generation for the given percentage will result in a 
	 *	duplicate of the module.
	 *
	 *	@param	SourceLODLevel		The source LODLevel
	 *	@param	DestLODLevel		The destination LODLevel
	 *	@param	Percentage			The percentage value that should be used when setting values
	 *
	 *	@return	UBOOL				TRUE if the generated module will be a duplicate.
	 *								FALSE if not.
	 */
	virtual UBOOL WillGeneratedModuleBeIdentical(UParticleLODLevel* SourceLODLevel, UParticleLODLevel* DestLODLevel, FLOAT Percentage)
	{
		// The assumption is that at 100%, ANY module will be identical...
		// (Although this is virtual to allow over-riding that assumption on a case-by-case basis!)

		if (Percentage != 100.0f)
		{
			return LODDuplicate;
		}

		return TRUE;
	}

	/**
	 *	Returns TRUE if the module validiy flags indicate this module is used in the given LOD level.
	 *
	 *	@param	SourceLODIndex		The index of the source LODLevel
	 *
	 *	@return	UBOOL				TRUE if the generated module is used, FALSE if not.
	 */
	virtual UBOOL IsUsedInLODLevel(INT SourceLODIndex) const;

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);

	/**
	 *	Retrieve the distributions that use ParticleParameters in this module.
	 *
	 *	@param	ParticleParameterList	The list of ParticleParameter distributions to add to
	 */
	virtual void GetParticleParametersUtilized(TArray<FString>& ParticleParameterList);
	
	/**
	 *	Refresh the module...
	 */
	virtual void RefreshModule(UInterpCurveEdSetup* EdSetup, UParticleEmitter* InEmitter, INT InLODLevel) {}

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return FALSE; }

	/** 
	 *	Prepare a random seed instance payload...
	 *
	 *	@param	Owner					The emitter instance that owns this module
	 *	@param	InRandSeedPayload		The random seed instance payload to initialize
	 *	@param	InRandSeedInfo			The random seed info of the module
	 *
	 *	@return	UINT					0xffffffff is failed
	 */
	virtual UINT	PrepRandomSeedInstancePayload(FParticleEmitterInstance* Owner, FParticleRandomSeedInstancePayload* InRandSeedPayload, const FParticleRandomSeedInfo& InRandSeedInfo);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return NULL;
	}

	/**
	 *	Set the random seed info entry at the given index to the given seed
	 *
	 *	@param	InIndex			The index of the entry to set
	 *	@param	InRandomSeed	The seed to set the entry to
	 *
	 *	@return	UBOOL			TRUE if successful; FALSE if not (not found, etc.)
	 */
	virtual UBOOL SetRandomSeedEntry(INT InIndex, INT InRandomSeed);

#if WITH_EDITOR
	/**
	 *	Custom Cascade module menu entries support
	 */
	/**
	 *	Get the number of custom entries this module has. Maximum of 3.
	 *
	 *	@return	INT		The number of custom menu entries
	 */
	virtual INT GetNumberOfCustomMenuOptions() const { return 0; }

	/**
	 *	Get the display name of the custom menu entry.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2)
	 *	@param	OutDisplayString	The string to display for the menu
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL GetCustomMenuEntryDisplayString(INT InEntryIndex, FString& OutDisplayString) const { return FALSE; }

	/**
	 *	Perform the custom menu entry option.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2) to perform
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL PerformCustomMenuEntry(INT InEntryIndex) { return FALSE; }
#endif
};

class UParticleModuleAccelerationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleAccelerationBase
    BITFIELD bAlwaysInWorldSpace:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleAccelerationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleAccelerationBase,UParticleModule,0,Engine)
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleAcceleration : public UParticleModuleAccelerationBase
{
public:
    //## BEGIN PROPS ParticleModuleAcceleration
    struct FRawDistributionVector Acceleration;
    BITFIELD bApplyOwnerScale:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleAcceleration

    DECLARE_CLASS(UParticleModuleAcceleration,UParticleModuleAccelerationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleAccelerationOverLifetime : public UParticleModuleAccelerationBase
{
public:
    //## BEGIN PROPS ParticleModuleAccelerationOverLifetime
    struct FRawDistributionVector AccelOverLife;
    //## END PROPS ParticleModuleAccelerationOverLifetime

    DECLARE_CLASS(UParticleModuleAccelerationOverLifetime,UParticleModuleAccelerationBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleAttractorBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleAttractorBase
    //## END PROPS ParticleModuleAttractorBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleAttractorBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleAttractorBase)
};

struct FAttractLocationBoneSocketInfo
{
    FName BoneSocketName;
    FVector Offset;

    /** Constructors */
    FAttractLocationBoneSocketInfo() {}
    FAttractLocationBoneSocketInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAttractLocationBoneSocketInfo));
    }
};

class UParticleModuleAttractorBoneSocket : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorBoneSocket
    BYTE FalloffType;
    BYTE DestinationType;
    BYTE SelectionMethod;
    SCRIPT_ALIGN;
    BITFIELD bParticleLifeRelative:1;
    BITFIELD bAttractAlongLengthOfBone:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat FalloffExponent;
    struct FRawDistributionFloat Range;
    struct FRawDistributionFloat Strength;
    struct FRawDistributionFloat CollisionRadius;
    struct FRawDistributionFloat DragCoefficient;
    struct FRawDistributionFloat DragRadius;
    FVector UniversalOffset;
    TArrayNoInit<struct FAttractLocationBoneSocketInfo> SourceLocations;
    FName SkelMeshActorParamName;
#if WITH_EDITORONLY_DATA
    class USkeletalMesh* EditorSkelMesh;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS ParticleModuleAttractorBoneSocket

    DECLARE_CLASS(UParticleModuleAttractorBoneSocket,UParticleModuleAttractorBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Called on an emitter when all other update operations have taken place
	 *	INCLUDING bounding box cacluations!
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	FinalUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Helper function used by the editor to auto-populate a placed AEmitter with any
	 *	instance parameters that are utilized.
	 *
	 *	@param	PSysComp		The particle system component to be populated.
	 */
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

#if WITH_EDITOR
	/**
	 *	Get the number of custom entries this module has. Maximum of 3.
	 *
	 *	@return	INT		The number of custom menu entries
	 */
	virtual INT GetNumberOfCustomMenuOptions() const;

	/**
	 *	Get the display name of the custom menu entry.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2)
	 *	@param	OutDisplayString	The string to display for the menu
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL GetCustomMenuEntryDisplayString(INT InEntryIndex, FString& OutDisplayString) const;

	/**
	 *	Perform the custom menu entry option.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2) to perform
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL PerformCustomMenuEntry(INT InEntryIndex);
#endif

	/**
	 *	Retrieve the velocity and position for the given particle/socket combination.
	 *
	 *	@param	Owner					The particle emitter instance that is being setup
	 *	@param	InSkelMeshComponent		The skeletal mesh component to use as the source
	 *	@param	InBoneSocketIndex		The index of the bone/socket of interest
	 *  @param  InCurrentLocation		The current location of the particle
	 *  @param  InCurrentTime			The current time (either particle or emitter depending on module settings)
	 *  @param  InBoneLerpAlpha			The alpha value to lerp between the ends of a bone when bAttractAlongLengthOfBone is TRUE
	 *	@param	OutVelocityToAdd		The velocity to add for this particle
	 *	@param	OutDestinationLocation	Location of the bone or socket attracting the particle
	 *	
	 *	@return	UBOOL					TRUE if successful, FALSE if not
	 */
	UBOOL GetVelocityForAttraction(FParticleEmitterInstance* Owner, USkeletalMeshComponent* InSkelMeshComponent, INT InBoneSocketIndex,
		FVector& InCurrentLocation, FLOAT InCurrentTime, FLOAT InBoneLerpAlpha, FVector& OutVelocityToAdd, FVector& OutDestinationLocation);
};

class UParticleModuleAttractorLine : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorLine
    FVector EndPoint0;
    FVector EndPoint1;
    struct FRawDistributionFloat Range;
    struct FRawDistributionFloat Strength;
    //## END PROPS ParticleModuleAttractorLine

    DECLARE_CLASS(UParticleModuleAttractorLine,UParticleModuleAttractorBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleAttractorParticle : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorParticle
    FName EmitterName;
    struct FRawDistributionFloat Range;
    BITFIELD bStrengthByDistance:1;
    BITFIELD bAffectBaseVelocity:1;
    BITFIELD bRenewSource:1;
    BITFIELD bInheritSourceVel:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat Strength;
    BYTE SelectionMethod;
    INT LastSelIndex;
    //## END PROPS ParticleModuleAttractorParticle

    DECLARE_CLASS(UParticleModuleAttractorParticle,UParticleModuleAttractorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleAttractorPoint : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorPoint
    struct FRawDistributionVector Position;
    struct FRawDistributionFloat Range;
    struct FRawDistributionFloat Strength;
    BITFIELD StrengthByDistance:1;
    BITFIELD bAffectBaseVelocity:1;
    BITFIELD bOverrideVelocity:1;
    BITFIELD bUseWorldSpacePosition:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleAttractorPoint

    DECLARE_CLASS(UParticleModuleAttractorPoint,UParticleModuleAttractorBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleAttractorSkelVertSurface : public UParticleModuleAttractorBase
{
public:
    //## BEGIN PROPS ParticleModuleAttractorSkelVertSurface
    BYTE FalloffType;
    BYTE DestinationType;
    SCRIPT_ALIGN;
    BITFIELD bParticleLifeRelative:1;
    BITFIELD bEnforceNormalCheck:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat FalloffExponent;
    struct FRawDistributionFloat Range;
    struct FRawDistributionFloat Strength;
    struct FRawDistributionFloat CollisionRadius;
    struct FRawDistributionFloat DragCoefficient;
    struct FRawDistributionFloat DragRadius;
    FVector UniversalOffset;
    FName SkelMeshActorParamName;
#if WITH_EDITORONLY_DATA
    class USkeletalMesh* EditorSkelMesh;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<FName> ValidAssociatedBones;
    FVector NormalToCompare;
    FLOAT NormalCheckToleranceDegrees;
    FLOAT NormalCheckTolerance;
    TArrayNoInit<INT> ValidMaterialIndices;
    //## END PROPS ParticleModuleAttractorSkelVertSurface

    DECLARE_CLASS(UParticleModuleAttractorSkelVertSurface,UParticleModuleAttractorBase,0,Engine)
	/**
	 *	Called after loading the module.
	 */
	virtual void PostLoad();

	/**
	 *	Called when a property has change on an instance of the module.
	 *
	 *	@param	PropertyChangedEvent		Information on the change that occurred.
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return TRUE; }

	/**
	 *	Helper function used by the editor to auto-populate a placed AEmitter with any
	 *	instance parameters that are utilized.
	 *
	 *	@param	PSysComp		The particle system component to be populated.
	 */
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

#if WITH_EDITOR
	/**
	 *	Get the number of custom entries this module has. Maximum of 3.
	 *
	 *	@return	INT		The number of custom menu entries
	 */
	virtual INT GetNumberOfCustomMenuOptions() const;

	/**
	 *	Get the display name of the custom menu entry.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2)
	 *	@param	OutDisplayString	The string to display for the menu
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL GetCustomMenuEntryDisplayString(INT InEntryIndex, FString& OutDisplayString) const;

	/**
	 *	Perform the custom menu entry option.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2) to perform
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL PerformCustomMenuEntry(INT InEntryIndex);
#endif

	/**
	 *	Retrieve the velocity and position for the given particle/socket combination.
	 *
	 *	@param	Owner					The particle emitter instance that is being setup
	 *	@param	InSkelMeshComponent		The skeletal mesh component to use as the source
	 *	@param	InPrimaryVertexIndex	The index of the primary vertice
	 *  @param  InCurrentLocation		The current location of the particle
	 *  @param  InCurrentTime			The current time (either particle or emitter depending on module settings)
	 *	@param	OutVelocityToAdd		The velocity to add for this particle
	 *	@param	OutDestinationLocation	Location of the bone or socket attracting the particle
	 *	
	 *	@return	UBOOL					TRUE if successful, FALSE if not
	 */
	UBOOL GetVelocityForAttraction(FParticleEmitterInstance* Owner, USkeletalMeshComponent* InSkelMeshComponent, INT InPrimaryVertexIndex,
		FVector& InCurrentLocation, FLOAT InCurrentTime, FVector& OutVelocityToAdd, FVector& OutDestinationLocation);
};

class UParticleModuleBeamBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleBeamBase
    //## END PROPS ParticleModuleBeamBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleBeamBase,UParticleModule,0,Engine)
	virtual EModuleType	GetModuleType() const	{	return EPMT_Beam;	}
};

struct FBeamModifierOptions
{
    BITFIELD bModify:1;
    BITFIELD bScale:1;
    BITFIELD bLock:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FBeamModifierOptions() {}
    FBeamModifierOptions(EEventParm)
    {
        appMemzero(this, sizeof(FBeamModifierOptions));
    }
};

class UParticleModuleBeamModifier : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamModifier
    BYTE ModifierType;
    SCRIPT_ALIGN;
    struct FBeamModifierOptions PositionOptions;
    struct FRawDistributionVector Position;
    struct FBeamModifierOptions TangentOptions;
    struct FRawDistributionVector Tangent;
    BITFIELD bAbsoluteTangent:1;
    SCRIPT_ALIGN;
    struct FBeamModifierOptions StrengthOptions;
    struct FRawDistributionFloat Strength;
    //## END PROPS ParticleModuleBeamModifier

    DECLARE_CLASS(UParticleModuleBeamModifier,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	/** 
	 *	Fill an array with each Object property that fulfills the FCurveEdInterface interface.
	 *
	 *	@param	OutCurve	The array that should be filled in.
	 */
	virtual void	GetCurveObjects(TArray<FParticleCurvePair>& OutCurves);
	
	/** 
	 *	Add all curve-editable Objects within this module to the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to use for adding curved.
	 */
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);


			void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, FBeam2TypeDataPayload*& BeamDataPayload, 
						FBeamParticleModifierPayloadData*& SourceModifierPayload,
						FBeamParticleModifierPayloadData*& TargetModifierPayload);
			void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT& BeamDataOffset, INT& SourceModifierOffset, 
						INT& TargetModifierOffset);

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleBeamNoise : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamNoise
    BITFIELD bLowFreq_Enabled:1;
    BITFIELD bNRScaleEmitterTime:1;
    BITFIELD bSmooth:1;
    BITFIELD bNoiseLock:1;
    BITFIELD bOscillate:1;
    BITFIELD bUseNoiseTangents:1;
    BITFIELD bTargetNoise:1;
    BITFIELD bApplyNoiseScale:1;
    INT Frequency;
    INT Frequency_LowRange;
    struct FRawDistributionVector NoiseRange;
    struct FRawDistributionFloat NoiseRangeScale;
    struct FRawDistributionVector NoiseSpeed;
    FLOAT NoiseLockRadius;
    FLOAT NoiseLockTime;
    FLOAT NoiseTension;
    struct FRawDistributionFloat NoiseTangentStrength;
    INT NoiseTessellation;
    FLOAT FrequencyDistance;
    struct FRawDistributionFloat NoiseScale;
    //## END PROPS ParticleModuleBeamNoise

    DECLARE_CLASS(UParticleModuleBeamNoise,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	SetToSensibleDefaults(UParticleEmitter* Owner);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
			void	GetNoiseRange(FVector& NoiseMin, FVector& NoiseMax);
};

class UParticleModuleBeamSource : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamSource
    BYTE SourceMethod;
    BYTE SourceTangentMethod;
    FName SourceName;
    BITFIELD bSourceAbsolute:1;
    BITFIELD bLockSource:1;
    BITFIELD bLockSourceTangent:1;
    BITFIELD bLockSourceStength:1;
    SCRIPT_ALIGN;
    struct FRawDistributionVector Source;
    struct FRawDistributionVector SourceTangent;
    struct FRawDistributionFloat SourceStrength;
    //## END PROPS ParticleModuleBeamSource

    DECLARE_CLASS(UParticleModuleBeamSource,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

			void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, 
						FBeamParticleSourceTargetPayloadData*& ParticleSource,
						FBeamParticleSourceBranchPayloadData*& BranchSource);
			void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT& ParticleSourceOffset, INT& BranchSourceOffset);
						
			UBOOL	ResolveSourceData(FParticleBeam2EmitterInstance* BeamInst, 
						FBeam2TypeDataPayload* BeamData, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT	ParticleIndex, UBOOL bSpawning,
						FBeamParticleModifierPayloadData* ModifierData);
	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleBeamTarget : public UParticleModuleBeamBase
{
public:
    //## BEGIN PROPS ParticleModuleBeamTarget
    BYTE TargetMethod;
    BYTE TargetTangentMethod;
    FName TargetName;
    struct FRawDistributionVector Target;
    BITFIELD bTargetAbsolute:1;
    BITFIELD bLockTarget:1;
    BITFIELD bLockTargetTangent:1;
    BITFIELD bLockTargetStength:1;
    SCRIPT_ALIGN;
    struct FRawDistributionVector TargetTangent;
    struct FRawDistributionFloat TargetStrength;
    FLOAT LockRadius;
    //## END PROPS ParticleModuleBeamTarget

    DECLARE_CLASS(UParticleModuleBeamTarget,UParticleModuleBeamBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

			void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
						INT& CurrentOffset, 
						FBeamParticleSourceTargetPayloadData*& ParticleSource);
						
			UBOOL	ResolveTargetData(FParticleBeam2EmitterInstance* BeamInst, 
						FBeam2TypeDataPayload* BeamData, const BYTE* ParticleBase, 
						INT& CurrentOffset, INT	ParticleIndex, UBOOL bSpawning,
						FBeamParticleModifierPayloadData* ModifierData);

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleCameraBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleCameraBase
    //## END PROPS ParticleModuleCameraBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleCameraBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleCameraBase)
};

class UParticleModuleCameraOffset : public UParticleModuleCameraBase
{
public:
    //## BEGIN PROPS ParticleModuleCameraOffset
    struct FRawDistributionFloat CameraOffset;
    BITFIELD bSpawnTimeOnly:1;
    SCRIPT_ALIGN;
    BYTE UpdateMethod;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleCameraOffset

    DECLARE_CLASS(UParticleModuleCameraOffset,UParticleModuleCameraBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleCollisionBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleCollisionBase
    //## END PROPS ParticleModuleCollisionBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleCollisionBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleCollisionBase)
};

struct FParticleAttractorCollisionAction
{
    BYTE Type;
    FStringNoInit EventName;

    /** Constructors */
    FParticleAttractorCollisionAction() {}
    FParticleAttractorCollisionAction(EEventParm)
    {
        appMemzero(this, sizeof(FParticleAttractorCollisionAction));
    }
};

class UParticleModuleCollision : public UParticleModuleCollisionBase
{
public:
    //## BEGIN PROPS ParticleModuleCollision
    struct FRawDistributionVector DampingFactor;
    struct FRawDistributionVector DampingFactorRotation;
    struct FRawDistributionFloat MaxCollisions;
    BYTE CollisionCompletionOption;
    SCRIPT_ALIGN;
    BITFIELD bApplyPhysics:1;
    BITFIELD bPawnsDoNotDecrementCount:1;
    BITFIELD bOnlyVerticalNormalsDecrementCount:1;
    BITFIELD bDropDetail:1;
    BITFIELD bCollideOnlyIfVisible:1;
    BITFIELD bCollideWithWorld:1;
    BITFIELD bCollideWithWorldAttractors:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat ParticleMass;
    FLOAT DirScalar;
    FLOAT VerticalFudgeFactor;
    struct FRawDistributionFloat DelayAmount;
    FLOAT MaxCollisionDistance;
    TArrayNoInit<struct FParticleAttractorCollisionAction> ParticleAttractorCollisionActions;
    //## END PROPS ParticleModuleCollision

    DECLARE_CLASS(UParticleModuleCollision,UParticleModuleCollisionBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	
	virtual UBOOL GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);

	/**
	 *	Perform the desired collision check for this module.
	 *	
	 *	@param	Owner			The emitter instance that owns the particle being checked
	 *	@param	InParticle		The particle being checked for a collision
	 *	@param	Hit				The hit results to fill in for a collision
	 *	@param	SourceActor		The source actor for the check
	 *	@param	End				The end position for the check
	 *	@param	Start			The start position for the check
	 *	@param	TraceFlags		The trace flags to use for the check
	 *	@param	Extent			The extent to use for the check
	 *	
	 *	@return UBOOL			TRUE if a collision occurred.
	 */
	virtual UBOOL PerformCollisionCheck(FParticleEmitterInstance* Owner, FBaseParticle* InParticle, 
		FCheckResult& Hit, AActor* SourceActor, const FVector& End, const FVector& Start, DWORD TraceFlags, const FVector& Extent);

	/**
	 *  Kills, freezes, or triggers an event based on the list of collision actions.
	 *  @param ParticleEmitter Used to retrieve the particle.
	 *  @param ParticleIndex Needed to retrieve the current particle and to kill particles.
	 *  @param EventPayload Needed to pass off to the EventGenerator.  (Only used if an event is in the list of actions)
	 *  @param CollisionPayload Needed to populate the collision event fields.  (Only used if an event is in the list of actions)
	 *  @param Hit The collision information which gets passed off to the EventGenerator.
	 *  @param Direction The direction of the particle at collision time which gets passed off to the EventGenerator.
	 *  @returns TRUE if any particle has been effected.
	 */
	UBOOL HandleParticleCollision(FParticleEmitterInstance* ParticleEmitter, INT ParticleIndex, FParticleEventInstancePayload* EventPayload, FParticleCollisionPayload* CollisionPayload, FCheckResult& Hit, FVector& Direction);

	/**
	 *  Determines if the given position is in collision with an attractor and if so it returns
	 *  the hit result through the first parameter.
	 *  @param Hit The returned result of the check.
	 *  @param ParticlePosition The position to check against the attractor locations for collision.
	 *  @param Attractors An array of all the WorldAttractors to check against.
	 *  @return TRUE if there was a collision.
	 */
	UBOOL WorldAttractorCheck(FCheckResult& Hit, const FVector& ParticlePosition, TArray<AWorldAttractor*>& Attractors);
};

class UParticleModuleCollisionActor : public UParticleModuleCollision
{
public:
    //## BEGIN PROPS ParticleModuleCollisionActor
    TArrayNoInit<FName> ActorsToCollideWith;
    BITFIELD bCheckPawnCollisions:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleCollisionActor

    DECLARE_CLASS(UParticleModuleCollisionActor,UParticleModuleCollision,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Perform the desired collision check for this module.
	 *	
	 *	@param	Owner			The emitter instance that owns the particle being checked
	 *	@param	InParticle		The particle being checked for a collision
	 *	@param	Hit				The hit results to fill in for a collision
	 *	@param	SourceActor		The source actor for the check
	 *	@param	End				The end position for the check
	 *	@param	Start			The start position for the check
	 *	@param	TraceFlags		The trace flags to use for the check
	 *	@param	Extent			The extent to use for the check
	 *	
	 *	@return UBOOL			TRUE if a collision occurred.
	 */
	virtual UBOOL PerformCollisionCheck(FParticleEmitterInstance* Owner, FBaseParticle* InParticle, 
		FCheckResult& Hit, AActor* SourceActor, const FVector& End, const FVector& Start, DWORD TraceFlags, const FVector& Extent);

	/**
	 *	Helper function used by the editor to auto-populate a placed AEmitter with any
	 *	instance parameters that are utilized.
	 *
	 *	@param	PSysComp		The particle system component to be populated.
	 */
	virtual void AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);
};

class UParticleModuleColorBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleColorBase
    //## END PROPS ParticleModuleColorBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleColorBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleColorBase)
};

class UParticleModuleColor : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColor
    struct FRawDistributionVector StartColor;
    struct FRawDistributionFloat StartAlpha;
    BITFIELD bClampAlpha:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleColor

    DECLARE_CLASS(UParticleModuleColor,UParticleModuleColorBase,0,Engine)
	virtual void	PostLoad();
	virtual	void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleColor_Seeded : public UParticleModuleColor
{
public:
    //## BEGIN PROPS ParticleModuleColor_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleColor_Seeded

    DECLARE_CLASS(UParticleModuleColor_Seeded,UParticleModuleColor,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleColorByParameter : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorByParameter
    FName ColorParam;
    FColor DefaultColor;
    //## END PROPS ParticleModuleColorByParameter

    DECLARE_CLASS(UParticleModuleColorByParameter,UParticleModuleColorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleColorOverLife : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorOverLife
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    BITFIELD bClampAlpha:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleColorOverLife

    DECLARE_CLASS(UParticleModuleColorOverLife,UParticleModuleColorBase,0,Engine)
	virtual void	PostLoad();
	virtual	void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleColorScaleOverDensity : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorScaleOverDensity
    struct FRawDistributionVector ColorScaleOverDensity;
    struct FRawDistributionFloat AlphaScaleOverDensity;
    //## END PROPS ParticleModuleColorScaleOverDensity

    DECLARE_CLASS(UParticleModuleColorScaleOverDensity,UParticleModuleColorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleColorScaleOverLife : public UParticleModuleColorBase
{
public:
    //## BEGIN PROPS ParticleModuleColorScaleOverLife
    struct FRawDistributionVector ColorScaleOverLife;
    struct FRawDistributionFloat AlphaScaleOverLife;
    BITFIELD bEmitterTime:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleColorScaleOverLife

    DECLARE_CLASS(UParticleModuleColorScaleOverLife,UParticleModuleColorBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

#if WITH_EDITOR
	/**
	 *	Get the number of custom entries this module has. Maximum of 3.
	 *
	 *	@return	INT		The number of custom menu entries
	 */
	virtual INT GetNumberOfCustomMenuOptions() const;

	/**
	 *	Get the display name of the custom menu entry.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2)
	 *	@param	OutDisplayString	The string to display for the menu
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL GetCustomMenuEntryDisplayString(INT InEntryIndex, FString& OutDisplayString) const;

	/**
	 *	Perform the custom menu entry option.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2) to perform
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL PerformCustomMenuEntry(INT InEntryIndex);
#endif

};

class UParticleModuleEventBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleEventBase
    //## END PROPS ParticleModuleEventBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleEventBase,UParticleModule,0,Engine)
	/**
	 *	Retrieve the ModuleType of this module.
	 *
	 *	@return	EModuleType		The type of module this is.
	 */
	virtual EModuleType	GetModuleType() const	{	return EPMT_Event;	}
};

struct FParticleEvent_GenerateInfo
{
    BYTE Type;
    INT Frequency;
    INT LowFreq;
    INT ParticleFrequency;
    BITFIELD FirstTimeOnly:1;
    BITFIELD LastTimeOnly:1;
    BITFIELD UseReflectedImpactVector:1;
    FName CustomName;
    TArrayNoInit<class UParticleModuleEventSendToGame*> ParticleModuleEventsToSendToGame;

    /** Constructors */
    FParticleEvent_GenerateInfo() {}
    FParticleEvent_GenerateInfo(EEventParm)
    {
        appMemzero(this, sizeof(FParticleEvent_GenerateInfo));
    }
};

class UParticleModuleEventGenerator : public UParticleModuleEventBase
{
public:
    //## BEGIN PROPS ParticleModuleEventGenerator
    TArrayNoInit<struct FParticleEvent_GenerateInfo> Events;
    //## END PROPS ParticleModuleEventGenerator

    DECLARE_CLASS(UParticleModuleEventGenerator,UParticleModuleEventBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Called when the properties change in the property window.
	 *
	 *	@param	PropertyThatChanged		The property that was edited...
	 */
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Called when a particle is spawned and an event payload is present.
	 *
	 *	@param	Owner			Pointer to the owning FParticleEmitterInstance.
	 *	@param	EventPayload	Pointer to the event instance payload data.
	 *	@param	NewParticle		Pointer to the particle that was spawned.
	 *
	 *	@return	UBOOL			TRUE if processed, FALSE if not.
	 */
	virtual UBOOL	HandleParticleSpawned(FParticleEmitterInstance* Owner, FParticleEventInstancePayload* EventPayload, FBaseParticle* NewParticle);

	/**
	 *	Called when a particle is killed and an event payload is present.
	 *
	 *	@param	Owner			Pointer to the owning FParticleEmitterInstance.
	 *	@param	EventPayload	Pointer to the event instance payload data.
	 *	@param	DeadParticle	Pointer to the particle that is being killed.
	 *
	 *	@return	UBOOL			TRUE if processed, FALSE if not.
	 */
	virtual UBOOL	HandleParticleKilled(FParticleEmitterInstance* Owner, FParticleEventInstancePayload* EventPayload, FBaseParticle* DeadParticle);

	/**
	 *	Called when a particle collides and an event payload is present.
	 *
	 *	@param	Owner				Pointer to the owning FParticleEmitterInstance.
	 *	@param	EventPayload		Pointer to the event instance payload data.
	 *	@param	CollidePayload		Pointer to the collision payload data.
	 *	@param	Hit					The CheckResult for the collision.
	 *	@param	CollideParticle		Pointer to the particle that has collided.
	 *	@param	CollideDirection	The direction the particle was traveling when the collision occurred.
	 *
	 *	@return	UBOOL				TRUE if processed, FALSE if not.
	 */
	virtual UBOOL	HandleParticleCollision(FParticleEmitterInstance* Owner, FParticleEventInstancePayload* EventPayload, 
		FParticleCollisionPayload* CollidePayload, FCheckResult* Hit, FBaseParticle* CollideParticle, FVector& CollideDirection);

	/**
	 *	Called when a particle collides with a world attractor and an event payload is present.
	 *
	 *	@param	Owner				Pointer to the owning FParticleEmitterInstance.
	 *	@param	EventPayload		Pointer to the event instance payload data.
	 *	@param	CollidePayload		Pointer to the collision payload data.
	 *	@param	Hit					The CheckResult for the collision.
	 *	@param	CollideParticle		Pointer to the particle that has collided.
	 *	@param	CollideDirection	The direction the particle was traveling when the collision occurred.
	 *
	 *	@return	UBOOL				TRUE if processed, FALSE if not.
	 */
	virtual UBOOL	HandleParticleAttractorCollision(FParticleEmitterInstance* Owner, FParticleEventInstancePayload* EventPayload, 
		FParticleCollisionPayload* CollidePayload, FCheckResult* Hit, FBaseParticle* CollideParticle, FVector& CollideDirection);
};

class UParticleModuleEventReceiverBase : public UParticleModuleEventBase
{
public:
    //## BEGIN PROPS ParticleModuleEventReceiverBase
    BYTE EventGeneratorType;
    FName EventName;
    //## END PROPS ParticleModuleEventReceiverBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleEventReceiverBase,UParticleModuleEventBase,0,Engine)
	/**
	 *	Is the module interested in events of the given type?
	 *
	 *	@param	InEventType		The event type to check
	 *
	 *	@return	UBOOL			TRUE if interested.
	 */
	virtual UBOOL WillProcessParticleEvent(EParticleEventType InEventType)
	{
		if ((EventGeneratorType == EPET_Any) || (InEventType == EventGeneratorType))
		{
			return TRUE;
		}

		return FALSE;
	}

	/**
	 *	Process the event...
	 *
	 *	@param	Owner		The FParticleEmitterInstance this module is contained in.
	 *	@param	InEvent		The FParticleEventData that occurred.
	 *	@param	DeltaTime	The time slice of this frame.
	 *
	 *	@return	UBOOL		TRUE if the event was processed; FALSE if not.
	 */
	virtual UBOOL ProcessParticleEvent(FParticleEmitterInstance* Owner, FParticleEventData& InEvent, FLOAT DeltaTime)
	{
		return FALSE;
	}
};

class UParticleModuleEventReceiverKillParticles : public UParticleModuleEventReceiverBase
{
public:
    //## BEGIN PROPS ParticleModuleEventReceiverKillParticles
    BITFIELD bStopSpawning:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleEventReceiverKillParticles

    DECLARE_CLASS(UParticleModuleEventReceiverKillParticles,UParticleModuleEventReceiverBase,0,Engine)
	// Event Receiver functionality
	/**
	 *	Process the event...
	 *
	 *	@param	Owner		The FParticleEmitterInstance this module is contained in.
	 *	@param	InEvent		The FParticleEventData that occurred.
	 *	@param	DeltaTime	The time slice of this frame.
	 *
	 *	@return	UBOOL		TRUE if the event was processed; FALSE if not.
	 */
	virtual UBOOL ProcessParticleEvent(FParticleEmitterInstance* Owner, FParticleEventData& InEvent, FLOAT DeltaTime);
};

class UParticleModuleEventReceiverSpawn : public UParticleModuleEventReceiverBase
{
public:
    //## BEGIN PROPS ParticleModuleEventReceiverSpawn
    struct FRawDistributionFloat SpawnCount;
    BITFIELD bUseParticleTime:1;
    BITFIELD bUsePSysLocation:1;
    BITFIELD bInheritVelocity:1;
    SCRIPT_ALIGN;
    struct FRawDistributionVector InheritVelocityScale;
    //## END PROPS ParticleModuleEventReceiverSpawn

    DECLARE_CLASS(UParticleModuleEventReceiverSpawn,UParticleModuleEventReceiverBase,0,Engine)
	// UObject functionality
	
	// Event Receiver functionality
	/**
	 *	Process the event...
	 *
	 *	@param	Owner		The FParticleEmitterInstance this module is contained in.
	 *	@param	InEvent		The FParticleEventData that occurred.
	 *	@param	DeltaTime	The time slice of this frame.
	 *
	 *	@return	UBOOL		TRUE if the event was processed; FALSE if not.
	 */
	virtual UBOOL ProcessParticleEvent(FParticleEmitterInstance* Owner, FParticleEventData& InEvent, FLOAT DeltaTime);
};

class UParticleModuleKillBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleKillBase
    //## END PROPS ParticleModuleKillBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleKillBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleKillBase)
};

class UParticleModuleKillBox : public UParticleModuleKillBase
{
public:
    //## BEGIN PROPS ParticleModuleKillBox
    struct FRawDistributionVector LowerLeftCorner;
    struct FRawDistributionVector UpperRightCorner;
    BITFIELD bAbsolute:1;
    BITFIELD bKillInside:1;
    BITFIELD bAxisAlignedAndFixedSize:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleKillBox

    DECLARE_CLASS(UParticleModuleKillBox,UParticleModuleKillBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleKillHeight : public UParticleModuleKillBase
{
public:
    //## BEGIN PROPS ParticleModuleKillHeight
    struct FRawDistributionFloat Height;
    BITFIELD bAbsolute:1;
    BITFIELD bFloor:1;
    BITFIELD bApplyPSysScale:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleKillHeight

    DECLARE_CLASS(UParticleModuleKillHeight,UParticleModuleKillBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleLifetimeBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleLifetimeBase
    //## END PROPS ParticleModuleLifetimeBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleLifetimeBase,UParticleModule,0,Engine)
	/** Return the maximum lifetime this module would return. */
	virtual FLOAT	GetMaxLifetime()
	{
		return 0.0f;
	}

	/**
	 *	Call to retrieve the lifetime value at the given time.
	 *
	 *	@param	Owner		The emitter instance that owns this module
	 *	@param	InTime		The time input for retrieving the lifetime value
	 *	@param	Data		The data associated with the distribution
	 *
	 *	@return	FLOAT		The Lifetime value
	 */
	virtual FLOAT	GetLifetimeValue(FParticleEmitterInstance* Owner, FLOAT InTime, UObject* Data = NULL)
		PURE_VIRTUAL(UParticleModuleLifetimeBase::GetLifetimeValue,return 0.0f;);
};

class UParticleModuleLifetime : public UParticleModuleLifetimeBase
{
public:
    //## BEGIN PROPS ParticleModuleLifetime
    struct FRawDistributionFloat Lifetime;
    //## END PROPS ParticleModuleLifetime

    DECLARE_CLASS(UParticleModuleLifetime,UParticleModuleLifetimeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

	virtual FLOAT	GetMaxLifetime();

	/**
	 *	Call to retrieve the lifetime value at the given time.
	 *
	 *	@param	Owner		The emitter instance that owns this module
	 *	@param	InTime		The time input for retrieving the lifetime value
	 *	@param	Data		The data associated with the distribution
	 *
	 *	@return	FLOAT		The Lifetime value
	 */
	virtual FLOAT	GetLifetimeValue(FParticleEmitterInstance* Owner, FLOAT InTime, UObject* Data = NULL);
};

class UParticleModuleLifetime_Seeded : public UParticleModuleLifetime
{
public:
    //## BEGIN PROPS ParticleModuleLifetime_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleLifetime_Seeded

    DECLARE_CLASS(UParticleModuleLifetime_Seeded,UParticleModuleLifetime,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Call to retrieve the lifetime value at the given time.
	 *
	 *	@param	Owner		The emitter instance that owns this module
	 *	@param	InTime		The time input for retrieving the lifetime value
	 *	@param	Data		The data associated with the distribution
	 *
	 *	@return	FLOAT		The Lifetime value
	 */
	virtual FLOAT	GetLifetimeValue(FParticleEmitterInstance* Owner, FLOAT InTime, UObject* Data = NULL);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleLocationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleLocationBase
    //## END PROPS ParticleModuleLocationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleLocationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleLocationBase)
};

class UParticleModuleLocation : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocation
    struct FRawDistributionVector StartLocation;
    FLOAT DistributeOverNPoints;
    FLOAT DistributeThreshold;
    //## END PROPS ParticleModuleLocation

    DECLARE_CLASS(UParticleModuleLocation,UParticleModuleLocationBase,0,Engine)
protected:
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	virtual void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);

public:
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleLocation_Seeded : public UParticleModuleLocation
{
public:
    //## BEGIN PROPS ParticleModuleLocation_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleLocation_Seeded

    DECLARE_CLASS(UParticleModuleLocation_Seeded,UParticleModuleLocation,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleLocationWorldOffset : public UParticleModuleLocation
{
public:
    //## BEGIN PROPS ParticleModuleLocationWorldOffset
    //## END PROPS ParticleModuleLocationWorldOffset

    DECLARE_CLASS(UParticleModuleLocationWorldOffset,UParticleModuleLocation,0,Engine)
protected:
	virtual void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);
};

class UParticleModuleLocationWorldOffset_Seeded : public UParticleModuleLocationWorldOffset
{
public:
    //## BEGIN PROPS ParticleModuleLocationWorldOffset_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleLocationWorldOffset_Seeded

    DECLARE_CLASS(UParticleModuleLocationWorldOffset_Seeded,UParticleModuleLocationWorldOffset,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

struct FLocationBoneSocketInfo
{
    FName BoneSocketName;
    FVector Offset;

    /** Constructors */
    FLocationBoneSocketInfo() {}
    FLocationBoneSocketInfo(EEventParm)
    {
        appMemzero(this, sizeof(FLocationBoneSocketInfo));
    }
};

class UParticleModuleLocationBoneSocket : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationBoneSocket
    BYTE SourceType;
    BYTE SelectionMethod;
    SCRIPT_ALIGN;
    FVector UniversalOffset;
    TArrayNoInit<struct FLocationBoneSocketInfo> SourceLocations;
    BITFIELD bUpdatePositionEachFrame:1;
    BITFIELD bOrientMeshEmitters:1;
    BITFIELD bInheritVelocityAtSpawn:1;
    FName SkelMeshActorParamName;
#if WITH_EDITORONLY_DATA
    class USkeletalMesh* EditorSkelMesh;
#endif // WITH_EDITORONLY_DATA
    FLOAT LastUpdateTime;
    //## END PROPS ParticleModuleLocationBoneSocket

    DECLARE_CLASS(UParticleModuleLocationBoneSocket,UParticleModuleLocationBase,0,Engine)
	/**
	 *	Called when a property has change on an instance of the module.
	 *
	 *	@param	PropertyChangedEvent		Information on the change that occurred.
	 */
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Called on an emitter when all other update operations have taken place
	 *	INCLUDING bounding box cacluations!
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	FinalUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return TRUE; }

	/**
	 *	Helper function used by the editor to auto-populate a placed AEmitter with any
	 *	instance parameters that are utilized.
	 *
	 *	@param	PSysComp		The particle system component to be populated.
	 */
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

#if WITH_EDITOR
	/**
	 *	Get the number of custom entries this module has. Maximum of 3.
	 *
	 *	@return	INT		The number of custom menu entries
	 */
	virtual INT GetNumberOfCustomMenuOptions() const;

	/**
	 *	Get the display name of the custom menu entry.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2)
	 *	@param	OutDisplayString	The string to display for the menu
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL GetCustomMenuEntryDisplayString(INT InEntryIndex, FString& OutDisplayString) const;

	/**
	 *	Perform the custom menu entry option.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2) to perform
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL PerformCustomMenuEntry(INT InEntryIndex);
#endif

	/**
	 *	Retrieve the position for the given socket index.
	 *
	 *	@param	Owner					The particle emitter instance that is being setup
	 *	@param	InSkelMeshComponent		The skeletal mesh component to use as the source
	 *	@param	InBoneSocketIndex		The index of the bone/socket of interest
	 *	@param	OutPosition				The position for the particle location
	 *	@param	OutRotation				Optional orientation for the particle (mesh emitters)
	 *	
	 *	@return	UBOOL					TRUE if successful, FALSE if not
	 */
	UBOOL GetParticleLocation(FParticleEmitterInstance* Owner, USkeletalMeshComponent* InSkelMeshComponent, INT InBoneSocketIndex, FVector& OutPosition, FQuat* OutRotation);
};

class UParticleModuleLocationDirect : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationDirect
    struct FRawDistributionVector Location;
    struct FRawDistributionVector LocationOffset;
    struct FRawDistributionVector ScaleFactor;
    struct FRawDistributionVector Direction;
    //## END PROPS ParticleModuleLocationDirect

    DECLARE_CLASS(UParticleModuleLocationDirect,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class UParticleModuleLocationEmitter : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationEmitter
    FName EmitterName;
    BYTE SelectionMethod;
    SCRIPT_ALIGN;
    BITFIELD InheritSourceVelocity:1;
    BITFIELD bInheritSourceRotation:1;
    FLOAT InheritSourceVelocityScale;
    FLOAT InheritSourceRotationScale;
    //## END PROPS ParticleModuleLocationEmitter

    DECLARE_CLASS(UParticleModuleLocationEmitter,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleLocationEmitterDirect : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationEmitterDirect
    FName EmitterName;
    //## END PROPS ParticleModuleLocationEmitterDirect

    DECLARE_CLASS(UParticleModuleLocationEmitterDirect,UParticleModuleLocationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleLocationPrimitiveBase : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveBase
    BITFIELD Positive_X:1;
    BITFIELD Positive_Y:1;
    BITFIELD Positive_Z:1;
    BITFIELD Negative_X:1;
    BITFIELD Negative_Y:1;
    BITFIELD Negative_Z:1;
    BITFIELD SurfaceOnly:1;
    BITFIELD Velocity:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat VelocityScale;
    struct FRawDistributionVector StartLocation;
    //## END PROPS ParticleModuleLocationPrimitiveBase

    DECLARE_CLASS(UParticleModuleLocationPrimitiveBase,UParticleModuleLocationBase,0,Engine)
	virtual void	DetermineUnitDirection(FParticleEmitterInstance* Owner, FVector& vUnitDir, class FRandomStream* InRandomStream);
};

class UParticleModuleLocationPrimitiveCylinder : public UParticleModuleLocationPrimitiveBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveCylinder
    BITFIELD RadialVelocity:1;
    BITFIELD bAdjustForWorldSpace:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat StartRadius;
    struct FRawDistributionFloat StartHeight;
    BYTE HeightAxis;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleLocationPrimitiveCylinder

    DECLARE_CLASS(UParticleModuleLocationPrimitiveCylinder,UParticleModuleLocationPrimitiveBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
	
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void	SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleLocationPrimitiveCylinder_Seeded : public UParticleModuleLocationPrimitiveCylinder
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveCylinder_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleLocationPrimitiveCylinder_Seeded

    DECLARE_CLASS(UParticleModuleLocationPrimitiveCylinder_Seeded,UParticleModuleLocationPrimitiveCylinder,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleLocationPrimitiveSphere : public UParticleModuleLocationPrimitiveBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveSphere
    struct FRawDistributionFloat StartRadius;
    //## END PROPS ParticleModuleLocationPrimitiveSphere

    DECLARE_CLASS(UParticleModuleLocationPrimitiveSphere,UParticleModuleLocationPrimitiveBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleLocationPrimitiveSphere_Seeded : public UParticleModuleLocationPrimitiveSphere
{
public:
    //## BEGIN PROPS ParticleModuleLocationPrimitiveSphere_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleLocationPrimitiveSphere_Seeded

    DECLARE_CLASS(UParticleModuleLocationPrimitiveSphere_Seeded,UParticleModuleLocationPrimitiveSphere,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleLocationSkelVertSurface : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationSkelVertSurface
    BYTE SourceType;
    SCRIPT_ALIGN;
    FVector UniversalOffset;
    BITFIELD bUpdatePositionEachFrame:1;
    BITFIELD bOrientMeshEmitters:1;
    BITFIELD bEnforceNormalCheck:1;
    FName SkelMeshActorParamName;
#if WITH_EDITORONLY_DATA
    class USkeletalMesh* EditorSkelMesh;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<FName> ValidAssociatedBones;
    FVector NormalToCompare;
    FLOAT NormalCheckToleranceDegrees;
    FLOAT NormalCheckTolerance;
    TArrayNoInit<INT> ValidMaterialIndices;
    //## END PROPS ParticleModuleLocationSkelVertSurface

    DECLARE_CLASS(UParticleModuleLocationSkelVertSurface,UParticleModuleLocationBase,0,Engine)
	/**
	 *	Called after loading the module.
	 */
	virtual void PostLoad();

	/**
	 *	Called when a property has change on an instance of the module.
	 *
	 *	@param	PropertyChangedEvent		Information on the change that occurred.
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return TRUE; }

	/**
	 *	Helper function used by the editor to auto-populate a placed AEmitter with any
	 *	instance parameters that are utilized.
	 *
	 *	@param	PSysComp		The particle system component to be populated.
	 */
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

#if WITH_EDITOR
	/**
	 *	Get the number of custom entries this module has. Maximum of 3.
	 *
	 *	@return	INT		The number of custom menu entries
	 */
	virtual INT GetNumberOfCustomMenuOptions() const;

	/**
	 *	Get the display name of the custom menu entry.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2)
	 *	@param	OutDisplayString	The string to display for the menu
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL GetCustomMenuEntryDisplayString(INT InEntryIndex, FString& OutDisplayString) const;

	/**
	 *	Perform the custom menu entry option.
	 *
	 *	@param	InEntryIndex		The custom entry index (0-2) to perform
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not
	 */
	virtual UBOOL PerformCustomMenuEntry(INT InEntryIndex);
#endif

	/**
	 *	Retrieve the position for the given socket index.
	 *
	 *	@param	Owner					The particle emitter instance that is being setup
	 *	@param	InSkelMeshComponent		The skeletal mesh component to use as the source
	 *	@param	InPrimaryVertexIndex	The index of the only vertex (vert mode) or the first vertex (surface mode)
	 *	@param	OutPosition				The position for the particle location
	 *	@param	OutRotation				Optional orientation for the particle (mesh emitters)
	 *  @param  bSpawning				When TRUE and when using normal check on surfaces, will return false if the check fails.
	 *	
	 *	@return	UBOOL					TRUE if successful, FALSE if not
	 */
	UBOOL GetParticleLocation(FParticleEmitterInstance* Owner, USkeletalMeshComponent* InSkelMeshComponent, INT InPrimaryVertexIndex, FVector& OutPosition, FQuat* OutRotation, UBOOL bSpawning = FALSE);

};

class UParticleModuleLocationStaticVertSurface : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleLocationStaticVertSurface
    BYTE SourceType;
    SCRIPT_ALIGN;
    FVector UniversalOffset;
    BITFIELD bUpdatePositionEachFrame:1;
    BITFIELD bOrientMeshEmitters:1;
    BITFIELD bEnforceNormalCheck:1;
    FName StaticMeshActorParamName;
#if WITH_EDITORONLY_DATA
    class UStaticMesh* EditorStaticMesh;
#endif // WITH_EDITORONLY_DATA
    FVector NormalToCompare;
    FLOAT NormalCheckToleranceDegrees;
    FLOAT NormalCheckTolerance;
    TArrayNoInit<INT> ValidMaterialIndices;
    //## END PROPS ParticleModuleLocationStaticVertSurface

    DECLARE_CLASS(UParticleModuleLocationStaticVertSurface,UParticleModuleLocationBase,0,Engine)
	/**
	 *	Called after loading the module.
	 */
	virtual void PostLoad();

	/**
	 *	Called when a property has change on an instance of the module.
	 *
	 *	@param	PropertyChangedEvent		Information on the change that occurred.
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return TRUE; }

	/**
	 *	Helper function used by the editor to auto-populate a placed AEmitter with any
	 *	instance parameters that are utilized.
	 *
	 *	@param	PSysComp		The particle system component to be populated.
	 */
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	/**
	 *	Retrieve the position for the given vert or face index.
	 *
	 *	@param	Owner					The particle emitter instance that is being setup
	 *	@param	InStaticMeshComponent	The static mesh component to use as the source
	 *	@param	InPrimaryVertexIndex	The index of the only vertex (vert mode) or the first vertex (surface mode)
	 *	@param	OutPosition				The position for the particle location
	 *	@param	OutRotation				Optional orientation for the particle (mesh emitters)
	 *  @param  bSpawning				When TRUE and when using normal check on surfaces, will return false if the check fails.
	 *	
	 *	@return	UBOOL					TRUE if successful, FALSE if not
	 */
	UBOOL GetParticleLocation(FParticleEmitterInstance* Owner, UStaticMeshComponent* InStaticMeshComponent, INT InPrimaryVertexIndex, FVector& OutPosition, FQuat* OutRotation, UBOOL bSpawning = FALSE);
};

class UParticleModuleSourceMovement : public UParticleModuleLocationBase
{
public:
    //## BEGIN PROPS ParticleModuleSourceMovement
    struct FRawDistributionVector SourceMovementScale;
    //## END PROPS ParticleModuleSourceMovement

    DECLARE_CLASS(UParticleModuleSourceMovement,UParticleModuleLocationBase,0,Engine)
	/**
	 *	Called on an emitter when all other update operations have taken place
	 *	INCLUDING bounding box calculations!
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	FinalUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleMaterialBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleMaterialBase
    //## END PROPS ParticleModuleMaterialBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleMaterialBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleMaterialBase)
};

class UParticleModuleMaterialByParameter : public UParticleModuleMaterialBase
{
public:
    //## BEGIN PROPS ParticleModuleMaterialByParameter
    TArrayNoInit<FName> MaterialParameters;
    TArrayNoInit<class UMaterialInterface*> DefaultMaterials;
    //## END PROPS ParticleModuleMaterialByParameter

    DECLARE_CLASS(UParticleModuleMaterialByParameter,UParticleModuleMaterialBase,0,Engine)
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Auto-populates the Emitter actors Instance list.
	 */
	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleMeshMaterial : public UParticleModuleMaterialBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshMaterial
    TArrayNoInit<class UMaterialInterface*> MeshMaterials;
    //## END PROPS ParticleModuleMeshMaterial

    DECLARE_CLASS(UParticleModuleMeshMaterial,UParticleModuleMaterialBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleOrbitBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleOrbitBase
    BITFIELD bUseEmitterTime:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleOrbitBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleOrbitBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleOrbitBase)
};

struct FOrbitOptions
{
    BITFIELD bProcessDuringSpawn:1;
    BITFIELD bProcessDuringUpdate:1;
    BITFIELD bUseEmitterTime:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FOrbitOptions() {}
    FOrbitOptions(EEventParm)
    {
        appMemzero(this, sizeof(FOrbitOptions));
    }
};

class UParticleModuleOrbit : public UParticleModuleOrbitBase
{
public:
    //## BEGIN PROPS ParticleModuleOrbit
    BYTE ChainMode;
    SCRIPT_ALIGN;
    struct FRawDistributionVector OffsetAmount;
    struct FOrbitOptions OffsetOptions;
    struct FRawDistributionVector RotationAmount;
    struct FOrbitOptions RotationOptions;
    struct FRawDistributionVector RotationRateAmount;
    struct FOrbitOptions RotationRateOptions;
    //## END PROPS ParticleModuleOrbit

    DECLARE_CLASS(UParticleModuleOrbit,UParticleModuleOrbitBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
};

class UParticleModuleOrientationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleOrientationBase
    //## END PROPS ParticleModuleOrientationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleOrientationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleOrientationBase)
};

class UParticleModuleOrientationAxisLock : public UParticleModuleOrientationBase
{
public:
    //## BEGIN PROPS ParticleModuleOrientationAxisLock
    MS_ALIGN(4) BYTE LockAxisFlags GCC_ALIGN(4); // Extra alignment flags needed because all properties are bytes
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleOrientationAxisLock

    DECLARE_CLASS(UParticleModuleOrientationAxisLock,UParticleModuleOrientationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual void	SetLockAxis(EParticleAxisLock eLockFlags);
};

class UParticleModuleParameterBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleParameterBase
    //## END PROPS ParticleModuleParameterBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleParameterBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleParameterBase)
};

struct FEmitterDynamicParameter
{
    FName ParamName;
    BITFIELD bUseEmitterTime:1;
    BITFIELD bSpawnTimeOnly:1;
    SCRIPT_ALIGN;
    BYTE ValueMethod;
    SCRIPT_ALIGN;
    BITFIELD bScaleVelocityByParamValue:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat ParamValue;

    /** Constructors */
    FEmitterDynamicParameter() {}
    FEmitterDynamicParameter(EEventParm)
    {
        appMemzero(this, sizeof(FEmitterDynamicParameter));
    }
};

class UParticleModuleParameterDynamic : public UParticleModuleParameterBase
{
public:
    //## BEGIN PROPS ParticleModuleParameterDynamic
    TArrayNoInit<struct FEmitterDynamicParameter> DynamicParams;
    INT UpdateFlags;
    BITFIELD bUsesVelocity:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleParameterDynamic

    DECLARE_CLASS(UParticleModuleParameterDynamic,UParticleModuleParameterBase,0,Engine)
	/**
	 *	Called after an object has been loaded
	 */
	virtual void	PostLoad();

	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	// For Cascade
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

	/** 
	 *	PostEditChange...
	 */
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** 
	 *	Fill an array with each Object property that fulfills the FCurveEdInterface interface.
	 *
	 *	@param	OutCurve	The array that should be filled in.
	 */
	virtual void	GetCurveObjects(TArray<FParticleCurvePair>& OutCurves);

	/**
	 *	Returns TRUE if the results of LOD generation for the given percentage will result in a 
	 *	duplicate of the module.
	 *
	 *	@param	SourceLODLevel		The source LODLevel
	 *	@param	DestLODLevel		The destination LODLevel
	 *	@param	Percentage			The percentage value that should be used when setting values
	 *
	 *	@return	UBOOL				TRUE if the generated module will be a duplicate.
	 *								FALSE if not.
	 */
	virtual UBOOL WillGeneratedModuleBeIdentical(UParticleLODLevel* SourceLODLevel, UParticleLODLevel* DestLODLevel, FLOAT Percentage)
	{
		// The assumption is that at 100%, ANY module will be identical...
		// (Although this is virtual to allow over-riding that assumption on a case-by-case basis!)
		return TRUE;
	}

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);

	/**
	 *	Retrieve the distributions that use ParticleParameters in this module.
	 *
	 *	@param	ParticleParameterList	The list of ParticleParameter distributions to add to
	 */
	virtual void GetParticleParametersUtilized(TArray<FString>& ParticleParameterList);
	
	/**
	 *	Update the parameter names with the given material...
	 *
	 *	@param	InMaterialInterface	Pointer to the material interface
	 *	@param	bIsMeshEmitter		TRUE if the emitter is a mesh emitter...
	 *
	 */
	virtual void UpdateParameterNames(UMaterialInterface* InMaterialInterface, UBOOL bIsMeshEmitter);

	/**
	 *	Refresh the module...
	 */
	virtual void RefreshModule(UInterpCurveEdSetup* EdSetup, UParticleEmitter* InEmitter, INT InLODLevel);
	
	/**
	 *	Retrieve the value for the parameter at the given index.
	 *
	 *	@param	InDynParams		The FEmitterDynamicParameter to fetch the value for
	 *	@param	Particle		The particle we are getting the value for.
	 *	@param	Owner			The FParticleEmitterInstance owner of the particle.
	 *	@param	InRandomStream	The random stream to use when retrieving the value
	 *
	 *	@return	FLOAT			The value for the parameter.
	 */
	FORCEINLINE FLOAT GetParameterValue(FEmitterDynamicParameter& InDynParams, FBaseParticle& Particle, FParticleEmitterInstance* Owner, class FRandomStream* InRandomStream)
	{
		FLOAT ScaleValue = 1.0f;
		FLOAT DistributionValue = 1.0f;
		FLOAT TimeValue = InDynParams.bUseEmitterTime ? Owner->EmitterTime : Particle.RelativeTime;
		switch (InDynParams.ValueMethod)
		{
		case EDPV_VelocityX:
		case EDPV_VelocityY:
		case EDPV_VelocityZ:
			ScaleValue = Particle.Velocity[InDynParams.ValueMethod - 1];
			break;
		case EDPV_VelocityMag:
			ScaleValue = Particle.Velocity.Size();
			break;
		default:
			//case EDPV_UserSet:
			break;
		}

		if ((InDynParams.bScaleVelocityByParamValue == TRUE) || (InDynParams.ValueMethod == EDPV_UserSet))
		{
			DistributionValue = InDynParams.ParamValue.GetValue(TimeValue, Owner->Component, InRandomStream);
		}

		return DistributionValue * ScaleValue;
	}

	/**
	 *	Retrieve the value for the parameter at the given index.
	 *
	 *	@param	InDynParams		The FEmitterDynamicParameter to fetch the value for
	 *	@param	Particle		The particle we are getting the value for.
	 *	@param	Owner			The FParticleEmitterInstance owner of the particle.
	 *	@param	InRandomStream	The random stream to use when retrieving the value
	 *
	 *	@return	FLOAT			The value for the parameter.
	 */
	FORCEINLINE FLOAT GetParameterValue_UserSet(FEmitterDynamicParameter& InDynParams, FBaseParticle& Particle, FParticleEmitterInstance* Owner, class FRandomStream* InRandomStream)
	{
		return InDynParams.ParamValue.GetValue(InDynParams.bUseEmitterTime ? Owner->EmitterTime : Particle.RelativeTime, Owner->Component, InRandomStream);
	}

	/**
	 *	Set the UpdatesFlags and bUsesVelocity
	 */
	virtual	void UpdateUsageFlags();

#if WITH_MOBILE_RHI || WITH_EDITOR
	/**
	 *	Retrieve the index of the Time variable.
	 *	@param	MaxIndex	The max value of index the Time could be stored in
	 *	@return	INT			The index of the time variable or -1 if not found.
	 */
	INT ParticleDynamicParameter_GetTimeIndex(INT MaxIndex)
	{
		int TimeIndex = -1;
		for (int i = 0; i < MaxIndex && TimeIndex==-1; ++i)
		{
			if (DynamicParams(i).ParamName == FName("Time"))
			{
				TimeIndex = i;
			}
		}
		return TimeIndex;
	}
#endif //WITH_MOBILE_RHI || WITH_EDITOR
};

class UParticleModuleParameterDynamic_Seeded : public UParticleModuleParameterDynamic
{
public:
    //## BEGIN PROPS ParticleModuleParameterDynamic_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleParameterDynamic_Seeded

    DECLARE_CLASS(UParticleModuleParameterDynamic_Seeded,UParticleModuleParameterDynamic,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleRequired : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleRequired
    class UMaterialInterface* Material;
    BYTE ScreenAlignment;
    BYTE SortMode;
    BYTE ParticleBurstMethod;
    BYTE InterpolationMethod;
    BYTE EmitterNormalsMode;
    SCRIPT_ALIGN;
    BITFIELD bAllowImageFlipping:1;
    BITFIELD bSquareImageFlipping:1;
    BITFIELD bUseLocalSpace:1;
    BITFIELD bKillOnDeactivate:1;
    BITFIELD bKillOnCompleted:1;
    BITFIELD bRequiresSorting_DEPRECATED:1;
    BITFIELD bUseLegacyEmitterTime:1;
    BITFIELD bEnableNearParticleCulling:1;
    BITFIELD bEnableFarParticleCulling:1;
    BITFIELD bEmitterDurationUseRange:1;
    BITFIELD bDurationRecalcEachLoop:1;
    BITFIELD bEmitterDelayUseRange:1;
    BITFIELD bDelayFirstLoopOnly:1;
    BITFIELD bScaleUV:1;
    BITFIELD bDirectUV:1;
    BITFIELD bOverrideSystemMacroUV:1;
    BITFIELD bUseMaxDrawCount:1;
    BITFIELD bOrbitModuleAffectsVelocityAlignment:1;
    FLOAT NearCullDistance;
    FLOAT NearFadeDistance;
    FLOAT FarFadeDistance;
    FLOAT FarCullDistance;
    FLOAT EmitterDuration;
    FLOAT EmitterDurationLow;
    INT EmitterLoops;
    struct FRawDistributionFloat SpawnRate;
    TArrayNoInit<struct FParticleBurst> BurstList;
    FLOAT EmitterDelay;
    FLOAT EmitterDelayLow;
    INT SubImages_Horizontal;
    INT SubImages_Vertical;
    FLOAT RandomImageTime;
    INT RandomImageChanges;
    FVector MacroUVPosition;
    FLOAT MacroUVRadius;
    INT MaxDrawCount;
    FLOAT DownsampleThresholdScreenFraction;
    FVector NormalsSphereCenter;
    FVector NormalsCylinderDirection;
    //## END PROPS ParticleModuleRequired

    DECLARE_CLASS(UParticleModuleRequired,UParticleModule,0,Engine)
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void	PostLoad();

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

	/** 
	 *	Add all curve-editable Objects within this module to the curve editor.
	 *
	 *	@param	EdSetup		The CurveEd setup to use for adding curved.
	 */
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup)
	{
		// Overide the base implementation to prevent old SpawnRate from being added...
	}

	/**
	 *	Retrieve the ModuleType of this module.
	 *
	 *	@return	EModuleType		The type of module this is.
	 */
	virtual EModuleType	GetModuleType() const	{	return EPMT_Required;	}

	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);
};

class UParticleModuleRotationBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleRotationBase
    //## END PROPS ParticleModuleRotationBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleRotationBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleRotationBase)
};

class UParticleModuleMeshRotation : public UParticleModuleRotationBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotation
    struct FRawDistributionVector StartRotation;
    BITFIELD bInheritParent:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleMeshRotation

    DECLARE_CLASS(UParticleModuleMeshRotation,UParticleModuleRotationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return TRUE; }
};

class UParticleModuleMeshRotation_Seeded : public UParticleModuleMeshRotation
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotation_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleMeshRotation_Seeded

    DECLARE_CLASS(UParticleModuleMeshRotation_Seeded,UParticleModuleMeshRotation,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleRotation : public UParticleModuleRotationBase
{
public:
    //## BEGIN PROPS ParticleModuleRotation
    struct FRawDistributionFloat StartRotation;
    //## END PROPS ParticleModuleRotation

    DECLARE_CLASS(UParticleModuleRotation,UParticleModuleRotationBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);
};

class UParticleModuleRotation_Seeded : public UParticleModuleRotation
{
public:
    //## BEGIN PROPS ParticleModuleRotation_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleRotation_Seeded

    DECLARE_CLASS(UParticleModuleRotation_Seeded,UParticleModuleRotation,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleRotationOverLifetime : public UParticleModuleRotationBase
{
public:
    //## BEGIN PROPS ParticleModuleRotationOverLifetime
    struct FRawDistributionFloat RotationOverLife;
    BITFIELD Scale:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleRotationOverLifetime

    DECLARE_CLASS(UParticleModuleRotationOverLifetime,UParticleModuleRotationBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleRotationRateBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleRotationRateBase
    //## END PROPS ParticleModuleRotationRateBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleRotationRateBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleRotationRateBase)
};

class UParticleModuleMeshRotationRate : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotationRate
    struct FRawDistributionVector StartRotationRate;
    //## END PROPS ParticleModuleMeshRotationRate

    DECLARE_CLASS(UParticleModuleMeshRotationRate,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return TRUE; }
};

class UParticleModuleMeshRotationRate_Seeded : public UParticleModuleMeshRotationRate
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotationRate_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleMeshRotationRate_Seeded

    DECLARE_CLASS(UParticleModuleMeshRotationRate_Seeded,UParticleModuleMeshRotationRate,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleMeshRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotationRateMultiplyLife
    struct FRawDistributionVector LifeMultiplier;
    //## END PROPS ParticleModuleMeshRotationRateMultiplyLife

    DECLARE_CLASS(UParticleModuleMeshRotationRateMultiplyLife,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleMeshRotationRateOverLife : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleMeshRotationRateOverLife
    struct FRawDistributionVector RotRate;
    BITFIELD bScaleRotRate:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleMeshRotationRateOverLife

    DECLARE_CLASS(UParticleModuleMeshRotationRateOverLife,UParticleModuleRotationRateBase,0,Engine)
	/**
	 *	Called during the spawning of a particle.
	 *	
	 *	@param	Owner		The emitter instance that owns the particle.
	 *	@param	Offset		The offset into the particle payload for this module.
	 *	@param	SpawnTime	The spawn time of the particle.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Called during the spawning of particles in the emitter instance.
	 *	
	 *	@param	Owner		The emitter instance that owns the particle.
	 *	@param	Offset		The offset into the particle payload for this module.
	 *	@param	DeltaTime	The time slice for this update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return TRUE; }
};

class UParticleModuleRotationRate : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleRotationRate
    struct FRawDistributionFloat StartRotationRate;
    //## END PROPS ParticleModuleRotationRate

    DECLARE_CLASS(UParticleModuleRotationRate,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleRotationRate_Seeded : public UParticleModuleRotationRate
{
public:
    //## BEGIN PROPS ParticleModuleRotationRate_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleRotationRate_Seeded

    DECLARE_CLASS(UParticleModuleRotationRate_Seeded,UParticleModuleRotationRate,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleRotationRateMultiplyLife : public UParticleModuleRotationRateBase
{
public:
    //## BEGIN PROPS ParticleModuleRotationRateMultiplyLife
    struct FRawDistributionFloat LifeMultiplier;
    //## END PROPS ParticleModuleRotationRateMultiplyLife

    DECLARE_CLASS(UParticleModuleRotationRateMultiplyLife,UParticleModuleRotationRateBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSizeBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleSizeBase
    //## END PROPS ParticleModuleSizeBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleSizeBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleSizeBase)
};

class UParticleModuleSize : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSize
    struct FRawDistributionVector StartSize;
    //## END PROPS ParticleModuleSize

    DECLARE_CLASS(UParticleModuleSize,UParticleModuleSizeBase,0,Engine)
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);
};

class UParticleModuleSize_Seeded : public UParticleModuleSize
{
public:
    //## BEGIN PROPS ParticleModuleSize_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleSize_Seeded

    DECLARE_CLASS(UParticleModuleSize_Seeded,UParticleModuleSize,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleSizeMultiplyLife : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeMultiplyLife
    struct FRawDistributionVector LifeMultiplier;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleSizeMultiplyLife

    DECLARE_CLASS(UParticleModuleSizeMultiplyLife,UParticleModuleSizeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	/**
	 *	Returns whether the module is SizeMultipleLife or not.
	 *
	 *	@return	UBOOL	TRUE if the module is a UParticleModuleSizeMultipleLife
	 *					FALSE if not
	 */
	virtual UBOOL   IsSizeMultiplyLife() { return TRUE; };
};

class UParticleModuleSizeMultiplyVelocity : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeMultiplyVelocity
    struct FRawDistributionVector VelocityMultiplier;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    SCRIPT_ALIGN;
    FVector CapMaxSize;
    FVector CapMinSize;
    //## END PROPS ParticleModuleSizeMultiplyVelocity

    DECLARE_CLASS(UParticleModuleSizeMultiplyVelocity,UParticleModuleSizeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	
	/**
	 *	Called when a property has change on an instance of the module.
	 *
	 *	@param	PropertyChangedEvent		Information on the change that occurred.
	 */
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 * Applies the scaling factor and min/max caps
	 */
	 FLOAT ScaleSize(FLOAT Size, FLOAT Scale, FLOAT Min, FLOAT Max);
};

class UParticleModuleSizeScale : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeScale
    struct FRawDistributionVector SizeScale;
    BITFIELD EnableX:1;
    BITFIELD EnableY:1;
    BITFIELD EnableZ:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleSizeScale

    DECLARE_CLASS(UParticleModuleSizeScale,UParticleModuleSizeBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSizeScaleByTime : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeScaleByTime
    struct FRawDistributionVector SizeScaleByTime;
    BITFIELD bEnableX:1;
    BITFIELD bEnableY:1;
    BITFIELD bEnableZ:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleSizeScaleByTime

    DECLARE_CLASS(UParticleModuleSizeScaleByTime,UParticleModuleSizeBase,0,Engine)
	/**
	 *	Called during the spawning of a particle.
	 *	
	 *	@param	Owner		The emitter instance that owns the particle.
	 *	@param	Offset		The offset into the particle payload for this module.
	 *	@param	SpawnTime	The spawn time of the particle.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Called during the spawning of particles in the emitter instance.
	 *	
	 *	@param	Owner		The emitter instance that owns the particle.
	 *	@param	Offset		The offset into the particle payload for this module.
	 *	@param	DeltaTime	The time slice for this update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	
	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSizeScaleOverDensity : public UParticleModuleSizeBase
{
public:
    //## BEGIN PROPS ParticleModuleSizeScaleOverDensity
    struct FRawDistributionVector SizeScaleOverDensity;
    //## END PROPS ParticleModuleSizeScaleOverDensity

    DECLARE_CLASS(UParticleModuleSizeScaleOverDensity,UParticleModuleSizeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSpawnBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleSpawnBase
    BITFIELD bProcessSpawnRate:1;
    BITFIELD bProcessBurstList:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleSpawnBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleSpawnBase,UParticleModule,0,Engine)
	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to spawn. (OUTPUT)
	 *	@param	Rate		The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the SpawnRate should be ignored.
	 *						TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number, FLOAT& Rate)
	{
		return bProcessSpawnRate;
	}
	
	/**
	 *	Retrieve the burst count this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the default BurstList, it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to burst. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the default BurstList should be ignored.
	 *						TRUE if the default BurstList should still be processed.
	 */
	virtual UBOOL GetBurstCount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number)
	{
		Number = 0;
		return bProcessBurstList;
	}

	/**
	 *	Retrieve the maximum spawn rate for this module...
	 *	Used in estimating the number of particles that could be used.
	 *
	 *	@return	FLOAT		The maximum spawn rate
	 */
	virtual FLOAT GetMaximumSpawnRate() { return 0.0f; }

	/**
	 *	Retrieve the estimated spawn rate for this module...
	 *	Used in estimating the number of particles that could be used.
	 *
	 *	@return	FLOAT			The maximum spawn rate
	 */
	virtual FLOAT GetEstimatedSpawnRate() { return 0.0f; }

	/**
	 *	Retrieve the maximum number of particles this module could burst.
	 *	Used in estimating the number of particles that could be used.
	 *
	 *	@return	INT			The maximum burst count
	 */
	virtual INT GetMaximumBurstCount() { return 0; }

	/**
	 *	Retrieve the ModuleType of this module.
	 *
	 *	@return	EModuleType		The type of module this is.
	 */
	virtual EModuleType	GetModuleType() const	{	return EPMT_Spawn;	}
};

class UParticleModuleSpawn : public UParticleModuleSpawnBase
{
public:
    //## BEGIN PROPS ParticleModuleSpawn
    struct FRawDistributionFloat Rate;
    struct FRawDistributionFloat RateScale;
    BYTE ParticleBurstMethod;
    TArrayNoInit<struct FParticleBurst> BurstList;
    //## END PROPS ParticleModuleSpawn

    DECLARE_CLASS(UParticleModuleSpawn,UParticleModuleSpawnBase,0,Engine)
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to spawn. (OUTPUT)
	 *	@param	Rate		The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the SpawnRate should be ignored.
	 *						TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number, FLOAT& Rate);

	virtual UBOOL	GenerateLODModuleValues(UParticleModule* SourceModule, FLOAT Percentage, UParticleLODLevel* LODLevel);

	/**
	 *	Retrieve the maximum spawn rate for this module...
	 *	Used in estimating the number of particles that could be used.
	 *
	 *	@return	FLOAT			The maximum spawn rate
	 */
	virtual FLOAT GetMaximumSpawnRate();

	/**
	 *	Retrieve the estimated spawn rate for this module...
	 *	Used in estimating the number of particles that could be used.
	 *
	 *	@return	FLOAT			The maximum spawn rate
	 */
	virtual FLOAT GetEstimatedSpawnRate();

	/**
	 *	Retrieve the maximum number of particles this module could burst.
	 *	Used in estimating the number of particles that could be used.
	 *
	 *	@return	INT			The maximum burst count
	 */
	virtual INT GetMaximumBurstCount();
};

class UParticleModuleSpawnPerUnit : public UParticleModuleSpawnBase
{
public:
    //## BEGIN PROPS ParticleModuleSpawnPerUnit
    FLOAT UnitScalar;
    struct FRawDistributionFloat SpawnPerUnit;
    BITFIELD bIgnoreSpawnRateWhenMoving:1;
    BITFIELD bIgnoreMovementAlongX:1;
    BITFIELD bIgnoreMovementAlongY:1;
    BITFIELD bIgnoreMovementAlongZ:1;
    FLOAT MovementTolerance;
    FLOAT MaxFrameDistance;
    FLOAT MinFrameDistance;
    //## END PROPS ParticleModuleSpawnPerUnit

    DECLARE_CLASS(UParticleModuleSpawnPerUnit,UParticleModuleSpawnBase,0,Engine)
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number fo bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	/**
	 *	Retrieve the spawn amount this module is contributing.
	 *	Note that if multiple Spawn-specific modules are present, if any one
	 *	of them ignores the SpawnRate processing it will be ignored.
	 *
	 *	@param	Owner		The particle emitter instance that is spawning.
	 *	@param	Offset		The offset into the particle payload for the module.
	 *	@param	OldLeftover	The bit of timeslice left over from the previous frame.
	 *	@param	DeltaTime	The time that has expired since the last frame.
	 *	@param	Number		The number of particles to spawn. (OUTPUT)
	 *	@param	Rate		The spawn rate of the module. (OUTPUT)
	 *
	 *	@return	UBOOL		FALSE if the SpawnRate should be ignored.
	 *						TRUE if the SpawnRate should still be processed.
	 */
	virtual UBOOL GetSpawnAmount(FParticleEmitterInstance* Owner, INT Offset, FLOAT OldLeftover, 
		FLOAT DeltaTime, INT& Number, FLOAT& Rate);
};

class UParticleModuleStoreSpawnTimeBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleStoreSpawnTimeBase
    //## END PROPS ParticleModuleStoreSpawnTimeBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleStoreSpawnTimeBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleStoreSpawnTimeBase)
};

class UParticleModuleStoreSpawnTime : public UParticleModuleStoreSpawnTimeBase
{
public:
    //## BEGIN PROPS ParticleModuleStoreSpawnTime
    //## END PROPS ParticleModuleStoreSpawnTime

    DECLARE_CLASS(UParticleModuleStoreSpawnTime,UParticleModuleStoreSpawnTimeBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

};

class UParticleModuleSubUVBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleSubUVBase
    //## END PROPS ParticleModuleSubUVBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleSubUVBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleSubUVBase)
};

class UParticleModuleSubUV : public UParticleModuleSubUVBase
{
public:
    //## BEGIN PROPS ParticleModuleSubUV
    struct FRawDistributionFloat SubImageIndex;
    BITFIELD bUseRealTime:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleSubUV

    DECLARE_CLASS(UParticleModuleSubUV,UParticleModuleSubUVBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/**
	 *	Determine the current image index to use...
	 *
	 *	@param	Owner					The emitter instance being updated.
	 *	@param	Offset					The offset to the particle payload for this module.
	 *	@param	Particle				The particle that the image index is being determined for.
	 *	@param	eMethod					The EParticleSubUVInterpMethod method used to update the subUV.
	 *	@param	SubUVPayload			The FFullSubUVPayload for this particle.
	 *	@param	ImageIndex		[out]	The image index to use for the particle.
	 *	@param	Interp			[out]	The current interpolation value (for blending 2 sub-images).
	 *	@param	DeltaTime				The time slice for this update.
	 *
	 *	@return	UBOOL					TRUE if successful, FALSE if not.
	 */
	virtual UBOOL	DetermineImageIndex(FParticleEmitterInstance* Owner, INT Offset, FBaseParticle* Particle, 
						EParticleSubUVInterpMethod eMethod, FFullSubUVPayload& SubUVPayload, 
						INT& ImageIndex, FLOAT& Interp, FLOAT DeltaTime);
	
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
};

class UParticleModuleSubUVMovie : public UParticleModuleSubUV
{
public:
    //## BEGIN PROPS ParticleModuleSubUVMovie
    BITFIELD bUseEmitterTime:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat FrameRate;
    INT StartingFrame;
    //## END PROPS ParticleModuleSubUVMovie

    DECLARE_CLASS(UParticleModuleSubUVMovie,UParticleModuleSubUV,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);

	/**
	 *	Returns the number of bytes that the module requires in the particle payload block.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return	UINT		The number of bytes the module needs per particle.
	 */
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	
	/**
	 *	Determine the current image index to use...
	 *
	 *	@param	Owner					The emitter instance being updated.
	 *	@param	Offset					The offset to the particle payload for this module.
	 *	@param	Particle				The particle that the image index is being determined for.
	 *	@param	eMethod					The EParticleSubUVInterpMethod method used to update the subUV.
	 *	@param	SubUVPayload			The FFullSubUVPayload for this particle.
	 *	@param	ImageIndex		[out]	The image index to use for the particle.
	 *	@param	Interp			[out]	The current interpolation value (for blending 2 sub-images).
	 *	@param	DeltaTime				The time slice for this update.
	 *
	 *	@return	UBOOL					TRUE if successful, FALSE if not.
	 */
	virtual UBOOL	DetermineImageIndex(FParticleEmitterInstance* Owner, INT Offset, FBaseParticle* Particle, 
						EParticleSubUVInterpMethod eMethod, FFullSubUVPayload& SubUVPayload, 
						INT& ImageIndex, FLOAT& Interp, FLOAT DeltaTime);
	
	/**
	 *	Called when the module is created, this function allows for setting values that make
	 *	sense for the type of emitter they are being used in.
	 *
	 *	@param	Owner			The UParticleEmitter that the module is being added to.
	 */
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);

	/** Fill an array with each Object property that fulfills the FCurveEdInterface interface. */
	virtual void GetCurveObjects(TArray<FParticleCurvePair>& OutCurves);
};

class UParticleModuleSubUVDirect : public UParticleModuleSubUVBase
{
public:
    //## BEGIN PROPS ParticleModuleSubUVDirect
    struct FRawDistributionVector SubUVPosition;
    struct FRawDistributionVector SubUVSize;
    //## END PROPS ParticleModuleSubUVDirect

    DECLARE_CLASS(UParticleModuleSubUVDirect,UParticleModuleSubUVBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateSprite(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	UpdateMesh(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleSubUVSelect : public UParticleModuleSubUVBase
{
public:
    //## BEGIN PROPS ParticleModuleSubUVSelect
    struct FRawDistributionVector SubImageSelect;
    //## END PROPS ParticleModuleSubUVSelect

    DECLARE_CLASS(UParticleModuleSubUVSelect,UParticleModuleSubUVBase,0,Engine)
	virtual void Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleTrailBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleTrailBase
    //## END PROPS ParticleModuleTrailBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleTrailBase,UParticleModule,0,Engine)
	virtual EModuleType	GetModuleType() const	{	return EPMT_Trail;	}
};

class UParticleModuleTrailSource : public UParticleModuleTrailBase
{
public:
    //## BEGIN PROPS ParticleModuleTrailSource
    BYTE SourceMethod;
    BYTE SelectionMethod;
    FName SourceName;
    struct FRawDistributionFloat SourceStrength;
    BITFIELD bLockSourceStength:1;
    BITFIELD bInheritRotation:1;
    INT SourceOffsetCount;
    TArrayNoInit<FVector> SourceOffsetDefaults;
    //## END PROPS ParticleModuleTrailSource

    DECLARE_CLASS(UParticleModuleTrailSource,UParticleModuleTrailBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual void	AutoPopulateInstanceProperties(UParticleSystemComponent* PSysComp);

			void	GetDataPointers(FParticleTrail2EmitterInstance* TrailInst, 
						const BYTE* ParticleBase, INT& CurrentOffset, 
						FTrailParticleSourcePayloadData*& ParticleSource);
			void	GetDataPointerOffsets(FParticleTrail2EmitterInstance* TrailInst, 
						const BYTE* ParticleBase, INT& CurrentOffset, 
						INT& ParticleSourceOffset);
						
			UBOOL	ResolveSourceData(FParticleTrail2EmitterInstance* TrailInst, 
						const BYTE* ParticleBase, FTrail2TypeDataPayload* TrailData, 
						INT& CurrentOffset, INT	ParticleIndex, UBOOL bSpawning);

			UBOOL	ResolveSourcePoint(FParticleTrail2EmitterInstance* TrailInst, 
				FBaseParticle& Particle, FTrail2TypeDataPayload& TrailData, 
				FVector& Position, FVector& Tangent);

			FVector	ResolveSourceOffset(FParticleTrail2EmitterInstance* TrailInst, 
				FBaseParticle& Particle, FTrail2TypeDataPayload& TrailData);

	/**
	 *	Retrieve the SourceOffset for the given trail index.
	 *	Currently, this is only intended for use by Ribbon emitters
	 *
	 *	@param	InTrailIdx			The index of the trail whose offset is being retrieved
	 *	@param	InEmitterInst		The EmitterInstance requesting the SourceOffset
	 *	@param	OutSourceOffset		The source offset for the trail of interest
	 *
	 *	@return	UBOOL				TRUE if successful, FALSE if not (including no offset)
	 */
	UBOOL	ResolveSourceOffset(INT InTrailIdx, FParticleEmitterInstance* InEmitterInst, FVector& OutSourceOffset);

	/**
	 *	Retrieve the ParticleSysParams associated with this module.
	 *
	 *	@param	ParticleSysParamList	The list of FParticleSysParams to add to
	 */
	virtual void GetParticleSysParamsUtilized(TArray<FString>& ParticleSysParamList);
};

class UParticleModuleTrailSpawn : public UParticleModuleTrailBase
{
public:
    //## BEGIN PROPS ParticleModuleTrailSpawn
    class UDistributionFloatParticleParameter* SpawnDistanceMap;
    FLOAT MinSpawnVelocity;
    //## END PROPS ParticleModuleTrailSpawn

    DECLARE_CLASS(UParticleModuleTrailSpawn,UParticleModuleTrailBase,0,Engine)
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void	PostLoad();

	// Trail
//	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
//			INT& CurrentOffset, FBeam2TypeDataPayload*& BeamData, FVector*& InterpolatedPoints, 
//			FLOAT*& NoiseRate, FVector*& TargetNoisePoints, FVector*& CurrentNoisePoints, 
//			FLOAT*& TaperValues);

			UINT	GetSpawnCount(FParticleTrail2EmitterInstance* TrailInst, FLOAT DeltaTime);
};

class UParticleModuleTrailTaper : public UParticleModuleTrailBase
{
public:
    //## BEGIN PROPS ParticleModuleTrailTaper
    BYTE TaperMethod;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat TaperFactor;
    //## END PROPS ParticleModuleTrailTaper

    DECLARE_CLASS(UParticleModuleTrailTaper,UParticleModuleTrailBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// Trail
//	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
//			INT& CurrentOffset, FBeam2TypeDataPayload*& BeamData, FVector*& InterpolatedPoints, 
//			FLOAT*& NoiseRate, FVector*& TargetNoisePoints, FVector*& CurrentNoisePoints, 
//			FLOAT*& TaperValues);
};

class UParticleModuleTypeDataBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataBase
    //## END PROPS ParticleModuleTypeDataBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleTypeDataBase,UParticleModule,0,Engine)
	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);
	virtual void	PreSpawn(FParticleEmitterInstance* Owner, FBaseParticle* Particle)			{};
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime)		{};
	virtual void	PostUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime)	{};

	virtual EModuleType	GetModuleType() const							{	return EPMT_TypeData;	}
	virtual UBOOL		SupportsSpecificScreenAlignmentFlags() const	{	return FALSE;			}
	virtual UBOOL		SupportsSubUV() const	{ return FALSE; }
	virtual UBOOL		IsAMeshEmitter() const	{ return FALSE; }
};

class UParticleModuleTypeDataAnimTrail : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataAnimTrail
    FName ControlEdgeName;
    INT SheetsPerTrail;
    BITFIELD bDeadTrailsOnDeactivate:1;
    BITFIELD bClipSourceSegement:1;
    BITFIELD bEnablePreviousTangentRecalculation:1;
    BITFIELD bTangentRecalculationEveryFrame:1;
    BITFIELD bRenderGeometry:1;
    BITFIELD bRenderSpawnPoints:1;
    BITFIELD bRenderTangents:1;
    BITFIELD bRenderTessellation:1;
    FLOAT TilingDistance;
    FLOAT DistanceTessellationStepSize;
    FLOAT TangentTessellationScalar;
    //## END PROPS ParticleModuleTypeDataAnimTrail

    DECLARE_CLASS(UParticleModuleTypeDataAnimTrail,UParticleModuleTypeDataBase,0,Engine)
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);
};

class UParticleModuleTypeDataApex : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataApex
    class UApexGenericAsset* ApexIOFX;
    class UApexGenericAsset* ApexEmitter;
    //## END PROPS ParticleModuleTypeDataApex

    DECLARE_CLASS(UParticleModuleTypeDataApex,UParticleModuleTypeDataBase,0,Engine)
	virtual FParticleEmitterInstance *CreateInstance(UParticleEmitter *InEmitterParent, UParticleSystemComponent *InComponent);

	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void FinishDestroy();
	
	void ConditionalInitialize(void);
};

class UParticleModuleTypeDataBeam : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataBeam
    BYTE BeamMethod;
    BYTE EndPointMethod;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat Distance;
    struct FRawDistributionVector EndPoint;
    INT TessellationFactor;
    struct FRawDistributionFloat EmitterStrength;
    struct FRawDistributionFloat TargetStrength;
    struct FRawDistributionVector EndPointDirection;
    INT TextureTile;
    BITFIELD RenderGeometry:1;
    BITFIELD RenderDirectLine:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleTypeDataBeam

    DECLARE_CLASS(UParticleModuleTypeDataBeam,UParticleModuleTypeDataBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	FVector			DetermineEndPointPosition(FParticleEmitterInstance* Owner, FLOAT DeltaTime);
	FVector			DetermineParticlePosition(FParticleEmitterInstance* Owner, FBaseParticle* pkParticle, FLOAT DeltaTime);

	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class UParticleModuleTypeDataBeam2 : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataBeam2
    BYTE BeamMethod;
    BYTE TaperMethod;
    INT TextureTile;
    FLOAT TextureTileDistance;
    INT Sheets;
    INT MaxBeamCount;
    FLOAT Speed;
    INT InterpolationPoints;
    BITFIELD bAlwaysOn:1;
    BITFIELD RenderGeometry:1;
    BITFIELD RenderDirectLine:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    INT UpVectorStepSize;
    FName BranchParentName;
    struct FRawDistributionFloat Distance;
    struct FRawDistributionFloat TaperFactor;
    struct FRawDistributionFloat TaperScale;
    //## END PROPS ParticleModuleTypeDataBeam2

    DECLARE_CLASS(UParticleModuleTypeDataBeam2,UParticleModuleTypeDataBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual void	PreUpdate(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);

	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	// For Cascade
	virtual	void	AddModuleCurvesToEditor(UInterpCurveEdSetup* EdSetup);

	// Beam
	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, FBeam2TypeDataPayload*& BeamData, FVector*& InterpolatedPoints, 
			FLOAT*& NoiseRate, FLOAT*& NoiseDeltaTime, FVector*& TargetNoisePoints, 
			FVector*& NextNoisePoints, FLOAT*& TaperValues, FLOAT*& NoiseDistanceScale,
			FBeamParticleModifierPayloadData*& SourceModifier,
			FBeamParticleModifierPayloadData*& TargetModifier);
	virtual void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, INT& BeamDataOffset, INT& InterpolatedPointsOffset, INT& NoiseRateOffset, 
			INT& NoiseDeltaTimeOffset, INT& TargetNoisePointsOffset, INT& NextNoisePointsOffset, 
			INT& TaperCount, INT& TaperValuesOffset, INT& NoiseDistanceScaleOffset);

			void	GetNoiseRange(FVector& NoiseMin, FVector& NoiseMax);
};

class UParticleModuleTypeDataMesh : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataMesh
    class UStaticMesh* Mesh;
    BITFIELD CastShadows:1;
    BITFIELD DoCollisions:1;
    BITFIELD bAllowMotionBlur:1;
    BITFIELD bOverrideMaterial:1;
    BITFIELD bCameraFacing:1;
    BITFIELD bApplyParticleRotationAsSpin:1;
    SCRIPT_ALIGN;
    BYTE MeshAlignment;
    BYTE AxisLockOption;
    BYTE CameraFacingUpAxisOption_DEPRECATED;
    BYTE CameraFacingOption;
    FLOAT Pitch;
    FLOAT Roll;
    FLOAT Yaw;
    //## END PROPS ParticleModuleTypeDataMesh

    DECLARE_CLASS(UParticleModuleTypeDataMesh,UParticleModuleTypeDataBase,0,Engine)
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void	PostLoad();
	virtual FParticleEmitterInstance*	CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);
	virtual void	SetToSensibleDefaults(UParticleEmitter* Owner);
	
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual UBOOL	SupportsSpecificScreenAlignmentFlags() const	{	return TRUE;	}	
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);

	virtual UBOOL	SupportsSubUV() const	{ return TRUE; }
	virtual UBOOL	IsAMeshEmitter() const	{ return TRUE; }
};

struct FPhysXEmitterVerticalLodProperties
{
    FLOAT WeightForFifo;
    FLOAT WeightForSpawnLod;
    FLOAT SpawnLodRateVsLifeBias;
    FLOAT RelativeFadeoutTime;

    /** Constructors */
    FPhysXEmitterVerticalLodProperties() {}
    FPhysXEmitterVerticalLodProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPhysXEmitterVerticalLodProperties));
    }
};

class UParticleModuleTypeDataPhysX : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataPhysX
    class UPhysXParticleSystem* PhysXParSys;
    struct FPhysXEmitterVerticalLodProperties VerticalLod;
    //## END PROPS ParticleModuleTypeDataPhysX

    DECLARE_CLASS(UParticleModuleTypeDataPhysX,UParticleModuleTypeDataBase,0,Engine)
	virtual FParticleEmitterInstance *CreateInstance(UParticleEmitter *InEmitterParent, UParticleSystemComponent *InComponent);

	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void FinishDestroy();

	virtual UBOOL	SupportsSubUV() const	{ return TRUE; }
};

class UParticleModuleTypeDataMeshPhysX : public UParticleModuleTypeDataMesh
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataMeshPhysX
    class UPhysXParticleSystem* PhysXParSys;
    BYTE PhysXRotationMethod;
    FLOAT FluidRotationCoefficient;
    struct FPhysXEmitterVerticalLodProperties VerticalLod;
    FLOAT ZOffset;
    //## END PROPS ParticleModuleTypeDataMeshPhysX

    DECLARE_CLASS(UParticleModuleTypeDataMeshPhysX,UParticleModuleTypeDataMesh,0,Engine)
	virtual FParticleEmitterInstance *CreateInstance(UParticleEmitter *InEmitterParent, UParticleSystemComponent *InComponent);
	virtual void SetToSensibleDefaults(UParticleEmitter* Owner);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void FinishDestroy();

 	virtual UBOOL	SupportsSubUV() const	{ return TRUE; }
	virtual UBOOL	IsAMeshEmitter() const	{ return TRUE; }
};

class UParticleModuleTypeDataRibbon : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataRibbon
    INT MaxTessellationBetweenParticles;
    INT SheetsPerTrail;
    INT MaxTrailCount;
    INT MaxParticleInTrailCount;
    BITFIELD bDeadTrailsOnDeactivate:1;
    BITFIELD bDeadTrailsOnSourceLoss:1;
    BITFIELD bClipSourceSegement:1;
    BITFIELD bEnablePreviousTangentRecalculation:1;
    BITFIELD bTangentRecalculationEveryFrame:1;
    BITFIELD bSpawnInitialParticle:1;
    BITFIELD bRenderGeometry:1;
    BITFIELD bRenderSpawnPoints:1;
    BITFIELD bRenderTangents:1;
    BITFIELD bRenderTessellation:1;
    BITFIELD bEnableTangentDiffInterpScale:1;
    SCRIPT_ALIGN;
    BYTE RenderAxis;
    FLOAT TangentSpawningScalar;
    FLOAT TilingDistance;
    FLOAT DistanceTessellationStepSize;
    FLOAT TangentTessellationScalar;
    //## END PROPS ParticleModuleTypeDataRibbon

    DECLARE_CLASS(UParticleModuleTypeDataRibbon,UParticleModuleTypeDataBase,0,Engine)
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);
};

class UParticleModuleTypeDataTrail : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataTrail
    BITFIELD RenderGeometry:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    BITFIELD Tapered:1;
    BITFIELD SpawnByDistance:1;
    INT TessellationFactor;
    struct FRawDistributionFloat Tension;
    FVector SpawnDistance;
    //## END PROPS ParticleModuleTypeDataTrail

    DECLARE_CLASS(UParticleModuleTypeDataTrail,UParticleModuleTypeDataBase,0,Engine)
	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class UParticleModuleTypeDataTrail2 : public UParticleModuleTypeDataBase
{
public:
    //## BEGIN PROPS ParticleModuleTypeDataTrail2
    INT TessellationFactor;
    FLOAT TessellationFactorDistance;
    FLOAT TessellationStrength;
    INT TextureTile;
    INT Sheets;
    INT MaxTrailCount;
    INT MaxParticleInTrailCount;
    BITFIELD bClipSourceSegement:1;
    BITFIELD bClearTangents:1;
    BITFIELD RenderGeometry:1;
    BITFIELD RenderDirectLine:1;
    BITFIELD RenderLines:1;
    BITFIELD RenderTessellation:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleTypeDataTrail2

    DECLARE_CLASS(UParticleModuleTypeDataTrail2,UParticleModuleTypeDataBase,0,Engine)
	virtual UINT	RequiredBytes(FParticleEmitterInstance* Owner = NULL);
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual FParticleEmitterInstance* CreateInstance(UParticleEmitter* InEmitterParent, UParticleSystemComponent* InComponent);

	// Trail
	virtual void	GetDataPointers(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, FTrail2TypeDataPayload*& TrailData, FLOAT*& TaperValues);
	virtual void	GetDataPointerOffsets(FParticleEmitterInstance* Owner, const BYTE* ParticleBase, 
			INT& CurrentOffset, INT& TrailDataOffset, INT& TaperValuesOffset);
};

class UParticleModuleUberBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleUberBase
    TArrayNoInit<FName> RequiredModules;
    //## END PROPS ParticleModuleUberBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleUberBase,UParticleModule,0,Engine)
	/** This function will determine the proper uber-module to utilize.					*/
	static	UParticleModule*	DetermineBestUberModule(UParticleEmitter* InputEmitter);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL				IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberLTISIVCL : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberLTISIVCL
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    //## END PROPS ParticleModuleUberLTISIVCL

    DECLARE_CLASS(UParticleModuleUberLTISIVCL,UParticleModuleUberBase,0,Engine)
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/** Spawn - called when spawning particles											*/
	virtual void				Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/** Update - called when updating particles											*/
	virtual void				Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleUberLTISIVCLIL : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberLTISIVCLIL
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    struct FRawDistributionVector StartLocation;
    //## END PROPS ParticleModuleUberLTISIVCLIL

    DECLARE_CLASS(UParticleModuleUberLTISIVCLIL,UParticleModuleUberBase,0,Engine)
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/** Spawn - called when spawning particles											*/
	virtual void				Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/** Update - called when updating particles											*/
	virtual void				Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleUberLTISIVCLILIRSSBLIRR : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberLTISIVCLILIRSSBLIRR
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    struct FRawDistributionVector StartLocation;
    struct FRawDistributionFloat StartRotation;
    struct FRawDistributionVector SizeLifeMultiplier;
    BITFIELD SizeMultiplyX:1;
    BITFIELD SizeMultiplyY:1;
    BITFIELD SizeMultiplyZ:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat StartRotationRate;
    //## END PROPS ParticleModuleUberLTISIVCLILIRSSBLIRR

    DECLARE_CLASS(UParticleModuleUberLTISIVCLILIRSSBLIRR,UParticleModuleUberBase,0,Engine)
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/** Spawn - called when spawning particles											*/
	virtual void				Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/** Update - called when updating particles											*/
	virtual void				Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleUberRainDrops : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainDrops
    FLOAT LifetimeMin;
    FLOAT LifetimeMax;
    FVector StartSizeMin;
    FVector StartSizeMax;
    FVector StartVelocityMin;
    FVector StartVelocityMax;
    FLOAT StartVelocityRadialMin;
    FLOAT StartVelocityRadialMax;
    FVector ColorOverLife;
    FLOAT AlphaOverLife;
    BITFIELD bIsUsingCylinder:1;
    BITFIELD bPositive_X:1;
    BITFIELD bPositive_Y:1;
    BITFIELD bPositive_Z:1;
    BITFIELD bNegative_X:1;
    BITFIELD bNegative_Y:1;
    BITFIELD bNegative_Z:1;
    BITFIELD bSurfaceOnly:1;
    BITFIELD bVelocity:1;
    BITFIELD bRadialVelocity:1;
    FLOAT PC_VelocityScale;
    FVector PC_StartLocation;
    FLOAT PC_StartRadius;
    FLOAT PC_StartHeight;
    BYTE PC_HeightAxis;
    SCRIPT_ALIGN;
    FVector StartLocationMin;
    FVector StartLocationMax;
    //## END PROPS ParticleModuleUberRainDrops

    DECLARE_CLASS(UParticleModuleUberRainDrops,UParticleModuleUberBase,0,Engine)
	virtual void	PostLoad();
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);

	void	DetermineUnitDirection(FParticleEmitterInstance* Owner, FVector& vUnitDir);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL				IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleUberRainImpacts : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainImpacts
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartRotation;
    BITFIELD bInheritParent:1;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    BITFIELD bIsUsingCylinder:1;
    BITFIELD bPositive_X:1;
    BITFIELD bPositive_Y:1;
    BITFIELD bPositive_Z:1;
    BITFIELD bNegative_X:1;
    BITFIELD bNegative_Y:1;
    BITFIELD bNegative_Z:1;
    BITFIELD bSurfaceOnly:1;
    BITFIELD bVelocity:1;
    BITFIELD bRadialVelocity:1;
    SCRIPT_ALIGN;
    struct FRawDistributionVector LifeMultiplier;
    struct FRawDistributionFloat PC_VelocityScale;
    struct FRawDistributionVector PC_StartLocation;
    struct FRawDistributionFloat PC_StartRadius;
    struct FRawDistributionFloat PC_StartHeight;
    BYTE PC_HeightAxis;
    SCRIPT_ALIGN;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    //## END PROPS ParticleModuleUberRainImpacts

    DECLARE_CLASS(UParticleModuleUberRainImpacts,UParticleModuleUberBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);

	void	DetermineUnitDirection(FParticleEmitterInstance* Owner, FVector& vUnitDir);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL				IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL				ConvertToUberModule(UParticleEmitter* InputEmitter);

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return TRUE; }
};

class UParticleModuleUberRainSplashA : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainSplashA
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector StartRotation;
    BITFIELD bInheritParent:1;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    SCRIPT_ALIGN;
    struct FRawDistributionVector LifeMultiplier;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    //## END PROPS ParticleModuleUberRainSplashA

    DECLARE_CLASS(UParticleModuleUberRainSplashA,UParticleModuleUberBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL	IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL	ConvertToUberModule(UParticleEmitter* InputEmitter);

	/**
	 *	Return TRUE if this module impacts rotation of Mesh emitters
	 *	@return	UBOOL		TRUE if the module impacts mesh emitter rotation
	 */
	virtual UBOOL	TouchesMeshRotation() const	{ return TRUE; }
};

class UParticleModuleUberRainSplashB : public UParticleModuleUberBase
{
public:
    //## BEGIN PROPS ParticleModuleUberRainSplashB
    struct FRawDistributionFloat Lifetime;
    struct FRawDistributionVector StartSize;
    struct FRawDistributionVector ColorOverLife;
    struct FRawDistributionFloat AlphaOverLife;
    struct FRawDistributionVector LifeMultiplier;
    BITFIELD MultiplyX:1;
    BITFIELD MultiplyY:1;
    BITFIELD MultiplyZ:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat StartRotationRate;
    //## END PROPS ParticleModuleUberRainSplashB

    DECLARE_CLASS(UParticleModuleUberRainSplashB,UParticleModuleUberBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);

	/** Used by derived classes to indicate they could be used on the given emitter.	*/
	virtual	UBOOL	IsCompatible(UParticleEmitter* InputEmitter);
	
	/** Copy the contents of the modules to the UberModule								*/
	virtual	UBOOL	ConvertToUberModule(UParticleEmitter* InputEmitter);
};

class UParticleModuleVelocityBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleVelocityBase
    BITFIELD bInWorldSpace:1;
    BITFIELD bApplyOwnerScale:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleVelocityBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleVelocityBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleVelocityBase)
};

class UParticleModuleVelocity : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocity
    struct FRawDistributionVector StartVelocity;
    struct FRawDistributionFloat StartVelocityRadial;
    //## END PROPS ParticleModuleVelocity

    DECLARE_CLASS(UParticleModuleVelocity,UParticleModuleVelocityBase,0,Engine)
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);
};

class UParticleModuleVelocity_Seeded : public UParticleModuleVelocity
{
public:
    //## BEGIN PROPS ParticleModuleVelocity_Seeded
    struct FParticleRandomSeedInfo RandomSeedInfo;
    //## END PROPS ParticleModuleVelocity_Seeded

    DECLARE_CLASS(UParticleModuleVelocity_Seeded,UParticleModuleVelocity,0,Engine)
	/**
	 *	Called on a particle when it is spawned.
	 *
	 *	@param	Owner			The emitter instance that spawned the particle
	 *	@param	Offset			The payload data offset for this module
	 *	@param	SpawnTime		The spawn time of the particle
	 */
	virtual void Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	/**
	 *	Returns the number of bytes the module requires in the emitters 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *
	 *	@return UINT		The number of bytes the module needs per emitter instance.
	 */
	virtual UINT	RequiredBytesPerInstance(FParticleEmitterInstance* Owner = NULL);
	/**
	 *	Allows the module to prep its 'per-instance' data block.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	InstData	Pointer to the data block for this module.
	 */
	virtual UINT	PrepPerInstanceBlock(FParticleEmitterInstance* Owner, void* InstData);

	/**
	 *	Retrieve the random seed info for this module.
	 *
	 *	@return	FParticleRandomSeedInfo*	The random seed info; NULL if not supported
	 */
	virtual FParticleRandomSeedInfo* GetRandomSeedInfo()
	{
		return &RandomSeedInfo;
	}

	/** 
	 *	Called when an emitter instance is looping...
	 *
	 *	@param	Owner	The emitter instance that owns this module
	 */
	virtual void EmitterLoopingNotify(FParticleEmitterInstance* Owner);
};

class UParticleModuleVelocityCone : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocityCone
    struct FRawDistributionFloat Angle;
    struct FRawDistributionFloat Velocity;
    FVector Direction;
    //## END PROPS ParticleModuleVelocityCone

    DECLARE_CLASS(UParticleModuleVelocityCone,UParticleModuleVelocityBase,0,Engine)
	/**
	 *	Called on a particle that is freshly spawned by the emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that spawned the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	SpawnTime	The time of the spawn.
	 */
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	
	/**
	 *	Extended version of spawn, allows for using a random stream for distribution value retrieval
	 *
	 *	@param	Owner				The particle emitter instance that is spawning
	 *	@param	Offset				The offset to the modules payload data
	 *	@param	SpawnTime			The time of the spawn
	 *	@param	InRandomStream		The random stream to use for retrieving random values
	 */
	void			SpawnEx(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime, class FRandomStream* InRandomStream);

	/** 
	 *	Render the modules 3D visualization helper primitive.
	 *
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the module.
	 *	@param	View		The scene view that is being rendered.
	 *	@param	PDI			The FPrimitiveDrawInterface to use for rendering.
	 */
	virtual void	Render3DPreview(FParticleEmitterInstance* Owner, const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UParticleModuleVelocityInheritParent : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocityInheritParent
    struct FRawDistributionVector Scale;
    //## END PROPS ParticleModuleVelocityInheritParent

    DECLARE_CLASS(UParticleModuleVelocityInheritParent,UParticleModuleVelocityBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
};

class UParticleModuleVelocityOverLifetime : public UParticleModuleVelocityBase
{
public:
    //## BEGIN PROPS ParticleModuleVelocityOverLifetime
    struct FRawDistributionVector VelOverLife;
    BITFIELD Absolute:1;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModuleVelocityOverLifetime

    DECLARE_CLASS(UParticleModuleVelocityOverLifetime,UParticleModuleVelocityBase,0,Engine)
	virtual void	Spawn(FParticleEmitterInstance* Owner, INT Offset, FLOAT SpawnTime);
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleWorldForcesBase : public UParticleModule
{
public:
    //## BEGIN PROPS ParticleModuleWorldForcesBase
    //## END PROPS ParticleModuleWorldForcesBase

    DECLARE_ABSTRACT_CLASS(UParticleModuleWorldForcesBase,UParticleModule,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleWorldForcesBase)
};

class UParticleModulePhysicsVolumes : public UParticleModuleWorldForcesBase
{
public:
    //## BEGIN PROPS ParticleModulePhysicsVolumes
    struct FRawDistributionFloat GlobalInfluence;
    BYTE LevelInfluenceType;
    SCRIPT_ALIGN;
    //## END PROPS ParticleModulePhysicsVolumes

    DECLARE_CLASS(UParticleModulePhysicsVolumes,UParticleModuleWorldForcesBase,0,Engine)
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleWorldAttractor : public UParticleModuleWorldForcesBase
{
public:
    //## BEGIN PROPS ParticleModuleWorldAttractor
    BITFIELD bParticleLifeRelative:1;
    SCRIPT_ALIGN;
    struct FRawDistributionFloat AttractorInfluence;
    //## END PROPS ParticleModuleWorldAttractor

    DECLARE_CLASS(UParticleModuleWorldAttractor,UParticleModuleWorldForcesBase,0,Engine)
	/**
	 *	Called on a particle that is being updated by its emitter.
	 *	
	 *	@param	Owner		The FParticleEmitterInstance that 'owns' the particle.
	 *	@param	Offset		The modules offset into the data payload of the particle.
	 *	@param	DeltaTime	The time since the last update.
	 */
	virtual void	Update(FParticleEmitterInstance* Owner, INT Offset, FLOAT DeltaTime);
};

class UParticleModuleEventSendToGame : public UObject
{
public:
    //## BEGIN PROPS ParticleModuleEventSendToGame
    //## END PROPS ParticleModuleEventSendToGame

    DECLARE_ABSTRACT_CLASS(UParticleModuleEventSendToGame,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UParticleModuleEventSendToGame)
};

struct FParticleEmitterReplayFrame
{
    INT EmitterType;
    INT OriginalEmitterIndex;
    struct FDynamicEmitterReplayDataBase* FrameState;

		/** Constructors */
		FParticleEmitterReplayFrame() {}
		FParticleEmitterReplayFrame( EEventParm )
			: EmitterType( DET_Unknown ),
			  OriginalEmitterIndex( INDEX_NONE ),
			  FrameState( NULL )
		{
		}

		/** Destructor */
		~FParticleEmitterReplayFrame()
		{
			// Clean up frame state
			if( FrameState != NULL )
			{
				delete FrameState;
				FrameState = NULL;
			}
		}

		/** Serialization operator */
		friend FArchive& operator<<( FArchive& Ar, FParticleEmitterReplayFrame& Obj );
	
};

struct FParticleSystemReplayFrame
{
    TArrayNoInit<struct FParticleEmitterReplayFrame> Emitters;

		/** Constructors */
		FParticleSystemReplayFrame() {}
		FParticleSystemReplayFrame( EEventParm )
		{
			appMemzero( this, sizeof( FParticleSystemReplayFrame ) );
		}

		/** Serialization operator */
		friend FArchive& operator<<( FArchive& Ar, FParticleSystemReplayFrame& Obj );
	
};

class UParticleSystemReplay : public UObject
{
public:
    //## BEGIN PROPS ParticleSystemReplay
    INT ClipIDNumber;
    TArrayNoInit<struct FParticleSystemReplayFrame> Frames;
    //## END PROPS ParticleSystemReplay

    DECLARE_CLASS(UParticleSystemReplay,UObject,0,Engine)
	/** Serialization */
	virtual void Serialize( FArchive& Ar );
};

class UPhysXParticleSystem : public UObject
{
public:
    //## BEGIN PROPS PhysXParticleSystem
    INT MaxParticles;
    INT ParticleSpawnReserve;
    BYTE RBChannel;
    BYTE SimulationMethod;
    BYTE PacketSizeMultiplier;
    SCRIPT_ALIGN;
    FRBCollisionChannelContainer RBCollideWithChannels;
    FLOAT CollisionDistance;
    FLOAT RestitutionWithStaticShapes;
    FLOAT RestitutionWithDynamicShapes;
    FLOAT FrictionWithStaticShapes;
    FLOAT FrictionWithDynamicShapes;
    FLOAT StaticFrictionWithStaticShapes;
    FLOAT StaticFrictionWithDynamicShapes;
    BITFIELD bDynamicCollision:1;
    BITFIELD bDisableGravity:1;
    BITFIELD bStaticCollision:1;
    BITFIELD bTwoWayCollision:1;
    BITFIELD bDestroy:1;
    BITFIELD bSyncFailed:1;
    BITFIELD bIsInGame:1;
    FLOAT MaxMotionDistance;
    FLOAT Damping;
    FVector ExternalAcceleration;
    FLOAT RestParticleDistance;
    FLOAT RestDensity;
    FLOAT KernelRadiusMultiplier;
    FLOAT Stiffness;
    FLOAT Viscosity;
    FLOAT CollisionResponseCoefficient;
    class FRBPhysScene* CascadeScene;
    class FPhysXParticleSystem* PSys;
    //## END PROPS PhysXParticleSystem

    DECLARE_CLASS(UPhysXParticleSystem,UObject,0,Engine)
    virtual void FinishDestroy();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PreEditChange(UProperty* PropertyAboutToChange);

    void Tick(FLOAT deltaTime);
    void TickEditor(FLOAT deltaTime);
    void RemovedFromScene();
    void RemoveSpawnInstance(struct FParticleEmitterInstance*);
    UBOOL SyncConnect();
    UBOOL SyncDisconnect();
    UBOOL TryConnect();
    // Particle Data to Sync before physics update
    void PreSyncPhysXData();
    // Particle Data to Sync after physics update
	void PostSyncPhysXData();
	FRBPhysScene* GetScene();
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_PARTICLE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AEmitterCameraLensEffectBase,-1,execUpdateLocation);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetStopSpawning);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execResetToDefaults);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetActive);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execClearParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetMaterialParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetActorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetColorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetVectorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetFloatParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetMaterialParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetActorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetColorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetVectorRandParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetVectorParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetFloatRandParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetFloatParameter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetEditorLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetEditorLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetLODLevel);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSystemHasCompleted);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetMaxLifespan);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execDetermineLODLevelForLocation);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTargetStrength);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTargetTangent);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTargetPoint);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamSourceStrength);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamSourceTangent);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamSourcePoint);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamDistance);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamEndPoint);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamTessellationFactor);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetBeamType);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execRewindEmitterInstances);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execRewindEmitterInstance);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetKillOnCompleted);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetKillOnDeactivate);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetSkipBoundsUpdate);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetSkipBoundsUpdate);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execGetSkipUpdateDynamicDataDuringTick);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetSkipUpdateDynamicDataDuringTick);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execKillParticlesInEmitter);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execKillParticlesForced);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execDeactivateSystem);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execActivateSystem);
AUTOGENERATE_FUNCTION(UParticleSystemComponent,-1,execSetTemplate);
AUTOGENERATE_FUNCTION(UParticleEmitter,-1,execGetMaxLifespan);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetMaxLifespan);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execSetLODDistance);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execSetCurrentLODMethod);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetLODDistance);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetLODLevelCount);
AUTOGENERATE_FUNCTION(UParticleSystem,-1,execGetCurrentLODMethod);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_PARTICLE_NATIVE_DEFS
#define ENGINE_PARTICLE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_PARTICLE \
	AEmitterCameraLensEffectBase::StaticClass(); \
	GNativeLookupFuncs.Set(FName("EmitterCameraLensEffectBase"), GEngineAEmitterCameraLensEffectBaseNatives); \
	AParticleEventManager::StaticClass(); \
	UParticleSystemComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("ParticleSystemComponent"), GEngineUParticleSystemComponentNatives); \
	UDistributionFloatParticleParameter::StaticClass(); \
	UDistributionVectorParticleParameter::StaticClass(); \
	UParticleEmitter::StaticClass(); \
	GNativeLookupFuncs.Set(FName("ParticleEmitter"), GEngineUParticleEmitterNatives); \
	UParticleSpriteEmitter::StaticClass(); \
	UParticleLODLevel::StaticClass(); \
	UParticleModule::StaticClass(); \
	UParticleModuleAccelerationBase::StaticClass(); \
	UParticleModuleAcceleration::StaticClass(); \
	UParticleModuleAccelerationOverLifetime::StaticClass(); \
	UParticleModuleAttractorBase::StaticClass(); \
	UParticleModuleAttractorBoneSocket::StaticClass(); \
	UParticleModuleAttractorLine::StaticClass(); \
	UParticleModuleAttractorParticle::StaticClass(); \
	UParticleModuleAttractorPoint::StaticClass(); \
	UParticleModuleAttractorSkelVertSurface::StaticClass(); \
	UParticleModuleBeamBase::StaticClass(); \
	UParticleModuleBeamModifier::StaticClass(); \
	UParticleModuleBeamNoise::StaticClass(); \
	UParticleModuleBeamSource::StaticClass(); \
	UParticleModuleBeamTarget::StaticClass(); \
	UParticleModuleCameraBase::StaticClass(); \
	UParticleModuleCameraOffset::StaticClass(); \
	UParticleModuleCollisionBase::StaticClass(); \
	UParticleModuleCollision::StaticClass(); \
	UParticleModuleCollisionActor::StaticClass(); \
	UParticleModuleColorBase::StaticClass(); \
	UParticleModuleColor::StaticClass(); \
	UParticleModuleColor_Seeded::StaticClass(); \
	UParticleModuleColorByParameter::StaticClass(); \
	UParticleModuleColorOverLife::StaticClass(); \
	UParticleModuleColorScaleOverDensity::StaticClass(); \
	UParticleModuleColorScaleOverLife::StaticClass(); \
	UParticleModuleEventBase::StaticClass(); \
	UParticleModuleEventGenerator::StaticClass(); \
	UParticleModuleEventReceiverBase::StaticClass(); \
	UParticleModuleEventReceiverKillParticles::StaticClass(); \
	UParticleModuleEventReceiverSpawn::StaticClass(); \
	UParticleModuleKillBase::StaticClass(); \
	UParticleModuleKillBox::StaticClass(); \
	UParticleModuleKillHeight::StaticClass(); \
	UParticleModuleLifetimeBase::StaticClass(); \
	UParticleModuleLifetime::StaticClass(); \
	UParticleModuleLifetime_Seeded::StaticClass(); \
	UParticleModuleLocationBase::StaticClass(); \
	UParticleModuleLocation::StaticClass(); \
	UParticleModuleLocation_Seeded::StaticClass(); \
	UParticleModuleLocationWorldOffset::StaticClass(); \
	UParticleModuleLocationWorldOffset_Seeded::StaticClass(); \
	UParticleModuleLocationBoneSocket::StaticClass(); \
	UParticleModuleLocationDirect::StaticClass(); \
	UParticleModuleLocationEmitter::StaticClass(); \
	UParticleModuleLocationEmitterDirect::StaticClass(); \
	UParticleModuleLocationPrimitiveBase::StaticClass(); \
	UParticleModuleLocationPrimitiveCylinder::StaticClass(); \
	UParticleModuleLocationPrimitiveCylinder_Seeded::StaticClass(); \
	UParticleModuleLocationPrimitiveSphere::StaticClass(); \
	UParticleModuleLocationPrimitiveSphere_Seeded::StaticClass(); \
	UParticleModuleLocationSkelVertSurface::StaticClass(); \
	UParticleModuleLocationStaticVertSurface::StaticClass(); \
	UParticleModuleSourceMovement::StaticClass(); \
	UParticleModuleMaterialBase::StaticClass(); \
	UParticleModuleMaterialByParameter::StaticClass(); \
	UParticleModuleMeshMaterial::StaticClass(); \
	UParticleModuleOrbitBase::StaticClass(); \
	UParticleModuleOrbit::StaticClass(); \
	UParticleModuleOrientationBase::StaticClass(); \
	UParticleModuleOrientationAxisLock::StaticClass(); \
	UParticleModuleParameterBase::StaticClass(); \
	UParticleModuleParameterDynamic::StaticClass(); \
	UParticleModuleParameterDynamic_Seeded::StaticClass(); \
	UParticleModuleRequired::StaticClass(); \
	UParticleModuleRotationBase::StaticClass(); \
	UParticleModuleMeshRotation::StaticClass(); \
	UParticleModuleMeshRotation_Seeded::StaticClass(); \
	UParticleModuleRotation::StaticClass(); \
	UParticleModuleRotation_Seeded::StaticClass(); \
	UParticleModuleRotationOverLifetime::StaticClass(); \
	UParticleModuleRotationRateBase::StaticClass(); \
	UParticleModuleMeshRotationRate::StaticClass(); \
	UParticleModuleMeshRotationRate_Seeded::StaticClass(); \
	UParticleModuleMeshRotationRateMultiplyLife::StaticClass(); \
	UParticleModuleMeshRotationRateOverLife::StaticClass(); \
	UParticleModuleRotationRate::StaticClass(); \
	UParticleModuleRotationRate_Seeded::StaticClass(); \
	UParticleModuleRotationRateMultiplyLife::StaticClass(); \
	UParticleModuleSizeBase::StaticClass(); \
	UParticleModuleSize::StaticClass(); \
	UParticleModuleSize_Seeded::StaticClass(); \
	UParticleModuleSizeMultiplyLife::StaticClass(); \
	UParticleModuleSizeMultiplyVelocity::StaticClass(); \
	UParticleModuleSizeScale::StaticClass(); \
	UParticleModuleSizeScaleByTime::StaticClass(); \
	UParticleModuleSizeScaleOverDensity::StaticClass(); \
	UParticleModuleSpawnBase::StaticClass(); \
	UParticleModuleSpawn::StaticClass(); \
	UParticleModuleSpawnPerUnit::StaticClass(); \
	UParticleModuleStoreSpawnTimeBase::StaticClass(); \
	UParticleModuleStoreSpawnTime::StaticClass(); \
	UParticleModuleSubUVBase::StaticClass(); \
	UParticleModuleSubUV::StaticClass(); \
	UParticleModuleSubUVMovie::StaticClass(); \
	UParticleModuleSubUVDirect::StaticClass(); \
	UParticleModuleSubUVSelect::StaticClass(); \
	UParticleModuleTrailBase::StaticClass(); \
	UParticleModuleTrailSource::StaticClass(); \
	UParticleModuleTrailSpawn::StaticClass(); \
	UParticleModuleTrailTaper::StaticClass(); \
	UParticleModuleTypeDataBase::StaticClass(); \
	UParticleModuleTypeDataAnimTrail::StaticClass(); \
	UParticleModuleTypeDataApex::StaticClass(); \
	UParticleModuleTypeDataBeam::StaticClass(); \
	UParticleModuleTypeDataBeam2::StaticClass(); \
	UParticleModuleTypeDataMesh::StaticClass(); \
	UParticleModuleTypeDataMeshPhysX::StaticClass(); \
	UParticleModuleTypeDataPhysX::StaticClass(); \
	UParticleModuleTypeDataRibbon::StaticClass(); \
	UParticleModuleTypeDataTrail::StaticClass(); \
	UParticleModuleTypeDataTrail2::StaticClass(); \
	UParticleModuleUberBase::StaticClass(); \
	UParticleModuleUberLTISIVCL::StaticClass(); \
	UParticleModuleUberLTISIVCLIL::StaticClass(); \
	UParticleModuleUberLTISIVCLILIRSSBLIRR::StaticClass(); \
	UParticleModuleUberRainDrops::StaticClass(); \
	UParticleModuleUberRainImpacts::StaticClass(); \
	UParticleModuleUberRainSplashA::StaticClass(); \
	UParticleModuleUberRainSplashB::StaticClass(); \
	UParticleModuleVelocityBase::StaticClass(); \
	UParticleModuleVelocity::StaticClass(); \
	UParticleModuleVelocity_Seeded::StaticClass(); \
	UParticleModuleVelocityCone::StaticClass(); \
	UParticleModuleVelocityInheritParent::StaticClass(); \
	UParticleModuleVelocityOverLifetime::StaticClass(); \
	UParticleModuleWorldForcesBase::StaticClass(); \
	UParticleModulePhysicsVolumes::StaticClass(); \
	UParticleModuleWorldAttractor::StaticClass(); \
	UParticleModuleEventSendToGame::StaticClass(); \
	UParticleSystem::StaticClass(); \
	GNativeLookupFuncs.Set(FName("ParticleSystem"), GEngineUParticleSystemNatives); \
	UParticleSystemReplay::StaticClass(); \
	UPhysXParticleSystem::StaticClass(); \

#endif // ENGINE_PARTICLE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineAEmitterCameraLensEffectBaseNatives[] = 
{ 
	MAP_NATIVE(AEmitterCameraLensEffectBase, execUpdateLocation)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUParticleSystemComponentNatives[] = 
{ 
	MAP_NATIVE(UParticleSystemComponent, execSetStopSpawning)
	MAP_NATIVE(UParticleSystemComponent, execResetToDefaults)
	MAP_NATIVE(UParticleSystemComponent, execSetActive)
	MAP_NATIVE(UParticleSystemComponent, execClearParameter)
	MAP_NATIVE(UParticleSystemComponent, execGetMaterialParameter)
	MAP_NATIVE(UParticleSystemComponent, execGetActorParameter)
	MAP_NATIVE(UParticleSystemComponent, execGetColorParameter)
	MAP_NATIVE(UParticleSystemComponent, execGetVectorParameter)
	MAP_NATIVE(UParticleSystemComponent, execGetFloatParameter)
	MAP_NATIVE(UParticleSystemComponent, execSetMaterialParameter)
	MAP_NATIVE(UParticleSystemComponent, execSetActorParameter)
	MAP_NATIVE(UParticleSystemComponent, execSetColorParameter)
	MAP_NATIVE(UParticleSystemComponent, execSetVectorRandParameter)
	MAP_NATIVE(UParticleSystemComponent, execSetVectorParameter)
	MAP_NATIVE(UParticleSystemComponent, execSetFloatRandParameter)
	MAP_NATIVE(UParticleSystemComponent, execSetFloatParameter)
	MAP_NATIVE(UParticleSystemComponent, execGetEditorLODLevel)
	MAP_NATIVE(UParticleSystemComponent, execGetLODLevel)
	MAP_NATIVE(UParticleSystemComponent, execSetEditorLODLevel)
	MAP_NATIVE(UParticleSystemComponent, execSetLODLevel)
	MAP_NATIVE(UParticleSystemComponent, execSystemHasCompleted)
	MAP_NATIVE(UParticleSystemComponent, execGetMaxLifespan)
	MAP_NATIVE(UParticleSystemComponent, execDetermineLODLevelForLocation)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamTargetStrength)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamTargetTangent)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamTargetPoint)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamSourceStrength)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamSourceTangent)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamSourcePoint)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamDistance)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamEndPoint)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamTessellationFactor)
	MAP_NATIVE(UParticleSystemComponent, execSetBeamType)
	MAP_NATIVE(UParticleSystemComponent, execRewindEmitterInstances)
	MAP_NATIVE(UParticleSystemComponent, execRewindEmitterInstance)
	MAP_NATIVE(UParticleSystemComponent, execSetKillOnCompleted)
	MAP_NATIVE(UParticleSystemComponent, execSetKillOnDeactivate)
	MAP_NATIVE(UParticleSystemComponent, execGetSkipBoundsUpdate)
	MAP_NATIVE(UParticleSystemComponent, execSetSkipBoundsUpdate)
	MAP_NATIVE(UParticleSystemComponent, execGetSkipUpdateDynamicDataDuringTick)
	MAP_NATIVE(UParticleSystemComponent, execSetSkipUpdateDynamicDataDuringTick)
	MAP_NATIVE(UParticleSystemComponent, execKillParticlesInEmitter)
	MAP_NATIVE(UParticleSystemComponent, execKillParticlesForced)
	MAP_NATIVE(UParticleSystemComponent, execDeactivateSystem)
	MAP_NATIVE(UParticleSystemComponent, execActivateSystem)
	MAP_NATIVE(UParticleSystemComponent, execSetTemplate)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUParticleEmitterNatives[] = 
{ 
	MAP_NATIVE(UParticleEmitter, execGetMaxLifespan)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUParticleSystemNatives[] = 
{ 
	MAP_NATIVE(UParticleSystem, execGetMaxLifespan)
	MAP_NATIVE(UParticleSystem, execSetLODDistance)
	MAP_NATIVE(UParticleSystem, execSetCurrentLODMethod)
	MAP_NATIVE(UParticleSystem, execGetLODDistance)
	MAP_NATIVE(UParticleSystem, execGetLODLevelCount)
	MAP_NATIVE(UParticleSystem, execGetCurrentLODMethod)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(AEmitterCameraLensEffectBase,EmitterCameraLensEffectBase,PS_CameraEffect)
VERIFY_CLASS_OFFSET_NODIE(AEmitterCameraLensEffectBase,EmitterCameraLensEffectBase,BaseCamera)
VERIFY_CLASS_SIZE_NODIE(AEmitterCameraLensEffectBase)
VERIFY_CLASS_SIZE_NODIE(AParticleEventManager)
VERIFY_CLASS_OFFSET_NODIE(UParticleSystemComponent,ParticleSystemComponent,Template)
VERIFY_CLASS_OFFSET_NODIE(UParticleSystemComponent,ParticleSystemComponent,__OnSystemFinished__Delegate)
VERIFY_CLASS_SIZE_NODIE(UParticleSystemComponent)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatParticleParameter)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorParticleParameter)
VERIFY_CLASS_OFFSET_NODIE(UParticleEmitter,ParticleEmitter,EmitterName)
VERIFY_CLASS_OFFSET_NODIE(UParticleEmitter,ParticleEmitter,MediumDetailSpawnRateScale)
VERIFY_CLASS_SIZE_NODIE(UParticleEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleSpriteEmitter)
VERIFY_CLASS_OFFSET_NODIE(UParticleLODLevel,ParticleLODLevel,Level)
VERIFY_CLASS_OFFSET_NODIE(UParticleLODLevel,ParticleLODLevel,PeakActiveParticles)
VERIFY_CLASS_SIZE_NODIE(UParticleLODLevel)
VERIFY_CLASS_OFFSET_NODIE(UParticleModule,ParticleModule,LODValidity)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UParticleModule,ParticleModule,ModuleEditorColor)
#endif
VERIFY_CLASS_SIZE_NODIE(UParticleModule)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAccelerationBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAcceleration,ParticleModuleAcceleration,Acceleration)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAcceleration)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAccelerationOverLifetime,ParticleModuleAccelerationOverLifetime,AccelOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAccelerationOverLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorBoneSocket,ParticleModuleAttractorBoneSocket,FalloffType)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorBoneSocket,ParticleModuleAttractorBoneSocket,EditorSkelMesh)
#else
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorBoneSocket,ParticleModuleAttractorBoneSocket,SkelMeshActorParamName)
#endif
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorBoneSocket)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorLine,ParticleModuleAttractorLine,EndPoint0)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorLine,ParticleModuleAttractorLine,Strength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorLine)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorParticle,ParticleModuleAttractorParticle,EmitterName)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorParticle,ParticleModuleAttractorParticle,LastSelIndex)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorParticle)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorPoint,ParticleModuleAttractorPoint,Position)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorPoint,ParticleModuleAttractorPoint,Strength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorPoint)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorSkelVertSurface,ParticleModuleAttractorSkelVertSurface,FalloffType)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleAttractorSkelVertSurface,ParticleModuleAttractorSkelVertSurface,ValidMaterialIndices)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorSkelVertSurface)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleBeamModifier,ParticleModuleBeamModifier,ModifierType)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleBeamModifier,ParticleModuleBeamModifier,Strength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamModifier)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleBeamNoise,ParticleModuleBeamNoise,Frequency)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleBeamNoise,ParticleModuleBeamNoise,NoiseScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamNoise)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleBeamSource,ParticleModuleBeamSource,SourceMethod)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleBeamSource,ParticleModuleBeamSource,SourceStrength)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamSource)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleBeamTarget,ParticleModuleBeamTarget,TargetMethod)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleBeamTarget,ParticleModuleBeamTarget,LockRadius)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleBeamTarget)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCameraBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleCameraOffset,ParticleModuleCameraOffset,CameraOffset)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleCameraOffset,ParticleModuleCameraOffset,UpdateMethod)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCameraOffset)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCollisionBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleCollision,ParticleModuleCollision,DampingFactor)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleCollision,ParticleModuleCollision,ParticleAttractorCollisionActions)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCollision)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleCollisionActor,ParticleModuleCollisionActor,ActorsToCollideWith)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCollisionActor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColor,ParticleModuleColor,StartColor)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColor,ParticleModuleColor,StartAlpha)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColor)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColor_Seeded,ParticleModuleColor_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColor_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColorByParameter,ParticleModuleColorByParameter,ColorParam)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColorByParameter,ParticleModuleColorByParameter,DefaultColor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorByParameter)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColorOverLife,ParticleModuleColorOverLife,ColorOverLife)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColorOverLife,ParticleModuleColorOverLife,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorOverLife)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColorScaleOverDensity,ParticleModuleColorScaleOverDensity,ColorScaleOverDensity)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColorScaleOverDensity,ParticleModuleColorScaleOverDensity,AlphaScaleOverDensity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorScaleOverDensity)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColorScaleOverLife,ParticleModuleColorScaleOverLife,ColorScaleOverLife)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleColorScaleOverLife,ParticleModuleColorScaleOverLife,AlphaScaleOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorScaleOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleEventGenerator,ParticleModuleEventGenerator,Events)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventGenerator)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleEventReceiverBase,ParticleModuleEventReceiverBase,EventGeneratorType)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleEventReceiverBase,ParticleModuleEventReceiverBase,EventName)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventReceiverBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventReceiverKillParticles)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleEventReceiverSpawn,ParticleModuleEventReceiverSpawn,SpawnCount)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleEventReceiverSpawn,ParticleModuleEventReceiverSpawn,InheritVelocityScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventReceiverSpawn)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleKillBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleKillBox,ParticleModuleKillBox,LowerLeftCorner)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleKillBox,ParticleModuleKillBox,UpperRightCorner)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleKillBox)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleKillHeight,ParticleModuleKillHeight,Height)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleKillHeight)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLifetimeBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLifetime,ParticleModuleLifetime,Lifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLifetime)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLifetime_Seeded,ParticleModuleLifetime_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLifetime_Seeded)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocation,ParticleModuleLocation,StartLocation)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocation,ParticleModuleLocation,DistributeThreshold)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocation)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocation_Seeded,ParticleModuleLocation_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocation_Seeded)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationWorldOffset)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationWorldOffset_Seeded,ParticleModuleLocationWorldOffset_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationWorldOffset_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationBoneSocket,ParticleModuleLocationBoneSocket,SourceType)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationBoneSocket,ParticleModuleLocationBoneSocket,LastUpdateTime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationBoneSocket)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationDirect,ParticleModuleLocationDirect,Location)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationDirect,ParticleModuleLocationDirect,Direction)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationDirect)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationEmitter,ParticleModuleLocationEmitter,EmitterName)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationEmitter,ParticleModuleLocationEmitter,InheritSourceRotationScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationEmitter)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationEmitterDirect,ParticleModuleLocationEmitterDirect,EmitterName)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationEmitterDirect)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationPrimitiveBase,ParticleModuleLocationPrimitiveBase,VelocityScale)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationPrimitiveBase,ParticleModuleLocationPrimitiveBase,StartLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationPrimitiveCylinder,ParticleModuleLocationPrimitiveCylinder,StartRadius)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationPrimitiveCylinder,ParticleModuleLocationPrimitiveCylinder,HeightAxis)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveCylinder)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationPrimitiveCylinder_Seeded,ParticleModuleLocationPrimitiveCylinder_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveCylinder_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationPrimitiveSphere,ParticleModuleLocationPrimitiveSphere,StartRadius)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveSphere)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationPrimitiveSphere_Seeded,ParticleModuleLocationPrimitiveSphere_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationPrimitiveSphere_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationSkelVertSurface,ParticleModuleLocationSkelVertSurface,SourceType)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationSkelVertSurface,ParticleModuleLocationSkelVertSurface,ValidMaterialIndices)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationSkelVertSurface)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationStaticVertSurface,ParticleModuleLocationStaticVertSurface,SourceType)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleLocationStaticVertSurface,ParticleModuleLocationStaticVertSurface,ValidMaterialIndices)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationStaticVertSurface)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSourceMovement,ParticleModuleSourceMovement,SourceMovementScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSourceMovement)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMaterialBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleMaterialByParameter,ParticleModuleMaterialByParameter,MaterialParameters)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleMaterialByParameter,ParticleModuleMaterialByParameter,DefaultMaterials)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMaterialByParameter)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleMeshMaterial,ParticleModuleMeshMaterial,MeshMaterials)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshMaterial)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrbitBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleOrbit,ParticleModuleOrbit,ChainMode)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleOrbit,ParticleModuleOrbit,RotationRateOptions)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrbit)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrientationBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleOrientationAxisLock,ParticleModuleOrientationAxisLock,LockAxisFlags)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleOrientationAxisLock)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleParameterBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleParameterDynamic,ParticleModuleParameterDynamic,DynamicParams)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleParameterDynamic,ParticleModuleParameterDynamic,UpdateFlags)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleParameterDynamic)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleParameterDynamic_Seeded,ParticleModuleParameterDynamic_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleParameterDynamic_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleRequired,ParticleModuleRequired,Material)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleRequired,ParticleModuleRequired,NormalsCylinderDirection)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRequired)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleMeshRotation,ParticleModuleMeshRotation,StartRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotation)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleMeshRotation_Seeded,ParticleModuleMeshRotation_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotation_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleRotation,ParticleModuleRotation,StartRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotation)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleRotation_Seeded,ParticleModuleRotation_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotation_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleRotationOverLifetime,ParticleModuleRotationOverLifetime,RotationOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationOverLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRateBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleMeshRotationRate,ParticleModuleMeshRotationRate,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotationRate)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleMeshRotationRate_Seeded,ParticleModuleMeshRotationRate_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotationRate_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleMeshRotationRateMultiplyLife,ParticleModuleMeshRotationRateMultiplyLife,LifeMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotationRateMultiplyLife)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleMeshRotationRateOverLife,ParticleModuleMeshRotationRateOverLife,RotRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotationRateOverLife)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleRotationRate,ParticleModuleRotationRate,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRate)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleRotationRate_Seeded,ParticleModuleRotationRate_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRate_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleRotationRateMultiplyLife,ParticleModuleRotationRateMultiplyLife,LifeMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRateMultiplyLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSize,ParticleModuleSize,StartSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSize)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSize_Seeded,ParticleModuleSize_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSize_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSizeMultiplyLife,ParticleModuleSizeMultiplyLife,LifeMultiplier)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeMultiplyLife)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSizeMultiplyVelocity,ParticleModuleSizeMultiplyVelocity,VelocityMultiplier)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSizeMultiplyVelocity,ParticleModuleSizeMultiplyVelocity,CapMinSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeMultiplyVelocity)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSizeScale,ParticleModuleSizeScale,SizeScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeScale)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSizeScaleByTime,ParticleModuleSizeScaleByTime,SizeScaleByTime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeScaleByTime)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSizeScaleOverDensity,ParticleModuleSizeScaleOverDensity,SizeScaleOverDensity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeScaleOverDensity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSpawnBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSpawn,ParticleModuleSpawn,Rate)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSpawn,ParticleModuleSpawn,BurstList)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSpawn)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSpawnPerUnit,ParticleModuleSpawnPerUnit,UnitScalar)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSpawnPerUnit,ParticleModuleSpawnPerUnit,MinFrameDistance)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSpawnPerUnit)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleStoreSpawnTimeBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleStoreSpawnTime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSubUV,ParticleModuleSubUV,SubImageIndex)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUV)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSubUVMovie,ParticleModuleSubUVMovie,FrameRate)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSubUVMovie,ParticleModuleSubUVMovie,StartingFrame)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVMovie)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSubUVDirect,ParticleModuleSubUVDirect,SubUVPosition)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSubUVDirect,ParticleModuleSubUVDirect,SubUVSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVDirect)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleSubUVSelect,ParticleModuleSubUVSelect,SubImageSelect)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVSelect)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTrailSource,ParticleModuleTrailSource,SourceMethod)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTrailSource,ParticleModuleTrailSource,SourceOffsetDefaults)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailSource)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTrailSpawn,ParticleModuleTrailSpawn,SpawnDistanceMap)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTrailSpawn,ParticleModuleTrailSpawn,MinSpawnVelocity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailSpawn)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTrailTaper,ParticleModuleTrailTaper,TaperMethod)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTrailTaper,ParticleModuleTrailTaper,TaperFactor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTrailTaper)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataAnimTrail,ParticleModuleTypeDataAnimTrail,ControlEdgeName)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataAnimTrail,ParticleModuleTypeDataAnimTrail,TangentTessellationScalar)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataAnimTrail)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataApex,ParticleModuleTypeDataApex,ApexIOFX)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataApex,ParticleModuleTypeDataApex,ApexEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataApex)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataBeam,ParticleModuleTypeDataBeam,BeamMethod)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataBeam,ParticleModuleTypeDataBeam,TextureTile)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBeam)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataBeam2,ParticleModuleTypeDataBeam2,BeamMethod)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataBeam2,ParticleModuleTypeDataBeam2,TaperScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBeam2)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataMesh,ParticleModuleTypeDataMesh,Mesh)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataMesh,ParticleModuleTypeDataMesh,Yaw)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataMesh)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataMeshPhysX,ParticleModuleTypeDataMeshPhysX,PhysXParSys)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataMeshPhysX,ParticleModuleTypeDataMeshPhysX,ZOffset)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataMeshPhysX)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataPhysX,ParticleModuleTypeDataPhysX,PhysXParSys)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataPhysX,ParticleModuleTypeDataPhysX,VerticalLod)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataPhysX)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataRibbon,ParticleModuleTypeDataRibbon,MaxTessellationBetweenParticles)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataRibbon,ParticleModuleTypeDataRibbon,TangentTessellationScalar)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataRibbon)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataTrail,ParticleModuleTypeDataTrail,TessellationFactor)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataTrail,ParticleModuleTypeDataTrail,SpawnDistance)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataTrail)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataTrail2,ParticleModuleTypeDataTrail2,TessellationFactor)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleTypeDataTrail2,ParticleModuleTypeDataTrail2,MaxParticleInTrailCount)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataTrail2)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberBase,ParticleModuleUberBase,RequiredModules)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberLTISIVCL,ParticleModuleUberLTISIVCL,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberLTISIVCL,ParticleModuleUberLTISIVCL,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberLTISIVCL)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberLTISIVCLIL,ParticleModuleUberLTISIVCLIL,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberLTISIVCLIL,ParticleModuleUberLTISIVCLIL,StartLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberLTISIVCLIL)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberLTISIVCLILIRSSBLIRR,ParticleModuleUberLTISIVCLILIRSSBLIRR,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberLTISIVCLILIRSSBLIRR,ParticleModuleUberLTISIVCLILIRSSBLIRR,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberLTISIVCLILIRSSBLIRR)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberRainDrops,ParticleModuleUberRainDrops,LifetimeMin)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberRainDrops,ParticleModuleUberRainDrops,StartLocationMax)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainDrops)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberRainImpacts,ParticleModuleUberRainImpacts,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberRainImpacts,ParticleModuleUberRainImpacts,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainImpacts)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberRainSplashA,ParticleModuleUberRainSplashA,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberRainSplashA,ParticleModuleUberRainSplashA,AlphaOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainSplashA)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberRainSplashB,ParticleModuleUberRainSplashB,Lifetime)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleUberRainSplashB,ParticleModuleUberRainSplashB,StartRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleUberRainSplashB)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleVelocity,ParticleModuleVelocity,StartVelocity)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleVelocity,ParticleModuleVelocity,StartVelocityRadial)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocity)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleVelocity_Seeded,ParticleModuleVelocity_Seeded,RandomSeedInfo)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocity_Seeded)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleVelocityCone,ParticleModuleVelocityCone,Angle)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleVelocityCone,ParticleModuleVelocityCone,Direction)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityCone)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleVelocityInheritParent,ParticleModuleVelocityInheritParent,Scale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityInheritParent)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleVelocityOverLifetime,ParticleModuleVelocityOverLifetime,VelOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityOverLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleWorldForcesBase)
VERIFY_CLASS_OFFSET_NODIE(UParticleModulePhysicsVolumes,ParticleModulePhysicsVolumes,GlobalInfluence)
VERIFY_CLASS_OFFSET_NODIE(UParticleModulePhysicsVolumes,ParticleModulePhysicsVolumes,LevelInfluenceType)
VERIFY_CLASS_SIZE_NODIE(UParticleModulePhysicsVolumes)
VERIFY_CLASS_OFFSET_NODIE(UParticleModuleWorldAttractor,ParticleModuleWorldAttractor,AttractorInfluence)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleWorldAttractor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleEventSendToGame)
VERIFY_CLASS_OFFSET_NODIE(UParticleSystem,ParticleSystem,SystemUpdateMode)
VERIFY_CLASS_OFFSET_NODIE(UParticleSystem,ParticleSystem,SoloTracking)
VERIFY_CLASS_SIZE_NODIE(UParticleSystem)
VERIFY_CLASS_OFFSET_NODIE(UParticleSystemReplay,ParticleSystemReplay,ClipIDNumber)
VERIFY_CLASS_OFFSET_NODIE(UParticleSystemReplay,ParticleSystemReplay,Frames)
VERIFY_CLASS_SIZE_NODIE(UParticleSystemReplay)
VERIFY_CLASS_OFFSET_NODIE(UPhysXParticleSystem,PhysXParticleSystem,MaxParticles)
VERIFY_CLASS_OFFSET_NODIE(UPhysXParticleSystem,PhysXParticleSystem,PSys)
VERIFY_CLASS_SIZE_NODIE(UPhysXParticleSystem)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
