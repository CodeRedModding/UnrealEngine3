/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineUserInterfaceGlobalIncludes.h"

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_USERINTERFACE_ENUMS
#define INCLUDED_ENGINE_USERINTERFACE_ENUMS 1

enum EInputPlatformType
{
    IPT_PC                  =0,
    IPT_360                 =1,
    IPT_PS3                 =2,
    IPT_MAX                 =3,
};
#define FOREACH_ENUM_EINPUTPLATFORMTYPE(op) \
    op(IPT_PC) \
    op(IPT_360) \
    op(IPT_PS3) 
enum ETouchType
{
    Touch_Began             =0,
    Touch_Moved             =1,
    Touch_Stationary        =2,
    Touch_Ended             =3,
    Touch_Cancelled         =4,
    Touch_MAX               =5,
};
#define FOREACH_ENUM_ETOUCHTYPE(op) \
    op(Touch_Began) \
    op(Touch_Moved) \
    op(Touch_Stationary) \
    op(Touch_Ended) \
    op(Touch_Cancelled) 

#endif // !INCLUDED_ENGINE_USERINTERFACE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_USERINTERFACE_CLASSES
#define INCLUDED_ENGINE_USERINTERFACE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

#define UCONST_MAX_SUPPORTED_GAMEPADS 4
#define UCONST_DEFAULT_SIZE_Y 768
#define UCONST_DEFAULT_SIZE_X 1024

struct FUIRangeData
{
private:
    FLOAT CurrentValue;
public:
    FLOAT MinValue;
    FLOAT MaxValue;
private:
    FLOAT NudgeValue;
public:
    BITFIELD bIntRange:1;
    SCRIPT_ALIGN;

	/** Constructors */
	FUIRangeData() {}
	FUIRangeData(EEventParm)
	: CurrentValue(0.f), MinValue(0.f), MaxValue(0.f), NudgeValue(0.f), bIntRange(FALSE)
	{}

	FUIRangeData( const FUIRangeData& Other )
	: CurrentValue(Other.CurrentValue)
	, MinValue(Other.MinValue), MaxValue(Other.MaxValue)
	, NudgeValue(Other.NudgeValue), bIntRange(Other.bIntRange)
	{}

	/** Comparison operators */
	UBOOL operator==( const FUIRangeData& Other ) const;
	UBOOL operator!=( const FUIRangeData& Other ) const;

	/**
	 * Returns true if any values in this struct are non-zero.
	 */
	UBOOL HasValue() const;

	/**
	 * Returns the amount that this range should be incremented/decremented when nudging.
	 */
	FLOAT GetNudgeValue() const;

	/**
	 * Sets the NudgeValue for this UIRangeData to the value specified.
	 */
	void SetNudgeValue( FLOAT NewNudgeValue )
	{
		NudgeValue = NewNudgeValue;
	}

	/**
	 * Returns the current value of this UIRange.
	 */
	FLOAT GetCurrentValue() const;

	/**
	 * Sets the value of this UIRange.
	 *
	 * @param	NewValue				the new value to assign to this UIRange.
	 * @param	bClampInvalidValues		specify TRUE to automatically clamp NewValue to a valid value for this UIRange.
	 *
	 * @return	TRUE if the value was successfully assigned.  FALSE if NewValue was outside the valid range and
	 *			bClampInvalidValues was FALSE or MinValue <= MaxValue.
	 */
	UBOOL SetCurrentValue( FLOAT NewValue, UBOOL bClampInvalidValues=TRUE );

};

struct FTextureCoordinates
{
    FLOAT U;
    FLOAT V;
    FLOAT UL;
    FLOAT VL;

	/** Constructors */
	FTextureCoordinates()
	{ }

	FTextureCoordinates(EEventParm)
	: U(0), V(0), UL(0), VL(0)
	{}

	FTextureCoordinates( FLOAT inU, FLOAT inV, FLOAT inUL, FLOAT inVL )
	: U(inU), V(inV), UL(inUL), VL(inVL)
	{ }

	/**
	 * Returns whether the values in this coordinate are zero, accounting for floating point
	 * precision errors.
	 */
	inline UBOOL IsZero() const
	{
		return	Abs(U) < DELTA && Abs(V) < DELTA
			&&	Abs(UL) < DELTA && Abs(VL) < DELTA;
	}

	/** Comparison operators */
	inline UBOOL operator==( const FTextureCoordinates& Other ) const
	{
		return ARE_FLOATS_EQUAL(U,Other.U)
			&& ARE_FLOATS_EQUAL(V,Other.V)
			&& ARE_FLOATS_EQUAL(UL,Other.UL)
			&& ARE_FLOATS_EQUAL(VL,Other.VL);
	}
	inline UBOOL operator!=( const FTextureCoordinates& Other ) const
	{
		return !ARE_FLOATS_EQUAL(U,Other.U)
			|| !ARE_FLOATS_EQUAL(V,Other.V)
			|| !ARE_FLOATS_EQUAL(UL,Other.UL)
			|| !ARE_FLOATS_EQUAL(VL,Other.VL);
	}

};

struct FInputKeyAction
{
    FName InputKeyName;
    BYTE InputKeyState;
    TArrayNoInit<struct FSeqOpOutputInputLink> TriggeredOps;
    TArrayNoInit<class USequenceOp*> ActionsToExecute_DEPRECATED;

		/** Default constructor; don't initialize any members or we'll overwrite values serialized from disk. */
		FInputKeyAction() {}

		/** Initialization constructor - zero initialize all members */
		FInputKeyAction(EEventParm)
		{
			appMemzero(this, sizeof(FInputKeyAction));
			InputKeyName = NAME_None;
			InputKeyState = IE_Released;
		}

		/** Copy constructor */
		FInputKeyAction( const FInputKeyAction& Other );

		/** Standard ctor */
		FInputKeyAction( FName InKeyName, EInputEvent InKeyState )
		{
			appMemzero(this, sizeof(FInputKeyAction));
			InputKeyName = InKeyName;
			InputKeyState = InKeyState;
		}

		/** Comparison operator */
		UBOOL operator==( const FInputKeyAction& Other ) const;

		/** Serialization operator */
		friend FArchive& operator<<(FArchive& Ar,FInputKeyAction& MyInputKeyAction);

		/**
		 * @return	TRUE if this input key action is linked to the sequence op.
		 */
		UBOOL IsLinkedTo( const class USequenceOp* CheckOp ) const;
	
};

struct FInputEventParameters
{
    INT PlayerIndex;
    INT ControllerId;
    FName InputKeyName;
    BYTE EventType;
    FLOAT InputDelta;
    FLOAT DeltaTime;
    BITFIELD bAltPressed:1;
    BITFIELD bCtrlPressed:1;
    BITFIELD bShiftPressed:1;
    SCRIPT_ALIGN;

		/** Default constructor */
		FInputEventParameters();

		/** Input Key Event constructor */
		FInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, EInputEvent Event, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift, FLOAT AmountDepressed=1.f );

		/** Input Axis Event constructor */
		FInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, FLOAT AxisAmount, FLOAT InDeltaTime, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift );
	
};

struct FSubscribedInputEventParameters : public FInputEventParameters
{
    FName InputAliasName;

		/** Default constructor */
		FSubscribedInputEventParameters();

		/** Input Key Event constructor */
		FSubscribedInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, EInputEvent Event, FName InInputAliasName, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift, FLOAT AmountDepressed=1.f );

		/** Input Axis Event constructor */
		FSubscribedInputEventParameters( INT InPlayerIndex, INT InControllerId, FName KeyName, FName InInputAliasName, FLOAT AxisAmount, FLOAT InDeltaTime, UBOOL bAlt, UBOOL bCtrl, UBOOL bShift );

		/** Copy constructor */
		FSubscribedInputEventParameters( const FSubscribedInputEventParameters& Other );
		FSubscribedInputEventParameters( const FInputEventParameters& Other, FName InInputAliasName );
	
};

struct FUIAxisEmulationDefinition
{
    FName AxisInputKey;
    FName AdjacentAxisInputKey;
    BITFIELD bEmulateButtonPress:1;
    FName InputKeyToEmulate[2];

    /** Constructors */
    FUIAxisEmulationDefinition() {}
    FUIAxisEmulationDefinition(EEventParm)
    {
        appMemzero(this, sizeof(FUIAxisEmulationDefinition));
    }
};

struct FRawInputKeyEventData
{
    FName InputKeyName;
    BYTE ModifierKeyFlags;
    SCRIPT_ALIGN;
    friend FArchive& operator<<(FArchive& Ar,FRawInputKeyEventData& MyRawInputKeyEventData)
    {
        return Ar << MyRawInputKeyEventData.InputKeyName << MyRawInputKeyEventData.ModifierKeyFlags;
    }

		/** Constructors */
		FRawInputKeyEventData() {}
		FRawInputKeyEventData(EEventParm)
		{
			appMemzero(this, sizeof(FRawInputKeyEventData));
		}

		explicit FRawInputKeyEventData( FName InKeyName, BYTE InModifierFlags=(KEYMODIFIER_AltExcluded|KEYMODIFIER_CtrlExcluded|KEYMODIFIER_ShiftExcluded) )
		: InputKeyName(InKeyName), ModifierKeyFlags(InModifierFlags)
		{}

		FRawInputKeyEventData( const FRawInputKeyEventData& Other )
		: InputKeyName(Other.InputKeyName), ModifierKeyFlags(Other.ModifierKeyFlags)
		{}

		/** Comparison operators */
		FORCEINLINE UBOOL operator==( const FRawInputKeyEventData& Other ) const
		{
			return InputKeyName == Other.InputKeyName && ModifierKeyFlags == Other.ModifierKeyFlags;
		}
		FORCEINLINE UBOOL operator!=( const FRawInputKeyEventData& Other ) const
		{
			return InputKeyName != Other.InputKeyName || ModifierKeyFlags != Other.ModifierKeyFlags;
		}
		FORCEINLINE FRawInputKeyEventData& operator=( const FRawInputKeyEventData& Other )
		{
			InputKeyName = Other.InputKeyName; ModifierKeyFlags = Other.ModifierKeyFlags;
			return *this;
		}
		/** Required in order for FRawInputKeyEventData to be used as the key in a map */
		friend inline DWORD GetTypeHash( const FRawInputKeyEventData& KeyEvt )
		{
			return GetTypeHash(KeyEvt.InputKeyName);
		}

		/**
		 * Applies the specified modifier key bitmask to ModifierKeyFlags
		 */
		FORCEINLINE void SetModifierKeyFlags( BYTE ModifierFlags )
		{
			ModifierKeyFlags |= ModifierFlags;
		}
		/** Clears the specified modifier key bitmask from ModifierKeyFlags */
		FORCEINLINE void ClearModifierKeyFlags( BYTE ModifierFlags )
		{
			ModifierKeyFlags &= ~ModifierFlags;
		}

		/**
		 * Returns TRUE if ModifierKeyFlags contains any of the bits in FlagsToCheck.
		 */
		FORCEINLINE UBOOL HasAnyModifierKeyFlags( BYTE FlagsToCheck ) const
		{
			return (ModifierKeyFlags&FlagsToCheck) != 0 || FlagsToCheck == KEYMODIFIER_All;
		}

		/**
		 * Returns TRUE if ModifierKeyFlags contains all of the bits in FlagsToCheck
		 */
		FORCEINLINE UBOOL HasAllModifierFlags( BYTE FlagsToCheck ) const
		{
			return (ModifierKeyFlags&FlagsToCheck) == FlagsToCheck;
		}
	
};

class UUIRoot : public UObject
{
public:
    //## BEGIN PROPS UIRoot
    TArrayNoInit<FString> BadCapsLocContexts;
    //## END PROPS UIRoot

    DECLARE_FUNCTION(execGetInputPlatformType);
    DECLARE_FUNCTION(execGetCurrentUIController);
    DECLARE_FUNCTION(execGetSceneClient);
    DECLARE_ABSTRACT_CLASS(UUIRoot,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/**
	 * Returns the friendly name for the specified input event from the EInputEvent enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetInputEventText( BYTE InputEvent );

	/**
	 * Returns the friendly name for the specified platform type from the EInputPlatformType enum.
	 *
	 * @return	the textual representation of the enum member specified, or "Unknown" if the value is invalid.
	 */
	static FString GetInputPlatformTypeText( BYTE PlatformType );

	/**
	 * Returns the platform type for the current input device.  This is not necessarily the platform the game is actually running
	 * on; for example, if the game is running on a PC, but the player is using an Xbox controller, the current InputPlatformType
	 * would be IPT_360.
	 *
	 * @param	OwningPlayer	if specified, the returned InputPlatformType will reflect the actual input device the player
	 *							is using.  Otherwise, the returned InputPlatformType is always the platform the game is running on.
	 *
	 * @return	the platform type for the current input device (if a player is specified) or the host platform.
	 */
	static EInputPlatformType GetInputPlatformType( ULocalPlayer* OwningPlayer=NULL );

	/**
	 * Returns the UIController class set for this game.
	 *
	 * @return	a pointer to a UIInteraction class which is set as the value for GameViewportClient.UIControllerClass.
	 */
	static class UClass* GetUIControllerClass();

	/**
	 * Returns the default object for the UIController class set for this game.
	 *
	 * @return	a pointer to the CDO for UIInteraction class configured for this game.
	 */
	static class UUIInteraction* GetDefaultUIController();

	/**
	 * Returns the UIInteraction instance currently controlling the UI system, which is valid in game.
	 *
	 * @return	a pointer to the UIInteraction object currently controlling the UI system.
	 */
	static class UUIInteraction* GetCurrentUIController();

	/**
	 * Returns the game's scene client.
	 *
	 * @return 	a pointer to the UGameUISceneClient instance currently managing the scenes for the UI System.
	 */
	static class UGameUISceneClient* GetSceneClient();

};

struct FPlayerDataStoreGroup
{
    class ULocalPlayer* PlayerOwner;
    TArray<class UUIDataStore*> DataStores;

    /** Constructors */
    FPlayerDataStoreGroup()
    : PlayerOwner(NULL)
    {}
    FPlayerDataStoreGroup(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerDataStoreGroup));
    }
};

struct DataStoreClient_eventNotifyGameSessionEnded_Parms
{
    DataStoreClient_eventNotifyGameSessionEnded_Parms(EEventParm)
    {
    }
};
class UDataStoreClient : public UUIRoot
{
public:
    //## BEGIN PROPS DataStoreClient
    TArrayNoInit<FString> GlobalDataStoreClasses;
    TArrayNoInit<class UUIDataStore*> GlobalDataStores;
    TArrayNoInit<FString> PlayerDataStoreClassNames;
    TArrayNoInit<class UClass*> PlayerDataStoreClasses;
    TArrayNoInit<struct FPlayerDataStoreGroup> PlayerDataStores;
    //## END PROPS DataStoreClient

    class UUIDataStore* FindDataStore(FName DataStoreTag,class ULocalPlayer* PlayerOwner=NULL);
    class UUIDataStore* CreateDataStore(class UClass* DataStoreClass);
    UBOOL RegisterDataStore(class UUIDataStore* DataStore,class ULocalPlayer* PlayerOwner=NULL);
    UBOOL UnregisterDataStore(class UUIDataStore* DataStore);
    INT FindPlayerDataStoreIndex(class ULocalPlayer* PlayerOwner) const;
    DECLARE_FUNCTION(execFindDataStore)
    {
        P_GET_NAME(DataStoreTag);
        P_GET_OBJECT_OPTX(ULocalPlayer,PlayerOwner,NULL);
        P_FINISH;
        *(class UUIDataStore**)Result=this->FindDataStore(DataStoreTag,PlayerOwner);
    }
    DECLARE_FUNCTION(execCreateDataStore)
    {
        P_GET_OBJECT(UClass,DataStoreClass);
        P_FINISH;
        *(class UUIDataStore**)Result=this->CreateDataStore(DataStoreClass);
    }
    DECLARE_FUNCTION(execRegisterDataStore)
    {
        P_GET_OBJECT(UUIDataStore,DataStore);
        P_GET_OBJECT_OPTX(ULocalPlayer,PlayerOwner,NULL);
        P_FINISH;
        *(UBOOL*)Result=this->RegisterDataStore(DataStore,PlayerOwner);
    }
    DECLARE_FUNCTION(execUnregisterDataStore)
    {
        P_GET_OBJECT(UUIDataStore,DataStore);
        P_FINISH;
        *(UBOOL*)Result=this->UnregisterDataStore(DataStore);
    }
    DECLARE_FUNCTION(execFindPlayerDataStoreIndex)
    {
        P_GET_OBJECT(ULocalPlayer,PlayerOwner);
        P_FINISH;
        *(INT*)Result=this->FindPlayerDataStoreIndex(PlayerOwner);
    }
    void eventNotifyGameSessionEnded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyGameSessionEnded),NULL);
    }
    DECLARE_CLASS(UDataStoreClient,UUIRoot,0|CLASS_Config,Engine)
	/**
	 * Loads each of the classes from the GlobalDataStoreClasses array, creates an instance of that class, and stores
	 * that instance in the GlobalDataStores array.
	 */
	virtual void InitializeDataStores();
};

struct Interaction_eventOnInitialize_Parms
{
    Interaction_eventOnInitialize_Parms(EEventParm)
    {
    }
};
struct Interaction_eventPostRender_Parms
{
    class UCanvas* Canvas;
    Interaction_eventPostRender_Parms(EEventParm)
    {
    }
};
struct Interaction_eventTick_Parms
{
    FLOAT DeltaTime;
    Interaction_eventTick_Parms(EEventParm)
    {
    }
};
struct Interaction_eventOnReceivedNativeInputChar_Parms
{
    INT ControllerId;
    FString Unicode;
    UBOOL ReturnValue;
    Interaction_eventOnReceivedNativeInputChar_Parms(EEventParm)
    {
    }
};
struct Interaction_eventOnReceivedNativeInputAxis_Parms
{
    INT ControllerId;
    FName Key;
    FLOAT Delta;
    FLOAT DeltaTime;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    Interaction_eventOnReceivedNativeInputAxis_Parms(EEventParm)
    {
    }
};
struct Interaction_eventOnReceivedNativeInputKey_Parms
{
    INT ControllerId;
    FName Key;
    BYTE EventType;
    FLOAT AmountDepressed;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    Interaction_eventOnReceivedNativeInputKey_Parms(EEventParm)
    {
    }
};
class UInteraction : public UUIRoot
{
public:
    //## BEGIN PROPS Interaction
    FScriptDelegate __OnReceivedNativeInputKey__Delegate;
    FScriptDelegate __OnReceivedNativeInputAxis__Delegate;
    FScriptDelegate __OnReceivedNativeInputChar__Delegate;
    FScriptDelegate __OnInitialize__Delegate;
    //## END PROPS Interaction

    virtual void Init();
    DECLARE_FUNCTION(execInit)
    {
        P_FINISH;
        this->Init();
    }
    void delegateOnInitialize()
    {
        ProcessDelegate(ENGINE_OnInitialize,&__OnInitialize__Delegate,NULL);
    }
    void eventPostRender(class UCanvas* Canvas)
    {
        Interaction_eventPostRender_Parms Parms(EC_EventParm);
        Parms.Canvas=Canvas;
        ProcessEvent(FindFunctionChecked(ENGINE_PostRender),&Parms);
    }
    void eventTick(FLOAT DeltaTime)
    {
        Interaction_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Tick),&Parms);
        }
    }
    UBOOL delegateOnReceivedNativeInputChar(INT ControllerId,const FString& Unicode)
    {
        Interaction_eventOnReceivedNativeInputChar_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Unicode=Unicode;
        ProcessDelegate(ENGINE_OnReceivedNativeInputChar,&__OnReceivedNativeInputChar__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnReceivedNativeInputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime,UBOOL bGamepad=FALSE)
    {
        Interaction_eventOnReceivedNativeInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.Delta=Delta;
        Parms.DeltaTime=DeltaTime;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnReceivedNativeInputAxis,&__OnReceivedNativeInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateOnReceivedNativeInputKey(INT ControllerId,FName Key,BYTE EventType,FLOAT AmountDepressed=1.000000,UBOOL bGamepad=FALSE)
    {
        Interaction_eventOnReceivedNativeInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.EventType=EventType;
        Parms.AmountDepressed=AmountDepressed;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnReceivedNativeInputKey,&__OnReceivedNativeInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UInteraction,UUIRoot,0|CLASS_Transient|CLASS_Config,Engine)
	/**
	 * Minimal initialization constructor.
	 */
	UInteraction();

	/**
	 * Called once a frame to update the interaction's state.
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime)
	{
		eventTick(DeltaTime);
	}

	/**
	 * Process an input key event received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	gamepad/controller that generated this input event
	 * @param	Key				the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)
	 * @param	EventType		the type of event which occured (pressed, released, etc.)
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE)
	{
		return FALSE;
	}

	/**
	 * Process an input axis (joystick, thumbstick, or mouse) event received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this input axis event
	 * @param	Key				the name of the axis that moved  (KEY_MouseX, KEY_XboxTypeS_LeftX, etc.)
	 * @param	Delta			the movement delta for the axis
	 * @param	DeltaTime		the time (in seconds) since the last axis update.
	 *
	 * @return	TRUE to consume the axis event, FALSE to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE)
	{
		return FALSE;
	}

	/**
	 * Process a character input event (typing) received from the viewport.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this character input event
	 * @param	Character		the character that was typed
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character)
	{
		return FALSE;
	}


	/**
	 * Process a touchpad touch input event received from the viewport.
	 *
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Handle - Identifier unique to this touch event
	 * @param	TouchLocation - Screen position of the touch
	 * @param	DeviceTimestamp - Timestamp of the event
	 * @param	TouchpadIndex - For devices with multiple touchpads, this is the index of which one
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputTouch(INT ControllerId, UINT Handle, ETouchType Type, FVector2D TouchLocation, DOUBLE DeviceTimestamp, UINT TouchpadIndex=0) 
	{ 
		return FALSE; 
	}

	/**
	 * Process a motion event received from the viewport.
	 *
	 * @param ControllerId - The controller which the key event is from.
	 * @param Tilt			The current orientation of the device
	 * @param RotationRate	How fast the tilt is changing
	 * @param Gravity		Describes the current gravity of the device
	 * @param Acceleration  Describes the acceleration of the device
	 * @return	True to consume the motion event, false to pass it on.
	 */
	virtual UBOOL InputMotion(INT ControllerId, const FVector& Tilt, const FVector& RotationRate, const FVector& Gravity, const FVector& Acceleration) 
	{ 
		return FALSE; 
	}


public:
};

#define UCONST_MaxHistory 16

struct FAutoCompleteCommand
{
    FStringNoInit Command;
    FStringNoInit Desc;

    /** Constructors */
    FAutoCompleteCommand() {}
    FAutoCompleteCommand(EEventParm)
    {
        appMemzero(this, sizeof(FAutoCompleteCommand));
    }
};

struct FAutoCompleteNode
{
    INT IndexChar;
    TArray<INT> AutoCompleteListIndices;
    TArray<FAutoCompleteNode*> ChildNodes;

	FAutoCompleteNode()
	{
		IndexChar = INDEX_NONE;
	}
	FAutoCompleteNode(INT NewChar)
	{
		IndexChar = NewChar;
	}
	~FAutoCompleteNode()
	{
		for (INT Idx = 0; Idx < ChildNodes.Num(); Idx++)
		{
			FAutoCompleteNode *Node = ChildNodes(Idx);
			delete Node;
		}
		ChildNodes.Empty();
	}

};

struct Console_eventOutputText_Parms
{
    FString Text;
    Console_eventOutputText_Parms(EEventParm)
    {
    }
};
class UConsole : public UInteraction
{
public:
    //## BEGIN PROPS Console
    class ULocalPlayer* ConsoleTargetPlayer;
    class UTexture2D* DefaultTexture_Black;
    class UTexture2D* DefaultTexture_White;
    FName ConsoleKey;
    FName TypeKey;
    INT MaxScrollbackSize;
    TArrayNoInit<FString> Scrollback;
    INT SBHead;
    INT SBPos;
    INT HistoryTop;
    INT HistoryBot;
    INT HistoryCur;
    FStringNoInit History[16];
    BITFIELD bNavigatingHistory:1;
    BITFIELD bCaptureKeyInput:1;
    BITFIELD bCtrl:1;
    BITFIELD bEnableUI:1;
    BITFIELD bAutoCompleteLocked:1;
    BITFIELD bRequireCtrlToNavigateAutoComplete:1;
    BITFIELD bIsRuntimeAutoCompleteUpToDate:1;
    FStringNoInit TypedStr;
    INT TypedStrPos;
    TArrayNoInit<struct FAutoCompleteCommand> ManualAutoCompleteList;
    TArrayNoInit<struct FAutoCompleteCommand> AutoCompleteList;
    INT AutoCompleteIndex;
    struct FAutoCompleteNode AutoCompleteTree;
    TArrayNoInit<INT> AutoCompleteIndices;
    //## END PROPS Console

    void BuildRuntimeAutoCompleteList(UBOOL bForce=FALSE);
    virtual void UpdateCompleteIndices();
    DECLARE_FUNCTION(execBuildRuntimeAutoCompleteList)
    {
        P_GET_UBOOL_OPTX(bForce,FALSE);
        P_FINISH;
        this->BuildRuntimeAutoCompleteList(bForce);
    }
    DECLARE_FUNCTION(execUpdateCompleteIndices)
    {
        P_FINISH;
        this->UpdateCompleteIndices();
    }
    void eventOutputText(const FString& Text)
    {
        Console_eventOutputText_Parms Parms(EC_EventParm);
        Parms.Text=Text;
        ProcessEvent(FindFunctionChecked(ENGINE_OutputText),&Parms);
    }
    DECLARE_CLASS(UConsole,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UGameViewportClient)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

    NO_DEFAULT_CONSTRUCTOR(UConsole)
};

struct FKeyBind
{
    FName Name;
    FStringNoInit Command;
    BITFIELD Control:1;
    BITFIELD Shift:1;
    BITFIELD Alt:1;
    BITFIELD bIgnoreCtrl:1;
    BITFIELD bIgnoreShift:1;
    BITFIELD bIgnoreAlt:1;
    SCRIPT_ALIGN;

	FKeyBind()
	: Name()
	, Control(FALSE), Shift(FALSE), Alt(FALSE)
	, bIgnoreCtrl(FALSE), bIgnoreShift(FALSE), bIgnoreAlt(FALSE)
	{}

};

struct FTouchTracker
{
    INT Handle;
    INT TouchpadIndex;
    FVector2D Location;
    BYTE EventType;
    SCRIPT_ALIGN;
    BITFIELD bTrapInput:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FTouchTracker() {}
    FTouchTracker(EEventParm)
    {
        appMemzero(this, sizeof(FTouchTracker));
    }
};

class UInput : public UInteraction
{
public:
    //## BEGIN PROPS Input
    TArrayNoInit<struct FKeyBind> Bindings;
    TArrayNoInit<FName> PressedKeys;
    INT CurrentControllerId;
    BYTE CurrentEvent;
    FLOAT CurrentDelta;
    FLOAT CurrentDeltaTime;
    TMap< FName,void* > NameToPtr;
    TArray<FLOAT*> AxisArray;
    TArrayNoInit<class USeqEvent_Input*> CachedInputEvents;
    TArrayNoInit<class USeqEvent_AnalogInput*> CachedAnalogInputEvents;
    TArrayNoInit<class USeqEvent_TouchInput*> CachedTouchInputEvents;
    TArrayNoInit<struct FTouchTracker> CurrentTouches;
    //## END PROPS Input

    virtual void ResetInput();
    virtual FString GetBind(const FName& Key);
    DECLARE_FUNCTION(execResetInput)
    {
        P_FINISH;
        this->ResetInput();
    }
    DECLARE_FUNCTION(execGetBind)
    {
        P_GET_NAME_REF(Key);
        P_FINISH;
        *(FString*)Result=this->GetBind(Key);
    }
    DECLARE_CLASS(UInput,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Input");}

	// UInteraction interface.

	virtual UBOOL InputKey(INT ControllerId, FName Key, enum EInputEvent Event, FLOAT AmountDepressed = 1.f, UBOOL bGamepad = FALSE );
	virtual UBOOL InputAxis(INT ControllerId, FName Key, FLOAT Delta, FLOAT DeltaTime, UBOOL bGamepad=FALSE);
	virtual void Tick(FLOAT DeltaTime);
	UBOOL IsPressed( FName InKey ) const;
	UBOOL IsCtrlPressed() const;
	UBOOL IsShiftPressed() const;
	UBOOL IsAltPressed() const;

	// UInput interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/**
	 * Clears the PressedKeys array.  Should be called when another interaction which swallows some (but perhaps not all) input is activated.
	 */
	virtual void FlushPressedKeys()
	{
		PressedKeys.Empty();
	}

	// Protected.

	BYTE* FindButtonName(const TCHAR* ButtonName);
	FLOAT* FindAxisName(const TCHAR* ButtonName);
	/**
	 * Returns the Name of a bind using the bind's Command as the key
	 * StartBind Index is where the search will start from and where the index result will be stored
	 *   -- If you don't where to start your search from (as the list will search backwards), set the StartBindIndex to -1 before passing it in
	 */
	FString GetBindNameFromCommand(const FString& KeyCommand, INT* StartBindIndex = NULL ) const;
	void ExecInputCommands(const TCHAR* Cmd,class FOutputDevice& Ar);
	virtual void UpdateAxisValue( FLOAT* Axis, FLOAT Delta );

	/**
	 * Processes any kismet events looking for this input
	 *
	 * @return TRUE if the input was absorbed - the caller MUST NOT CONTINUE processing this input if TRUE is returned
	 */
	UBOOL ProcessInputKismetEvents(INT ControllerId, FName InputName, EInputEvent Event);
	UBOOL ProcessAnalogKismetEvents(INT ControllerId, FName InputName, const FLOAT* FloatValue, const FVector* VectorValue);
	UBOOL ProcessTouchKismetEvents(INT ControllerId, INT TouchIndex, EInputEvent Event);
};

struct PlayerInput_eventPlayerInput_Parms
{
    FLOAT DeltaTime;
    PlayerInput_eventPlayerInput_Parms(EEventParm)
    {
    }
};
class UPlayerInput : public UInput
{
public:
    //## BEGIN PROPS PlayerInput
    BITFIELD bUsingGamepad:1;
    BITFIELD bInvertMouse:1;
    BITFIELD bInvertTurn:1;
    BITFIELD bWasForward:1;
    BITFIELD bWasBack:1;
    BITFIELD bWasLeft:1;
    BITFIELD bWasRight:1;
    BITFIELD bEdgeForward:1;
    BITFIELD bEdgeBack:1;
    BITFIELD bEdgeLeft:1;
    BITFIELD bEdgeRight:1;
    BITFIELD bEnableMouseSmoothing:1;
    BITFIELD bEnableFOVScaling:1;
    BITFIELD bLockTurnUntilRelease:1;
    FName LastAxisKeyName;
    FLOAT DoubleClickTimer;
    FLOAT DoubleClickTime;
    FLOAT MouseSensitivity;
    FLOAT aBaseX;
    FLOAT aBaseY;
    FLOAT aBaseZ;
    FLOAT aMouseX;
    FLOAT aMouseY;
    FLOAT aForward;
    FLOAT aTurn;
    FLOAT aStrafe;
    FLOAT aUp;
    FLOAT aLookUp;
    FLOAT aRightAnalogTrigger;
    FLOAT aLeftAnalogTrigger;
    FLOAT aPS3AccelX;
    FLOAT aPS3AccelY;
    FLOAT aPS3AccelZ;
    FLOAT aPS3Gyro;
    FLOAT aWiiUPointerX;
    FLOAT aWiiUPointerY;
    FVector aTilt;
    FVector aRotationRate;
    FVector aGravity;
    FVector aAcceleration;
    FVector aTouch[5];
    FVector aBackTouch[5];
    FLOAT RawJoyUp;
    FLOAT RawJoyRight;
    FLOAT RawJoyLookRight;
    FLOAT RawJoyLookUp;
    FLOAT MoveForwardSpeed;
    FLOAT MoveStrafeSpeed;
    FLOAT LookRightScale;
    FLOAT LookUpScale;
    BYTE bStrafe;
    BYTE bXAxis;
    BYTE bYAxis;
    FLOAT ZeroTime[2];
    FLOAT SmoothedMouse[2];
    INT MouseSamples;
    FLOAT MouseSamplingTotal;
    FLOAT AutoUnlockTurnTime;
    //## END PROPS PlayerInput

    virtual void CancelMobileInput();
    virtual void InitInputSystem();
    DECLARE_FUNCTION(execCancelMobileInput)
    {
        P_FINISH;
        this->CancelMobileInput();
    }
    DECLARE_FUNCTION(execInitInputSystem)
    {
        P_FINISH;
        this->InitInputSystem();
    }
    void eventPlayerInput(FLOAT DeltaTime)
    {
        PlayerInput_eventPlayerInput_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayerInput),&Parms);
    }
    DECLARE_CLASS(UPlayerInput,UInput,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(APlayerController)
	/**
	 * Generates an IE_Released event for each key in the PressedKeys array, then clears the array.  Should be called when another
	 * interaction which swallows some (but perhaps not all) input is activated.
	 */
	virtual void FlushPressedKeys();

	/** Override to detect input from a gamepad */
	virtual UBOOL InputKey(INT ControllerId, FName Key, enum EInputEvent Event, FLOAT AmountDepressed = 1.f, UBOOL bGamepad = FALSE );
	virtual UBOOL InputAxis(INT ControllerId, FName Key, FLOAT Delta, FLOAT DeltaTime, UBOOL bGamepad=FALSE);
	virtual UBOOL InputTouch(INT ControllerId, UINT Handle, ETouchType Type, FVector2D TouchLocation, DOUBLE DeviceTimestamp, UINT TouchpadIndex=0);
	virtual UBOOL InputMotion(INT ControllerId, const FVector& Tilt, const FVector& RotationRate, const FVector& Gravity, const FVector& Acceleration);
	virtual void  UpdateAxisValue( FLOAT* Axis, FLOAT Delta );
	virtual UBOOL IsGamepadKey(FName Name) const;
};

class UPlayerManagerInteraction : public UInteraction
{
public:
    //## BEGIN PROPS PlayerManagerInteraction
    //## END PROPS PlayerManagerInteraction

    DECLARE_CLASS(UPlayerManagerInteraction,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UGameViewportClient)
	/* === UInteraction interface === */
	/**
	 * Routes an input key event to the player's interactions array
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Routes an axis input event to the player's interactions array.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Routes a character input to the player's Interaction array.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);

	/**
	 * Process a touchpad touch input event received from the viewport.
	 *
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Handle - Identifier unique to this touch event
	 * @param	TouchLocation - Screen position of the touch
	 * @param	DeviceTimestamp - Timestamp of the event
	 * @param	TouchpadIndex - For devices with multiple touchpads, this is the index of which one
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputTouch(INT ControllerId, UINT Handle, ETouchType Type, FVector2D TouchLocation, DOUBLE DeviceTimestamp, UINT TouchpadIndex=0);

	/**
	 * Process a motion event received from the viewport.
	 *
	 * @param ControllerId - The controller which the key event is from.
	 * @param Tilt			The current orientation of the device
	 * @param RotationRate	How fast the tilt is changing
	 * @param Gravity		Describes the current gravity of the device
	 * @param Acceleration  Describes the acceleration of the device
	 * @return	True to consume the motion event, false to pass it on.
	 */
	virtual UBOOL InputMotion(INT ControllerId, const FVector& Tilt, const FVector& RotationRate, const FVector& Gravity, const FVector& Acceleration);
};

struct FUIKeyRepeatData
{
    FName CurrentRepeatKey;
    DOUBLE NextRepeatTime;

    /** Constructors */
	FUIKeyRepeatData()
	: CurrentRepeatKey(NAME_None)
	, NextRepeatTime(0.f)
	{}

};

struct FUIAxisEmulationData : public FUIKeyRepeatData
{
    BITFIELD bEnabled:1;
    SCRIPT_ALIGN;

    /** Constructors */
	FUIAxisEmulationData()
	: FUIKeyRepeatData(), bEnabled(TRUE)
	{}

	/**
	 * Toggles whether this axis emulation is enabled.
	 */
	void EnableAxisEmulation( UBOOL bShouldEnable )
	{
		if ( bEnabled != bShouldEnable )
		{
			bEnabled = bShouldEnable;
			CurrentRepeatKey = NAME_None;
			NextRepeatTime = 0.f;
		}
	}

};

struct UIInteraction_eventGetNATType_Parms
{
    BYTE ReturnValue;
    UIInteraction_eventGetNATType_Parms(EEventParm)
    {
    }
};
struct UIInteraction_eventIsLoggedIn_Parms
{
    INT ControllerId;
    UBOOL bRequireOnlineLogin;
    UBOOL ReturnValue;
    UIInteraction_eventIsLoggedIn_Parms(EEventParm)
    {
    }
};
struct UIInteraction_eventHasLinkConnection_Parms
{
    UBOOL ReturnValue;
    UIInteraction_eventHasLinkConnection_Parms(EEventParm)
    {
    }
};
struct UIInteraction_eventGetLoginStatus_Parms
{
    INT ControllerId;
    BYTE ReturnValue;
    UIInteraction_eventGetLoginStatus_Parms(EEventParm)
    {
    }
};
class UUIInteraction : public UInteraction, public FExec, public FGlobalDataStoreClientManager, public FCallbackEventDevice
{
public:
    //## BEGIN PROPS UIInteraction
    class UUIManager* UIManager;
    class UClass* UIManagerClass;
    class UClass* SceneClientClass;
    class UGameUISceneClient* SceneClient;
    TArrayNoInit<FName> SupportedDoubleClickKeys;
private:
    class UDataStoreClient* DataStoreManager;
public:
    BITFIELD bProcessInput:1;
    FLOAT UIJoystickDeadZone;
    FLOAT UIAxisMultiplier;
    FLOAT AxisRepeatDelay;
    FLOAT MouseButtonRepeatDelay;
    FLOAT DoubleClickTriggerSeconds;
    INT DoubleClickPixelTolerance;
    struct FUIKeyRepeatData MouseButtonRepeatInfo;
    TArrayNoInit<struct FUIAxisEmulationDefinition> ConfiguredAxisEmulationDefinitions;
    TMap< FName,struct FUIAxisEmulationDefinition > AxisEmulationDefinitions;
    struct FUIAxisEmulationData AxisInputEmulation[4];
    //## END PROPS UIInteraction

    DECLARE_FUNCTION(execGetPlayerCount)
    {
        P_FINISH;
        *(INT*)Result=this->GetPlayerCount();
    }
    DECLARE_FUNCTION(execGetPlayerIndex)
    {
        P_GET_INT(ControllerId);
        P_FINISH;
        *(INT*)Result=this->GetPlayerIndex(ControllerId);
    }
    DECLARE_FUNCTION(execGetPlayerControllerId)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(INT*)Result=this->GetPlayerControllerId(PlayerIndex);
    }
    DECLARE_FUNCTION(execGetDataStoreClient)
    {
        P_FINISH;
        *(class UDataStoreClient**)Result=this->GetDataStoreClient();
    }
    BYTE eventGetNATType()
    {
        UIInteraction_eventGetNATType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetNATType),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventIsLoggedIn(INT ControllerId,UBOOL bRequireOnlineLogin=FALSE)
    {
        UIInteraction_eventIsLoggedIn_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.bRequireOnlineLogin=bRequireOnlineLogin ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsLoggedIn),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventHasLinkConnection()
    {
        UIInteraction_eventHasLinkConnection_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_HasLinkConnection),&Parms);
        return Parms.ReturnValue;
    }
    BYTE eventGetLoginStatus(INT ControllerId)
    {
        UIInteraction_eventGetLoginStatus_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(ENGINE_GetLoginStatus),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UUIInteraction,UInteraction,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UGameViewportClient)
    static const TCHAR* StaticConfigName() {return TEXT("UI");}

	/* =======================================
		UObject interface
	======================================= */
	/**
	* Called to finish destroying the object.
	*/
	virtual void FinishDestroy();

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* === FCallbackEventDevice interface === */
	/**
	 * Called for notifications that require no additional information.
	 */
	virtual void Send( ECallbackEventType InType );

	/**
	 * Called when the viewport has been resized.
	 */
	virtual void Send( ECallbackEventType InType, FViewport* InViewport, UINT InMessage);

	/* ==============================================
		FGlobalDataStoreClientManager interface
	============================================== */
	/**
	 * Initializes the singleton data store client that will manage the global data stores.
	 */
	virtual void InitializeGlobalDataStore();

	/* =======================================
		UInteraction interface
	======================================= */
	/**
	 * Called when UIInteraction is added to the GameViewportClient's Interactions array
	 */
	virtual void Init();

	/**
	 * Called once a frame to update the interaction's state.
	 *
	 * @param	DeltaTime - The time since the last frame.
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 * Check a key event received by the viewport.
	 *
	 * @param	Viewport - The viewport which the key event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Key - The name of the key which an event occured for.
	 * @param	Event - The type of event which occured.
	 * @param	AmountDepressed - For analog keys, the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputKey(INT ControllerId,FName Key,EInputEvent Event,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Check an axis movement received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Key - The name of the axis which moved.
	 * @param	Delta - The axis movement delta.
	 * @param	DeltaTime - The time since the last axis update.
	 *
	 * @return	True to consume the axis movement, false to pass it on.
	 */
	virtual UBOOL InputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Check a character input received by the viewport.
	 *
	 * @param	Viewport - The viewport which the axis movement is from.
	 * @param	ControllerId - The controller which the axis movement is from.
	 * @param	Character - The character.
	 *
	 * @return	True to consume the character, false to pass it on.
	 */
	virtual UBOOL InputChar(INT ControllerId,TCHAR Character);

	/* =======================================
		UUIInteraction interface
	======================================= */
	/**
	 * Constructor
	 */
	UUIInteraction();

	/**
	 * Cleans up all objects created by this UIInteraction, including unrooting objects and unreferencing any other objects.
	 * Called when the UI system is being closed down (such as when exiting PIE).
	 */
	virtual void TearDownUI();

	/**
	 * Initializes the axis button-press/release emulation map.
	 */
	void InitializeAxisInputEmulations();

	/**
	 * Initializes all of the UI input alias names.
	 */
	void InitializeUIInputAliasNames();

	/**
	 * Returns the CDO for the configured scene client class.
	 */
	class UGameUISceneClient* GetDefaultSceneClient() const;

	/**
	 * Returns the number of players currently active.
	 */
	static INT GetPlayerCount();

	/**
	 * Retrieves the index (into the Engine.GamePlayers array) for the player which has the ControllerId specified
	 *
	 * @param	ControllerId	the gamepad index of the player to search for
	 *
	 * @return	the index [into the Engine.GamePlayers array] for the player that has the ControllerId specified, or INDEX_NONE
	 *			if no players have that ControllerId
	 */
	static INT GetPlayerIndex( INT ControllerId );

	/**
	 * Returns the index [into the Engine.GamePlayers array] for the player specified.
	 *
	 * @param	Player	the player to search for
	 *
	 * @return	the index of the player specified, or INDEX_NONE if the player is not in the game's list of active players.
	 */
	static INT GetPlayerIndex( class ULocalPlayer* Player );

	/**
	 * Retrieves the ControllerId for the player specified.
	 *
	 * @param	PlayerIndex		the index [into the Engine.GamePlayers array] for the player to retrieve the ControllerId for
	 *
	 * @return	the ControllerId for the player at the specified index in the GamePlayers array, or INDEX_NONE if the index is invalid
	 */
	static INT GetPlayerControllerId( INT PlayerIndex );

	/**
	 * Returns TRUE if button press/release events should be emulated for the specified axis input.
	 *
	 * @param	AxisKeyName		the name of the axis key that
	 */
	static UBOOL ShouldEmulateKeyPressForAxis( const FName& AxisKeyName );

	/**
	 * Returns a reference to the global data store client, if it exists.
	 *
	 * @return	the global data store client for the game.
	 */
	static class UDataStoreClient* GetDataStoreClient();
};

#define UCONST_SCENEFILTER_Any 0xFFFFFFFF
#define UCONST_SCENEFILTER_ReceivesFocus 0x00000020
#define UCONST_SCENEFILTER_UsesPostProcessing 0x00000010
#define UCONST_SCENEFILTER_PrimitiveUsersOnly 0x00000008
#define UCONST_SCENEFILTER_PausersOnly 0x00000004
#define UCONST_SCENEFILTER_InputProcessorOnly 0x00000002
#define UCONST_SCENEFILTER_IncludeTransient 0x00000001
#define UCONST_SCENEFILTER_None 0x00000000

struct UISceneClient_eventInitializeSceneClient_Parms
{
    UISceneClient_eventInitializeSceneClient_Parms(EEventParm)
    {
    }
};
class UUISceneClient : public UUIRoot, public FExec
{
public:
    //## BEGIN PROPS UISceneClient
    FViewport* RenderViewport;
    FIntPoint MousePosition;
    class UDataStoreClient* DataStoreManager;
    FMatrix CanvasToScreen;
    FMatrix InvCanvasToScreen;
    class UPostProcessChain* UIScenePostProcess;
    BITFIELD bEnablePostProcess:1;
    SCRIPT_ALIGN;
    //## END PROPS UISceneClient

    FMatrix GetCanvasToScreen() const;
    FMatrix GetInverseCanvasToScreen() const;
    DECLARE_FUNCTION(execIsUIActive)
    {
        P_GET_INT_OPTX(Flags,-1);
        P_FINISH;
        *(UBOOL*)Result=this->IsUIActive(Flags);
    }
    DECLARE_FUNCTION(execGetCanvasToScreen)
    {
        P_FINISH;
        *(FMatrix*)Result=this->GetCanvasToScreen();
    }
    DECLARE_FUNCTION(execGetInverseCanvasToScreen)
    {
        P_FINISH;
        *(FMatrix*)Result=this->GetInverseCanvasToScreen();
    }
    void eventInitializeSceneClient()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_InitializeSceneClient),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UUISceneClient,UUIRoot,0|CLASS_Transient|CLASS_Config,Engine)

	/**
	 * Used to limit which scenes should be considered when determining whether the UI should be considered "active"
	 */
	enum ESceneFilterTypes
	{
		SCENEFILTER_None=UCONST_SCENEFILTER_None,

		/** Include the transient scene */
		SCENEFILTER_IncludeTransient=UCONST_SCENEFILTER_IncludeTransient,

		/** Consider only scenes which can process input */
		SCENEFILTER_InputProcessorOnly=UCONST_SCENEFILTER_InputProcessorOnly,

		/** Consider only scenes which require the game to be paused */
		SCENEFILTER_PausersOnly=UCONST_SCENEFILTER_PausersOnly,

		/** Consider only scenes which support 3D primitives rendering */
		SCENEFILTER_PrimitiveUsersOnly=UCONST_SCENEFILTER_PrimitiveUsersOnly,

		/** Only consider scenes which render full-screen */
		SCENEFILTER_UsesPostProcessing=UCONST_SCENEFILTER_UsesPostProcessing,

		/** Include only those scenes which can receive focus (i.e. bNeverFocus=false) */
		SCENEFILTER_ReceivesFocus=UCONST_SCENEFILTER_ReceivesFocus,

		/** Include ANY scene, regardless of feature set */
		SCENEFILTER_Any=UCONST_SCENEFILTER_Any,
	};

	/* =======================================
		FExec interface
	======================================= */
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/* =======================================
		UUISceneClient interface
	======================================= */

	/**
	 * Performs any initialization for the UISceneClient.
	 */
	virtual void InitializeClient( );

	/**
	 * Assigns the viewport that scenes will use for rendering.
	 *
	 * @param	inViewport	the viewport to use for rendering scenes
	 */
	virtual void SetRenderViewport( FViewport* SceneViewport );

	/**
	 * Provides the scene client with a way to apply a platform input type other than the actual input type being used.
	 * Primarily for simulating platforms in the editor.
	 *
	 * @param	OwningPlayer		the player to use for determining the real platform input type, if necessary.
	 * @param	SimulatedPlatform	receives the value of the platform that should be used.
	 *
	 * @return	TRUE if the scene client wants to override the current platform input type.
	 */
	virtual UBOOL GetSimulatedPlatformInputType( BYTE& SimulatedPlatform ) const { return FALSE; }

	/**
	 * Returns true if there is an unhidden fullscreen UI active
	 *
	 * @param	Flags	modifies the logic which determines whether the UI is active
	 *
	 * @return TRUE if the UI is currently active
	 */
	virtual UBOOL IsUIActive( DWORD Flags=SCENEFILTER_Any ) const PURE_VIRTUAL(UUISceneClient::IsUIActive,return FALSE;);

	/**
	 * Returns true if the UI scenes should be rendered with post process
	 *
	 * @return TRUE if post process is enabled for any of the UI scenes
	 */
	virtual UBOOL UsesPostProcess() const;
};

struct FSoundEventMapping
{
    FName SoundEventName;
    class USoundCue* SoundToPlay;

    /** Constructors */
    FSoundEventMapping() {}
    FSoundEventMapping(EEventParm)
    {
        appMemzero(this, sizeof(FSoundEventMapping));
    }
};

struct UISoundTheme_eventProcessSoundEvent_Parms
{
    FName SoundEventName;
    class APlayerController* SoundOwner;
    UISoundTheme_eventProcessSoundEvent_Parms(EEventParm)
    {
    }
};
class UUISoundTheme : public UObject
{
public:
    //## BEGIN PROPS UISoundTheme
    TArrayNoInit<struct FSoundEventMapping> SoundEventBindings;
    //## END PROPS UISoundTheme

    void eventProcessSoundEvent(FName SoundEventName,class APlayerController* SoundOwner=NULL)
    {
        UISoundTheme_eventProcessSoundEvent_Parms Parms(EC_EventParm);
        Parms.SoundEventName=SoundEventName;
        Parms.SoundOwner=SoundOwner;
        ProcessEvent(FindFunctionChecked(ENGINE_ProcessSoundEvent),&Parms);
    }
    DECLARE_CLASS(UUISoundTheme,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UUISoundTheme)
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_USERINTERFACE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetSceneClient);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetCurrentUIController);
AUTOGENERATE_FUNCTION(UUIRoot,-1,execGetInputPlatformType);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execFindPlayerDataStoreIndex);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execUnregisterDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execRegisterDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execCreateDataStore);
AUTOGENERATE_FUNCTION(UDataStoreClient,-1,execFindDataStore);
AUTOGENERATE_FUNCTION(UInteraction,-1,execInit);
AUTOGENERATE_FUNCTION(UConsole,-1,execUpdateCompleteIndices);
AUTOGENERATE_FUNCTION(UConsole,-1,execBuildRuntimeAutoCompleteList);
AUTOGENERATE_FUNCTION(UInput,-1,execGetBind);
AUTOGENERATE_FUNCTION(UInput,-1,execResetInput);
AUTOGENERATE_FUNCTION(UPlayerInput,-1,execInitInputSystem);
AUTOGENERATE_FUNCTION(UPlayerInput,-1,execCancelMobileInput);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetDataStoreClient);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerControllerId);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerIndex);
AUTOGENERATE_FUNCTION(UUIInteraction,-1,execGetPlayerCount);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execGetInverseCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execGetCanvasToScreen);
AUTOGENERATE_FUNCTION(UUISceneClient,-1,execIsUIActive);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_USERINTERFACE_NATIVE_DEFS
#define ENGINE_USERINTERFACE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_USERINTERFACE \
	UUIRoot::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIRoot"), GEngineUUIRootNatives); \
	UDataStoreClient::StaticClass(); \
	GNativeLookupFuncs.Set(FName("DataStoreClient"), GEngineUDataStoreClientNatives); \
	UInteraction::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Interaction"), GEngineUInteractionNatives); \
	UConsole::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Console"), GEngineUConsoleNatives); \
	UInput::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Input"), GEngineUInputNatives); \
	UPlayerInput::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PlayerInput"), GEngineUPlayerInputNatives); \
	UPlayerManagerInteraction::StaticClass(); \
	UUIInteraction::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIInteraction"), GEngineUUIInteractionNatives); \
	UUISceneClient::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UISceneClient"), GEngineUUISceneClientNatives); \
	UUISoundTheme::StaticClass(); \

#endif // ENGINE_USERINTERFACE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineUUIRootNatives[] = 
{ 
	MAP_NATIVE(UUIRoot, execGetSceneClient)
	MAP_NATIVE(UUIRoot, execGetCurrentUIController)
	MAP_NATIVE(UUIRoot, execGetInputPlatformType)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUDataStoreClientNatives[] = 
{ 
	MAP_NATIVE(UDataStoreClient, execFindPlayerDataStoreIndex)
	MAP_NATIVE(UDataStoreClient, execUnregisterDataStore)
	MAP_NATIVE(UDataStoreClient, execRegisterDataStore)
	MAP_NATIVE(UDataStoreClient, execCreateDataStore)
	MAP_NATIVE(UDataStoreClient, execFindDataStore)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUInteractionNatives[] = 
{ 
	MAP_NATIVE(UInteraction, execInit)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUConsoleNatives[] = 
{ 
	MAP_NATIVE(UConsole, execUpdateCompleteIndices)
	MAP_NATIVE(UConsole, execBuildRuntimeAutoCompleteList)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUInputNatives[] = 
{ 
	MAP_NATIVE(UInput, execGetBind)
	MAP_NATIVE(UInput, execResetInput)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUPlayerInputNatives[] = 
{ 
	MAP_NATIVE(UPlayerInput, execInitInputSystem)
	MAP_NATIVE(UPlayerInput, execCancelMobileInput)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIInteractionNatives[] = 
{ 
	MAP_NATIVE(UUIInteraction, execGetDataStoreClient)
	MAP_NATIVE(UUIInteraction, execGetPlayerControllerId)
	MAP_NATIVE(UUIInteraction, execGetPlayerIndex)
	MAP_NATIVE(UUIInteraction, execGetPlayerCount)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUISceneClientNatives[] = 
{ 
	MAP_NATIVE(UUISceneClient, execGetInverseCanvasToScreen)
	MAP_NATIVE(UUISceneClient, execGetCanvasToScreen)
	MAP_NATIVE(UUISceneClient, execIsUIActive)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UUIRoot,UIRoot,BadCapsLocContexts)
VERIFY_CLASS_SIZE_NODIE(UUIRoot)
VERIFY_CLASS_OFFSET_NODIE(UDataStoreClient,DataStoreClient,GlobalDataStoreClasses)
VERIFY_CLASS_OFFSET_NODIE(UDataStoreClient,DataStoreClient,PlayerDataStores)
VERIFY_CLASS_SIZE_NODIE(UDataStoreClient)
VERIFY_CLASS_OFFSET_NODIE(UInteraction,Interaction,__OnReceivedNativeInputKey__Delegate)
VERIFY_CLASS_OFFSET_NODIE(UInteraction,Interaction,__OnInitialize__Delegate)
VERIFY_CLASS_SIZE_NODIE(UInteraction)
VERIFY_CLASS_OFFSET_NODIE(UConsole,Console,ConsoleTargetPlayer)
VERIFY_CLASS_OFFSET_NODIE(UConsole,Console,AutoCompleteIndices)
VERIFY_CLASS_SIZE_NODIE(UConsole)
VERIFY_CLASS_OFFSET_NODIE(UInput,Input,Bindings)
VERIFY_CLASS_OFFSET_NODIE(UInput,Input,CurrentTouches)
VERIFY_CLASS_SIZE_NODIE(UInput)
VERIFY_CLASS_OFFSET_NODIE(UPlayerInput,PlayerInput,LastAxisKeyName)
VERIFY_CLASS_OFFSET_NODIE(UPlayerInput,PlayerInput,AutoUnlockTurnTime)
VERIFY_CLASS_SIZE_NODIE(UPlayerInput)
VERIFY_CLASS_SIZE_NODIE(UPlayerManagerInteraction)
VERIFY_CLASS_OFFSET_NODIE(UUIInteraction,UIInteraction,UIManager)
VERIFY_CLASS_OFFSET_NODIE(UUIInteraction,UIInteraction,AxisInputEmulation)
VERIFY_CLASS_SIZE_NODIE(UUIInteraction)
VERIFY_CLASS_OFFSET_NODIE(UUISceneClient,UISceneClient,RenderViewport)
VERIFY_CLASS_OFFSET_NODIE(UUISceneClient,UISceneClient,UIScenePostProcess)
VERIFY_CLASS_SIZE_NODIE(UUISceneClient)
VERIFY_CLASS_OFFSET_NODIE(UUISoundTheme,UISoundTheme,SoundEventBindings)
VERIFY_CLASS_SIZE_NODIE(UUISoundTheme)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
