/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_ENUMS
#define INCLUDED_ENGINE_ENUMS 1

enum EDoubleClickDir
{
    DCLICK_None             =0,
    DCLICK_Left             =1,
    DCLICK_Right            =2,
    DCLICK_Forward          =3,
    DCLICK_Back             =4,
    DCLICK_Active           =5,
    DCLICK_Done             =6,
    DCLICK_MAX              =7,
};
#define FOREACH_ENUM_EDOUBLECLICKDIR(op) \
    op(DCLICK_None) \
    op(DCLICK_Left) \
    op(DCLICK_Right) \
    op(DCLICK_Forward) \
    op(DCLICK_Back) \
    op(DCLICK_Active) \
    op(DCLICK_Done) 
enum ETravelType
{
    TRAVEL_Absolute         =0,
    TRAVEL_Partial          =1,
    TRAVEL_Relative         =2,
    TRAVEL_MAX              =3,
};
#define FOREACH_ENUM_ETRAVELTYPE(op) \
    op(TRAVEL_Absolute) \
    op(TRAVEL_Partial) \
    op(TRAVEL_Relative) 
enum ECollisionType
{
    COLLIDE_CustomDefault   =0,
    COLLIDE_NoCollision     =1,
    COLLIDE_BlockAll        =2,
    COLLIDE_BlockWeapons    =3,
    COLLIDE_TouchAll        =4,
    COLLIDE_TouchWeapons    =5,
    COLLIDE_BlockAllButWeapons=6,
    COLLIDE_TouchAllButWeapons=7,
    COLLIDE_BlockWeaponsKickable=8,
    COLLIDE_MAX             =9,
};
#define FOREACH_ENUM_ECOLLISIONTYPE(op) \
    op(COLLIDE_CustomDefault) \
    op(COLLIDE_NoCollision) \
    op(COLLIDE_BlockAll) \
    op(COLLIDE_BlockWeapons) \
    op(COLLIDE_TouchAll) \
    op(COLLIDE_TouchWeapons) \
    op(COLLIDE_BlockAllButWeapons) \
    op(COLLIDE_TouchAllButWeapons) \
    op(COLLIDE_BlockWeaponsKickable) 
enum ENetRole
{
    ROLE_None               =0,
    ROLE_SimulatedProxy     =1,
    ROLE_AutonomousProxy    =2,
    ROLE_Authority          =3,
    ROLE_MAX                =4,
};
#define FOREACH_ENUM_ENETROLE(op) \
    op(ROLE_None) \
    op(ROLE_SimulatedProxy) \
    op(ROLE_AutonomousProxy) \
    op(ROLE_Authority) 
enum EActorMetricsType
{
    METRICS_VERTS           =0,
    METRICS_TRIS            =1,
    METRICS_SECTIONS        =2,
    METRICS_MAX             =3,
};
#define FOREACH_ENUM_EACTORMETRICSTYPE(op) \
    op(METRICS_VERTS) \
    op(METRICS_TRIS) \
    op(METRICS_SECTIONS) 
enum EMoveDir
{
    MD_Stationary           =0,
    MD_Forward              =1,
    MD_Backward             =2,
    MD_Left                 =3,
    MD_Right                =4,
    MD_Up                   =5,
    MD_Down                 =6,
    MD_MAX                  =7,
};
#define FOREACH_ENUM_EMOVEDIR(op) \
    op(MD_Stationary) \
    op(MD_Forward) \
    op(MD_Backward) \
    op(MD_Left) \
    op(MD_Right) \
    op(MD_Up) \
    op(MD_Down) 
enum EPhysics
{
    PHYS_None               =0,
    PHYS_Walking            =1,
    PHYS_Falling            =2,
    PHYS_Swimming           =3,
    PHYS_Flying             =4,
    PHYS_Rotating           =5,
    PHYS_Projectile         =6,
    PHYS_Interpolating      =7,
    PHYS_Spider             =8,
    PHYS_Ladder             =9,
    PHYS_RigidBody          =10,
    PHYS_SoftBody           =11,
    PHYS_NavMeshWalking     =12,
    PHYS_Unused             =13,
    PHYS_Custom             =14,
    PHYS_MAX                =15,
};
#define FOREACH_ENUM_EPHYSICS(op) \
    op(PHYS_None) \
    op(PHYS_Walking) \
    op(PHYS_Falling) \
    op(PHYS_Swimming) \
    op(PHYS_Flying) \
    op(PHYS_Rotating) \
    op(PHYS_Projectile) \
    op(PHYS_Interpolating) \
    op(PHYS_Spider) \
    op(PHYS_Ladder) \
    op(PHYS_RigidBody) \
    op(PHYS_SoftBody) \
    op(PHYS_NavMeshWalking) \
    op(PHYS_Unused) \
    op(PHYS_Custom) 
enum ECsgOper
{
    CSG_Active              =0,
    CSG_Add                 =1,
    CSG_Subtract            =2,
    CSG_Intersect           =3,
    CSG_Deintersect         =4,
    CSG_MAX                 =5,
};
#define FOREACH_ENUM_ECSGOPER(op) \
    op(CSG_Active) \
    op(CSG_Add) \
    op(CSG_Subtract) \
    op(CSG_Intersect) \
    op(CSG_Deintersect) 
enum LevelGridCellShape
{
    LGCS_Box                =0,
    LGCS_Hex                =1,
    LGCS_MAX                =2,
};
#define FOREACH_ENUM_LEVELGRIDCELLSHAPE(op) \
    op(LGCS_Box) \
    op(LGCS_Hex) 
enum EStreamingVolumeUsage
{
    SVB_Loading             =0,
    SVB_LoadingAndVisibility=1,
    SVB_VisibilityBlockingOnLoad=2,
    SVB_BlockingOnLoad      =3,
    SVB_LoadingNotVisible   =4,
    SVB_MAX                 =5,
};
#define FOREACH_ENUM_ESTREAMINGVOLUMEUSAGE(op) \
    op(SVB_Loading) \
    op(SVB_LoadingAndVisibility) \
    op(SVB_VisibilityBlockingOnLoad) \
    op(SVB_BlockingOnLoad) \
    op(SVB_LoadingNotVisible) 
enum EFocusType
{
    FOCUS_Distance          =0,
    FOCUS_Position          =1,
    FOCUS_MAX               =2,
};
#define FOREACH_ENUM_EFOCUSTYPE(op) \
    op(FOCUS_Distance) \
    op(FOCUS_Position) 
enum ReverbPreset
{
    REVERB_Default          =0,
    REVERB_Bathroom         =1,
    REVERB_StoneRoom        =2,
    REVERB_Auditorium       =3,
    REVERB_ConcertHall      =4,
    REVERB_Cave             =5,
    REVERB_Hallway          =6,
    REVERB_StoneCorridor    =7,
    REVERB_Alley            =8,
    REVERB_Forest           =9,
    REVERB_City             =10,
    REVERB_Mountains        =11,
    REVERB_Quarry           =12,
    REVERB_Plain            =13,
    REVERB_ParkingLot       =14,
    REVERB_SewerPipe        =15,
    REVERB_Underwater       =16,
    REVERB_SmallRoom        =17,
    REVERB_MediumRoom       =18,
    REVERB_LargeRoom        =19,
    REVERB_MediumHall       =20,
    REVERB_LargeHall        =21,
    REVERB_Plate            =22,
    REVERB_MAX              =23,
};
#define FOREACH_ENUM_REVERBPRESET(op) \
    op(REVERB_Default) \
    op(REVERB_Bathroom) \
    op(REVERB_StoneRoom) \
    op(REVERB_Auditorium) \
    op(REVERB_ConcertHall) \
    op(REVERB_Cave) \
    op(REVERB_Hallway) \
    op(REVERB_StoneCorridor) \
    op(REVERB_Alley) \
    op(REVERB_Forest) \
    op(REVERB_City) \
    op(REVERB_Mountains) \
    op(REVERB_Quarry) \
    op(REVERB_Plain) \
    op(REVERB_ParkingLot) \
    op(REVERB_SewerPipe) \
    op(REVERB_Underwater) \
    op(REVERB_SmallRoom) \
    op(REVERB_MediumRoom) \
    op(REVERB_LargeRoom) \
    op(REVERB_MediumHall) \
    op(REVERB_LargeHall) \
    op(REVERB_Plate) 
enum ECanvasBlendMode
{
    BLEND_CANVAS_Opaque     =0,
    BLEND_CANVAS_Masked     =1,
    BLEND_CANVAS_Translucent=2,
    BLEND_CANVAS_Additive   =3,
    BLEND_CANVAS_Modulate   =4,
    BLEND_CANVAS_ModulateAndAdd=5,
    BLEND_CANVAS_SoftMasked =6,
    BLEND_CANVAS_AlphaComposite=7,
    BLEND_CANVAS_DitheredTranslucent=8,
    BLEND_CANVAS_AlphaOnly  =9,
    BLEND_CANVAS_MAX        =10,
};
#define FOREACH_ENUM_ECANVASBLENDMODE(op) \
    op(BLEND_CANVAS_Opaque) \
    op(BLEND_CANVAS_Masked) \
    op(BLEND_CANVAS_Translucent) \
    op(BLEND_CANVAS_Additive) \
    op(BLEND_CANVAS_Modulate) \
    op(BLEND_CANVAS_ModulateAndAdd) \
    op(BLEND_CANVAS_SoftMasked) \
    op(BLEND_CANVAS_AlphaComposite) \
    op(BLEND_CANVAS_DitheredTranslucent) \
    op(BLEND_CANVAS_AlphaOnly) 
enum EPropertyValueMappingType
{
    PVMT_RawValue           =0,
    PVMT_PredefinedValues   =1,
    PVMT_Ranged             =2,
    PVMT_IdMapped           =3,
    PVMT_MAX                =4,
};
#define FOREACH_ENUM_EPROPERTYVALUEMAPPINGTYPE(op) \
    op(PVMT_RawValue) \
    op(PVMT_PredefinedValues) \
    op(PVMT_Ranged) \
    op(PVMT_IdMapped) 
enum ESettingsDataType
{
    SDT_Empty               =0,
    SDT_Int32               =1,
    SDT_Int64               =2,
    SDT_Double              =3,
    SDT_String              =4,
    SDT_Float               =5,
    SDT_Blob                =6,
    SDT_DateTime            =7,
    SDT_MAX                 =8,
};
#define FOREACH_ENUM_ESETTINGSDATATYPE(op) \
    op(SDT_Empty) \
    op(SDT_Int32) \
    op(SDT_Int64) \
    op(SDT_Double) \
    op(SDT_String) \
    op(SDT_Float) \
    op(SDT_Blob) \
    op(SDT_DateTime) 
enum EOnlineDataAdvertisementType
{
    ODAT_DontAdvertise      =0,
    ODAT_OnlineService      =1,
    ODAT_QoS                =2,
    ODAT_OnlineServiceAndQoS=3,
    ODAT_MAX                =4,
};
#define FOREACH_ENUM_EONLINEDATAADVERTISEMENTTYPE(op) \
    op(ODAT_DontAdvertise) \
    op(ODAT_OnlineService) \
    op(ODAT_QoS) \
    op(ODAT_OnlineServiceAndQoS) 
enum EOnlineNewsType
{
    ONT_Unknown             =0,
    ONT_GameNews            =1,
    ONT_ContentAnnouncements=2,
    ONT_Misc                =3,
    ONT_MAX                 =4,
};
#define FOREACH_ENUM_EONLINENEWSTYPE(op) \
    op(ONT_Unknown) \
    op(ONT_GameNews) \
    op(ONT_ContentAnnouncements) \
    op(ONT_Misc) 
enum EOnlineAccountCreateStatus
{
    OACS_CreateSuccessful   =0,
    OACS_UnknownError       =1,
    OACS_InvalidUserName    =2,
    OACS_InvalidPassword    =3,
    OACS_InvalidUniqueUserName=4,
    OACS_UniqueUserNameInUse=5,
    OACS_ServiceUnavailable =6,
    OACS_MAX                =7,
};
#define FOREACH_ENUM_EONLINEACCOUNTCREATESTATUS(op) \
    op(OACS_CreateSuccessful) \
    op(OACS_UnknownError) \
    op(OACS_InvalidUserName) \
    op(OACS_InvalidPassword) \
    op(OACS_InvalidUniqueUserName) \
    op(OACS_UniqueUserNameInUse) \
    op(OACS_ServiceUnavailable) 
enum ELanBeaconState
{
    LANB_NotUsingLanBeacon  =0,
    LANB_Hosting            =1,
    LANB_Searching          =2,
    LANB_MAX                =3,
};
#define FOREACH_ENUM_ELANBEACONSTATE(op) \
    op(LANB_NotUsingLanBeacon) \
    op(LANB_Hosting) \
    op(LANB_Searching) 
enum ENATType
{
    NAT_Unknown             =0,
    NAT_Open                =1,
    NAT_Moderate            =2,
    NAT_Strict              =3,
    NAT_MAX                 =4,
};
#define FOREACH_ENUM_ENATTYPE(op) \
    op(NAT_Unknown) \
    op(NAT_Open) \
    op(NAT_Moderate) \
    op(NAT_Strict) 
enum EOnlineServerConnectionStatus
{
    OSCS_NotConnected       =0,
    OSCS_Connected          =1,
    OSCS_ConnectionDropped  =2,
    OSCS_NoNetworkConnection=3,
    OSCS_ServiceUnavailable =4,
    OSCS_UpdateRequired     =5,
    OSCS_ServersTooBusy     =6,
    OSCS_DuplicateLoginDetected=7,
    OSCS_InvalidUser        =8,
    OSCS_MAX                =9,
};
#define FOREACH_ENUM_EONLINESERVERCONNECTIONSTATUS(op) \
    op(OSCS_NotConnected) \
    op(OSCS_Connected) \
    op(OSCS_ConnectionDropped) \
    op(OSCS_NoNetworkConnection) \
    op(OSCS_ServiceUnavailable) \
    op(OSCS_UpdateRequired) \
    op(OSCS_ServersTooBusy) \
    op(OSCS_DuplicateLoginDetected) \
    op(OSCS_InvalidUser) 
enum EOnlineContentType
{
    OCT_Downloaded          =0,
    OCT_SaveGame            =1,
    OCT_MAX                 =2,
};
#define FOREACH_ENUM_EONLINECONTENTTYPE(op) \
    op(OCT_Downloaded) \
    op(OCT_SaveGame) 
enum EOnlineFriendState
{
    OFS_Offline             =0,
    OFS_Online              =1,
    OFS_Away                =2,
    OFS_Busy                =3,
    OFS_MAX                 =4,
};
#define FOREACH_ENUM_EONLINEFRIENDSTATE(op) \
    op(OFS_Offline) \
    op(OFS_Online) \
    op(OFS_Away) \
    op(OFS_Busy) 
enum EOnlineEnumerationReadState
{
    OERS_NotStarted         =0,
    OERS_InProgress         =1,
    OERS_Done               =2,
    OERS_Failed             =3,
    OERS_MAX                =4,
};
#define FOREACH_ENUM_EONLINEENUMERATIONREADSTATE(op) \
    op(OERS_NotStarted) \
    op(OERS_InProgress) \
    op(OERS_Done) \
    op(OERS_Failed) 
enum EOnlineGameState
{
    OGS_NoSession           =0,
    OGS_Pending             =1,
    OGS_Starting            =2,
    OGS_InProgress          =3,
    OGS_Ending              =4,
    OGS_Ended               =5,
    OGS_MAX                 =6,
};
#define FOREACH_ENUM_EONLINEGAMESTATE(op) \
    op(OGS_NoSession) \
    op(OGS_Pending) \
    op(OGS_Starting) \
    op(OGS_InProgress) \
    op(OGS_Ending) \
    op(OGS_Ended) 
enum ENetworkNotificationPosition
{
    NNP_TopLeft             =0,
    NNP_TopCenter           =1,
    NNP_TopRight            =2,
    NNP_CenterLeft          =3,
    NNP_Center              =4,
    NNP_CenterRight         =5,
    NNP_BottomLeft          =6,
    NNP_BottomCenter        =7,
    NNP_BottomRight         =8,
    NNP_MAX                 =9,
};
#define FOREACH_ENUM_ENETWORKNOTIFICATIONPOSITION(op) \
    op(NNP_TopLeft) \
    op(NNP_TopCenter) \
    op(NNP_TopRight) \
    op(NNP_CenterLeft) \
    op(NNP_Center) \
    op(NNP_CenterRight) \
    op(NNP_BottomLeft) \
    op(NNP_BottomCenter) \
    op(NNP_BottomRight) 
enum EFeaturePrivilegeLevel
{
    FPL_Disabled            =0,
    FPL_EnabledFriendsOnly  =1,
    FPL_Enabled             =2,
    FPL_MAX                 =3,
};
#define FOREACH_ENUM_EFEATUREPRIVILEGELEVEL(op) \
    op(FPL_Disabled) \
    op(FPL_EnabledFriendsOnly) \
    op(FPL_Enabled) 
enum ELoginStatus
{
    LS_NotLoggedIn          =0,
    LS_UsingLocalProfile    =1,
    LS_LoggedIn             =2,
    LS_MAX                  =3,
};
#define FOREACH_ENUM_ELOGINSTATUS(op) \
    op(LS_NotLoggedIn) \
    op(LS_UsingLocalProfile) \
    op(LS_LoggedIn) 
enum EAuthStatus
{
    AUS_NotStarted          =0,
    AUS_Pending             =1,
    AUS_Authenticated       =2,
    AUS_Failed              =3,
    AUS_MAX                 =4,
};
#define FOREACH_ENUM_EAUTHSTATUS(op) \
    op(AUS_NotStarted) \
    op(AUS_Pending) \
    op(AUS_Authenticated) \
    op(AUS_Failed) 
enum ENavMeshEdgeType
{
    NAVEDGE_Normal          =0,
    NAVEDGE_Mantle          =1,
    NAVEDGE_Coverslip       =2,
    NAVEDGE_SwatTurn        =3,
    NAVEDGE_DropDown        =4,
    NAVEDGE_PathObject      =5,
    NAVEDGE_BackRefDummy    =6,
    NAVEDGE_Jump            =7,
    NAVEDGE_MAX             =8,
};
#define FOREACH_ENUM_ENAVMESHEDGETYPE(op) \
    op(NAVEDGE_Normal) \
    op(NAVEDGE_Mantle) \
    op(NAVEDGE_Coverslip) \
    op(NAVEDGE_SwatTurn) \
    op(NAVEDGE_DropDown) \
    op(NAVEDGE_PathObject) \
    op(NAVEDGE_BackRefDummy) \
    op(NAVEDGE_Jump) 
enum EFireLinkID
{
    FLI_FireLink            =0,
    FLI_RejectedFireLink    =1,
    FLI_MAX                 =2,
};
#define FOREACH_ENUM_EFIRELINKID(op) \
    op(FLI_FireLink) \
    op(FLI_RejectedFireLink) 
enum ECoverLocationDescription
{
    CoverDesc_None          =0,
    CoverDesc_InWindow      =1,
    CoverDesc_InDoorway     =2,
    CoverDesc_BehindCar     =3,
    CoverDesc_BehindTruck   =4,
    CoverDesc_OnTruck       =5,
    CoverDesc_BehindBarrier =6,
    CoverDesc_BehindColumn  =7,
    CoverDesc_BehindCrate   =8,
    CoverDesc_BehindWall    =9,
    CoverDesc_BehindStatue  =10,
    CoverDesc_BehindSandbags=11,
    CoverDesc_MAX           =12,
};
#define FOREACH_ENUM_ECOVERLOCATIONDESCRIPTION(op) \
    op(CoverDesc_None) \
    op(CoverDesc_InWindow) \
    op(CoverDesc_InDoorway) \
    op(CoverDesc_BehindCar) \
    op(CoverDesc_BehindTruck) \
    op(CoverDesc_OnTruck) \
    op(CoverDesc_BehindBarrier) \
    op(CoverDesc_BehindColumn) \
    op(CoverDesc_BehindCrate) \
    op(CoverDesc_BehindWall) \
    op(CoverDesc_BehindStatue) \
    op(CoverDesc_BehindSandbags) 
enum ECoverType
{
    CT_None                 =0,
    CT_Standing             =1,
    CT_MidLevel             =2,
    CT_MAX                  =3,
};
#define FOREACH_ENUM_ECOVERTYPE(op) \
    op(CT_None) \
    op(CT_Standing) \
    op(CT_MidLevel) 
enum ECoverDirection
{
    CD_Default              =0,
    CD_Left                 =1,
    CD_Right                =2,
    CD_Up                   =3,
    CD_MAX                  =4,
};
#define FOREACH_ENUM_ECOVERDIRECTION(op) \
    op(CD_Default) \
    op(CD_Left) \
    op(CD_Right) \
    op(CD_Up) 
enum ECoverAction
{
    CA_Default              =0,
    CA_BlindLeft            =1,
    CA_BlindRight           =2,
    CA_LeanLeft             =3,
    CA_LeanRight            =4,
    CA_PopUp                =5,
    CA_BlindUp              =6,
    CA_PeekLeft             =7,
    CA_PeekRight            =8,
    CA_PeekUp               =9,
    CA_MAX                  =10,
};
#define FOREACH_ENUM_ECOVERACTION(op) \
    op(CA_Default) \
    op(CA_BlindLeft) \
    op(CA_BlindRight) \
    op(CA_LeanLeft) \
    op(CA_LeanRight) \
    op(CA_PopUp) \
    op(CA_BlindUp) \
    op(CA_PeekLeft) \
    op(CA_PeekRight) \
    op(CA_PeekUp) 
enum ECoverGroupFillAction
{
    CGFA_Overwrite          =0,
    CGFA_Add                =1,
    CGFA_Remove             =2,
    CGFA_Clear              =3,
    CGFA_Cylinder           =4,
    CGFA_MAX                =5,
};
#define FOREACH_ENUM_ECOVERGROUPFILLACTION(op) \
    op(CGFA_Overwrite) \
    op(CGFA_Add) \
    op(CGFA_Remove) \
    op(CGFA_Clear) \
    op(CGFA_Cylinder) 
enum FWFileType
{
    FWFT_Log                =0,
    FWFT_Stats              =1,
    FWFT_HTML               =2,
    FWFT_User               =3,
    FWFT_Debug              =4,
    FWFT_MAX                =5,
};
#define FOREACH_ENUM_FWFILETYPE(op) \
    op(FWFT_Log) \
    op(FWFT_Stats) \
    op(FWFT_HTML) \
    op(FWFT_User) \
    op(FWFT_Debug) 
enum EStandbyType
{
    STDBY_Rx                =0,
    STDBY_Tx                =1,
    STDBY_BadPing           =2,
    STDBY_MAX               =3,
};
#define FOREACH_ENUM_ESTANDBYTYPE(op) \
    op(STDBY_Rx) \
    op(STDBY_Tx) \
    op(STDBY_BadPing) 
enum ERouteType
{
    ERT_Linear              =0,
    ERT_Loop                =1,
    ERT_Circle              =2,
    ERT_MAX                 =3,
};
#define FOREACH_ENUM_EROUTETYPE(op) \
    op(ERT_Linear) \
    op(ERT_Loop) \
    op(ERT_Circle) 
enum ERouteDirection
{
    ERD_Forward             =0,
    ERD_Reverse             =1,
    ERD_MAX                 =2,
};
#define FOREACH_ENUM_EROUTEDIRECTION(op) \
    op(ERD_Forward) \
    op(ERD_Reverse) 
enum ERouteFillAction
{
    RFA_Overwrite           =0,
    RFA_Add                 =1,
    RFA_Remove              =2,
    RFA_Clear               =3,
    RFA_MAX                 =4,
};
#define FOREACH_ENUM_EROUTEFILLACTION(op) \
    op(RFA_Overwrite) \
    op(RFA_Add) \
    op(RFA_Remove) \
    op(RFA_Clear) 
enum EWeaponFireType
{
    EWFT_InstantHit         =0,
    EWFT_Projectile         =1,
    EWFT_Custom             =2,
    EWFT_None               =3,
    EWFT_MAX                =4,
};
#define FOREACH_ENUM_EWEAPONFIRETYPE(op) \
    op(EWFT_InstantHit) \
    op(EWFT_Projectile) \
    op(EWFT_Custom) \
    op(EWFT_None) 
enum EDoorType
{
    DOOR_Shoot              =0,
    DOOR_Touch              =1,
    DOOR_MAX                =2,
};
#define FOREACH_ENUM_EDOORTYPE(op) \
    op(DOOR_Shoot) \
    op(DOOR_Touch) 
enum ESceneCaptureViewMode
{
    SceneCapView_Lit        =0,
    SceneCapView_Unlit      =1,
    SceneCapView_LitNoShadows=2,
    SceneCapView_Wire       =3,
    SceneCapView_MAX        =4,
};
#define FOREACH_ENUM_ESCENECAPTUREVIEWMODE(op) \
    op(SceneCapView_Lit) \
    op(SceneCapView_Unlit) \
    op(SceneCapView_LitNoShadows) \
    op(SceneCapView_Wire) 
enum SaveSlotOperationEnum
{
    SSO_SET                 =0,
    SSO_GET                 =1,
    SSO_DELETE              =2,
    SSO_MAX                 =3,
};
#define FOREACH_ENUM_SAVESLOTOPERATIONENUM(op) \
    op(SSO_SET) \
    op(SSO_GET) \
    op(SSO_DELETE) 
enum SaveDataVersionSupport
{
    SaveDataVersionSupportLessThenEqual=0,
    SaveDataVersionSupportEqual=1,
    SaveDataVersionSupportAny=2,
    SaveDataVersionSupport_MAX=3,
};
#define FOREACH_ENUM_SAVEDATAVERSIONSUPPORT(op) \
    op(SaveDataVersionSupportLessThenEqual) \
    op(SaveDataVersionSupportEqual) \
    op(SaveDataVersionSupportAny) 
enum DistributionParamMode
{
    DPM_Normal              =0,
    DPM_Abs                 =1,
    DPM_Direct              =2,
    DPM_MAX                 =3,
};
#define FOREACH_ENUM_DISTRIBUTIONPARAMMODE(op) \
    op(DPM_Normal) \
    op(DPM_Abs) \
    op(DPM_Direct) 
enum ELightingBuildQuality
{
    Quality_Preview         =0,
    Quality_Medium          =1,
    Quality_High            =2,
    Quality_Production      =3,
    Quality_NoGlobalIllumination=4,
    Quality_MAX             =5,
};
#define FOREACH_ENUM_ELIGHTINGBUILDQUALITY(op) \
    op(Quality_Preview) \
    op(Quality_Medium) \
    op(Quality_High) \
    op(Quality_Production) \
    op(Quality_NoGlobalIllumination) 
enum EMobileAmbientOcclusionSource
{
    MAOS_Disabled           =0,
    MAOS_VertexColorRed     =1,
    MAOS_VertexColorGreen   =2,
    MAOS_VertexColorBlue    =3,
    MAOS_VertexColorAlpha   =4,
    MAOS_MAX                =5,
};
#define FOREACH_ENUM_EMOBILEAMBIENTOCCLUSIONSOURCE(op) \
    op(MAOS_Disabled) \
    op(MAOS_VertexColorRed) \
    op(MAOS_VertexColorGreen) \
    op(MAOS_VertexColorBlue) \
    op(MAOS_VertexColorAlpha) 
enum EMobileSpecularMask
{
    MSM_Constant            =0,
    MSM_Luminance           =1,
    MSM_DiffuseRed          =2,
    MSM_DiffuseGreen        =3,
    MSM_DiffuseBlue         =4,
    MSM_DiffuseAlpha        =5,
    MSM_MaskTextureRGB      =6,
    MSM_MaskTextureRed      =7,
    MSM_MaskTextureGreen    =8,
    MSM_MaskTextureBlue     =9,
    MSM_MaskTextureAlpha    =10,
    MSM_MAX                 =11,
};
#define FOREACH_ENUM_EMOBILESPECULARMASK(op) \
    op(MSM_Constant) \
    op(MSM_Luminance) \
    op(MSM_DiffuseRed) \
    op(MSM_DiffuseGreen) \
    op(MSM_DiffuseBlue) \
    op(MSM_DiffuseAlpha) \
    op(MSM_MaskTextureRGB) \
    op(MSM_MaskTextureRed) \
    op(MSM_MaskTextureGreen) \
    op(MSM_MaskTextureBlue) \
    op(MSM_MaskTextureAlpha) 
enum EMobileEnvironmentBlendMode
{
    MEBM_Add                =0,
    MEBM_Lerp               =1,
    MEBM_MAX                =2,
};
#define FOREACH_ENUM_EMOBILEENVIRONMENTBLENDMODE(op) \
    op(MEBM_Add) \
    op(MEBM_Lerp) 
enum EMobileEmissiveColorSource
{
    MECS_EmissiveTexture    =0,
    MECS_BaseTexture        =1,
    MECS_Constant           =2,
    MECS_MAX                =3,
};
#define FOREACH_ENUM_EMOBILEEMISSIVECOLORSOURCE(op) \
    op(MECS_EmissiveTexture) \
    op(MECS_BaseTexture) \
    op(MECS_Constant) 
enum EMobileColorMultiplySource
{
    MCMS_None               =0,
    MCMS_BaseTextureRed     =1,
    MCMS_BaseTextureGreen   =2,
    MCMS_BaseTextureBlue    =3,
    MCMS_BaseTextureAlpha   =4,
    MCMS_MaskTextureRed     =5,
    MCMS_MaskTextureGreen   =6,
    MCMS_MaskTextureBlue    =7,
    MCMS_MaskTextureAlpha   =8,
    MCMS_MAX                =9,
};
#define FOREACH_ENUM_EMOBILECOLORMULTIPLYSOURCE(op) \
    op(MCMS_None) \
    op(MCMS_BaseTextureRed) \
    op(MCMS_BaseTextureGreen) \
    op(MCMS_BaseTextureBlue) \
    op(MCMS_BaseTextureAlpha) \
    op(MCMS_MaskTextureRed) \
    op(MCMS_MaskTextureGreen) \
    op(MCMS_MaskTextureBlue) \
    op(MCMS_MaskTextureAlpha) 
enum EMobileAlphaValueSource
{
    MAVS_DiffuseTextureAlpha=0,
    MAVS_MaskTextureRed     =1,
    MAVS_MaskTextureGreen   =2,
    MAVS_MaskTextureBlue    =3,
    MAVS_MAX                =4,
};
#define FOREACH_ENUM_EMOBILEALPHAVALUESOURCE(op) \
    op(MAVS_DiffuseTextureAlpha) \
    op(MAVS_MaskTextureRed) \
    op(MAVS_MaskTextureGreen) \
    op(MAVS_MaskTextureBlue) 
enum EMobileTexCoordsSource
{
    MTCS_TexCoords0         =0,
    MTCS_TexCoords1         =1,
    MTCS_TexCoords2         =2,
    MTCS_TexCoords3         =3,
    MTCS_MAX                =4,
};
#define FOREACH_ENUM_EMOBILETEXCOORDSSOURCE(op) \
    op(MTCS_TexCoords0) \
    op(MTCS_TexCoords1) \
    op(MTCS_TexCoords2) \
    op(MTCS_TexCoords3) 
enum EMobileTextureBlendFactorSource
{
    MTBFS_VertexColor       =0,
    MTBFS_MaskTexture       =1,
    MTBFS_MAX               =2,
};
#define FOREACH_ENUM_EMOBILETEXTUREBLENDFACTORSOURCE(op) \
    op(MTBFS_VertexColor) \
    op(MTBFS_MaskTexture) 
enum EMobileValueSource
{
    MVS_Constant            =0,
    MVS_VertexColorRed      =1,
    MVS_VertexColorGreen    =2,
    MVS_VertexColorBlue     =3,
    MVS_VertexColorAlpha    =4,
    MVS_BaseTextureRed      =5,
    MVS_BaseTextureGreen    =6,
    MVS_BaseTextureBlue     =7,
    MVS_BaseTextureAlpha    =8,
    MVS_MaskTextureRed      =9,
    MVS_MaskTextureGreen    =10,
    MVS_MaskTextureBlue     =11,
    MVS_MaskTextureAlpha    =12,
    MVS_NormalTextureAlpha  =13,
    MVS_EmissiveTextureRed  =14,
    MVS_EmissiveTextureGreen=15,
    MVS_EmissiveTextureBlue =16,
    MVS_EmissiveTextureAlpha=17,
    MVS_MAX                 =18,
};
#define FOREACH_ENUM_EMOBILEVALUESOURCE(op) \
    op(MVS_Constant) \
    op(MVS_VertexColorRed) \
    op(MVS_VertexColorGreen) \
    op(MVS_VertexColorBlue) \
    op(MVS_VertexColorAlpha) \
    op(MVS_BaseTextureRed) \
    op(MVS_BaseTextureGreen) \
    op(MVS_BaseTextureBlue) \
    op(MVS_BaseTextureAlpha) \
    op(MVS_MaskTextureRed) \
    op(MVS_MaskTextureGreen) \
    op(MVS_MaskTextureBlue) \
    op(MVS_MaskTextureAlpha) \
    op(MVS_NormalTextureAlpha) \
    op(MVS_EmissiveTextureRed) \
    op(MVS_EmissiveTextureGreen) \
    op(MVS_EmissiveTextureBlue) \
    op(MVS_EmissiveTextureAlpha) 
enum EMaterialTessellationMode
{
    MTM_NoTessellation      =0,
    MTM_FlatTessellation    =1,
    MTM_PNTriangles         =2,
    MTM_MAX                 =3,
};
#define FOREACH_ENUM_EMATERIALTESSELLATIONMODE(op) \
    op(MTM_NoTessellation) \
    op(MTM_FlatTessellation) \
    op(MTM_PNTriangles) 
enum EMaterialLightingModel
{
    MLM_Phong               =0,
    MLM_NonDirectional      =1,
    MLM_Unlit               =2,
    MLM_SHPRT               =3,
    MLM_Custom              =4,
    MLM_Anisotropic         =5,
    MLM_MAX                 =6,
};
#define FOREACH_ENUM_EMATERIALLIGHTINGMODEL(op) \
    op(MLM_Phong) \
    op(MLM_NonDirectional) \
    op(MLM_Unlit) \
    op(MLM_SHPRT) \
    op(MLM_Custom) \
    op(MLM_Anisotropic) 
enum EBlendMode
{
    BLEND_Opaque            =0,
    BLEND_Masked            =1,
    BLEND_Translucent       =2,
    BLEND_Additive          =3,
    BLEND_Modulate          =4,
    BLEND_ModulateAndAdd    =5,
    BLEND_SoftMasked        =6,
    BLEND_AlphaComposite    =7,
    BLEND_DitheredTranslucent=8,
    BLEND_MAX               =9,
};
#define FOREACH_ENUM_EBLENDMODE(op) \
    op(BLEND_Opaque) \
    op(BLEND_Masked) \
    op(BLEND_Translucent) \
    op(BLEND_Additive) \
    op(BLEND_Modulate) \
    op(BLEND_ModulateAndAdd) \
    op(BLEND_SoftMasked) \
    op(BLEND_AlphaComposite) \
    op(BLEND_DitheredTranslucent) 
enum EPathFindingError
{
    PATHERROR_STARTPOLYNOTFOUND=0,
    PATHERROR_GOALPOLYNOTFOUND=1,
    PATHERROR_ANCHORPYLONNOTFOUND=2,
    PATHERROR_NOPATHFOUND   =3,
    PATHERROR_COMPUTEVALIDFINALDEST_FAIL=4,
    PATHERROR_GETNEXTMOVELOCATION_FAIL=5,
    PATHERROR_MOVETIMEOUT   =6,
    PATHERROR_MAX           =7,
};
#define FOREACH_ENUM_EPATHFINDINGERROR(op) \
    op(PATHERROR_STARTPOLYNOTFOUND) \
    op(PATHERROR_GOALPOLYNOTFOUND) \
    op(PATHERROR_ANCHORPYLONNOTFOUND) \
    op(PATHERROR_NOPATHFOUND) \
    op(PATHERROR_COMPUTEVALIDFINALDEST_FAIL) \
    op(PATHERROR_GETNEXTMOVELOCATION_FAIL) \
    op(PATHERROR_MOVETIMEOUT) 
enum EFontImportCharacterSet
{
    FontICS_Default         =0,
    FontICS_Ansi            =1,
    FontICS_Symbol          =2,
    FontICS_MAX             =3,
};
#define FOREACH_ENUM_EFONTIMPORTCHARACTERSET(op) \
    op(FontICS_Default) \
    op(FontICS_Ansi) \
    op(FontICS_Symbol) 
enum EWaveformFunction
{
    WF_Constant             =0,
    WF_LinearIncreasing     =1,
    WF_LinearDecreasing     =2,
    WF_Sin0to90             =3,
    WF_Sin90to180           =4,
    WF_Sin0to180            =5,
    WF_Noise                =6,
    WF_MAX                  =7,
};
#define FOREACH_ENUM_EWAVEFORMFUNCTION(op) \
    op(WF_Constant) \
    op(WF_LinearIncreasing) \
    op(WF_LinearDecreasing) \
    op(WF_Sin0to90) \
    op(WF_Sin90to180) \
    op(WF_Sin0to180) \
    op(WF_Noise) 
enum EGameStatGroups
{
    GSG_EngineStats         =0,
    GSG_Game                =1,
    GSG_Team                =2,
    GSG_Player              =3,
    GSG_Weapon              =4,
    GSG_Damage              =5,
    GSG_Projectile          =6,
    GSG_Pawn                =7,
    GSG_GameSpecific        =8,
    GSG_Aggregate           =9,
    GSG_MAX                 =10,
};
#define FOREACH_ENUM_EGAMESTATGROUPS(op) \
    op(GSG_EngineStats) \
    op(GSG_Game) \
    op(GSG_Team) \
    op(GSG_Player) \
    op(GSG_Weapon) \
    op(GSG_Damage) \
    op(GSG_Projectile) \
    op(GSG_Pawn) \
    op(GSG_GameSpecific) \
    op(GSG_Aggregate) 
enum EOnlineGameSearchSortType
{
    OGSSO_Ascending         =0,
    OGSSO_Descending        =1,
    OGSSO_MAX               =2,
};
#define FOREACH_ENUM_EONLINEGAMESEARCHSORTTYPE(op) \
    op(OGSSO_Ascending) \
    op(OGSSO_Descending) 
enum EOnlineGameSearchComparisonType
{
    OGSCT_Equals            =0,
    OGSCT_NotEquals         =1,
    OGSCT_GreaterThan       =2,
    OGSCT_GreaterThanEquals =3,
    OGSCT_LessThan          =4,
    OGSCT_LessThanEquals    =5,
    OGSCT_MAX               =6,
};
#define FOREACH_ENUM_EONLINEGAMESEARCHCOMPARISONTYPE(op) \
    op(OGSCT_Equals) \
    op(OGSCT_NotEquals) \
    op(OGSCT_GreaterThan) \
    op(OGSCT_GreaterThanEquals) \
    op(OGSCT_LessThan) \
    op(OGSCT_LessThanEquals) 
enum EOnlineGameSearchEntryType
{
    OGSET_Property          =0,
    OGSET_LocalizedSetting  =1,
    OGSET_ObjectProperty    =2,
    OGSET_MAX               =3,
};
#define FOREACH_ENUM_EONLINEGAMESEARCHENTRYTYPE(op) \
    op(OGSET_Property) \
    op(OGSET_LocalizedSetting) \
    op(OGSET_ObjectProperty) 
enum EOnlinePlayerStorageAsyncState
{
    OPAS_NotStarted         =0,
    OPAS_Read               =1,
    OPAS_Write              =2,
    OPAS_Finished           =3,
    OPAS_MAX                =4,
};
#define FOREACH_ENUM_EONLINEPLAYERSTORAGEASYNCSTATE(op) \
    op(OPAS_NotStarted) \
    op(OPAS_Read) \
    op(OPAS_Write) \
    op(OPAS_Finished) 
enum EOnlineProfilePropertyOwner
{
    OPPO_None               =0,
    OPPO_OnlineService      =1,
    OPPO_Game               =2,
    OPPO_MAX                =3,
};
#define FOREACH_ENUM_EONLINEPROFILEPROPERTYOWNER(op) \
    op(OPPO_None) \
    op(OPPO_OnlineService) \
    op(OPPO_Game) 
enum EProfileVoiceThruSpeakersOptions
{
    PVTSO_Off               =0,
    PVTSO_On                =1,
    PVTSO_Both              =2,
    PVTSO_MAX               =3,
};
#define FOREACH_ENUM_EPROFILEVOICETHRUSPEAKERSOPTIONS(op) \
    op(PVTSO_Off) \
    op(PVTSO_On) \
    op(PVTSO_Both) 
enum EProfileControllerVibrationToggleOptions
{
    PCVTO_Off               =0,
    PCVTO_IgnoreThis        =1,
    PCVTO_IgnoreThis2       =2,
    PCVTO_On                =3,
    PCVTO_MAX               =4,
};
#define FOREACH_ENUM_EPROFILECONTROLLERVIBRATIONTOGGLEOPTIONS(op) \
    op(PCVTO_Off) \
    op(PCVTO_IgnoreThis) \
    op(PCVTO_IgnoreThis2) \
    op(PCVTO_On) 
enum EProfileOmniDirEvadeOptions
{
    PODI_Off                =0,
    PODI_On                 =1,
    PODI_MAX                =2,
};
#define FOREACH_ENUM_EPROFILEOMNIDIREVADEOPTIONS(op) \
    op(PODI_Off) \
    op(PODI_On) 
enum EProfileXInversionOptions
{
    PXIO_Off                =0,
    PXIO_On                 =1,
    PXIO_MAX                =2,
};
#define FOREACH_ENUM_EPROFILEXINVERSIONOPTIONS(op) \
    op(PXIO_Off) \
    op(PXIO_On) 
enum EProfileYInversionOptions
{
    PYIO_Off                =0,
    PYIO_On                 =1,
    PYIO_MAX                =2,
};
#define FOREACH_ENUM_EPROFILEYINVERSIONOPTIONS(op) \
    op(PYIO_Off) \
    op(PYIO_On) 
enum EProfileRaceAcceleratorControlOptions
{
    PRACO_Trigger           =0,
    PRACO_Button            =1,
    PRACO_MAX               =2,
};
#define FOREACH_ENUM_EPROFILERACEACCELERATORCONTROLOPTIONS(op) \
    op(PRACO_Trigger) \
    op(PRACO_Button) 
enum EProfileRaceBrakeControlOptions
{
    PRBCO_Trigger           =0,
    PRBCO_Button            =1,
    PRBCO_MAX               =2,
};
#define FOREACH_ENUM_EPROFILERACEBRAKECONTROLOPTIONS(op) \
    op(PRBCO_Trigger) \
    op(PRBCO_Button) 
enum EProfileRaceCameraLocationOptions
{
    PRCLO_Behind            =0,
    PRCLO_Front             =1,
    PRCLO_Inside            =2,
    PRCLO_MAX               =3,
};
#define FOREACH_ENUM_EPROFILERACECAMERALOCATIONOPTIONS(op) \
    op(PRCLO_Behind) \
    op(PRCLO_Front) \
    op(PRCLO_Inside) 
enum EProfileRaceTransmissionOptions
{
    PRTO_Auto               =0,
    PRTO_Manual             =1,
    PRTO_MAX                =2,
};
#define FOREACH_ENUM_EPROFILERACETRANSMISSIONOPTIONS(op) \
    op(PRTO_Auto) \
    op(PRTO_Manual) 
enum EProfileMovementControlOptions
{
    PMCO_L_Thumbstick       =0,
    PMCO_R_Thumbstick       =1,
    PMCO_MAX                =2,
};
#define FOREACH_ENUM_EPROFILEMOVEMENTCONTROLOPTIONS(op) \
    op(PMCO_L_Thumbstick) \
    op(PMCO_R_Thumbstick) 
enum EProfileAutoCenterOptions
{
    PACO_Off                =0,
    PACO_On                 =1,
    PACO_MAX                =2,
};
#define FOREACH_ENUM_EPROFILEAUTOCENTEROPTIONS(op) \
    op(PACO_Off) \
    op(PACO_On) 
enum EProfileAutoAimOptions
{
    PAAO_Off                =0,
    PAAO_On                 =1,
    PAAO_MAX                =2,
};
#define FOREACH_ENUM_EPROFILEAUTOAIMOPTIONS(op) \
    op(PAAO_Off) \
    op(PAAO_On) 
enum EProfilePreferredColorOptions
{
    PPCO_None               =0,
    PPCO_Black              =1,
    PPCO_White              =2,
    PPCO_Yellow             =3,
    PPCO_Orange             =4,
    PPCO_Pink               =5,
    PPCO_Red                =6,
    PPCO_Purple             =7,
    PPCO_Blue               =8,
    PPCO_Green              =9,
    PPCO_Brown              =10,
    PPCO_Silver             =11,
    PPCO_MAX                =12,
};
#define FOREACH_ENUM_EPROFILEPREFERREDCOLOROPTIONS(op) \
    op(PPCO_None) \
    op(PPCO_Black) \
    op(PPCO_White) \
    op(PPCO_Yellow) \
    op(PPCO_Orange) \
    op(PPCO_Pink) \
    op(PPCO_Red) \
    op(PPCO_Purple) \
    op(PPCO_Blue) \
    op(PPCO_Green) \
    op(PPCO_Brown) \
    op(PPCO_Silver) 
enum EProfileControllerSensitivityOptions
{
    PCSO_Medium             =0,
    PCSO_Low                =1,
    PCSO_High               =2,
    PCSO_MAX                =3,
};
#define FOREACH_ENUM_EPROFILECONTROLLERSENSITIVITYOPTIONS(op) \
    op(PCSO_Medium) \
    op(PCSO_Low) \
    op(PCSO_High) 
enum EProfileDifficultyOptions
{
    PDO_Normal              =0,
    PDO_Easy                =1,
    PDO_Hard                =2,
    PDO_MAX                 =3,
};
#define FOREACH_ENUM_EPROFILEDIFFICULTYOPTIONS(op) \
    op(PDO_Normal) \
    op(PDO_Easy) \
    op(PDO_Hard) 
enum EProfileSettingID
{
    PSI_Unknown             =0,
    PSI_ControllerVibration =1,
    PSI_YInversion          =2,
    PSI_GamerCred           =3,
    PSI_GamerRep            =4,
    PSI_VoiceMuted          =5,
    PSI_VoiceThruSpeakers   =6,
    PSI_VoiceVolume         =7,
    PSI_GamerPictureKey     =8,
    PSI_GamerMotto          =9,
    PSI_GamerTitlesPlayed   =10,
    PSI_GamerAchievementsEarned=11,
    PSI_GameDifficulty      =12,
    PSI_ControllerSensitivity=13,
    PSI_PreferredColor1     =14,
    PSI_PreferredColor2     =15,
    PSI_AutoAim             =16,
    PSI_AutoCenter          =17,
    PSI_MovementControl     =18,
    PSI_RaceTransmission    =19,
    PSI_RaceCameraLocation  =20,
    PSI_RaceBrakeControl    =21,
    PSI_RaceAcceleratorControl=22,
    PSI_GameCredEarned      =23,
    PSI_GameAchievementsEarned=24,
    PSI_EndLiveIds          =25,
    PSI_ProfileVersionNum   =26,
    PSI_ProfileSaveCount    =27,
    PSI_MAX                 =28,
};
#define FOREACH_ENUM_EPROFILESETTINGID(op) \
    op(PSI_Unknown) \
    op(PSI_ControllerVibration) \
    op(PSI_YInversion) \
    op(PSI_GamerCred) \
    op(PSI_GamerRep) \
    op(PSI_VoiceMuted) \
    op(PSI_VoiceThruSpeakers) \
    op(PSI_VoiceVolume) \
    op(PSI_GamerPictureKey) \
    op(PSI_GamerMotto) \
    op(PSI_GamerTitlesPlayed) \
    op(PSI_GamerAchievementsEarned) \
    op(PSI_GameDifficulty) \
    op(PSI_ControllerSensitivity) \
    op(PSI_PreferredColor1) \
    op(PSI_PreferredColor2) \
    op(PSI_AutoAim) \
    op(PSI_AutoCenter) \
    op(PSI_MovementControl) \
    op(PSI_RaceTransmission) \
    op(PSI_RaceCameraLocation) \
    op(PSI_RaceBrakeControl) \
    op(PSI_RaceAcceleratorControl) \
    op(PSI_GameCredEarned) \
    op(PSI_GameAchievementsEarned) \
    op(PSI_EndLiveIds) \
    op(PSI_ProfileVersionNum) \
    op(PSI_ProfileSaveCount) 
enum EAmbientOcclusionQuality
{
    AO_High                 =0,
    AO_Medium               =1,
    AO_Low                  =2,
    AO_MAX                  =3,
};
#define FOREACH_ENUM_EAMBIENTOCCLUSIONQUALITY(op) \
    op(AO_High) \
    op(AO_Medium) \
    op(AO_Low) 
enum EDOFQuality
{
    DOFQuality_Low          =0,
    DOFQuality_Medium       =1,
    DOFQuality_High         =2,
    DOFQuality_MAX          =3,
};
#define FOREACH_ENUM_EDOFQUALITY(op) \
    op(DOFQuality_Low) \
    op(DOFQuality_Medium) \
    op(DOFQuality_High) 
enum EDOFType
{
    DOFType_SimpleDOF       =0,
    DOFType_ReferenceDOF    =1,
    DOFType_BokehDOF        =2,
    DOFType_MAX             =3,
};
#define FOREACH_ENUM_EDOFTYPE(op) \
    op(DOFType_SimpleDOF) \
    op(DOFType_ReferenceDOF) \
    op(DOFType_BokehDOF) 
enum EPostProcessAAType
{
    PostProcessAA_Off       =0,
    PostProcessAA_FXAA0     =1,
    PostProcessAA_FXAA1     =2,
    PostProcessAA_FXAA2     =3,
    PostProcessAA_FXAA3     =4,
    PostProcessAA_FXAA4     =5,
    PostProcessAA_FXAA5     =6,
    PostProcessAA_MLAA      =7,
    PostProcessAA_MAX       =8,
};
#define FOREACH_ENUM_EPOSTPROCESSAATYPE(op) \
    op(PostProcessAA_Off) \
    op(PostProcessAA_FXAA0) \
    op(PostProcessAA_FXAA1) \
    op(PostProcessAA_FXAA2) \
    op(PostProcessAA_FXAA3) \
    op(PostProcessAA_FXAA4) \
    op(PostProcessAA_FXAA5) \
    op(PostProcessAA_MLAA) 
enum ETonemapperType
{
    Tonemapper_Off          =0,
    Tonemapper_Filmic       =1,
    Tonemapper_Customizable =2,
    Tonemapper_MAX          =3,
};
#define FOREACH_ENUM_ETONEMAPPERTYPE(op) \
    op(Tonemapper_Off) \
    op(Tonemapper_Filmic) \
    op(Tonemapper_Customizable) 
enum ESetMode
{
    SetMode_Toggle          =0,
    SetMode_Enable          =1,
    SetMode_Disable         =2,
    SetMode_MAX             =3,
};
#define FOREACH_ENUM_ESETMODE(op) \
    op(SetMode_Toggle) \
    op(SetMode_Enable) \
    op(SetMode_Disable) 
enum ESafeZoneType
{
    eSZ_TOP                 =0,
    eSZ_BOTTOM              =1,
    eSZ_LEFT                =2,
    eSZ_RIGHT               =3,
    eSZ_MAX                 =4,
};
#define FOREACH_ENUM_ESAFEZONETYPE(op) \
    op(eSZ_TOP) \
    op(eSZ_BOTTOM) \
    op(eSZ_LEFT) \
    op(eSZ_RIGHT) 
enum ESplitScreenType
{
    eSST_NONE               =0,
    eSST_2P_HORIZONTAL      =1,
    eSST_2P_VERTICAL        =2,
    eSST_3P_FAVOR_TOP       =3,
    eSST_3P_FAVOR_BOTTOM    =4,
    eSST_4P                 =5,
    eSST_MAX                =6,
};
#define FOREACH_ENUM_ESPLITSCREENTYPE(op) \
    op(eSST_NONE) \
    op(eSST_2P_HORIZONTAL) \
    op(eSST_2P_VERTICAL) \
    op(eSST_3P_FAVOR_TOP) \
    op(eSST_3P_FAVOR_BOTTOM) \
    op(eSST_4P) 

#endif // !INCLUDED_ENGINE_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_CLASSES
#define INCLUDED_ENGINE_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

#define UCONST_RB_Sleeping 0x02
#define UCONST_RB_NeedsUpdate 0x01
#define UCONST_RB_None 0x00
#define UCONST_RBSTATE_ANGVELSCALE 1000.0
#define UCONST_RBSTATE_LINVELSCALE 10.0
#define UCONST_ACTORMAXSTEPHEIGHT 35.0
#define UCONST_MINFLOORZ 0.7
#define UCONST_REP_RBLOCATION_ERROR_TOLERANCE_SQ 16.0f
#define UCONST_TRACEFLAG_ForceController 16
#define UCONST_TRACEFLAG_Blocking 8
#define UCONST_TRACEFLAG_SkipMovers 4
#define UCONST_TRACEFLAG_PhysicsVolumes 2
#define UCONST_TRACEFLAG_Bullet 1

struct FTimerData
{
    BITFIELD bLoop:1;
    BITFIELD bPaused:1;
    FName FuncName;
    FLOAT Rate;
    FLOAT Count;
    FLOAT TimerTimeDilation;
    class UObject* TimerObj;

		FTimerData(EEventParm)
		{
			appMemzero(this, sizeof(FTimerData));
			TimerTimeDilation = 1.0f;
		}
	
};

struct FTraceHitInfo
{
    class UMaterial* Material;
    class UPhysicalMaterial* PhysMaterial;
    INT Item;
    INT LevelIndex;
    FName BoneName;
    class UPrimitiveComponent* HitComponent;

    /** Constructors */
    FTraceHitInfo()
    : Material(NULL)
    , PhysMaterial(NULL)
    , Item(0)
    , LevelIndex(0)
    , BoneName(NAME_None)
    , HitComponent(NULL)
    {}
    FTraceHitInfo(EEventParm)
    {
        appMemzero(this, sizeof(FTraceHitInfo));
    }
};

struct FImpactInfo
{
    class AActor* HitActor;
    FVector HitLocation;
    FVector HitNormal;
    FVector RayDir;
    FVector StartTrace;
    struct FTraceHitInfo HitInfo;

		FImpactInfo()
		: HitActor(NULL)
		, HitLocation(0,0,0)
		, HitNormal(0,0,0)
		, RayDir(0,0,0)
		, StartTrace(0,0,0)
		{}

		FImpactInfo(EEventParm)
		{
			appMemzero(this, sizeof(FImpactInfo));
		}
	
};

struct FAnimSlotInfo
{
    FName SlotName;
    TArray<FLOAT> ChannelWeights;

    /** Constructors */
    FAnimSlotInfo()
    : SlotName(NAME_None)
    {}
    FAnimSlotInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAnimSlotInfo));
    }
};

struct FAnimSlotDesc
{
    FName SlotName;
    INT NumChannels;

    /** Constructors */
    FAnimSlotDesc()
    : SlotName(NAME_None)
    , NumChannels(0)
    {}
    FAnimSlotDesc(EEventParm)
    {
        appMemzero(this, sizeof(FAnimSlotDesc));
    }
};

struct FPhysEffectInfo
{
    FLOAT Threshold;
    FLOAT ReFireDelay;
    class UParticleSystem* Effect;
    class USoundCue* Sound;

    /** Constructors */
    FPhysEffectInfo() {}
    FPhysEffectInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPhysEffectInfo));
    }
};

struct FActorReference
{
    class AActor* Actor;
    FGuid Guid;

		FActorReference()
		{
			Actor = NULL;
		}
		FActorReference(EEventParm)
		{
			appMemzero(this, sizeof(FActorReference));
		}
		explicit FActorReference(class AActor *InActor, FGuid &InGuid)
		{
			Actor = InActor;
			Guid = InGuid;
		}
		// overload various operators to make the reference struct as transparent as possible
		FORCEINLINE AActor* operator*()
		{
			return Actor;
		}
		FORCEINLINE AActor* operator->()
		{
			return Actor;
		}
		/** Slow version of deref that will use GUID if Actor is NULL */
		AActor* operator~();
		FORCEINLINE FActorReference* operator=(AActor* TargetActor)
		{
			Actor = TargetActor;
			return this;
		}
		FORCEINLINE UBOOL operator==(const FActorReference &Ref) const
		{
			return (Ref != NULL && (Ref.Actor == Actor));
		}
		FORCEINLINE UBOOL operator!=(const FActorReference &Ref) const
		{
			return (Ref == NULL || (Ref.Actor != Actor));
		}
		FORCEINLINE UBOOL operator==(AActor *TestActor) const
		{
			return (Actor == TestActor);
		}
		FORCEINLINE UBOOL operator!=(AActor *TestActor) const
		{
			return (Actor != TestActor);
		}
		FORCEINLINE operator AActor*()
		{
			return Actor;
		}
		FORCEINLINE operator UBOOL()
		{
			return (Actor != NULL);
		}
		FORCEINLINE UBOOL operator!()
		{
			return (Actor == NULL);
		}
		FORCEINLINE class ANavigationPoint* Nav()
		{
			return ((class ANavigationPoint*)Actor);
		}

		friend FArchive& operator<<( FArchive& Ar, FActorReference& T );
	
};

struct FNavReference
{
    class ANavigationPoint* Nav;
    FGuid Guid;

    /** Constructors */
    FNavReference() {}
    FNavReference(EEventParm)
    {
        appMemzero(this, sizeof(FNavReference));
    }
};

struct FBasedPosition
{
    class AActor* Base;
    FVector Position;
    FVector CachedBaseLocation;
    FRotator CachedBaseRotation;
    FVector CachedTransPosition;

		FBasedPosition();
		FBasedPosition(EEventParm);
		explicit FBasedPosition( class AActor *InBase, FVector& InPosition );
		// Retrieve world location of this position
		FVector operator*();
		void Set( class AActor* InBase, FVector& InPosition );
		void Clear();

		friend FArchive& operator<<( FArchive& Ar, FBasedPosition& T );
	
};

struct Actor_eventOnMobileTouch_Parms
{
    class APlayerController* InPC;
    FVector2D TouchLocation;
    UBOOL ReturnValue;
    Actor_eventOnMobileTouch_Parms(EEventParm)
    {
    }
};
struct Actor_eventReplicationEnded_Parms
{
    Actor_eventReplicationEnded_Parms(EEventParm)
    {
    }
};
struct Actor_eventPostDemoRewind_Parms
{
    Actor_eventPostDemoRewind_Parms(EEventParm)
    {
    }
};
struct Actor_eventAnimTreeUpdated_Parms
{
    class USkeletalMeshComponent* SkelMesh;
    Actor_eventAnimTreeUpdated_Parms(EEventParm)
    {
    }
};
struct Actor_eventTrailsNotifyEnd_Parms
{
    const class UAnimNotify_Trails* AnimNotifyData;
    Actor_eventTrailsNotifyEnd_Parms(EEventParm)
    {
    }
};
struct Actor_eventTrailsNotifyTick_Parms
{
    const class UAnimNotify_Trails* AnimNotifyData;
    Actor_eventTrailsNotifyTick_Parms(EEventParm)
    {
    }
};
struct Actor_eventTrailsNotify_Parms
{
    const class UAnimNotify_Trails* AnimNotifyData;
    Actor_eventTrailsNotify_Parms(EEventParm)
    {
    }
};
struct Actor_eventCreateForceField_Parms
{
    const class UAnimNotify_ForceField* AnimNotifyData;
    UBOOL ReturnValue;
    Actor_eventCreateForceField_Parms(EEventParm)
    {
    }
};
struct Actor_eventPlayParticleEffect_Parms
{
    const class UAnimNotify_PlayParticleEffect* AnimNotifyData;
    UBOOL ReturnValue;
    Actor_eventPlayParticleEffect_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnRigidBodySpringOverextension_Parms
{
    class URB_BodyInstance* BodyInstance;
    Actor_eventOnRigidBodySpringOverextension_Parms(EEventParm)
    {
    }
};
struct Actor_eventPostInitAnimTree_Parms
{
    class USkeletalMeshComponent* SkelComp;
    Actor_eventPostInitAnimTree_Parms(EEventParm)
    {
    }
};
struct Actor_eventRootMotionExtracted_Parms
{
    class USkeletalMeshComponent* SkelComp;
    FBoneAtom ExtractedRootMotionDelta;
    Actor_eventRootMotionExtracted_Parms(EEventParm)
    {
    }
};
struct Actor_eventRootMotionProcessed_Parms
{
    class USkeletalMeshComponent* SkelComp;
    Actor_eventRootMotionProcessed_Parms(EEventParm)
    {
    }
};
struct Actor_eventRootMotionModeChanged_Parms
{
    class USkeletalMeshComponent* SkelComp;
    Actor_eventRootMotionModeChanged_Parms(EEventParm)
    {
    }
};
struct Actor_eventPostRenderFor_Parms
{
    class APlayerController* PC;
    class UCanvas* Canvas;
    FVector CameraPosition;
    FVector CameraDir;
    Actor_eventPostRenderFor_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnRanOver_Parms
{
    class ASVehicle* Vehicle;
    class UPrimitiveComponent* RunOverComponent;
    INT WheelIndex;
    Actor_eventOnRanOver_Parms(EEventParm)
    {
    }
};
struct Actor_eventRigidBodyCollision_Parms
{
    class UPrimitiveComponent* HitComponent;
    class UPrimitiveComponent* OtherComponent;
    FCollisionImpactData RigidCollisionData;
    INT ContactIndex;
    Actor_eventRigidBodyCollision_Parms(EEventParm)
    : RigidCollisionData(EC_EventParm)
    {
    }
};
struct Actor_eventInterpolationChanged_Parms
{
    class USeqAct_Interp* InterpAction;
    Actor_eventInterpolationChanged_Parms(EEventParm)
    {
    }
};
struct Actor_eventInterpolationFinished_Parms
{
    class USeqAct_Interp* InterpAction;
    Actor_eventInterpolationFinished_Parms(EEventParm)
    {
    }
};
struct Actor_eventInterpolationStarted_Parms
{
    class USeqAct_Interp* InterpAction;
    class UInterpGroupInst* GroupInst;
    Actor_eventInterpolationStarted_Parms(EEventParm)
    {
    }
};
struct Actor_eventSpawnedByKismet_Parms
{
    Actor_eventSpawnedByKismet_Parms(EEventParm)
    {
    }
};
struct Actor_eventScriptGetTeamNum_Parms
{
    BYTE ReturnValue;
    Actor_eventScriptGetTeamNum_Parms(EEventParm)
    {
    }
};
struct Actor_eventGetActorEyesViewPoint_Parms
{
    FVector out_Location;
    FRotator out_Rotation;
    Actor_eventGetActorEyesViewPoint_Parms(EEventParm)
    {
    }
};
struct Actor_eventGetActorFaceFXAsset_Parms
{
    class UFaceFXAsset* ReturnValue;
    Actor_eventGetActorFaceFXAsset_Parms(EEventParm)
    {
    }
};
struct Actor_eventTickSkelControl_Parms
{
    FLOAT DeltaTime;
    class USkeletalMeshComponent* SkelComp;
    class USkelControlBase* SkelCtrl;
    Actor_eventTickSkelControl_Parms(EEventParm)
    {
    }
};
struct Actor_eventSetSkelControlScale_Parms
{
    FName SkelControlName;
    FLOAT Scale;
    Actor_eventSetSkelControlScale_Parms(EEventParm)
    {
    }
};
struct Actor_eventSetMorphWeight_Parms
{
    FName MorphNodeName;
    FLOAT MorphWeight;
    Actor_eventSetMorphWeight_Parms(EEventParm)
    {
    }
};
struct Actor_eventStopActorFaceFXAnim_Parms
{
    Actor_eventStopActorFaceFXAnim_Parms(EEventParm)
    {
    }
};
struct Actor_eventPlayActorFaceFXAnim_Parms
{
    class UFaceFXAnimSet* AnimSet;
    FString GroupName;
    FString SeqName;
    class USoundCue* SoundCueToPlay;
    UBOOL ReturnValue;
    Actor_eventPlayActorFaceFXAnim_Parms(EEventParm)
    {
    }
};
struct Actor_eventFinishAnimControl_Parms
{
    class UInterpGroup* InInterpGroup;
    Actor_eventFinishAnimControl_Parms(EEventParm)
    {
    }
};
struct Actor_eventSetAnimPosition_Parms
{
    FName SlotName;
    INT ChannelIndex;
    FName InAnimSeqName;
    FLOAT InPosition;
    UBOOL bFireNotifies;
    UBOOL bLooping;
    UBOOL bEnableRootMotion;
    Actor_eventSetAnimPosition_Parms(EEventParm)
    {
    }
};
struct Actor_eventBeginAnimControl_Parms
{
    class UInterpGroup* InInterpGroup;
    Actor_eventBeginAnimControl_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnAnimPlay_Parms
{
    class UAnimNodeSequence* SeqNode;
    Actor_eventOnAnimPlay_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnAnimEnd_Parms
{
    class UAnimNodeSequence* SeqNode;
    FLOAT PlayedTime;
    FLOAT ExcessTime;
    Actor_eventOnAnimEnd_Parms(EEventParm)
    {
    }
};
struct Actor_eventShutDown_Parms
{
    Actor_eventShutDown_Parms(EEventParm)
    {
    }
};
struct Actor_eventForceNetRelevant_Parms
{
    Actor_eventForceNetRelevant_Parms(EEventParm)
    {
    }
};
struct Actor_eventReceivedNewEvent_Parms
{
    class USequenceEvent* Evt;
    Actor_eventReceivedNewEvent_Parms(EEventParm)
    {
    }
};
struct Actor_eventDebugMessagePlayer_Parms
{
    FString msg;
    Actor_eventDebugMessagePlayer_Parms(EEventParm)
    {
    }
};
struct Actor_eventReset_Parms
{
    Actor_eventReset_Parms(EEventParm)
    {
    }
};
struct Actor_eventGetFaceFXAudioComponent_Parms
{
    class UAudioComponent* ReturnValue;
    Actor_eventGetFaceFXAudioComponent_Parms(EEventParm)
    {
    }
};
struct Actor_eventModifyHearSoundComponent_Parms
{
    class UAudioComponent* AC;
    Actor_eventModifyHearSoundComponent_Parms(EEventParm)
    {
    }
};
struct Actor_eventEndViewTarget_Parms
{
    class APlayerController* PC;
    Actor_eventEndViewTarget_Parms(EEventParm)
    {
    }
};
struct Actor_eventBecomeViewTarget_Parms
{
    class APlayerController* PC;
    Actor_eventBecomeViewTarget_Parms(EEventParm)
    {
    }
};
struct Actor_eventDebugFreezeGame_Parms
{
    class AActor* ActorToLookAt;
    Actor_eventDebugFreezeGame_Parms(EEventParm)
    {
    }
};
struct Actor_eventHealDamage_Parms
{
    INT Amount;
    class AController* Healer;
    class UClass* DamageType;
    UBOOL ReturnValue;
    Actor_eventHealDamage_Parms(EEventParm)
    {
    }
};
struct Actor_eventTakeDamage_Parms
{
    INT DamageAmount;
    class AController* EventInstigator;
    FVector HitLocation;
    FVector Momentum;
    class UClass* DamageType;
    struct FTraceHitInfo HitInfo;
    class AActor* DamageCauser;
    Actor_eventTakeDamage_Parms(EEventParm)
    {
    }
};
struct Actor_eventNotifySkelControlBeyondLimit_Parms
{
    class USkelControlLookAt* LookAt;
    Actor_eventNotifySkelControlBeyondLimit_Parms(EEventParm)
    {
    }
};
struct Actor_eventConstraintBrokenNotify_Parms
{
    class AActor* ConOwner;
    class URB_ConstraintSetup* ConSetup;
    class URB_ConstraintInstance* ConInstance;
    Actor_eventConstraintBrokenNotify_Parms(EEventParm)
    {
    }
};
struct Actor_eventSetInitialState_Parms
{
    Actor_eventSetInitialState_Parms(EEventParm)
    {
    }
};
struct Actor_eventPostBeginPlay_Parms
{
    Actor_eventPostBeginPlay_Parms(EEventParm)
    {
    }
};
struct Actor_eventBroadcastLocalizedTeamMessage_Parms
{
    INT TeamIndex;
    class UClass* InMessageClass;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    Actor_eventBroadcastLocalizedTeamMessage_Parms(EEventParm)
    {
    }
};
struct Actor_eventBroadcastLocalizedMessage_Parms
{
    class UClass* InMessageClass;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    Actor_eventBroadcastLocalizedMessage_Parms(EEventParm)
    {
    }
};
struct Actor_eventPreBeginPlay_Parms
{
    Actor_eventPreBeginPlay_Parms(EEventParm)
    {
    }
};
struct Actor_eventTornOff_Parms
{
    Actor_eventTornOff_Parms(EEventParm)
    {
    }
};
struct Actor_eventOutsideWorldBounds_Parms
{
    Actor_eventOutsideWorldBounds_Parms(EEventParm)
    {
    }
};
struct Actor_eventFellOutOfWorld_Parms
{
    class UClass* dmgType;
    Actor_eventFellOutOfWorld_Parms(EEventParm)
    {
    }
};
struct Actor_eventOverRotated_Parms
{
    FRotator out_Desired;
    FRotator out_Actual;
    UBOOL ReturnValue;
    Actor_eventOverRotated_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnSleepRBPhysics_Parms
{
    Actor_eventOnSleepRBPhysics_Parms(EEventParm)
    {
    }
};
struct Actor_eventOnWakeRBPhysics_Parms
{
    Actor_eventOnWakeRBPhysics_Parms(EEventParm)
    {
    }
};
struct Actor_eventRanInto_Parms
{
    class AActor* Other;
    Actor_eventRanInto_Parms(EEventParm)
    {
    }
};
struct Actor_eventEncroachedBy_Parms
{
    class AActor* Other;
    Actor_eventEncroachedBy_Parms(EEventParm)
    {
    }
};
struct Actor_eventEncroachingOn_Parms
{
    class AActor* Other;
    UBOOL ReturnValue;
    Actor_eventEncroachingOn_Parms(EEventParm)
    {
    }
};
struct Actor_eventCollisionChanged_Parms
{
    Actor_eventCollisionChanged_Parms(EEventParm)
    {
    }
};
struct Actor_eventSpecialHandling_Parms
{
    class APawn* Other;
    class AActor* ReturnValue;
    Actor_eventSpecialHandling_Parms(EEventParm)
    {
    }
};
struct Actor_eventDetach_Parms
{
    class AActor* Other;
    Actor_eventDetach_Parms(EEventParm)
    {
    }
};
struct Actor_eventAttach_Parms
{
    class AActor* Other;
    Actor_eventAttach_Parms(EEventParm)
    {
    }
};
struct Actor_eventBaseChange_Parms
{
    Actor_eventBaseChange_Parms(EEventParm)
    {
    }
};
struct Actor_eventBump_Parms
{
    class AActor* Other;
    class UPrimitiveComponent* OtherComp;
    FVector HitNormal;
    Actor_eventBump_Parms(EEventParm)
    {
    }
};
struct Actor_eventUnTouch_Parms
{
    class AActor* Other;
    Actor_eventUnTouch_Parms(EEventParm)
    {
    }
};
struct Actor_eventPostTouch_Parms
{
    class AActor* Other;
    Actor_eventPostTouch_Parms(EEventParm)
    {
    }
};
struct Actor_eventTouch_Parms
{
    class AActor* Other;
    class UPrimitiveComponent* OtherComp;
    FVector HitLocation;
    FVector HitNormal;
    Actor_eventTouch_Parms(EEventParm)
    {
    }
};
struct Actor_eventPhysicsVolumeChange_Parms
{
    class APhysicsVolume* NewVolume;
    Actor_eventPhysicsVolumeChange_Parms(EEventParm)
    {
    }
};
struct Actor_eventLanded_Parms
{
    FVector HitNormal;
    class AActor* FloorActor;
    Actor_eventLanded_Parms(EEventParm)
    {
    }
};
struct Actor_eventFalling_Parms
{
    Actor_eventFalling_Parms(EEventParm)
    {
    }
};
struct Actor_eventHitWall_Parms
{
    FVector HitNormal;
    class AActor* Wall;
    class UPrimitiveComponent* WallComp;
    Actor_eventHitWall_Parms(EEventParm)
    {
    }
};
struct Actor_eventTimer_Parms
{
    Actor_eventTimer_Parms(EEventParm)
    {
    }
};
struct Actor_eventTick_Parms
{
    FLOAT DeltaTime;
    Actor_eventTick_Parms(EEventParm)
    {
    }
};
struct Actor_eventLostChild_Parms
{
    class AActor* Other;
    Actor_eventLostChild_Parms(EEventParm)
    {
    }
};
struct Actor_eventGainedChild_Parms
{
    class AActor* Other;
    Actor_eventGainedChild_Parms(EEventParm)
    {
    }
};
struct Actor_eventDestroyed_Parms
{
    Actor_eventDestroyed_Parms(EEventParm)
    {
    }
};
struct Actor_eventReplicatedEvent_Parms
{
    FName VarName;
    Actor_eventReplicatedEvent_Parms(EEventParm)
    {
    }
};
class AActor : public UObject
{
public:
    //## BEGIN PROPS Actor
    TArrayNoInit<class UActorComponent*> Components;
    TArrayNoInit<class UActorComponent*> AllComponents;
    FVector Location;
    FRotator Rotation;
    FLOAT DrawScale;
    FVector DrawScale3D;
    FVector PrePivot;
#if WITH_EDITORONLY_DATA
    FColor EditorIconColor;
#endif // WITH_EDITORONLY_DATA
    FRenderCommandFence DetachFence;
    FLOAT CustomTimeDilation;
    BYTE Physics;
    BYTE RemoteRole;
    BYTE Role;
    BYTE CollisionType;
    BYTE ReplicatedCollisionType;
    BYTE TickGroup;
    class AActor* Owner;
    class AActor* Base;
    TArrayNoInit<struct FTimerData> Timers;
private:
    BITFIELD bStatic:1;
public:
    BITFIELD bHidden:1;
    BITFIELD bNoDelete:1;
    BITFIELD bDeleteMe:1;
    BITFIELD bTicked:1;
    BITFIELD bOnlyOwnerSee:1;
private:
    BITFIELD bTickIsDisabled:1;
public:
    BITFIELD bWorldGeometry:1;
    BITFIELD bIgnoreRigidBodyPawns:1;
    BITFIELD bOrientOnSlope:1;
    BITFIELD bIgnoreEncroachers:1;
    BITFIELD bPushedByEncroachers:1;
    BITFIELD bDestroyedByInterpActor:1;
    BITFIELD bRouteBeginPlayEvenIfStatic:1;
    BITFIELD bIsMoving:1;
    BITFIELD bAlwaysEncroachCheck:1;
    BITFIELD bHasAlternateTargetLocation:1;
    BITFIELD bCanStepUpOn:1;
    BITFIELD bNetTemporary:1;
    BITFIELD bOnlyRelevantToOwner:1;
    BITFIELD bNetDirty:1;
    BITFIELD bAlwaysRelevant:1;
    BITFIELD bReplicateInstigator:1;
    BITFIELD bReplicateMovement:1;
    BITFIELD bSkipActorPropertyReplication:1;
    BITFIELD bUpdateSimulatedPosition:1;
    BITFIELD bTearOff:1;
    BITFIELD bOnlyDirtyReplication:1;
    BITFIELD bAllowFluidSurfaceInteraction:1;
    BITFIELD bDemoRecording:1;
    BITFIELD bDemoOwner:1;
    BITFIELD bForceDemoRelevant:1;
    BITFIELD bNetInitialRotation:1;
    BITFIELD bReplicateRigidBodyLocation:1;
    BITFIELD bKillDuringLevelTransition:1;
    BITFIELD bExchangedRoles:1;
    BITFIELD bConsiderAllStaticMeshComponentsForStreaming:1;
    BITFIELD bDebug:1;
    BITFIELD bPostRenderIfNotVisible:1;
    BITFIELD bForceNetUpdate:1;
    BITFIELD bPendingNetUpdate:1;
    BITFIELD bHardAttach:1;
    BITFIELD bIgnoreBaseRotation:1;
    BITFIELD bShadowParented:1;
    BITFIELD bSkipAttachedMoves:1;
    BITFIELD bCanBeAdheredTo:1;
    BITFIELD bCanBeFrictionedTo:1;
    BITFIELD bHurtEntry:1;
    BITFIELD bGameRelevant:1;
    BITFIELD bMovable:1;
    BITFIELD bDestroyInPainVolume:1;
    BITFIELD bCanBeDamaged:1;
    BITFIELD bShouldBaseAtStartup:1;
    BITFIELD bPendingDelete:1;
    BITFIELD bCanTeleport:1;
    BITFIELD bAlwaysTick:1;
    BITFIELD bBlocksNavigation:1;
    BITFIELD BlockRigidBody:1;
    BITFIELD bCollideWhenPlacing:1;
    BITFIELD bCollideActors:1;
    BITFIELD bCollideWorld:1;
    BITFIELD bCollideComplex:1;
    BITFIELD bBlockActors:1;
    BITFIELD bProjTarget:1;
    BITFIELD bBlocksTeleport:1;
    BITFIELD bMoveIgnoresDestruction:1;
    BITFIELD bProjectileMoveSingleBlocking:1;
    BITFIELD bNoEncroachCheck:1;
    BITFIELD bCollideAsEncroacher:1;
    BITFIELD bPhysRigidBodyOutOfWorldCheck:1;
    BITFIELD bComponentOutsideWorld:1;
    BITFIELD bForceOctreeSNFilter:1;
    BITFIELD bForceOctreeMNFilter:1;
    BITFIELD bRigidBodyWasAwake:1;
    BITFIELD bCallRigidBodyWakeEvents:1;
    BITFIELD bBounce:1;
    BITFIELD bJustTeleported:1;
    BITFIELD bEnableMobileTouch:1;
    BITFIELD bNetInitial:1;
    BITFIELD bNetOwner:1;
    BITFIELD bHiddenEd:1;
    BITFIELD bEditable:1;
    BITFIELD bHiddenEdGroup_DEPRECATED:1;
    BITFIELD bHiddenEdLayer:1;
    BITFIELD bHiddenEdCustom:1;
    BITFIELD bHiddenEdTemporary:1;
    BITFIELD bHiddenEdLevel:1;
    BITFIELD bHiddenEdScene:1;
    BITFIELD bEdShouldSnap:1;
    BITFIELD bTempEditor:1;
    BITFIELD bPathColliding:1;
    BITFIELD bPathTemp:1;
    BITFIELD bScriptInitialized:1;
    BITFIELD bLockLocation:1;
    BITFIELD bForceAllowKismetModification:1;
    BITFIELD bDebugEffectIsRelevant:1;
    INT SkelMeshCompTickTag;
    INT NetTag;
    FLOAT NetUpdateTime;
    FLOAT NetUpdateFrequency;
    FLOAT NetPriority;
    FLOAT LastNetUpdateTime;
    FLOAT TimeSinceLastTick;
    class APawn* Instigator;
    class AWorldInfo* WorldInfo;
    FLOAT LifeSpan;
    FLOAT CreationTime;
    FLOAT LastRenderTime;
    FName Tag;
    FName InitialState;
    FName Layer;
    FName Group_DEPRECATED;
    QWORD HiddenEditorViews;
    TArrayNoInit<class AActor*> Touching;
    TArrayNoInit<class AActor*> Children;
    FLOAT LatentFloat;
    class UAnimNodeSequence* LatentSeqNode;
    class APhysicsVolume* PhysicsVolume;
    FVector Velocity;
    FVector Acceleration;
    FVector AngularVelocity;
    class USkeletalMeshComponent* BaseSkelComponent;
    FName BaseBoneName;
    TArrayNoInit<class AActor*> Attached;
    FVector RelativeLocation;
    FRotator RelativeRotation;
    class UPrimitiveComponent* CollisionComponent;
    INT OverlapTag;
    FRotator RotationRate;
    class AActor* PendingTouch;
    class UClass* MessageClass;
    TArrayNoInit<class UClass*> SupportedEvents;
    TArrayNoInit<class USequenceEvent*> GeneratedEvents;
    TArrayNoInit<class USeqAct_Latent*> LatentActions;
    //## END PROPS Actor

    virtual void ForceUpdateComponents(UBOOL bCollisionUpdate=FALSE,UBOOL bTransformOnly=TRUE);
    virtual FString ConsoleCommand(const FString& Command,UBOOL bWriteToLog=TRUE);
    void Sleep(FLOAT Seconds);
    void FinishAnim(class UAnimNodeSequence* SeqNode,UBOOL bFinishOnBlendOut=FALSE);
    void SetCollisionSize(FLOAT NewRadius,FLOAT NewHeight);
    void SetCollisionType(BYTE NewCollisionType);
    void SetDrawScale(FLOAT NewScale);
    void SetDrawScale3D(FVector NewScale3D);
    UBOOL Move(FVector Delta);
    UBOOL SetLocation(FVector NewLocation);
    UBOOL SetRotation(FRotator NewRotation);
    virtual BYTE MovingWhichWay(FLOAT& Amount);
    UBOOL SetRelativeRotation(FRotator NewRotation);
    UBOOL SetRelativeLocation(FVector NewLocation);
    virtual void SetShadowParentOnAllAttachedComponents(class UPrimitiveComponent* MyPrimComp,class ULightEnvironmentComponent* MyLightEnv);
    INT fixedTurn(INT Current,INT Desired,INT DeltaRate);
    void AutonomousPhysics(FLOAT DeltaSeconds);
    virtual FLOAT GetTerminalVelocity();
    void SetOwner(class AActor* NewOwner);
    virtual void FindBase();
    virtual void SearchForBaseBelow(FLOAT HeightBelow,class AActor*& NewBase,FVector& HitNormal);
    virtual class AActor* GetBaseMost();
    FVector GetAggregateBaseVelocity(class AActor* TestBase=NULL);
    void SetForcedInitialReplicatedProperty(class UProperty* PropToReplicate,UBOOL bAdd);
    void Vect2BP(struct FBasedPosition& BP,FVector pos,class AActor* ForcedBase=NULL) const;
    FVector BP2Vect(struct FBasedPosition BP) const;
    void SetBasedPosition(struct FBasedPosition& BP,FVector pos,class AActor* ForcedBase=NULL) const;
    FVector GetBasedPosition(struct FBasedPosition BP) const;
    void FlushPersistentDebugLines() const;
    void DrawDebugLine(FVector LineStart,FVector LineEnd,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE) const;
    void DrawDebugPoint(FVector Position,FLOAT Size,FLinearColor PointColor,UBOOL bPersistentLines=FALSE) const;
    void DrawDebugBox(FVector Center,FVector Extent,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE) const;
    void DrawDebugStar(FVector Position,FLOAT Size,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE) const;
    void DrawDebugCoordinateSystem(FVector AxisLoc,FRotator AxisRot,FLOAT Scale,UBOOL bPersistentLines=FALSE) const;
    void DrawDebugSphere(FVector Center,FLOAT Radius,INT Segments,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE) const;
    void DrawDebugCylinder(FVector Start,FVector End,FLOAT Radius,INT Segments,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE) const;
    void DrawDebugCone(FVector Origin,FVector Direction,FLOAT Length,FLOAT AngleWidth,FLOAT AngleHeight,INT NumSides,FColor DrawColor,UBOOL bPersistentLines=FALSE) const;
    void DrawDebugString(FVector TextLocation,const FString& Text,class AActor* TestBaseActor=NULL,FColor TextColor=FColor(EC_EventParm),FLOAT Duration=-1.000000) const;
    void DrawDebugFrustrum(const FMatrix& FrustumToWorld,BYTE R,BYTE G,BYTE B,UBOOL bPersistentLines=FALSE) const;
    void FlushDebugStrings() const;
    void ChartData(const FString& DataName,FLOAT DataValue);
    void SetHidden(UBOOL bNewHidden);
    void SetOnlyOwnerSee(UBOOL bNewOnlyOwnerSee);
    void Clock(FLOAT& Time);
    void UnClock(FLOAT& Time);
    void AttachComponent(class UActorComponent* NewComponent);
    void DetachComponent(class UActorComponent* ExComponent);
    void ReattachComponent(class UActorComponent* ComponentToReattach);
    void SetTickGroup(BYTE NewTickGroup);
    void SetTickIsDisabled(UBOOL bInDisabled);
    UBOOL ClampRotation(FRotator& out_Rot,FRotator rBase,FRotator rUpperLimits,FRotator rLowerLimits);
    UBOOL FindSpot(FVector BoxExtent,FVector& SpotLocation);
    UBOOL ContainsPoint(FVector Spot);
    void GetComponentsBoundingBox(FBox& ActorBox) const;
    virtual void GetBoundingCylinder(FLOAT& CollisionRadius,FLOAT& CollisionHeight) const;
    void SetTimer(FLOAT InRate,UBOOL inbLoop=FALSE,FName inTimerFunc=NAME_Timer,class UObject* inObj=NULL);
    void ClearTimer(FName inTimerFunc=NAME_Timer,class UObject* inObj=NULL);
    void ClearAllTimers(class UObject* inObj=NULL);
    void PauseTimer(UBOOL bPause,FName inTimerFunc=NAME_Timer,class UObject* inObj=NULL);
    UBOOL IsTimerActive(FName inTimerFunc=NAME_Timer,class UObject* inObj=NULL);
    FLOAT GetTimerCount(FName inTimerFunc=NAME_Timer,class UObject* inObj=NULL);
    FLOAT GetTimerRate(FName TimerFuncName=NAME_Timer,class UObject* inObj=NULL);
    void ModifyTimerTimeDilation(const FName TimerName,const FLOAT InTimerTimeDilation,class UObject* inObj=NULL);
    void ResetTimerTimeDilation(const FName TimerName,class UObject* inObj=NULL);
    class UAudioComponent* CreateAudioComponent(class USoundCue* InSoundCue,UBOOL bPlay=FALSE,UBOOL bStopWhenOwnerDestroyed=FALSE,UBOOL bUseLocation=FALSE,FVector SourceLocation=FVector(EC_EventParm),UBOOL bAttachToSelf=TRUE);
    void MakeNoise(FLOAT Loudness,FName NoiseType=NAME_None);
    UBOOL PlayerCanSeeMe(UBOOL bForceLOSCheck=FALSE);
    UBOOL CalculateMinSpeedTrajectory(FVector& out_Velocity,FVector End,FVector Start,FLOAT MaxTossSpeed,FLOAT MinTossSpeed,FVector CollisionSize=FVector(EC_EventParm),FLOAT TerminalVelocity=0,FLOAT GravityZ=0,UBOOL bOnlyTraceUp=FALSE);
    virtual FVector GetDestination(class AController* C);
    FString GetURLMap();
    class APlayerController* GetALocalPlayerController();
    virtual FLOAT GetGravityZ();
    void SetNetUpdateTime(FLOAT NewUpdateTime);
    virtual void PrestreamTextures(FLOAT Seconds,UBOOL bEnableStreaming,INT CinematicTextureGroups=0);
    virtual UBOOL IsPlayerOwned();
    virtual BYTE GetTeamNum();
    virtual FVector GetTargetLocation(class AActor* RequestedBy=NULL,UBOOL bRequestAlternateLoc=FALSE) const;
    virtual void SetHUDLocation(FVector NewHUDLocation);
    virtual void NativePostRenderFor(class APlayerController* PC,class UCanvas* Canvas,FVector CameraPosition,FVector CameraDir);
    FGuid GetPackageGuid(FName PackageName);
    UBOOL IsInPersistentLevel(UBOOL bIncludeLevelStreamingPersistent=FALSE) const;
    virtual class UParticleSystem* GetAnimTrailParticleSystem(const class UAnimNotify_Trails* AnimNotifyData) const;
    virtual UBOOL SupportsKismetModification(class USequenceOp* AskingOp,FString& Reason) const;
    FVector GetAvoidanceVector(const TArray<class AActor*>& Obstacles,FVector GoalLocation,FLOAT CollisionRadius,FLOAT MaxSpeed,INT NumSamples=8,FLOAT VelocityStepRate=0.100000,FLOAT MaxTimeTilOverlap=1.000000);
    UBOOL WillOverlap(FVector PosA,FVector VelA,FVector PosB,FVector VelB,FLOAT StepSize,FLOAT Radius,FLOAT& Time);
    virtual UBOOL ShouldBeHiddenBySHOW_NavigationNodes();
    virtual INT GetActorMetrics(BYTE MetricsType);
    virtual class USpriteComponent* GetActorSpriteComponent() const;
    DECLARE_FUNCTION(execForceUpdateComponents)
    {
        P_GET_UBOOL_OPTX(bCollisionUpdate,FALSE);
        P_GET_UBOOL_OPTX(bTransformOnly,TRUE);
        P_FINISH;
        this->ForceUpdateComponents(bCollisionUpdate,bTransformOnly);
    }
    DECLARE_FUNCTION(execConsoleCommand)
    {
        P_GET_STR(Command);
        P_GET_UBOOL_OPTX(bWriteToLog,TRUE);
        P_FINISH;
        *(FString*)Result=this->ConsoleCommand(Command,bWriteToLog);
    }
    DECLARE_FUNCTION(execSleep)
    {
        P_GET_FLOAT(Seconds);
        P_FINISH;
        this->Sleep(Seconds);
    }
    DECLARE_FUNCTION(execFinishAnim)
    {
        P_GET_OBJECT(UAnimNodeSequence,SeqNode);
        P_GET_UBOOL_OPTX(bFinishOnBlendOut,FALSE);
        P_FINISH;
        this->FinishAnim(SeqNode,bFinishOnBlendOut);
    }
    DECLARE_FUNCTION(execSetCollision);
    DECLARE_FUNCTION(execSetCollisionSize)
    {
        P_GET_FLOAT(NewRadius);
        P_GET_FLOAT(NewHeight);
        P_FINISH;
        this->SetCollisionSize(NewRadius,NewHeight);
    }
    DECLARE_FUNCTION(execSetCollisionType)
    {
        P_GET_BYTE(NewCollisionType);
        P_FINISH;
        this->SetCollisionType(NewCollisionType);
    }
    DECLARE_FUNCTION(execSetDrawScale)
    {
        P_GET_FLOAT(NewScale);
        P_FINISH;
        this->SetDrawScale(NewScale);
    }
    DECLARE_FUNCTION(execSetDrawScale3D)
    {
        P_GET_STRUCT(FVector,NewScale3D);
        P_FINISH;
        this->SetDrawScale3D(NewScale3D);
    }
    DECLARE_FUNCTION(execMove)
    {
        P_GET_STRUCT(FVector,Delta);
        P_FINISH;
        *(UBOOL*)Result=this->Move(Delta);
    }
    DECLARE_FUNCTION(execSetLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_FINISH;
        *(UBOOL*)Result=this->SetLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetRotation)
    {
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        *(UBOOL*)Result=this->SetRotation(NewRotation);
    }
    DECLARE_FUNCTION(execMovingWhichWay)
    {
        P_GET_FLOAT_REF(Amount);
        P_FINISH;
        *(BYTE*)Result=this->MovingWhichWay(Amount);
    }
    DECLARE_FUNCTION(execSetZone);
    DECLARE_FUNCTION(execSetRelativeRotation)
    {
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        *(UBOOL*)Result=this->SetRelativeRotation(NewRotation);
    }
    DECLARE_FUNCTION(execSetRelativeLocation)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_FINISH;
        *(UBOOL*)Result=this->SetRelativeLocation(NewLocation);
    }
    DECLARE_FUNCTION(execSetHardAttach);
    DECLARE_FUNCTION(execSetShadowParentOnAllAttachedComponents)
    {
        P_GET_OBJECT(UPrimitiveComponent,MyPrimComp);
        P_GET_OBJECT(ULightEnvironmentComponent,MyLightEnv);
        P_FINISH;
        this->SetShadowParentOnAllAttachedComponents(MyPrimComp,MyLightEnv);
    }
    DECLARE_FUNCTION(execfixedTurn)
    {
        P_GET_INT(Current);
        P_GET_INT(Desired);
        P_GET_INT(DeltaRate);
        P_FINISH;
        *(INT*)Result=this->fixedTurn(Current,Desired,DeltaRate);
    }
    DECLARE_FUNCTION(execMoveSmooth);
    DECLARE_FUNCTION(execAutonomousPhysics)
    {
        P_GET_FLOAT(DeltaSeconds);
        P_FINISH;
        this->AutonomousPhysics(DeltaSeconds);
    }
    DECLARE_FUNCTION(execGetTerminalVelocity)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetTerminalVelocity();
    }
    DECLARE_FUNCTION(execSetBase);
    DECLARE_FUNCTION(execSetOwner)
    {
        P_GET_OBJECT(AActor,NewOwner);
        P_FINISH;
        this->SetOwner(NewOwner);
    }
    DECLARE_FUNCTION(execFindBase)
    {
        P_FINISH;
        this->FindBase();
    }
    DECLARE_FUNCTION(execSearchForBaseBelow)
    {
        P_GET_FLOAT(HeightBelow);
        P_GET_OBJECT_REF(AActor,NewBase);
        P_GET_STRUCT_REF(FVector,HitNormal);
        P_FINISH;
        this->SearchForBaseBelow(HeightBelow,NewBase,HitNormal);
    }
    DECLARE_FUNCTION(execIsBasedOn);
    DECLARE_FUNCTION(execGetBaseMost)
    {
        P_FINISH;
        *(class AActor**)Result=this->GetBaseMost();
    }
    DECLARE_FUNCTION(execIsOwnedBy);
    DECLARE_FUNCTION(execGetAggregateBaseVelocity)
    {
        P_GET_OBJECT_OPTX(AActor,TestBase,NULL);
        P_FINISH;
        *(FVector*)Result=this->GetAggregateBaseVelocity(TestBase);
    }
    DECLARE_FUNCTION(execSetForcedInitialReplicatedProperty)
    {
        P_GET_OBJECT(UProperty,PropToReplicate);
        P_GET_UBOOL(bAdd);
        P_FINISH;
        this->SetForcedInitialReplicatedProperty(PropToReplicate,bAdd);
    }
    DECLARE_FUNCTION(execVect2BP)
    {
        P_GET_STRUCT_REF(struct FBasedPosition,BP);
        P_GET_STRUCT(FVector,pos);
        P_GET_OBJECT_OPTX(AActor,ForcedBase,NULL);
        P_FINISH;
        this->Vect2BP(BP,pos,ForcedBase);
    }
    DECLARE_FUNCTION(execBP2Vect)
    {
        P_GET_STRUCT(struct FBasedPosition,BP);
        P_FINISH;
        *(FVector*)Result=this->BP2Vect(BP);
    }
    DECLARE_FUNCTION(execSetBasedPosition)
    {
        P_GET_STRUCT_REF(struct FBasedPosition,BP);
        P_GET_STRUCT(FVector,pos);
        P_GET_OBJECT_OPTX(AActor,ForcedBase,NULL);
        P_FINISH;
        this->SetBasedPosition(BP,pos,ForcedBase);
    }
    DECLARE_FUNCTION(execGetBasedPosition)
    {
        P_GET_STRUCT(struct FBasedPosition,BP);
        P_FINISH;
        *(FVector*)Result=this->GetBasedPosition(BP);
    }
    DECLARE_FUNCTION(execFlushPersistentDebugLines)
    {
        P_FINISH;
        this->FlushPersistentDebugLines();
    }
    DECLARE_FUNCTION(execDrawDebugLine)
    {
        P_GET_STRUCT(FVector,LineStart);
        P_GET_STRUCT(FVector,LineEnd);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        this->DrawDebugLine(LineStart,LineEnd,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugPoint)
    {
        P_GET_STRUCT(FVector,Position);
        P_GET_FLOAT(Size);
        P_GET_STRUCT(FLinearColor,PointColor);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        this->DrawDebugPoint(Position,Size,PointColor,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugBox)
    {
        P_GET_STRUCT(FVector,Center);
        P_GET_STRUCT(FVector,Extent);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        this->DrawDebugBox(Center,Extent,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugStar)
    {
        P_GET_STRUCT(FVector,Position);
        P_GET_FLOAT(Size);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        this->DrawDebugStar(Position,Size,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugCoordinateSystem)
    {
        P_GET_STRUCT(FVector,AxisLoc);
        P_GET_STRUCT(FRotator,AxisRot);
        P_GET_FLOAT(Scale);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        this->DrawDebugCoordinateSystem(AxisLoc,AxisRot,Scale,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugSphere)
    {
        P_GET_STRUCT(FVector,Center);
        P_GET_FLOAT(Radius);
        P_GET_INT(Segments);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        this->DrawDebugSphere(Center,Radius,Segments,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugCylinder)
    {
        P_GET_STRUCT(FVector,Start);
        P_GET_STRUCT(FVector,End);
        P_GET_FLOAT(Radius);
        P_GET_INT(Segments);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        this->DrawDebugCylinder(Start,End,Radius,Segments,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugCone)
    {
        P_GET_STRUCT(FVector,Origin);
        P_GET_STRUCT(FVector,Direction);
        P_GET_FLOAT(Length);
        P_GET_FLOAT(AngleWidth);
        P_GET_FLOAT(AngleHeight);
        P_GET_INT(NumSides);
        P_GET_STRUCT(FColor,DrawColor);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        this->DrawDebugCone(Origin,Direction,Length,AngleWidth,AngleHeight,NumSides,DrawColor,bPersistentLines);
    }
    DECLARE_FUNCTION(execDrawDebugString)
    {
        P_GET_STRUCT(FVector,TextLocation);
        P_GET_STR(Text);
        P_GET_OBJECT_OPTX(AActor,TestBaseActor,NULL);
        P_GET_STRUCT_OPTX(FColor,TextColor,FColor(EC_EventParm));
        P_GET_FLOAT_OPTX(Duration,-1.000000);
        P_FINISH;
        this->DrawDebugString(TextLocation,Text,TestBaseActor,TextColor,Duration);
    }
    DECLARE_FUNCTION(execDrawDebugFrustrum)
    {
        P_GET_STRUCT_REF(FMatrix,FrustumToWorld);
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_UBOOL_OPTX(bPersistentLines,FALSE);
        P_FINISH;
        this->DrawDebugFrustrum(FrustumToWorld,R,G,B,bPersistentLines);
    }
    DECLARE_FUNCTION(execFlushDebugStrings)
    {
        P_FINISH;
        this->FlushDebugStrings();
    }
    DECLARE_FUNCTION(execChartData)
    {
        P_GET_STR(DataName);
        P_GET_FLOAT(DataValue);
        P_FINISH;
        this->ChartData(DataName,DataValue);
    }
    DECLARE_FUNCTION(execSetHidden)
    {
        P_GET_UBOOL(bNewHidden);
        P_FINISH;
        this->SetHidden(bNewHidden);
    }
    DECLARE_FUNCTION(execSetOnlyOwnerSee)
    {
        P_GET_UBOOL(bNewOnlyOwnerSee);
        P_FINISH;
        this->SetOnlyOwnerSee(bNewOnlyOwnerSee);
    }
    DECLARE_FUNCTION(execSetPhysics);
    DECLARE_FUNCTION(execClock)
    {
        P_GET_FLOAT_REF(Time);
        P_FINISH;
        this->Clock(Time);
    }
    DECLARE_FUNCTION(execUnClock)
    {
        P_GET_FLOAT_REF(Time);
        P_FINISH;
        this->UnClock(Time);
    }
    DECLARE_FUNCTION(execAttachComponent)
    {
        P_GET_OBJECT(UActorComponent,NewComponent);
        P_FINISH;
        this->AttachComponent(NewComponent);
    }
    DECLARE_FUNCTION(execDetachComponent)
    {
        P_GET_OBJECT(UActorComponent,ExComponent);
        P_FINISH;
        this->DetachComponent(ExComponent);
    }
    DECLARE_FUNCTION(execReattachComponent)
    {
        P_GET_OBJECT(UActorComponent,ComponentToReattach);
        P_FINISH;
        this->ReattachComponent(ComponentToReattach);
    }
    DECLARE_FUNCTION(execSetTickGroup)
    {
        P_GET_BYTE(NewTickGroup);
        P_FINISH;
        this->SetTickGroup(NewTickGroup);
    }
    DECLARE_FUNCTION(execSetTickIsDisabled)
    {
        P_GET_UBOOL(bInDisabled);
        P_FINISH;
        this->SetTickIsDisabled(bInDisabled);
    }
    DECLARE_FUNCTION(execClampRotation)
    {
        P_GET_STRUCT_REF(FRotator,out_Rot);
        P_GET_STRUCT(FRotator,rBase);
        P_GET_STRUCT(FRotator,rUpperLimits);
        P_GET_STRUCT(FRotator,rLowerLimits);
        P_FINISH;
        *(UBOOL*)Result=this->ClampRotation(out_Rot,rBase,rUpperLimits,rLowerLimits);
    }
    DECLARE_FUNCTION(execTrace);
    DECLARE_FUNCTION(execTraceComponent);
    DECLARE_FUNCTION(execPointCheckComponent);
    DECLARE_FUNCTION(execFastTrace);
    DECLARE_FUNCTION(execTraceAllPhysicsAssetInteractions);
    DECLARE_FUNCTION(execFindSpot)
    {
        P_GET_STRUCT(FVector,BoxExtent);
        P_GET_STRUCT_REF(FVector,SpotLocation);
        P_FINISH;
        *(UBOOL*)Result=this->FindSpot(BoxExtent,SpotLocation);
    }
    DECLARE_FUNCTION(execContainsPoint)
    {
        P_GET_STRUCT(FVector,Spot);
        P_FINISH;
        *(UBOOL*)Result=this->ContainsPoint(Spot);
    }
    DECLARE_FUNCTION(execIsOverlapping);
    DECLARE_FUNCTION(execGetComponentsBoundingBox)
    {
        P_GET_STRUCT_REF(FBox,ActorBox);
        P_FINISH;
        this->GetComponentsBoundingBox(ActorBox);
    }
    DECLARE_FUNCTION(execGetBoundingCylinder)
    {
        P_GET_FLOAT_REF(CollisionRadius);
        P_GET_FLOAT_REF(CollisionHeight);
        P_FINISH;
        this->GetBoundingCylinder(CollisionRadius,CollisionHeight);
    }
    DECLARE_FUNCTION(execIsBlockedBy);
    DECLARE_FUNCTION(execSpawn);
    DECLARE_FUNCTION(execDestroy);
    DECLARE_FUNCTION(execSetTimer)
    {
        P_GET_FLOAT(InRate);
        P_GET_UBOOL_OPTX(inbLoop,FALSE);
        P_GET_NAME_OPTX(inTimerFunc,NAME_Timer);
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        this->SetTimer(InRate,inbLoop,inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execClearTimer)
    {
        P_GET_NAME_OPTX(inTimerFunc,NAME_Timer);
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        this->ClearTimer(inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execClearAllTimers)
    {
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        this->ClearAllTimers(inObj);
    }
    DECLARE_FUNCTION(execPauseTimer)
    {
        P_GET_UBOOL(bPause);
        P_GET_NAME_OPTX(inTimerFunc,NAME_Timer);
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        this->PauseTimer(bPause,inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execIsTimerActive)
    {
        P_GET_NAME_OPTX(inTimerFunc,NAME_Timer);
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        *(UBOOL*)Result=this->IsTimerActive(inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execGetTimerCount)
    {
        P_GET_NAME_OPTX(inTimerFunc,NAME_Timer);
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        *(FLOAT*)Result=this->GetTimerCount(inTimerFunc,inObj);
    }
    DECLARE_FUNCTION(execGetTimerRate)
    {
        P_GET_NAME_OPTX(TimerFuncName,NAME_Timer);
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        *(FLOAT*)Result=this->GetTimerRate(TimerFuncName,inObj);
    }
    DECLARE_FUNCTION(execModifyTimerTimeDilation)
    {
        P_GET_NAME(TimerName);
        P_GET_FLOAT(InTimerTimeDilation);
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        this->ModifyTimerTimeDilation(TimerName,InTimerTimeDilation,inObj);
    }
    DECLARE_FUNCTION(execResetTimerTimeDilation)
    {
        P_GET_NAME(TimerName);
        P_GET_OBJECT_OPTX(UObject,inObj,NULL);
        P_FINISH;
        this->ResetTimerTimeDilation(TimerName,inObj);
    }
    DECLARE_FUNCTION(execCreateAudioComponent)
    {
        P_GET_OBJECT(USoundCue,InSoundCue);
        P_GET_UBOOL_OPTX(bPlay,FALSE);
        P_GET_UBOOL_OPTX(bStopWhenOwnerDestroyed,FALSE);
        P_GET_UBOOL_OPTX(bUseLocation,FALSE);
        P_GET_STRUCT_OPTX(FVector,SourceLocation,FVector(EC_EventParm));
        P_GET_UBOOL_OPTX(bAttachToSelf,TRUE);
        P_FINISH;
        *(class UAudioComponent**)Result=this->CreateAudioComponent(InSoundCue,bPlay,bStopWhenOwnerDestroyed,bUseLocation,SourceLocation,bAttachToSelf);
    }
    DECLARE_FUNCTION(execPlaySound);
    DECLARE_FUNCTION(execMakeNoise)
    {
        P_GET_FLOAT(Loudness);
        P_GET_NAME_OPTX(NoiseType,NAME_None);
        P_FINISH;
        this->MakeNoise(Loudness,NoiseType);
    }
    DECLARE_FUNCTION(execPlayerCanSeeMe)
    {
        P_GET_UBOOL_OPTX(bForceLOSCheck,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->PlayerCanSeeMe(bForceLOSCheck);
    }
    DECLARE_FUNCTION(execSuggestTossVelocity);
    DECLARE_FUNCTION(execCalculateMinSpeedTrajectory)
    {
        P_GET_STRUCT_REF(FVector,out_Velocity);
        P_GET_STRUCT(FVector,End);
        P_GET_STRUCT(FVector,Start);
        P_GET_FLOAT(MaxTossSpeed);
        P_GET_FLOAT(MinTossSpeed);
        P_GET_STRUCT_OPTX(FVector,CollisionSize,FVector(EC_EventParm));
        P_GET_FLOAT_OPTX(TerminalVelocity,0);
        P_GET_FLOAT_OPTX(GravityZ,GetGravityZ());
        P_GET_UBOOL_OPTX(bOnlyTraceUp,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->CalculateMinSpeedTrajectory(out_Velocity,End,Start,MaxTossSpeed,MinTossSpeed,CollisionSize,TerminalVelocity,GravityZ,bOnlyTraceUp);
    }
    DECLARE_FUNCTION(execGetDestination)
    {
        P_GET_OBJECT(AController,C);
        P_FINISH;
        *(FVector*)Result=this->GetDestination(C);
    }
    DECLARE_FUNCTION(execGetURLMap)
    {
        P_FINISH;
        *(FString*)Result=this->GetURLMap();
    }
    DECLARE_FUNCTION(execAllActors);
    DECLARE_FUNCTION(execDynamicActors);
    DECLARE_FUNCTION(execChildActors);
    DECLARE_FUNCTION(execBasedActors);
    DECLARE_FUNCTION(execTouchingActors);
    DECLARE_FUNCTION(execTraceActors);
    DECLARE_FUNCTION(execVisibleActors);
    DECLARE_FUNCTION(execVisibleCollidingActors);
    DECLARE_FUNCTION(execCollidingActors);
    DECLARE_FUNCTION(execOverlappingActors);
    DECLARE_FUNCTION(execComponentList);
    DECLARE_FUNCTION(execAllOwnedComponents);
    DECLARE_FUNCTION(execLocalPlayerControllers);
    DECLARE_FUNCTION(execGetALocalPlayerController)
    {
        P_FINISH;
        *(class APlayerController**)Result=this->GetALocalPlayerController();
    }
    DECLARE_FUNCTION(execGetGravityZ)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetGravityZ();
    }
    DECLARE_FUNCTION(execSetNetUpdateTime)
    {
        P_GET_FLOAT(NewUpdateTime);
        P_FINISH;
        this->SetNetUpdateTime(NewUpdateTime);
    }
    DECLARE_FUNCTION(execPrestreamTextures)
    {
        P_GET_FLOAT(Seconds);
        P_GET_UBOOL(bEnableStreaming);
        P_GET_INT_OPTX(CinematicTextureGroups,0);
        P_FINISH;
        this->PrestreamTextures(Seconds,bEnableStreaming,CinematicTextureGroups);
    }
    DECLARE_FUNCTION(execIsPlayerOwned)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsPlayerOwned();
    }
    DECLARE_FUNCTION(execGetTeamNum)
    {
        P_FINISH;
        *(BYTE*)Result=this->GetTeamNum();
    }
    DECLARE_FUNCTION(execGetTargetLocation)
    {
        P_GET_OBJECT_OPTX(AActor,RequestedBy,NULL);
        P_GET_UBOOL_OPTX(bRequestAlternateLoc,FALSE);
        P_FINISH;
        *(FVector*)Result=this->GetTargetLocation(RequestedBy,bRequestAlternateLoc);
    }
    DECLARE_FUNCTION(execSetHUDLocation)
    {
        P_GET_STRUCT(FVector,NewHUDLocation);
        P_FINISH;
        this->SetHUDLocation(NewHUDLocation);
    }
    DECLARE_FUNCTION(execNativePostRenderFor)
    {
        P_GET_OBJECT(APlayerController,PC);
        P_GET_OBJECT(UCanvas,Canvas);
        P_GET_STRUCT(FVector,CameraPosition);
        P_GET_STRUCT(FVector,CameraDir);
        P_FINISH;
        this->NativePostRenderFor(PC,Canvas,CameraPosition,CameraDir);
    }
    DECLARE_FUNCTION(execGetPackageGuid)
    {
        P_GET_NAME(PackageName);
        P_FINISH;
        *(FGuid*)Result=this->GetPackageGuid(PackageName);
    }
    DECLARE_FUNCTION(execIsInPersistentLevel)
    {
        P_GET_UBOOL_OPTX(bIncludeLevelStreamingPersistent,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->IsInPersistentLevel(bIncludeLevelStreamingPersistent);
    }
    DECLARE_FUNCTION(execGetAnimTrailParticleSystem)
    {
        P_GET_OBJECT(UAnimNotify_Trails,AnimNotifyData);
        P_FINISH;
        *(class UParticleSystem**)Result=this->GetAnimTrailParticleSystem(AnimNotifyData);
    }
    DECLARE_FUNCTION(execSupportsKismetModification)
    {
        P_GET_OBJECT(USequenceOp,AskingOp);
        P_GET_STR_REF(Reason);
        P_FINISH;
        *(UBOOL*)Result=this->SupportsKismetModification(AskingOp,Reason);
    }
    DECLARE_FUNCTION(execGetAvoidanceVector)
    {
        P_GET_TARRAY_REF(class AActor*,Obstacles);
        P_GET_STRUCT(FVector,GoalLocation);
        P_GET_FLOAT(CollisionRadius);
        P_GET_FLOAT(MaxSpeed);
        P_GET_INT_OPTX(NumSamples,8);
        P_GET_FLOAT_OPTX(VelocityStepRate,0.100000);
        P_GET_FLOAT_OPTX(MaxTimeTilOverlap,1.000000);
        P_FINISH;
        *(FVector*)Result=this->GetAvoidanceVector(Obstacles,GoalLocation,CollisionRadius,MaxSpeed,NumSamples,VelocityStepRate,MaxTimeTilOverlap);
    }
    DECLARE_FUNCTION(execWillOverlap)
    {
        P_GET_STRUCT(FVector,PosA);
        P_GET_STRUCT(FVector,VelA);
        P_GET_STRUCT(FVector,PosB);
        P_GET_STRUCT(FVector,VelB);
        P_GET_FLOAT(StepSize);
        P_GET_FLOAT(Radius);
        P_GET_FLOAT_REF(Time);
        P_FINISH;
        *(UBOOL*)Result=this->WillOverlap(PosA,VelA,PosB,VelB,StepSize,Radius,Time);
    }
    DECLARE_FUNCTION(execShouldBeHiddenBySHOW_NavigationNodes)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ShouldBeHiddenBySHOW_NavigationNodes();
    }
    DECLARE_FUNCTION(execGetActorMetrics)
    {
        P_GET_BYTE(MetricsType);
        P_FINISH;
        *(INT*)Result=this->GetActorMetrics(MetricsType);
    }
    DECLARE_FUNCTION(execGetActorSpriteComponent)
    {
        P_FINISH;
        *(class USpriteComponent**)Result=this->GetActorSpriteComponent();
    }
    UBOOL eventOnMobileTouch(class APlayerController* InPC,FVector2D TouchLocation)
    {
        Actor_eventOnMobileTouch_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.InPC=InPC;
        Parms.TouchLocation=TouchLocation;
        ProcessEvent(FindFunctionChecked(ENGINE_OnMobileTouch),&Parms);
        return Parms.ReturnValue;
    }
    void eventReplicationEnded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ReplicationEnded),NULL);
    }
    void eventPostDemoRewind()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostDemoRewind),NULL);
    }
    void eventAnimTreeUpdated(class USkeletalMeshComponent* SkelMesh)
    {
        Actor_eventAnimTreeUpdated_Parms Parms(EC_EventParm);
        Parms.SkelMesh=SkelMesh;
        ProcessEvent(FindFunctionChecked(ENGINE_AnimTreeUpdated),&Parms);
    }
    void eventTrailsNotifyEnd(const class UAnimNotify_Trails* AnimNotifyData)
    {
        Actor_eventTrailsNotifyEnd_Parms Parms(EC_EventParm);
        Parms.AnimNotifyData=AnimNotifyData;
        ProcessEvent(FindFunctionChecked(ENGINE_TrailsNotifyEnd),&Parms);
    }
    void eventTrailsNotifyTick(const class UAnimNotify_Trails* AnimNotifyData)
    {
        Actor_eventTrailsNotifyTick_Parms Parms(EC_EventParm);
        Parms.AnimNotifyData=AnimNotifyData;
        ProcessEvent(FindFunctionChecked(ENGINE_TrailsNotifyTick),&Parms);
    }
    void eventTrailsNotify(const class UAnimNotify_Trails* AnimNotifyData)
    {
        Actor_eventTrailsNotify_Parms Parms(EC_EventParm);
        Parms.AnimNotifyData=AnimNotifyData;
        ProcessEvent(FindFunctionChecked(ENGINE_TrailsNotify),&Parms);
    }
    UBOOL eventCreateForceField(const class UAnimNotify_ForceField* AnimNotifyData)
    {
        Actor_eventCreateForceField_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AnimNotifyData=AnimNotifyData;
        ProcessEvent(FindFunctionChecked(ENGINE_CreateForceField),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventPlayParticleEffect(const class UAnimNotify_PlayParticleEffect* AnimNotifyData)
    {
        Actor_eventPlayParticleEffect_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AnimNotifyData=AnimNotifyData;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayParticleEffect),&Parms);
        return Parms.ReturnValue;
    }
    void eventOnRigidBodySpringOverextension(class URB_BodyInstance* BodyInstance)
    {
        Actor_eventOnRigidBodySpringOverextension_Parms Parms(EC_EventParm);
        Parms.BodyInstance=BodyInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRigidBodySpringOverextension),&Parms);
    }
    void eventPostInitAnimTree(class USkeletalMeshComponent* SkelComp)
    {
        Actor_eventPostInitAnimTree_Parms Parms(EC_EventParm);
        Parms.SkelComp=SkelComp;
        ProcessEvent(FindFunctionChecked(ENGINE_PostInitAnimTree),&Parms);
    }
    void eventRootMotionExtracted(class USkeletalMeshComponent* SkelComp,FBoneAtom& ExtractedRootMotionDelta)
    {
        Actor_eventRootMotionExtracted_Parms Parms(EC_EventParm);
        Parms.SkelComp=SkelComp;
        Parms.ExtractedRootMotionDelta=ExtractedRootMotionDelta;
        ProcessEvent(FindFunctionChecked(ENGINE_RootMotionExtracted),&Parms);
        ExtractedRootMotionDelta=Parms.ExtractedRootMotionDelta;
    }
    void eventRootMotionProcessed(class USkeletalMeshComponent* SkelComp)
    {
        Actor_eventRootMotionProcessed_Parms Parms(EC_EventParm);
        Parms.SkelComp=SkelComp;
        ProcessEvent(FindFunctionChecked(ENGINE_RootMotionProcessed),&Parms);
    }
    void eventRootMotionModeChanged(class USkeletalMeshComponent* SkelComp)
    {
        Actor_eventRootMotionModeChanged_Parms Parms(EC_EventParm);
        Parms.SkelComp=SkelComp;
        ProcessEvent(FindFunctionChecked(ENGINE_RootMotionModeChanged),&Parms);
    }
    void eventPostRenderFor(class APlayerController* PC,class UCanvas* Canvas,FVector CameraPosition,FVector CameraDir)
    {
        Actor_eventPostRenderFor_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        Parms.Canvas=Canvas;
        Parms.CameraPosition=CameraPosition;
        Parms.CameraDir=CameraDir;
        ProcessEvent(FindFunctionChecked(ENGINE_PostRenderFor),&Parms);
    }
    void eventOnRanOver(class ASVehicle* Vehicle,class UPrimitiveComponent* RunOverComponent,INT WheelIndex)
    {
        Actor_eventOnRanOver_Parms Parms(EC_EventParm);
        Parms.Vehicle=Vehicle;
        Parms.RunOverComponent=RunOverComponent;
        Parms.WheelIndex=WheelIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_OnRanOver),&Parms);
    }
    void eventRigidBodyCollision(class UPrimitiveComponent* HitComponent,class UPrimitiveComponent* OtherComponent,const FCollisionImpactData& RigidCollisionData,INT ContactIndex)
    {
        Actor_eventRigidBodyCollision_Parms Parms(EC_EventParm);
        Parms.HitComponent=HitComponent;
        Parms.OtherComponent=OtherComponent;
        Parms.RigidCollisionData=RigidCollisionData;
        Parms.ContactIndex=ContactIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_RigidBodyCollision),&Parms);
    }
    void eventInterpolationChanged(class USeqAct_Interp* InterpAction)
    {
        Actor_eventInterpolationChanged_Parms Parms(EC_EventParm);
        Parms.InterpAction=InterpAction;
        ProcessEvent(FindFunctionChecked(ENGINE_InterpolationChanged),&Parms);
    }
    void eventInterpolationFinished(class USeqAct_Interp* InterpAction)
    {
        Actor_eventInterpolationFinished_Parms Parms(EC_EventParm);
        Parms.InterpAction=InterpAction;
        ProcessEvent(FindFunctionChecked(ENGINE_InterpolationFinished),&Parms);
    }
    void eventInterpolationStarted(class USeqAct_Interp* InterpAction,class UInterpGroupInst* GroupInst)
    {
        Actor_eventInterpolationStarted_Parms Parms(EC_EventParm);
        Parms.InterpAction=InterpAction;
        Parms.GroupInst=GroupInst;
        ProcessEvent(FindFunctionChecked(ENGINE_InterpolationStarted),&Parms);
    }
    void eventSpawnedByKismet()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SpawnedByKismet),NULL);
    }
    BYTE eventScriptGetTeamNum()
    {
        Actor_eventScriptGetTeamNum_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_ScriptGetTeamNum),&Parms);
        return Parms.ReturnValue;
    }
    void eventGetActorEyesViewPoint(FVector& out_Location,FRotator& out_Rotation)
    {
        Actor_eventGetActorEyesViewPoint_Parms Parms(EC_EventParm);
        Parms.out_Location=out_Location;
        Parms.out_Rotation=out_Rotation;
        ProcessEvent(FindFunctionChecked(ENGINE_GetActorEyesViewPoint),&Parms);
        out_Location=Parms.out_Location;
        out_Rotation=Parms.out_Rotation;
    }
    class UFaceFXAsset* eventGetActorFaceFXAsset()
    {
        Actor_eventGetActorFaceFXAsset_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetActorFaceFXAsset),&Parms);
        return Parms.ReturnValue;
    }
    void eventTickSkelControl(FLOAT DeltaTime,class USkeletalMeshComponent* SkelComp,class USkelControlBase* SkelCtrl)
    {
        Actor_eventTickSkelControl_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        Parms.SkelComp=SkelComp;
        Parms.SkelCtrl=SkelCtrl;
        ProcessEvent(FindFunctionChecked(ENGINE_TickSkelControl),&Parms);
    }
    void eventSetSkelControlScale(FName SkelControlName,FLOAT Scale)
    {
        Actor_eventSetSkelControlScale_Parms Parms(EC_EventParm);
        Parms.SkelControlName=SkelControlName;
        Parms.Scale=Scale;
        ProcessEvent(FindFunctionChecked(ENGINE_SetSkelControlScale),&Parms);
    }
    void eventSetMorphWeight(FName MorphNodeName,FLOAT MorphWeight)
    {
        Actor_eventSetMorphWeight_Parms Parms(EC_EventParm);
        Parms.MorphNodeName=MorphNodeName;
        Parms.MorphWeight=MorphWeight;
        ProcessEvent(FindFunctionChecked(ENGINE_SetMorphWeight),&Parms);
    }
    void eventStopActorFaceFXAnim()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StopActorFaceFXAnim),NULL);
    }
    UBOOL eventPlayActorFaceFXAnim(class UFaceFXAnimSet* AnimSet,const FString& GroupName,const FString& SeqName,class USoundCue* SoundCueToPlay)
    {
        Actor_eventPlayActorFaceFXAnim_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.AnimSet=AnimSet;
        Parms.GroupName=GroupName;
        Parms.SeqName=SeqName;
        Parms.SoundCueToPlay=SoundCueToPlay;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayActorFaceFXAnim),&Parms);
        return Parms.ReturnValue;
    }
    void eventFinishAnimControl(class UInterpGroup* InInterpGroup)
    {
        Actor_eventFinishAnimControl_Parms Parms(EC_EventParm);
        Parms.InInterpGroup=InInterpGroup;
        ProcessEvent(FindFunctionChecked(ENGINE_FinishAnimControl),&Parms);
    }
    void eventSetAnimPosition(FName SlotName,INT ChannelIndex,FName InAnimSeqName,FLOAT InPosition,UBOOL bFireNotifies,UBOOL bLooping,UBOOL bEnableRootMotion)
    {
        Actor_eventSetAnimPosition_Parms Parms(EC_EventParm);
        Parms.SlotName=SlotName;
        Parms.ChannelIndex=ChannelIndex;
        Parms.InAnimSeqName=InAnimSeqName;
        Parms.InPosition=InPosition;
        Parms.bFireNotifies=bFireNotifies ? FIRST_BITFIELD : FALSE;
        Parms.bLooping=bLooping ? FIRST_BITFIELD : FALSE;
        Parms.bEnableRootMotion=bEnableRootMotion ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetAnimPosition),&Parms);
    }
    void eventBeginAnimControl(class UInterpGroup* InInterpGroup)
    {
        Actor_eventBeginAnimControl_Parms Parms(EC_EventParm);
        Parms.InInterpGroup=InInterpGroup;
        ProcessEvent(FindFunctionChecked(ENGINE_BeginAnimControl),&Parms);
    }
    void eventOnAnimPlay(class UAnimNodeSequence* SeqNode)
    {
        Actor_eventOnAnimPlay_Parms Parms(EC_EventParm);
        Parms.SeqNode=SeqNode;
        ProcessEvent(FindFunctionChecked(ENGINE_OnAnimPlay),&Parms);
    }
    void eventOnAnimEnd(class UAnimNodeSequence* SeqNode,FLOAT PlayedTime,FLOAT ExcessTime)
    {
        Actor_eventOnAnimEnd_Parms Parms(EC_EventParm);
        Parms.SeqNode=SeqNode;
        Parms.PlayedTime=PlayedTime;
        Parms.ExcessTime=ExcessTime;
        ProcessEvent(FindFunctionChecked(ENGINE_OnAnimEnd),&Parms);
    }
    void eventShutDown()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ShutDown),NULL);
    }
    void eventForceNetRelevant()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ForceNetRelevant),NULL);
    }
    void eventReceivedNewEvent(class USequenceEvent* Evt)
    {
        Actor_eventReceivedNewEvent_Parms Parms(EC_EventParm);
        Parms.Evt=Evt;
        ProcessEvent(FindFunctionChecked(ENGINE_ReceivedNewEvent),&Parms);
    }
    void eventDebugMessagePlayer(const FString& msg)
    {
        Actor_eventDebugMessagePlayer_Parms Parms(EC_EventParm);
        Parms.msg=msg;
        ProcessEvent(FindFunctionChecked(ENGINE_DebugMessagePlayer),&Parms);
    }
    void eventReset()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Reset),NULL);
    }
    class UAudioComponent* eventGetFaceFXAudioComponent()
    {
        Actor_eventGetFaceFXAudioComponent_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        ProcessEvent(FindFunctionChecked(ENGINE_GetFaceFXAudioComponent),&Parms);
        return Parms.ReturnValue;
    }
    void eventModifyHearSoundComponent(class UAudioComponent* AC)
    {
        Actor_eventModifyHearSoundComponent_Parms Parms(EC_EventParm);
        Parms.AC=AC;
        ProcessEvent(FindFunctionChecked(ENGINE_ModifyHearSoundComponent),&Parms);
    }
    void eventEndViewTarget(class APlayerController* PC)
    {
        Actor_eventEndViewTarget_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        ProcessEvent(FindFunctionChecked(ENGINE_EndViewTarget),&Parms);
    }
    void eventBecomeViewTarget(class APlayerController* PC)
    {
        Actor_eventBecomeViewTarget_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        ProcessEvent(FindFunctionChecked(ENGINE_BecomeViewTarget),&Parms);
    }
    void eventDebugFreezeGame(class AActor* ActorToLookAt=NULL)
    {
        Actor_eventDebugFreezeGame_Parms Parms(EC_EventParm);
        Parms.ActorToLookAt=ActorToLookAt;
        ProcessEvent(FindFunctionChecked(ENGINE_DebugFreezeGame),&Parms);
    }
    UBOOL eventHealDamage(INT Amount,class AController* Healer,class UClass* DamageType)
    {
        Actor_eventHealDamage_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Amount=Amount;
        Parms.Healer=Healer;
        Parms.DamageType=DamageType;
        ProcessEvent(FindFunctionChecked(ENGINE_HealDamage),&Parms);
        return Parms.ReturnValue;
    }
    void eventTakeDamage(INT DamageAmount,class AController* EventInstigator,FVector HitLocation,FVector Momentum,class UClass* DamageType,struct FTraceHitInfo HitInfo=FTraceHitInfo(EC_EventParm),class AActor* DamageCauser=NULL)
    {
        Actor_eventTakeDamage_Parms Parms(EC_EventParm);
        Parms.DamageAmount=DamageAmount;
        Parms.EventInstigator=EventInstigator;
        Parms.HitLocation=HitLocation;
        Parms.Momentum=Momentum;
        Parms.DamageType=DamageType;
        Parms.HitInfo=HitInfo;
        Parms.DamageCauser=DamageCauser;
        ProcessEvent(FindFunctionChecked(ENGINE_TakeDamage),&Parms);
    }
    void eventNotifySkelControlBeyondLimit(class USkelControlLookAt* LookAt)
    {
        Actor_eventNotifySkelControlBeyondLimit_Parms Parms(EC_EventParm);
        Parms.LookAt=LookAt;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifySkelControlBeyondLimit),&Parms);
    }
    void eventConstraintBrokenNotify(class AActor* ConOwner,class URB_ConstraintSetup* ConSetup,class URB_ConstraintInstance* ConInstance)
    {
        Actor_eventConstraintBrokenNotify_Parms Parms(EC_EventParm);
        Parms.ConOwner=ConOwner;
        Parms.ConSetup=ConSetup;
        Parms.ConInstance=ConInstance;
        ProcessEvent(FindFunctionChecked(ENGINE_ConstraintBrokenNotify),&Parms);
    }
    void eventSetInitialState()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SetInitialState),NULL);
    }
    void eventPostBeginPlay()
    {
        if(IsProbing(NAME_PostBeginPlay)) {
        ProcessEvent(FindFunctionChecked(ENGINE_PostBeginPlay),NULL);
        }
    }
    void eventBroadcastLocalizedTeamMessage(INT TeamIndex,class UClass* InMessageClass,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        Actor_eventBroadcastLocalizedTeamMessage_Parms Parms(EC_EventParm);
        Parms.TeamIndex=TeamIndex;
        Parms.InMessageClass=InMessageClass;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalizedTeamMessage),&Parms);
    }
    void eventBroadcastLocalizedMessage(class UClass* InMessageClass,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        Actor_eventBroadcastLocalizedMessage_Parms Parms(EC_EventParm);
        Parms.InMessageClass=InMessageClass;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalizedMessage),&Parms);
    }
    void eventPreBeginPlay()
    {
        if(IsProbing(NAME_PreBeginPlay)) {
        ProcessEvent(FindFunctionChecked(ENGINE_PreBeginPlay),NULL);
        }
    }
    void eventTornOff()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_TornOff),NULL);
    }
    void eventOutsideWorldBounds()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OutsideWorldBounds),NULL);
    }
    void eventFellOutOfWorld(class UClass* dmgType)
    {
        Actor_eventFellOutOfWorld_Parms Parms(EC_EventParm);
        Parms.dmgType=dmgType;
        ProcessEvent(FindFunctionChecked(ENGINE_FellOutOfWorld),&Parms);
    }
    UBOOL eventOverRotated(FRotator& out_Desired,FRotator& out_Actual)
    {
        Actor_eventOverRotated_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.out_Desired=out_Desired;
        Parms.out_Actual=out_Actual;
        ProcessEvent(FindFunctionChecked(ENGINE_OverRotated),&Parms);
        out_Desired=Parms.out_Desired;
        out_Actual=Parms.out_Actual;
        return Parms.ReturnValue;
    }
    void eventOnSleepRBPhysics()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnSleepRBPhysics),NULL);
    }
    void eventOnWakeRBPhysics()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnWakeRBPhysics),NULL);
    }
    void eventRanInto(class AActor* Other)
    {
        Actor_eventRanInto_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_RanInto),&Parms);
    }
    void eventEncroachedBy(class AActor* Other)
    {
        Actor_eventEncroachedBy_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_EncroachedBy)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_EncroachedBy),&Parms);
        }
    }
    UBOOL eventEncroachingOn(class AActor* Other)
    {
        Actor_eventEncroachingOn_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        if(IsProbing(NAME_EncroachingOn)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_EncroachingOn),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventCollisionChanged()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_CollisionChanged),NULL);
    }
    class AActor* eventSpecialHandling(class APawn* Other)
    {
        Actor_eventSpecialHandling_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        if(IsProbing(NAME_SpecialHandling)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_SpecialHandling),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventDetach(class AActor* Other)
    {
        Actor_eventDetach_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Detach)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_Detach),&Parms);
        }
    }
    void eventAttach(class AActor* Other)
    {
        Actor_eventAttach_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Attach)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_Attach),&Parms);
        }
    }
    void eventBaseChange()
    {
        if(IsProbing(NAME_BaseChange)) {
        ProcessEvent(FindFunctionChecked(ENGINE_BaseChange),NULL);
        }
    }
    void eventBump(class AActor* Other,class UPrimitiveComponent* OtherComp,FVector HitNormal)
    {
        Actor_eventBump_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Bump)) {
        Parms.Other=Other;
        Parms.OtherComp=OtherComp;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_Bump),&Parms);
        }
    }
    void eventUnTouch(class AActor* Other)
    {
        Actor_eventUnTouch_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_UnTouch)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_UnTouch),&Parms);
        }
    }
    void eventPostTouch(class AActor* Other)
    {
        Actor_eventPostTouch_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PostTouch),&Parms);
    }
    void eventTouch(class AActor* Other,class UPrimitiveComponent* OtherComp,FVector HitLocation,FVector HitNormal)
    {
        Actor_eventTouch_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Touch)) {
        Parms.Other=Other;
        Parms.OtherComp=OtherComp;
        Parms.HitLocation=HitLocation;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_Touch),&Parms);
        }
    }
    void eventPhysicsVolumeChange(class APhysicsVolume* NewVolume)
    {
        Actor_eventPhysicsVolumeChange_Parms Parms(EC_EventParm);
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_PhysicsVolumeChange),&Parms);
    }
    void eventLanded(FVector HitNormal,class AActor* FloorActor)
    {
        Actor_eventLanded_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Landed)) {
        Parms.HitNormal=HitNormal;
        Parms.FloorActor=FloorActor;
        ProcessEvent(FindFunctionChecked(ENGINE_Landed),&Parms);
        }
    }
    void eventFalling()
    {
        if(IsProbing(NAME_Falling)) {
        ProcessEvent(FindFunctionChecked(ENGINE_Falling),NULL);
        }
    }
    void eventHitWall(FVector HitNormal,class AActor* Wall,class UPrimitiveComponent* WallComp)
    {
        Actor_eventHitWall_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_HitWall)) {
        Parms.HitNormal=HitNormal;
        Parms.Wall=Wall;
        Parms.WallComp=WallComp;
        ProcessEvent(FindFunctionChecked(ENGINE_HitWall),&Parms);
        }
    }
    void eventTimer()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Timer),NULL);
    }
    void eventTick(FLOAT DeltaTime)
    {
        Actor_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Tick),&Parms);
        }
    }
    void eventLostChild(class AActor* Other)
    {
        Actor_eventLostChild_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_LostChild)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_LostChild),&Parms);
        }
    }
    void eventGainedChild(class AActor* Other)
    {
        Actor_eventGainedChild_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_GainedChild)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_GainedChild),&Parms);
        }
    }
    void eventDestroyed()
    {
        if(IsProbing(NAME_Destroyed)) {
        ProcessEvent(FindFunctionChecked(ENGINE_Destroyed),NULL);
        }
    }
    void eventReplicatedEvent(FName VarName)
    {
        Actor_eventReplicatedEvent_Parms Parms(EC_EventParm);
        Parms.VarName=VarName;
        ProcessEvent(FindFunctionChecked(ENGINE_ReplicatedEvent),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(AActor,UObject,0|CLASS_NativeReplication,Engine)
	// Used to adjust box used for collision in overlap checks which are performed at a location other than the actor's current location.
	static FVector OverlapAdjust;

	// Constructors.
	virtual void BeginDestroy();
	virtual UBOOL IsReadyForFinishDestroy();

	// UObject interface.
	virtual INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	void ProcessEvent( UFunction* Function, void* Parms, void* Result=NULL );
	void ProcessState( FLOAT DeltaSeconds );
	UBOOL ProcessRemoteFunction( UFunction* Function, void* Parms, FFrame* Stack );
	void ProcessDemoRecFunction( UFunction* Function, void* Parms, FFrame* Stack );
	void InitExecution();
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PreSave();
	virtual void PostLoad();
	void NetDirty(UProperty* property);

	// AActor interface.
	virtual APawn* GetPlayerPawn() const {return NULL;}
	virtual UBOOL IsPlayerPawn() const {return false;}
	virtual UBOOL IgnoreBlockingBy( const AActor *Other) const;
	UBOOL IsOwnedBy( const AActor *TestOwner ) const;
	UBOOL IsBlockedBy( const AActor* Other, const UPrimitiveComponent* Primitive ) const;
	UBOOL IsBasedOn( const AActor *Other ) const;

	/** If returns TRUE, can fracture a FSMA, if it has bBreakChunksOnActorTouch set. */
	virtual UBOOL CanCauseFractureOnTouch()
	{
		return FALSE;
	}

	/** Creates offsets for locations based on the editor grid size and active viewport. **/
	virtual FVector CreateLocationOffset(UBOOL bDuplicate, UBOOL bOffsetLocations, INT ViewportType, FLOAT GridSize) const;

	/**
	 * Utility for finding the PrefabInstance that 'owns' this actor.
	 * If the actor is not part of a prefab instance, returns NULL.
	 * If the actor _is_ a PrefabInstance, return itself.
	 */
	class APrefabInstance* FindOwningPrefabInstance() const;

	AActor* GetBase() const;

#if WITH_EDITOR
	// Editor specific

	/**
	 * @return		TRUE if the actor is in the named layer, FALSE otherwise.
	 */
	UBOOL IsInLayer(const TCHAR* LayerName) const;

	/**
	 * Parses the actor's layer string into a list of layer names (strings).
	 * @param		OutLayers		[out] Receives the list of layer names.
	 */
	void GetLayers(TArray<FString>& OutLayers) const;

	/**
	 * Called by ApplyDeltaToActor to perform an actor class-specific operation based on widget manipulation.
	 * The default implementation is simply to translate the actor's location.
	 */
	virtual void EditorApplyTranslation(const FVector& DeltaTranslation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	/**
	 * Called by ApplyDeltaToActor to perform an actor class-specific operation based on widget manipulation.
	 * The default implementation is simply to modify the actor's rotation.
	 */
	virtual void EditorApplyRotation(const FRotator& DeltaRotation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	/**
	 * Called by ApplyDeltaToActor to perform an actor class-specific operation based on widget manipulation.
	 * The default implementation is simply to modify the actor's draw scale.
	 */
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	/**
	 * Called by MirrorActors to perform a mirroring operation on the actor
	 */
	virtual void EditorApplyMirror(const FVector& MirrorScale, const FVector& PivotLocation);

	/**
	 * Simple accessor to check if the actor is hidden upon editor startup
	 *
	 * @return	TRUE if the actor is hidden upon editor startup; FALSE if it is not
	 */
	UBOOL IsHiddenEdAtStartup() const
	{
		return bHiddenEd;
	}

	// Called before editor copy, TRUE allow export
	virtual UBOOL ShouldExport() { return TRUE; }
	// Called before editor paste, TRUE allow import
	virtual UBOOL ShouldImport(FString* ActorPropString, UBOOL IsMovingLevel) { return TRUE; }
	// For UUnrealEdEngine::UpdatePropertyWindows()
	virtual UBOOL GetSelectedComponents(TArray<UObject*>& SelectedObjects) { return FALSE; }

	/** Notifications that a key was pressed in the editor */
	virtual void OnEditorKeyPressed(FName Key, EInputEvent Event) {};

	/**
	* Called by ReplaceSelectedActors to allow a new actor to copy properties from an old actor when it is replaced
	*
	* @param OldActor the actor that is being replaced.
	*/
	virtual void EditorReplacedActor (AActor* OldActor) {}
#endif

	void EditorUpdateBase();
	void EditorUpdateAttachedActors(const TArray<AActor*>& IgnoreActors);


	UBOOL IsHiddenEd() const;
	virtual UBOOL IsSelected() const
	{
		return (UObject::IsSelected() && !bDeleteMe);
	}

	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);
	/** ticks the actor
	 * @return TRUE if the actor was ticked, FALSE if it was aborted (e.g. because it's in stasis)
	 */
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	/**
	 * bFinished is FALSE while the actor is being continually moved, and becomes TRUE on the last call.
	 * This can be used to defer computationally intensive calculations to the final PostEditMove call of
	 * eg a drag operation.
	 */
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostRename();
	virtual void Spawned();
	/** sets CollisionType to a default value based on the current collision settings of this Actor and its CollisionComponent */
	void SetDefaultCollisionType();
	/** sets collision flags based on the current CollisionType */
	void SetCollisionFromCollisionType();
	virtual void PreNetReceive();
	virtual void PostNetReceive();
	virtual void PostNetReceiveLocation();
	virtual void PostNetReceiveBase(AActor* NewBase);

	// Rendering info.

	FMatrix LocalToWorld() const
	{
#if 0
		FTranslationMatrix	LToW		( -PrePivot					);
		FScaleMatrix		TempScale	( DrawScale3D * DrawScale	);
		FRotationMatrix		TempRot		( Rotation					);
		FTranslationMatrix	TempTrans	( Location					);
		LToW *= TempScale;
		LToW *= TempRot;
		LToW *= TempTrans;
		return LToW;
#else
		FMatrix Result;

		const FLOAT	SR = GMath.SinTab(Rotation.Roll),
				    SP = GMath.SinTab(Rotation.Pitch),
					SY = GMath.SinTab(Rotation.Yaw),
					CR = GMath.CosTab(Rotation.Roll),
					CP = GMath.CosTab(Rotation.Pitch),
					CY = GMath.CosTab(Rotation.Yaw);

		const FLOAT	LX = Location.X,
				    LY = Location.Y,
					LZ = Location.Z,
					PX = PrePivot.X,
					PY = PrePivot.Y,
					PZ = PrePivot.Z;

		const FLOAT	DX = DrawScale3D.X * DrawScale,
			        DY = DrawScale3D.Y * DrawScale,
					DZ = DrawScale3D.Z * DrawScale;

		Result.M[0][0] = CP * CY * DX;
		Result.M[0][1] = CP * DX * SY;
		Result.M[0][2] = DX * SP;
		Result.M[0][3] = 0.f;

		Result.M[1][0] = DY * ( CY * SP * SR - CR * SY );
		Result.M[1][1] = DY * ( CR * CY + SP * SR * SY );
		Result.M[1][2] = -CP * DY * SR;
		Result.M[1][3] = 0.f;

		Result.M[2][0] = -DZ * ( CR * CY * SP + SR * SY );
		Result.M[2][1] =  DZ * ( CY * SR - CR * SP * SY );
		Result.M[2][2] = CP * CR * DZ;
		Result.M[2][3] = 0.f;

		Result.M[3][0] = LX - CP * CY * DX * PX + CR * CY * DZ * PZ * SP - CY * DY * PY * SP * SR + CR * DY * PY * SY + DZ * PZ * SR * SY;
		Result.M[3][1] = LY - (CR * CY * DY * PY + CY * DZ * PZ * SR + CP * DX * PX * SY - CR * DZ * PZ * SP * SY + DY * PY * SP * SR * SY);
		Result.M[3][2] = LZ - (CP * CR * DZ * PZ + DX * PX * SP - CP * DY * PY * SR);
		Result.M[3][3] = 1.f;

		return Result;
#endif
	}
	FMatrix WorldToLocal() const
	{
		return	FTranslationMatrix(-Location) *
				FInverseRotationMatrix(Rotation) *
				FScaleMatrix(FVector( 1.f / DrawScale3D.X, 1.f / DrawScale3D.Y, 1.f / DrawScale3D.Z) / DrawScale) *
				FTranslationMatrix(PrePivot);
	}

	/** Returns the size of the extent to use when moving the object through the world */
	FVector GetCylinderExtent() const;

	AActor* GetTopOwner();
	virtual UBOOL IsPendingKill() const
	{
		return bDeleteMe || HasAnyFlags(RF_PendingKill);
	}
	/** Fast check to see if an actor is alive by not being virtual */
	FORCEINLINE UBOOL ActorIsPendingKill(void) const
	{
		return bDeleteMe || HasAnyFlags(RF_PendingKill);
	}
	virtual void PostScriptDestroyed() {} // C++ notification that the script Destroyed() function has been called.

	// AActor collision functions.
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual UBOOL IsOverlapping( AActor *Other, FCheckResult* Hit=NULL, UPrimitiveComponent* OtherPrimitiveComponent=NULL, UPrimitiveComponent* MyPrimitiveComponent=NULL );

	virtual FBox GetComponentsBoundingBox(UBOOL bNonColliding=0) const;

	/**
	 * This will check to see if the Actor is still in the world.  It will check things like
	 * the KillZ, SoftKillZ, outside world bounds, etc. and handle the situation.
	 **/
	void CheckStillInWorld();

	// AActor general functions.
	void UnTouchActors();
	void FindTouchingActors();
	void BeginTouch(AActor *Other, UPrimitiveComponent* OtherComp, const FVector &HitLocation, const FVector &HitNormal, UPrimitiveComponent* MyComp=NULL);
	void EndTouch(AActor *Other, UBOOL NoNotifySelf);
	UBOOL IsBrush()       const;
	UBOOL IsStaticBrush() const;
	UBOOL IsVolumeBrush() const;
	UBOOL IsBrushShape() const;
	UBOOL IsEncroacher() const;

	virtual UBOOL FindInterpMoveTrack(class UInterpTrackMove** MoveTrack, class UInterpTrackInstMove** MoveTrackInst, class USeqAct_Interp** OutSeq);

	/** whether this Actor wants to be ticked */
	FORCEINLINE UBOOL WantsTick() const { return !bStatic && !bTickIsDisabled; }
	/** accessor for the value of bStatic */
	FORCEINLINE UBOOL IsStatic() const { return bStatic; }
	/**
	 * Returns True if an actor cannot move or be destroyed during gameplay, and can thus cast and receive static shadowing.
	 */
	UBOOL HasStaticShadowing() const { return bStatic || (bNoDelete && !bMovable); }

	/**
	 * Sets the hard attach flag by first handling the case of already being
	 * based upon another actor
	 *
	 * @param bNewHardAttach the new hard attach setting
	 */
	virtual void SetHardAttach(UBOOL bNewHardAttach);

	virtual void NotifyBump(AActor *Other, UPrimitiveComponent* OtherComp, const FVector &HitNormal);
	/** notification when actor has bumped against the level */
	virtual void NotifyBumpLevel(const FVector &HitLocation, const FVector &HitNormal);

	void SetCollision( UBOOL bNewCollideActors, UBOOL bNewBlockActors, UBOOL bNewIgnoreEncroachers );
	virtual void SetBase(AActor *NewBase, FVector NewFloor = FVector(0,0,1), INT bNotifyActor=1, USkeletalMeshComponent* SkelComp=NULL, FName AttachName=NAME_None );
	void UpdateTimers(FLOAT DeltaSeconds);
	virtual void TickAuthoritative( FLOAT DeltaSeconds );
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickSpecial( FLOAT DeltaSeconds );
	virtual UBOOL PlayerControlled();
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);

	/**
	 * Check if this actor is the owner when doing relevancy checks for actors marked bOnlyRelevantToOwner
	 *
	 * @param ReplicatedActor - the actor we're doing a relevancy test on
	 *
	 * @param ActorOwner - the owner of ReplicatedActor
	 *
	 * @param ConnectionActor - the controller of the connection that we're doing relevancy checks for
	 *
	 * @return TRUE if this actor should be considered the owner
	 */
	virtual UBOOL IsRelevancyOwnerFor(AActor* ReplicatedActor, AActor* ActorOwner, AActor* ConnectionActor);

	/** returns whether this Actor should be considered relevant because it is visible through
	 * the other side of any portals RealViewer can see
	 */
	UBOOL IsRelevantThroughPortals(APlayerController* RealViewer);

	// Level functions
	virtual void SetZone( UBOOL bTest, UBOOL bForceRefresh );
	virtual void SetVolumes();
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	virtual void PreBeginPlay();
	virtual void PostBeginPlay();

	/*
	 * Play a sound.  Creates an AudioComponent only if the sound is determined to be audible, and replicates the sound to clients based on optional flags
	 *
	 * @param	SoundLocation	the location to play the sound; if not specified, uses the actor's location.
	 */
	void PlaySound(class USoundCue* InSoundCue, UBOOL bNotReplicated = FALSE, UBOOL bNoRepToOwner = FALSE, UBOOL bStopWhenOwnerDestroyed = FALSE, FVector* SoundLocation = NULL, UBOOL bNoRepToRelevant = FALSE);

	// Physics functions.
	virtual void setPhysics(BYTE NewPhysics, AActor *NewFloor = NULL, FVector NewFloorV = FVector(0,0,1) );
	virtual void performPhysics(FLOAT DeltaSeconds);
	virtual void physProjectile(FLOAT deltaTime, INT Iterations);
	virtual void BoundProjectileVelocity();
	virtual void processHitWall(FCheckResult const& Hit, FLOAT TimeSlice=0.f);
	virtual void processLanded(FVector const& HitNormal, AActor *HitActor, FLOAT remainingTime, INT Iterations);
	virtual void physFalling(FLOAT deltaTime, INT Iterations);
	virtual void physWalking(FLOAT deltaTime, INT Iterations);
	virtual void physNavMeshWalking(FLOAT deltaTime){}
	virtual void physCustom(FLOAT deltaTime, INT Iterations) {};
	virtual void physicsRotation(FLOAT deltaTime, FVector OldVelocity);
	inline void TwoWallAdjust(const FVector &DesiredDir, FVector &Delta, const FVector &HitNormal, const FVector &OldHitNormal, FLOAT HitTime)
	{
		if ((OldHitNormal | HitNormal) <= 0.f) //90 or less corner, so use cross product for dir
		{
			FVector NewDir = (HitNormal ^ OldHitNormal);
			NewDir = NewDir.SafeNormal();
			Delta = (Delta | NewDir) * (1.f - HitTime) * NewDir;
			if ((DesiredDir | Delta) < 0.f)
				Delta = -1.f * Delta;
		}
		else //adjust to new wall
		{
			Delta = (Delta - HitNormal * (Delta | HitNormal)) * (1.f - HitTime);
			if ((Delta | DesiredDir) <= 0.f)
				Delta = FVector(0.f,0.f,0.f);
			else if ( Abs((HitNormal | OldHitNormal) - 1.f) < KINDA_SMALL_NUMBER )
			{
				// we hit the same wall again even after adjusting to move along it the first time
				// nudge away from it (this can happen due to precision issues)
				Delta += HitNormal * 0.1f;
			}
		}
	}
	UBOOL moveSmooth(FVector const& Delta);
	virtual FRotator FindSlopeRotation(const FVector& FloorNormal, const FRotator& NewRotation);
	void UpdateRelativeRotation();
	virtual void GetNetBuoyancy(FLOAT &NetBuoyancy, FLOAT &NetFluidFriction);
	virtual void SmoothHitWall(FVector const& HitNormal, AActor *HitActor);
	virtual void stepUp(const FVector& GravDir, const FVector& DesiredDir, const FVector& Delta, FCheckResult &Hit);
	virtual UBOOL ShrinkCollision(AActor *HitActor, UPrimitiveComponent* HitComponent, const FVector &StartLocation);
	virtual void GrowCollision() {};
	virtual UBOOL MoveWithInterpMoveTrack(UInterpTrackMove* MoveTrack, UInterpTrackInstMove* MoveInst, FLOAT CurTime, FLOAT DeltaTime);
	virtual void AdjustInterpTrackMove(FVector& Pos, FRotator& Rot, FLOAT DeltaTime, UBOOL bIgnoreRotation = FALSE) {}
	virtual void physInterpolating(FLOAT DeltaTime);
	virtual void PushedBy(AActor* Other) {};
	virtual void UpdateBasedRotation(FRotator &FinalRotation, const FRotator& ReducedRotation) {};
	virtual void ReverseBasedRotation() {};

	/** Utility to add extra forces necessary for rigid-body gravity and damping to the collision component. */
	void AddRBGravAndDamping();

	virtual void physRigidBody(FLOAT DeltaTime);
	virtual void physSoftBody(FLOAT DeltaTime);

	virtual void InitRBPhys();
	virtual void InitRBPhysEditor() {}
	virtual void TermRBPhys(FRBPhysScene* Scene);

	/**
	* Used by the cooker to pre cache the convex data for static meshes within a given actor.
	* This data is stored with the level.
	* @param Level - The level the cache is in
	* @param TriByteCount - running total of memory usage for per-tri collision cache
	* @param TriMeshCount - running count of per-tri collision cache
	* @param HullByteCount - running total of memory usage for hull cache
	* @param HullCount - running count of hull cache
	*/
	virtual void BuildPhysStaticMeshCache(ULevel* Level,
										  INT& TriByteCount, INT& TriMeshCount, INT& HullByteCount, INT& HullCount);

	void ApplyNewRBState(const FRigidBodyState& NewState, FLOAT* AngErrorAccumulator, FVector& OutDeltaPos);
	UBOOL GetCurrentRBState(FRigidBodyState& OutState);

	/**
	 *	Event called when this Actor is involved in a rigid body collision.
	 *	bNotifyRigidBodyCollision must be true on the physics PrimitiveComponent within this Actor for this event to be called.
	 *	This base class implementation fires off the RigidBodyCollision Kismet event if attached.
	 */
	virtual void OnRigidBodyCollision(const FRigidBodyCollisionInfo& MyInfo, const FRigidBodyCollisionInfo& OtherInfo, const FCollisionImpactData& RigidCollisionData);

	/** Update information used to detect overlaps between this actor and physics objects, used for 'pushing' things */
	virtual void UpdatePushBody() {};

#if WITH_NOVODEX
	virtual void ModifyNxActorDesc(NxActorDesc& ActorDesc,UPrimitiveComponent* PrimComp, const class NxGroupsMask& GroupsMask, UINT MatIndex) {}
	virtual void PostInitRigidBody(NxActor* nActor, NxActorDesc& ActorDesc, UPrimitiveComponent* PrimComp) {}
	virtual void PreTermRigidBody(NxActor* nActor) {}
	virtual void SyncActorToRBPhysics();
	void SyncActorToClothPhysics();
#endif // WITH_NOVODEX

	// AnimControl Matinee Track support

	/** Used to provide information on the slots that this Actor provides for animation to Matinee. */
	virtual void GetAnimControlSlotDesc(TArray<struct FAnimSlotDesc>& OutSlotDescs) {}

	/**
	 *	Called by Matinee when we open it to start controlling animation on this Actor.
	 *	Is also called again when the GroupAnimSets array changes in Matinee, so must support multiple calls.
	 */
	virtual void PreviewBeginAnimControl(class UInterpGroup* InInterpGroup) {}

	/** Called each frame by Matinee to update the desired sequence by name and position within it. */
	virtual void PreviewSetAnimPosition(FName SlotName, INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bLooping, UBOOL bFireNotifies, UBOOL bEnableRootMotion, FLOAT DeltaTime) {}

	/** Called each frame by Matinee to update the desired animation channel weights for this Actor. */
	virtual void PreviewSetAnimWeights(TArray<FAnimSlotInfo>& SlotInfos) {}

	/** Called by Matinee when we close it after we have been controlling animation on this Actor. */
	virtual void PreviewFinishAnimControl(class UInterpGroup* InInterpGroup) {}

	/** Function used to control FaceFX animation in the editor (Matinee). */
	virtual void PreviewUpdateFaceFX(UBOOL bForceAnim, const FString& GroupName, const FString& SeqName, FLOAT InPosition) {}

	/** Used by Matinee playback to start a FaceFX animation playing. */
	virtual void PreviewActorPlayFaceFX(const FString& GroupName, const FString& SeqName, USoundCue* InSoundCue) {}

	/** Used by Matinee to stop current FaceFX animation playing. */
	virtual void PreviewActorStopFaceFX() {}

	/** Used in Matinee to get the AudioComponent we should play facial animation audio on. */
	virtual UAudioComponent* PreviewGetFaceFXAudioComponent() { return NULL; }

	/** Get the UFaceFXAsset that is currently being used by this Actor when playing facial animations. */
	virtual class UFaceFXAsset* PreviewGetActorFaceFXAsset() { return NULL; }

	/** Called each frame by Matinee to update the weight of a particular MorphNodeWeight. */
	virtual void PreviewSetMorphWeight(FName MorphNodeName, FLOAT MorphWeight) {}

	/** Called each frame by Matinee to update the scaling on a SkelControl. */
	virtual void PreviewSetSkelControlScale(FName SkelControlName, FLOAT Scale) {}

	/** Called each frame by Matinee to update the controlstrength on a SkelControl. */
	virtual void SetSkelControlStrength(FName SkelControlName, FLOAT ControlStrength) {}

	// AI functions.
	int TestCanSeeMe(class APlayerController *Viewer);
	virtual AActor* AssociatedLevelGeometry();
	virtual UBOOL HasAssociatedLevelGeometry(AActor *Other);
	UBOOL SuggestTossVelocity(FVector* TossVelocity, const FVector& Dest, const FVector& Start, FLOAT TossSpeed, FLOAT BaseTossZ, FLOAT DesiredZPct, const FVector& CollisionSize, FLOAT TerminalVelocity, FLOAT OverrideGravityZ = 0.f, UBOOL bOnlyTraceUp = FALSE);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual UBOOL TouchReachSucceeded(APawn *P, const FVector &TestPosition);
	virtual UBOOL BlockedByVehicle();

	// Special editor behavior
	AActor* GetHitActor();
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual INT AddMyMarker(AActor *S) { return 0; };
	virtual void ClearMarker() {};

	virtual void CheckForErrors();
	virtual void CheckForDeprecated();


	/** tells this Actor to set its collision for the path building state
	 * for normally colliding Actors that AI should path through (e.g. doors) or vice versa
	 * @param bNowPathBuilding - whether we are now building paths
	 */
	virtual void SetCollisionForPathBuilding(UBOOL bNowPathBuilding);

#endif

	// path creation
	virtual void PrePath() {};
	virtual void PostPath() {};

	/**
	 * Return whether this actor is a builder brush or not.
	 *
	 * @return TRUE if this actor is a builder brush, FALSE otherwise
	 */
	virtual UBOOL IsABuilderBrush() const { return FALSE; }

	/**
	 * Return whether this actor is the current builder brush or not
	 *
	 * @return TRUE if htis actor is the current builder brush, FALSE otherwise
	 */
	virtual UBOOL IsCurrentBuilderBrush() const { return FALSE; }

	virtual UBOOL IsABrush() const {return FALSE;}
	virtual UBOOL IsAVolume() const {return FALSE;}
	virtual UBOOL IsABrushShape() const {return FALSE;}
	virtual UBOOL IsAFluidSurface() const {return FALSE;}

	virtual APlayerController* GetAPlayerController() { return NULL; }
	virtual AController* GetAController() { return NULL; }
	virtual APawn* GetAPawn() { return NULL; }
	virtual const APawn* GetAPawn() const { return NULL; }
	virtual class AVehicle* GetAVehicle() { return NULL; }
	virtual AVolume* GetAVolume() { return NULL; }
	virtual class AFluidSurfaceActor* GetAFluidSurface() { return NULL; }
	virtual class AProjectile* GetAProjectile() { return NULL; }
	virtual const class AProjectile* GetAProjectile() const { return NULL; }
	virtual class APortalTeleporter* GetAPortalTeleporter() { return NULL; };

	virtual APlayerController* GetTopPlayerController()
	{
		AActor* TopActor = GetTopOwner();
		return (TopActor ? TopActor->GetAPlayerController() : NULL);
	}

	/**
	 * Verifies that neither this actor nor any of its components are RF_Unreachable and therefore pending
	 * deletion via the GC.
	 *
	 * @return TRUE if no unreachable actors are referenced, FALSE otherwise
	 */
	virtual UBOOL VerifyNoUnreachableReferences();

	virtual void ClearComponents();
	void ConditionalUpdateComponents(UBOOL bCollisionUpdate = FALSE);

	/** Used by octree RestrictedOverlapCheck to determine whether an actor should be considered
	 *
	 *  @return TRUE is actor should be considered
	 */
	virtual UBOOL WantsOverlapCheckWith(AActor* TestActor) { return TRUE; };

	/**
	  * Used by Octree ActorRadius check to determine whether to return a component even if the actor owning the component has already been returned.
	  * @RETURN True if component should be returned
	  */
	virtual UBOOL ForceReturnComponent(UPrimitiveComponent* TestPrimitive) { return FALSE; };

protected:
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:

	/**
	 * Flags all components as dirty if in the editor, and then calls UpdateComponents().
	 *
	 * @param	bCollisionUpdate	[opt] As per UpdateComponents; defaults to FALSE.
	 * @param	bTransformOnly		[opt] TRUE to update only the component transforms, FALSE to update the entire component.
	 */
	virtual void ConditionalForceUpdateComponents(UBOOL bCollisionUpdate = FALSE,UBOOL bTransformOnly = TRUE);

	/**
	 * Flags all components as dirty so that they will be guaranteed an update from
	 * AActor::Tick(), and also be conditionally reattached by AActor::ConditionalUpdateComponents().
	 * @param	bTransformOnly	- True if only the transform has changed.
	 */
	void MarkComponentsAsDirty(UBOOL bTransformOnly = TRUE);

	/**
	 * Works through the component arrays marking entries as pending kill so references to them
	 * will be NULL'ed.
	 *
	 * @param	bAllowComponentOverride		Whether to allow component to override marking the setting
	 */
	virtual void MarkComponentsAsPendingKill( UBOOL bAllowComponentOverride = FALSE );

	/**
	 * Called by the static lighting system, allows this actor to generate static lighting primitives.
	 * The individual component's GetStaticLightingInfo functions will not be called if this returns TRUE.
	 */
	virtual UBOOL GetActorStaticLightingInfo(TArray<FStaticLightingPrimitiveInfo>& PrimitiveInfos, const TArray<ULightComponent*>& InRelevantLights, const FLightingBuildOptions& Options)
	{
		return FALSE;
	}

	/** Called by the lighting system to allow actors to order their components for deterministic lighting */
	virtual void OrderComponentsForDeterministicLighting() {}

	virtual void InvalidateLightingCache();

	/** Called by the static lighting system after lighting has been built. */
	virtual void FinalizeStaticLighting() {};

	virtual UBOOL ActorLineCheck(FCheckResult& Result,const FVector& End,const FVector& Start,const FVector& Extent,DWORD TraceFlags);

	// Natives.
	DECLARE_FUNCTION(execPollSleep);
	DECLARE_FUNCTION(execPollFinishAnim);

	// Matinee
	void GetInterpFloatPropertyNames(TArray<FName> &outNames);
	void GetInterpVectorPropertyNames(TArray<FName> &outNames);
	void GetInterpColorPropertyNames(TArray<FName> &outNames);
	void GetInterpLinearColorPropertyNames(TArray<FName> &outNames);
	FLOAT* GetInterpFloatPropertyRef(FName inName, FPointer &outContainer);
	FVector* GetInterpVectorPropertyRef(FName inName);
	FColor* GetInterpColorPropertyRef(FName inName);
	FLinearColor* GetInterpLinearColorPropertyRef(FName inName);

	/**
	 *	Get the names of any boolean properties of this Actor which are marked as 'interp'.
	 *	Will also look in components of this Actor, and makes the name in the form 'componentname.propertyname'.
	 *
	 * @param	OutNames	The names of all the boolean properties marked as 'interp'.
	 */
	void GetInterpBoolPropertyNames( TArray<FName>& OutNames );

	/**
	 * Looks up the matching boolean property and returns a reference to the actual value.
	 *
	 * @param   InName  The name of boolean property to retrieve a reference.
	 * @return  A pointer to the actual value; NULL if the property was not found.
	 */
	BITFIELD* GetInterpBoolPropertyRef( FName InName, BITFIELD& Mask );

	/**
	 * Returns TRUE if this actor is contained by TestLevel.
	 * @todo seamless: update once Actor->Outer != Level
	 */
	UBOOL IsInLevel(const ULevel *TestLevel) const;
	/** Return the ULevel that this Actor is part of. */
	ULevel* GetLevel() const;

	/**
	 * Determine whether this actor is referenced by its level's GameSequence.
	 *
	 * @param	pReferencer		if specified, will be set to the SequenceObject that is referencing this actor.
	 *
	 * @return TRUE if this actor is referenced by kismet.
	 */
	UBOOL IsReferencedByKismet( class USequenceObject** pReferencer=NULL ) const;

	/**
	 *	Do anything needed to clear out cross level references; Called from ULevel::PreSave
	 */
	virtual void ClearCrossLevelReferences();

	/**
	 * Called when a level is loaded/unloaded, to get a list of all the crosslevel
	 * paths that need to be fixed up.
	 */
	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel) {}

	/** Returns ptr to GUID object for this actor.  Override in child classes that actually have a GUID */
	virtual FGuid* GetGuid() { return NULL; }

	/*
	 * Route finding notifications (sent to target)
	 */
	virtual class ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder) { return NULL; }
	virtual UBOOL AnchorNeedNotBeReachable();
	virtual void NotifyAnchorFindingResult(ANavigationPoint* EndAnchor, APawn* RouteFinder) {}
	virtual UBOOL ShouldHideActor(FVector const& CameraLocation) { return FALSE; }
	/** @return whether this Actor has exactly one attached colliding component (directly or indirectly)
	 *  and that component is its CollisionComponent
	 */
	UBOOL HasSingleCollidingComponent();
	/** Called each from while the Matinee action is running, to set the animation weights for the actor. */
	virtual void SetAnimWeights( const TArray<struct FAnimSlotInfo>& SlotInfos );
	/** called when this Actor was moved because its Base moved, but after that move the Actor was
	 * encroaching on its Base
	 * @param EncroachedBase - the Actor we encroached (Base will be temporarily NULL when this function is called)
	 * @param OverlapHit - result from the overlap check that determined this Actor was encroaching
	 * @return whether the encroachment was resolved (i.e, this Actor is no longer encroaching its base)
	 */
	virtual UBOOL ResolveAttachedMoveEncroachment(AActor* EncroachedBase, const FCheckResult& OverlapHit)
	{
	 	return FALSE;
	}

	virtual void OnEditorAnimEnd( UAnimNodeSequence* SeqNode, FLOAT PlayedTime, FLOAT ExcessTime ) {}

	virtual UBOOL Get_bDebug() { return bDebug; }

	/**
	 * Called when this actor is in a level which is being removed from the world (e.g. my level is getting UWorld::RemoveFromWorld called on it)
	 */
	virtual void OnRemoveFromWorld();

	/**
	 * allows actors to override path collision, but only during cover builds
	 * allows them to be ignored at path generation time but not ignored during cover build
	 */
	virtual UBOOL NeedsCollisionOverrideDuringCoverBuild() {return FALSE;}
};

struct FGeomSelection
{
    INT Type;
    INT Index;
    INT SelectionIndex;
    friend FArchive& operator<<(FArchive& Ar,FGeomSelection& MyGeomSelection)
    {
        return Ar << MyGeomSelection.Type << MyGeomSelection.Index << MyGeomSelection.SelectionIndex;
    }

    /** Constructors */
    FGeomSelection() {}
    FGeomSelection(EEventParm)
    {
        appMemzero(this, sizeof(FGeomSelection));
    }
};

class ABrush : public AActor
{
public:
    //## BEGIN PROPS Brush
    BYTE CsgOper;
    SCRIPT_ALIGN;
    FColor BrushColor;
    INT PolyFlags;
    BITFIELD bColored:1;
    BITFIELD bSolidWhenSelected:1;
    BITFIELD bPlaceableFromClassBrowser:1;
    class UModel* Brush;
    class UBrushComponent* BrushComponent;
    TArrayNoInit<struct FGeomSelection> SavedSelections;
    //## END PROPS Brush

    DECLARE_CLASS(ABrush,AActor,0,Engine)
	// UObject interface.
	virtual void PostLoad();

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	
	/** Called after using geom mode to edit thie brush's geometry */
	virtual void PostEditBrush() {}
	
	virtual UBOOL IsABrush() const {return TRUE;}

	/**
	 * Note that the object has been modified.  If we are currently recording into the 
	 * transaction buffer (undo/redo), save a copy of this object into the buffer and 
	 * marks the package as needing to be saved.
	 *
	 * @param	bAlwaysMarkDirty	if TRUE, marks the package dirty even if we aren't
	 *								currently recording an active undo/redo transaction
	 */
	virtual void Modify(UBOOL bAlwaysMarkDirty = FALSE);

	/**
	 * Serialize function
	 *
	 * @param Ar Archive to serialize with
	 */
	virtual void Serialize(FArchive& Ar);

	/**
	* Return whether this actor is a builder brush or not.
	*
	* @return TRUE if this actor is a builder brush, FALSE otherwise
	*/
	virtual UBOOL IsABuilderBrush() const;

	/**
	* Return whether this actor is the current builder brush or not
	*
	* @return TRUE if htis actor is the current builder brush, FALSE otherwise
	*/
	virtual UBOOL IsCurrentBuilderBrush() const;

	// ABrush interface.
	virtual void CopyPosRotScaleFrom( ABrush* Other );
	virtual void InitPosRotScale();

#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	/**
	* Figures out the best color to use for this brushes wireframe drawing.
	*/

	virtual FColor GetWireColor() const;
};

class ABrushShape : public ABrush
{
public:
    //## BEGIN PROPS BrushShape
    //## END PROPS BrushShape

    DECLARE_CLASS(ABrushShape,ABrush,0,Engine)
	virtual UBOOL IsABrushShape() const {return TRUE;}
};

struct Volume_eventProcessActorSetVolume_Parms
{
    class AActor* Other;
    Volume_eventProcessActorSetVolume_Parms(EEventParm)
    {
    }
};
class AVolume : public ABrush
{
public:
    //## BEGIN PROPS Volume
    class AActor* AssociatedActor;
    BITFIELD bForcePawnWalk:1;
    BITFIELD bProcessAllActors:1;
    BITFIELD bPawnsOnly:1;
    SCRIPT_ALIGN;
    //## END PROPS Volume

    DECLARE_FUNCTION(execEncompasses);
    DECLARE_FUNCTION(execEncompassesPoint);
    void eventProcessActorSetVolume(class AActor* Other)
    {
        Volume_eventProcessActorSetVolume_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ProcessActorSetVolume),&Parms);
    }
    DECLARE_CLASS(AVolume,ABrush,0|CLASS_NativeReplication,Engine)
	INT Encompasses(FVector point, FVector Extent=FVector(0.f));
	void SetVolumes();
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual UBOOL IsAVolume() const {return TRUE;}
	virtual AVolume* GetAVolume() { return this; }
	virtual INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void PostEditImport();

#if WITH_EDITOR
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
	virtual void CheckForErrors();
#endif
};

class ABlockingVolume : public AVolume
{
public:
    //## BEGIN PROPS BlockingVolume
    BITFIELD bBlockCamera:1;
    SCRIPT_ALIGN;
    //## END PROPS BlockingVolume

    DECLARE_CLASS(ABlockingVolume,AVolume,0,Engine)
	UBOOL IgnoreBlockingBy( const AActor *Other ) const;
};

class ADynamicBlockingVolume : public ABlockingVolume
{
public:
    //## BEGIN PROPS DynamicBlockingVolume
    BITFIELD bEnabled:1;
    SCRIPT_ALIGN;
    //## END PROPS DynamicBlockingVolume

    DECLARE_CLASS(ADynamicBlockingVolume,ABlockingVolume,0,Engine)
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	/**
	 * Force TRACE_LevelGeometry to still work with us even though bWorldGeometry is cleared
	 * bWorldGeometry is cleared so that actors can base properly on moving volumes
	 * 
	 * @param Primitive - the primitive to trace against
	 * 
	 * @param SourceActor - the actor doing the trace
	 * 
	 * @param TraceFlags - misc flags describing the trace
	 */
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);
};

struct FCullDistanceSizePair
{
    FLOAT Size;
    FLOAT CullDistance;

    /** Constructors */
    FCullDistanceSizePair() {}
    FCullDistanceSizePair(EEventParm)
    {
        appMemzero(this, sizeof(FCullDistanceSizePair));
    }
};

class ACullDistanceVolume : public AVolume
{
public:
    //## BEGIN PROPS CullDistanceVolume
    TArrayNoInit<struct FCullDistanceSizePair> CullDistances;
    BITFIELD bEnabled:1;
    SCRIPT_ALIGN;
    //## END PROPS CullDistanceVolume

    DECLARE_CLASS(ACullDistanceVolume,AVolume,0,Engine)
	/**
	 * Called after change has occured - used to force update of affected primitives.
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 * bFinished is FALSE while the actor is being continually moved, and becomes TRUE on the last call.
	 * This can be used to defer computationally intensive calculations to the final PostEditMove call of
	 * eg a drag operation.
	 */
	virtual void PostEditMove(UBOOL bFinished);

	/**
	 * Returns whether the passed in primitive can be affected by cull distance volumes.
	 *
	 * @param	PrimitiveComponent	Component to test
	 * @return	TRUE if tested component can be affected, FALSE otherwise
	 */
	static UBOOL CanBeAffectedByVolumes( UPrimitiveComponent* PrimitiveComponent );

	/**
	 * Get the set of primitives and new max draw distances defined by this volume.
	 */
	void GetPrimitiveMaxDrawDistances(TMap<UPrimitiveComponent*,FLOAT>& OutCullDistances);
};

struct FLevelGridCellCoordinate
{
    INT X;
    INT Y;
    INT Z;

		/** Constructor */
		FLevelGridCellCoordinate()
			: X( 0 ), Y( 0 ), Z( 0 )
		{
		}

		/** Equality operator */
		UBOOL operator==( const FLevelGridCellCoordinate& RHS ) const
		{
			return ( RHS.X == X && RHS.Y == Y && RHS.Z == Z );
		}
	
};

class ALevelGridVolume : public AVolume
{
public:
    //## BEGIN PROPS LevelGridVolume
    FStringNoInit LevelGridVolumeName;
    BYTE CellShape;
    INT Subdivisions[3];
    FLOAT LoadingDistance;
    FLOAT KeepLoadedRange;
    FKConvexElem CellConvexElem;
    //## END PROPS LevelGridVolume

    DECLARE_CLASS(ALevelGridVolume,AVolume,0,Engine)
	/**
	 * Gets the "friendly" name of this grid volume
	 *
	 * @return	The name of this grid volume
	 */
	FString GetLevelGridVolumeName() const;


	/**
	 * UObject: Performs operations after the object is loaded
	 */
	virtual void PostLoad();


	/**
	 * UObject: Called when a property value has been changed in the editor.
	 *
	 * @param	PropertyThatChanged		The property that changed, or NULL
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);


	/**
	 * Computes the world space bounds of the entire grid
	 *
	 * @return	Bounds of the grid in world space
	 */
	FBox GetGridBounds() const;


	/**
	 * Computes the size of a grid subdivision (not necessarily the same as a grid cell's bounds!)
	 *
	 * @return	Size of a grid subdivision
	 */
	FVector GetGridCellSubdivisionSize() const;


	/**
	 * Computes the size of a single grid cell
	 *
	 * @return	Size of the cell
	 */
	FVector GetGridCellSize() const;



	/**
	 * Computes the world space bounds of a single grid cell
	 *
	 * @param	InCoords	Coordinate of cell to compute bounds for
	 *
	 * @return	Bounds of the cell in world space
	 */
	FBox GetGridCellBounds( const FLevelGridCellCoordinate& InCoords ) const;


	/**
	 * Updates the convex volume that represents the shape of a single cell within this volume.
	 * Important: The convex volume is centered about the origin and not relative to any volume or cell!
	 */
	void UpdateConvexCellVolume();


	/**
	 * Computes the center point of a grid cell
	 *
	 * @param	InCoords	Coordinate of cell to compute bounds for
	 *
	 * @return	Center point of the cell in world space
	 */
	FVector GetGridCellCenterPoint( const FLevelGridCellCoordinate& InCoords ) const;


	/**
	 * Computes the 2D shape of a hex cell for this volume
	 *
	 * @param	OutHexPoints	Array that will be filled in with the 6 hexagonal points
	 */
	void ComputeHexCellShape( FVector2D* OutHexPoints ) const;


	/**
	 * Gets all levels associated with this level grid volume (not including the P level)
	 *
	 * @param	OutLevels	List of levels (out)
	 */
	void GetLevelsForAllCells( TArray< class ULevelStreaming* >& OutLevels ) const;


	/**
	 * Finds the level for the specified cell coordinates
	 *
	 * @param	InCoords	Grid cell coordinates
	 *
	 * @return	Level streaming record for level at the specified coordinates, or NULL if not found
	 */
	class ULevelStreaming* FindLevelForGridCell( const FLevelGridCellCoordinate& InCoords ) const;


	/**
	 * Returns true if the specified actor belongs in this grid network
	 *
	 * @param	InActor		The actor to check
	 *
	 * @return	True if the actor belongs in this grid network
	 */
	UBOOL IsActorMemberOfGrid( AActor* InActor ) const;


	/**
	 * Returns true if the specified cell is 'usable'.  That is, the bounds of the cell overlaps the actual
	 * level grid volume's brush
	 *
	 * @return	True if the specified cell is 'usable'
	 */
	UBOOL IsGridCellUsable( const FLevelGridCellCoordinate& InCellCoord ) const;


	/**
	 * Computes the grid cell that a box should be associated with based on the cell that it most
	 * overlaps.  If the box doesn't overlap any cells but bMustOverlap is false, then the function
	 * will choose the cell that's closest to the box.
	 *
	 * @param	InBox			The box to test
	 * @param	bMustOverlap	True if the box must overlap a cell for the function to succeed
	 * @param	OutBestCell		(Out) The best cell for the box
	 *
	 * @return	True if a cell was found for the box.  If bMustOverlap is false, the function will always return true.
	 */
	UBOOL FindBestGridCellForBox( const FBox& InBox, const UBOOL bMustOverlap, FLevelGridCellCoordinate& OutBestCell ) const;


	/**
	 * Checks to see if an AABB overlaps the specified grid cell
	 *
	 * @param	InCellCoord		The grid cell coordinate to test against
	 * @param	InBox			The world space AABB to test
	 *
	 * @return	True if the box overlaps the grid cell
	 */
	UBOOL TestWhetherCellOverlapsBox( const FLevelGridCellCoordinate& InCellCoord, const FBox& InBox ) const;


	/**
	 * Computes the minimum distance between the specified point and grid cell in world space
	 *
	 * @param	InCellCoord		The grid cell coordinate to test against
	 * @param	InPoint			The world space location to test
	 *
	 * @return	Squared distance to the cell
	 */
	FLOAT ComputeSquaredDistanceToCell( const FLevelGridCellCoordinate& InCellCoord, const FVector& InPoint ) const;


	/**
	 * Determines whether or not the level associated with the specified grid cell should be loaded based on
	 * distance to the viewer's position
	 *
	 * @param	InCellCoord			The grid cell coordinate associated with the level we're testing
	 * @param	InViewLocation		The viewer's location
	 * @param	bIsAlreadyLoaded	Pass true if the associated level is already loaded, otherwise false.  This is used to determine whether we should keep an already-loaded level in memory based on a configured distance threshold.
	 *
	 * @return	True if level should be loaded (or for already-loaded levels, should stay loaded)
	 */
	UBOOL ShouldLevelBeLoaded( const FLevelGridCellCoordinate& InCellCoord, const FVector& InViewLocation, const UBOOL bIsAlreadyLoaded ) const;


	/**
	 * AActor: Checks this actor for errors.  Called during the map check phase in the editor.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class ALevelStreamingVolume : public AVolume
{
public:
    //## BEGIN PROPS LevelStreamingVolume
    TArrayNoInit<class ULevelStreaming*> StreamingLevels;
    BITFIELD bEditorPreVisOnly:1;
    BITFIELD bDisabled:1;
    BITFIELD bTestDistanceToVolume:1;
    SCRIPT_ALIGN;
    BYTE StreamingUsage;
    BYTE Usage_DEPRECATED;
    FLOAT TestVolumeDistance;
    //## END PROPS LevelStreamingVolume

    DECLARE_CLASS(ALevelStreamingVolume,AVolume,0,Engine)
	// UObject interace.
	/**
	 * Serialize function.
	 *
	 * @param	Ar	Archive to serialize with.
	 */
	void Serialize( FArchive& Ar );

	/**
	 * Performs operations after the object is loaded. 
	 * Used for fixing up deprecated fields. 
	 */
	virtual void PostLoad();

	// AActor interface.
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class ALightmassCharacterIndirectDetailVolume : public AVolume
{
public:
    //## BEGIN PROPS LightmassCharacterIndirectDetailVolume
    //## END PROPS LightmassCharacterIndirectDetailVolume

    DECLARE_CLASS(ALightmassCharacterIndirectDetailVolume,AVolume,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ALightmassCharacterIndirectDetailVolume)
};

class ALightmassImportanceVolume : public AVolume
{
public:
    //## BEGIN PROPS LightmassImportanceVolume
    //## END PROPS LightmassImportanceVolume

    DECLARE_CLASS(ALightmassImportanceVolume,AVolume,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ALightmassImportanceVolume)
};

class AMassiveLODOverrideVolume : public AVolume
{
public:
    //## BEGIN PROPS MassiveLODOverrideVolume
    //## END PROPS MassiveLODOverrideVolume

    DECLARE_CLASS(AMassiveLODOverrideVolume,AVolume,0,Engine)
	/**
	 * Removes the volume from world info's list of volumes.
	 */
	virtual void ClearComponents();

protected:
	/**
	 * Adds the volume to world info's list of volumes.
	 */
	virtual void UpdateComponentsInternal( UBOOL bCollisionUpdate = FALSE );
public:
};

class APathBlockingVolume : public AVolume
{
public:
    //## BEGIN PROPS PathBlockingVolume
    //## END PROPS PathBlockingVolume

    DECLARE_CLASS(APathBlockingVolume,AVolume,0,Engine)
#if WITH_EDITOR
	virtual void SetCollisionForPathBuilding(UBOOL bNowPathBuilding);
#endif
};

struct PhysicsVolume_eventPawnLeavingVolume_Parms
{
    class APawn* Other;
    PhysicsVolume_eventPawnLeavingVolume_Parms(EEventParm)
    {
    }
};
struct PhysicsVolume_eventPawnEnteredVolume_Parms
{
    class APawn* Other;
    PhysicsVolume_eventPawnEnteredVolume_Parms(EEventParm)
    {
    }
};
struct PhysicsVolume_eventActorLeavingVolume_Parms
{
    class AActor* Other;
    PhysicsVolume_eventActorLeavingVolume_Parms(EEventParm)
    {
    }
};
struct PhysicsVolume_eventActorEnteredVolume_Parms
{
    class AActor* Other;
    PhysicsVolume_eventActorEnteredVolume_Parms(EEventParm)
    {
    }
};
struct PhysicsVolume_eventPhysicsChangedFor_Parms
{
    class AActor* Other;
    PhysicsVolume_eventPhysicsChangedFor_Parms(EEventParm)
    {
    }
};
class APhysicsVolume : public AVolume
{
public:
    //## BEGIN PROPS PhysicsVolume
    FVector ZoneVelocity;
    BITFIELD bVelocityAffectsWalking:1;
    BITFIELD bPainCausing:1;
    BITFIELD bAIShouldIgnorePain:1;
    BITFIELD bEntryPain:1;
    BITFIELD BACKUP_bPainCausing:1;
    BITFIELD bDestructive:1;
    BITFIELD bNoInventory:1;
    BITFIELD bMoveProjectiles:1;
    BITFIELD bBounceVelocity:1;
    BITFIELD bNeutralZone:1;
    BITFIELD bCrowdAgentsPlayDeathAnim:1;
    BITFIELD bPhysicsOnContact:1;
    BITFIELD bWaterVolume:1;
    FLOAT GroundFriction;
    FLOAT TerminalVelocity;
    FLOAT DamagePerSec;
    class UClass* DamageType;
    INT Priority;
    FLOAT FluidFriction;
    FLOAT PainInterval;
    FLOAT RigidBodyDamping;
    FLOAT MaxDampingForce;
    class AInfo* PainTimer;
    class AController* DamageInstigator;
    class APhysicsVolume* NextPhysicsVolume;
    //## END PROPS PhysicsVolume

    virtual FLOAT GetGravityZ();
    virtual FVector GetZoneVelocityForActor(class AActor* TheActor);
    DECLARE_FUNCTION(execGetZoneVelocityForActor)
    {
        P_GET_OBJECT(AActor,TheActor);
        P_FINISH;
        *(FVector*)Result=this->GetZoneVelocityForActor(TheActor);
    }
    void eventPawnLeavingVolume(class APawn* Other)
    {
        PhysicsVolume_eventPawnLeavingVolume_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PawnLeavingVolume),&Parms);
    }
    void eventPawnEnteredVolume(class APawn* Other)
    {
        PhysicsVolume_eventPawnEnteredVolume_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PawnEnteredVolume),&Parms);
    }
    void eventActorLeavingVolume(class AActor* Other)
    {
        PhysicsVolume_eventActorLeavingVolume_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ActorLeavingVolume),&Parms);
    }
    void eventActorEnteredVolume(class AActor* Other)
    {
        PhysicsVolume_eventActorEnteredVolume_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ActorEnteredVolume),&Parms);
    }
    void eventPhysicsChangedFor(class AActor* Other)
    {
        PhysicsVolume_eventPhysicsChangedFor_Parms Parms(EC_EventParm);
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PhysicsChangedFor),&Parms);
    }
    DECLARE_CLASS(APhysicsVolume,AVolume,0|CLASS_NativeReplication,Engine)
	virtual void Spawned();

	virtual void PostLoad();

	virtual void BeginDestroy();

	virtual void Serialize(FArchive& Ar);

	void Register();

	void Unregister();

	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	void SetZone( UBOOL bTest, UBOOL bForceRefresh );
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual UBOOL WillHurt(APawn *P);
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	virtual FLOAT GetVolumeRBGravityZ() { return GetGravityZ(); }
};

class ADefaultPhysicsVolume : public APhysicsVolume
{
public:
    //## BEGIN PROPS DefaultPhysicsVolume
    //## END PROPS DefaultPhysicsVolume

    DECLARE_CLASS(ADefaultPhysicsVolume,APhysicsVolume,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(ADefaultPhysicsVolume)
};

class AGravityVolume : public APhysicsVolume
{
public:
    //## BEGIN PROPS GravityVolume
    FLOAT GravityZ;
    //## END PROPS GravityVolume

    DECLARE_CLASS(AGravityVolume,APhysicsVolume,0,Engine)
	virtual FLOAT GetGravityZ() { return GravityZ; }
};

class ALadderVolume : public APhysicsVolume
{
public:
    //## BEGIN PROPS LadderVolume
    FRotator WallDir;
    FVector LookDir;
    FVector ClimbDir;
    class ALadder* LadderList;
    BITFIELD bNoPhysicalLadder:1;
    BITFIELD bAutoPath:1;
    BITFIELD bAllowLadderStrafing:1;
    class APawn* PendingClimber;
    class UArrowComponent* WallDirArrow;
    //## END PROPS LadderVolume

    DECLARE_CLASS(ALadderVolume,APhysicsVolume,0,Engine)
	// Editor modification
#if WITH_EDITOR
	FVector FindTop(FVector V);
	FVector FindCenter();
	virtual INT AddMyMarker(AActor *S);
#endif
	virtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent);
};

class APortalVolume : public AVolume
{
public:
    //## BEGIN PROPS PortalVolume
    TArrayNoInit<class APortalTeleporter*> Portals;
    //## END PROPS PortalVolume

    DECLARE_CLASS(APortalVolume,AVolume,0,Engine)
	/**
	 * Removes the portal volume to world info's list of portal volumes.
	 */
	virtual void ClearComponents( void );

protected:
	/**
	 * Adds the portal volume to world info's list of portal volumes.
	 */
	virtual void UpdateComponentsInternal( UBOOL bCollisionUpdate = FALSE );
public:
};

class UPostProcessEffect : public UObject
{
public:
    //## BEGIN PROPS PostProcessEffect
    BITFIELD bShowInEditor:1;
    BITFIELD bShowInGame:1;
    BITFIELD bUseWorldSettings:1;
    BITFIELD bAffectsLightingOnly:1;
    FName EffectName;
    INT NodePosY;
    INT NodePosX;
    INT DrawWidth;
    INT DrawHeight;
    INT OutDrawY;
    INT InDrawY;
    BYTE SceneDPG;
    SCRIPT_ALIGN;
    //## END PROPS PostProcessEffect

    DECLARE_CLASS(UPostProcessEffect,UObject,0,Engine)
	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 *			Will be NULL if the view didn't provide them, or the effect has bUseWorldSettings=False.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings) 
	{ 
		return NULL; 
	}

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;

	/**
	* @return TRUE if the effect requires the uber post process
	*/
	virtual UBOOL RequiresUberpostprocess() const 
	{ 
		return FALSE; 
	}

	/**
	* Tells the SceneRenderer is this effect includes the uber post process.
	*/
	virtual UBOOL IncludesUberpostprocess() const
	{
		return FALSE;
	}

	/**
	* This allows to print a warning when the effect is used.
	*/
	virtual void OnPostProcessWarning(FString& OutWarning) const
	{
	}
};

class UDOFEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS DOFEffect
    FLOAT FalloffExponent;
    FLOAT BlurKernelSize;
    FLOAT MaxNearBlurAmount;
    FLOAT MinBlurAmount;
    FLOAT MaxFarBlurAmount;
    BYTE FocusType;
    FLOAT FocusInnerRadius;
    FLOAT FocusDistance;
    FVector FocusPosition;
    //## END PROPS DOFEffect

    DECLARE_ABSTRACT_CLASS(UDOFEffect,UPostProcessEffect,0,Engine)
	// UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;

	// UObject inteface

	/** callback for changed property */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

struct FLUTBlender
{
    TArrayNoInit<class UTexture*> LUTTextures;
    TArrayNoInit<FLOAT> LUTWeights;
    BITFIELD bHasChanged:1;
    SCRIPT_ALIGN;

		/** constructor, by default not even the Neutral element is defined */
		FLUTBlender();

		UBOOL IsLUTEmpty() const;

		/** new = lerp(old, Rhs, Weight) (main thread only)
		*
		* @param Texture 0 is a valid entry and is used for neutral
		* @param Weight 0..1
		*/
		void LerpTo(UTexture* Texture, float Weight);

		/** resolve to one LUT (render thread only)*/
		const FTextureRHIRef ResolveLUT(class FViewInfo& View, const struct ColorTransformMaterialProperties& ColorTransform);

		/** Is updated every frame if GColorGrading is set to debug mode, empty if not */
		static UBOOL GetDebugInfo(FString& Out);

		void CopyToRenderThread(FLUTBlender& Dest) const;

		/**
		 * Check if the parameters are different, compared to the previous LUT Blender parameters.
		 */
		void CheckForChanges( const FLUTBlender& PreviousLUTBlender );

		/**
		 * Whether this LUTBlender contains new parameters and should regenerate the LUT Texture.
		 */
		UBOOL HasChanged() const
		{
			return bHasChanged;
		}

		/**
		* Clean the container and adds the neutral LUT. 
		* should be called after the render thread copied the data
		*/
		void Reset();

	private:

		/**
		*
		* @param Texture 0 is used for the neutral LUT
		*/
		void SetLUT(UTexture *Texture);

		/** 
		* add a LUT to the ones that are blended together 
		*
		* @param Texture can be 0 then the call is ignored
		* @param Weight 0..1
		*/
		void PushLUT(UTexture* Texture, float Weight);

		/** @return 0xffffffff if not found */
		UINT FindIndex(UTexture* Tex) const;

		/** @return count */
		UINT GenerateFinalTable(FTexture* OutTextures[], float OutWeights[], UINT MaxCount) const;
	
};

struct FMobileColorGradingParams
{
    FLOAT TransitionTime;
    FLOAT Blend;
    FLOAT Desaturation;
    FLinearColor HighLights;
    FLinearColor MidTones;
    FLinearColor Shadows;

    /** Constructors */
    FMobileColorGradingParams() {}
    FMobileColorGradingParams(EEventParm)
    {
        appMemzero(this, sizeof(FMobileColorGradingParams));
    }
};

struct FMobilePostProcessSettings
{
    BITFIELD bOverride_Mobile_BlurAmount:1;
    BITFIELD bOverride_Mobile_TransitionTime:1;
    BITFIELD bOverride_Mobile_Bloom_Scale:1;
    BITFIELD bOverride_Mobile_Bloom_Threshold:1;
    BITFIELD bOverride_Mobile_Bloom_Tint:1;
    BITFIELD bOverride_Mobile_DOF_Distance:1;
    BITFIELD bOverride_Mobile_DOF_MinRange:1;
    BITFIELD bOverride_Mobile_DOF_MaxRange:1;
    BITFIELD bOverride_Mobile_DOF_FarBlurFactor:1;
    FLOAT Mobile_BlurAmount;
    FLOAT Mobile_TransitionTime;
    FLOAT Mobile_Bloom_Scale;
    FLOAT Mobile_Bloom_Threshold;
    FLinearColor Mobile_Bloom_Tint;
    FLOAT Mobile_DOF_Distance;
    FLOAT Mobile_DOF_MinRange;
    FLOAT Mobile_DOF_MaxRange;
    FLOAT Mobile_DOF_FarBlurFactor;

		/* default constructor, for script, values are overwritten by serialization after that */
		FMobilePostProcessSettings()
		{}

		/* second constructor, supposed to be used by C++ */
		FMobilePostProcessSettings(INT A)
		{
			bOverride_Mobile_BlurAmount = FALSE;
			bOverride_Mobile_TransitionTime = FALSE;
			bOverride_Mobile_Bloom_Scale = FALSE;
			bOverride_Mobile_Bloom_Threshold = FALSE;
			bOverride_Mobile_Bloom_Tint = FALSE;
			bOverride_Mobile_DOF_Distance = FALSE;
			bOverride_Mobile_DOF_MinRange = FALSE;
			bOverride_Mobile_DOF_MaxRange = FALSE;
			bOverride_Mobile_DOF_FarBlurFactor = FALSE;

			Mobile_BlurAmount = 16.0f;
			Mobile_TransitionTime = 1.0f;
			Mobile_Bloom_Scale = 0.5f;
			Mobile_Bloom_Threshold = 0.75f;
			Mobile_Bloom_Tint = FLinearColor::White;
			Mobile_DOF_Distance = 1500.0f;
			Mobile_DOF_MinRange = 600.0f;
			Mobile_DOF_MaxRange = 1200.0f;
			Mobile_DOF_FarBlurFactor = 1.0f;
		}
	
};

struct FPostProcessSettings
{
    BITFIELD bOverride_EnableBloom:1;
    BITFIELD bOverride_EnableDOF:1;
    BITFIELD bOverride_EnableMotionBlur:1;
    BITFIELD bOverride_EnableSceneEffect:1;
    BITFIELD bOverride_AllowAmbientOcclusion:1;
    BITFIELD bOverride_OverrideRimShaderColor:1;
    BITFIELD bOverride_Bloom_Scale:1;
    BITFIELD bOverride_Bloom_Threshold:1;
    BITFIELD bOverride_Bloom_Tint:1;
    BITFIELD bOverride_Bloom_ScreenBlendThreshold:1;
    BITFIELD bOverride_Bloom_InterpolationDuration:1;
    BITFIELD bOverride_DOF_FalloffExponent:1;
    BITFIELD bOverride_DOF_BlurKernelSize:1;
    BITFIELD bOverride_DOF_BlurBloomKernelSize:1;
    BITFIELD bOverride_DOF_MaxNearBlurAmount:1;
    BITFIELD bOverride_DOF_MinBlurAmount:1;
    BITFIELD bOverride_DOF_MaxFarBlurAmount:1;
    BITFIELD bOverride_DOF_FocusType:1;
    BITFIELD bOverride_DOF_FocusInnerRadius:1;
    BITFIELD bOverride_DOF_FocusDistance:1;
    BITFIELD bOverride_DOF_FocusPosition:1;
    BITFIELD bOverride_DOF_InterpolationDuration:1;
    BITFIELD bOverride_DOF_BokehTexture:1;
    BITFIELD bOverride_MotionBlur_MaxVelocity:1;
    BITFIELD bOverride_MotionBlur_Amount:1;
    BITFIELD bOverride_MotionBlur_FullMotionBlur:1;
    BITFIELD bOverride_MotionBlur_CameraRotationThreshold:1;
    BITFIELD bOverride_MotionBlur_CameraTranslationThreshold:1;
    BITFIELD bOverride_MotionBlur_InterpolationDuration:1;
    BITFIELD bOverride_Scene_Desaturation:1;
    BITFIELD bOverride_Scene_Colorize:1;
    BITFIELD bOverride_Scene_TonemapperScale:1;
    BITFIELD bOverride_Scene_ImageGrainScale:1;
    BITFIELD bOverride_Scene_HighLights:1;
    BITFIELD bOverride_Scene_MidTones:1;
    BITFIELD bOverride_Scene_Shadows:1;
    BITFIELD bOverride_Scene_InterpolationDuration:1;
    BITFIELD bOverride_Scene_ColorGradingLUT:1;
    BITFIELD bOverride_RimShader_Color:1;
    BITFIELD bOverride_RimShader_InterpolationDuration:1;
    BITFIELD bOverride_MobileColorGrading:1;
    BITFIELD bEnableBloom:1;
    BITFIELD bEnableDOF:1;
    BITFIELD bEnableMotionBlur:1;
    BITFIELD bEnableSceneEffect:1;
    BITFIELD bAllowAmbientOcclusion:1;
    BITFIELD bOverrideRimShaderColor:1;
    FLOAT Bloom_Scale;
    FLOAT Bloom_Threshold;
    FColor Bloom_Tint;
    FLOAT Bloom_ScreenBlendThreshold;
    FLOAT Bloom_InterpolationDuration;
    FLOAT DOF_BlurBloomKernelSize;
    FLOAT DOF_FalloffExponent;
    FLOAT DOF_BlurKernelSize;
    FLOAT DOF_MaxNearBlurAmount;
    FLOAT DOF_MinBlurAmount;
    FLOAT DOF_MaxFarBlurAmount;
    BYTE DOF_FocusType;
    FLOAT DOF_FocusInnerRadius;
    FLOAT DOF_FocusDistance;
    FVector DOF_FocusPosition;
    FLOAT DOF_InterpolationDuration;
    class UTexture2D* DOF_BokehTexture;
    FLOAT MotionBlur_MaxVelocity;
    FLOAT MotionBlur_Amount;
    BITFIELD MotionBlur_FullMotionBlur:1;
    FLOAT MotionBlur_CameraRotationThreshold;
    FLOAT MotionBlur_CameraTranslationThreshold;
    FLOAT MotionBlur_InterpolationDuration;
    FLOAT Scene_Desaturation;
    FVector Scene_Colorize;
    FLOAT Scene_TonemapperScale;
    FLOAT Scene_ImageGrainScale;
    FVector Scene_HighLights;
    FVector Scene_MidTones;
    FVector Scene_Shadows;
    FLOAT Scene_InterpolationDuration;
    FLinearColor RimShader_Color;
    FLOAT RimShader_InterpolationDuration;
    class UTexture* ColorGrading_LookupTable;
    struct FLUTBlender ColorGradingLUT;
    struct FMobileColorGradingParams MobileColorGrading;
    struct FMobilePostProcessSettings MobilePostProcess;

		/* default constructor, for script, values are overwritten by serialization after that */
		FPostProcessSettings()
		{}

		/* second constructor, supposed to be used by C++ */
		FPostProcessSettings(INT A)
		:	MobilePostProcess(A)
		{
			bOverride_EnableBloom = TRUE;
			bOverride_EnableDOF = TRUE;
			bOverride_EnableMotionBlur = TRUE;
			bOverride_EnableSceneEffect = TRUE;
			bOverride_AllowAmbientOcclusion = TRUE;
			bOverride_OverrideRimShaderColor = TRUE;

			bOverride_Bloom_Scale = TRUE;
			bOverride_Bloom_Threshold = TRUE;
			bOverride_Bloom_Tint = TRUE;
			bOverride_Bloom_ScreenBlendThreshold = TRUE;
			bOverride_Bloom_InterpolationDuration = TRUE;

			bOverride_DOF_FalloffExponent = TRUE;
			bOverride_DOF_BlurKernelSize = TRUE;
			bOverride_DOF_BlurBloomKernelSize = TRUE;
			bOverride_DOF_MaxNearBlurAmount = TRUE;
			bOverride_DOF_MinBlurAmount = FALSE;
			bOverride_DOF_MaxFarBlurAmount = TRUE;
			bOverride_DOF_FocusType = TRUE;
			bOverride_DOF_FocusInnerRadius = TRUE;
			bOverride_DOF_FocusDistance = TRUE;
			bOverride_DOF_FocusPosition = TRUE;
			bOverride_DOF_InterpolationDuration = TRUE;
			bOverride_DOF_BokehTexture = FALSE;

			bOverride_MotionBlur_MaxVelocity = FALSE;
			bOverride_MotionBlur_Amount = FALSE;
			bOverride_MotionBlur_FullMotionBlur = FALSE;
			bOverride_MotionBlur_CameraRotationThreshold = FALSE;
			bOverride_MotionBlur_CameraTranslationThreshold = FALSE;
			bOverride_MotionBlur_InterpolationDuration = FALSE;
			bOverride_Scene_Desaturation = TRUE;
			bOverride_Scene_Colorize = FALSE;
			bOverride_Scene_TonemapperScale = FALSE;
			bOverride_Scene_ImageGrainScale = FALSE;
			bOverride_Scene_HighLights = TRUE;
			bOverride_Scene_MidTones = TRUE;
			bOverride_Scene_Shadows = TRUE;
			bOverride_Scene_InterpolationDuration = TRUE;
			bOverride_Scene_ColorGradingLUT = FALSE;
			bOverride_RimShader_Color = TRUE;
			bOverride_RimShader_InterpolationDuration = TRUE;
			bOverride_MobileColorGrading = FALSE;

			bEnableBloom=TRUE;
			bEnableDOF=FALSE;
			bEnableMotionBlur=TRUE;
			bEnableSceneEffect=TRUE;
			bAllowAmbientOcclusion=TRUE;
			bOverrideRimShaderColor=FALSE;

			Bloom_Scale=1;
			Bloom_Threshold=1;
			Bloom_Tint=FColor(255,255,255);
			Bloom_ScreenBlendThreshold=10;
			Bloom_InterpolationDuration=1;

			DOF_FalloffExponent=4;
			DOF_BlurKernelSize=16;
			DOF_BlurBloomKernelSize=16;
			DOF_MaxNearBlurAmount=1;
			DOF_MinBlurAmount=0;
			DOF_MaxFarBlurAmount=1;
			DOF_FocusType=FOCUS_Distance;
			DOF_FocusInnerRadius=2000;
			DOF_FocusDistance=0;
			DOF_InterpolationDuration=1;

			MotionBlur_MaxVelocity=1.0f;
			MotionBlur_Amount=0.5f;
			MotionBlur_FullMotionBlur=TRUE;
			MotionBlur_CameraRotationThreshold=90.0f;
			MotionBlur_CameraTranslationThreshold=10000.0f;
			MotionBlur_InterpolationDuration=1;

			Scene_Desaturation=0;
			Scene_Colorize=FVector(1,1,1);
			Scene_TonemapperScale=1.0f;
			Scene_ImageGrainScale=0.0f;
			Scene_HighLights=FVector(1,1,1);
			Scene_MidTones=FVector(1,1,1);
			Scene_Shadows=FVector(0,0,0);
			Scene_InterpolationDuration=1;

			RimShader_Color=FLinearColor(0.470440f,0.585973f,0.827726f,1.0f);
			RimShader_InterpolationDuration=1;
		}

		/**
		 * Blends the settings on this structure marked as override setting onto the given settings
		 *
		 * @param	ToOverride	The settings that get overridden by the overridable settings on this structure. 
		 * @param	Alpha		The opacity of these settings. If Alpha is 1, ToOverride will equal this setting structure.
		 */
		void OverrideSettingsFor( FPostProcessSettings& ToOverride, FLOAT Alpha=1.f ) const;

		/**
		 * Enables the override setting for the given post-process setting.
		 *
		 * @param	PropertyName	The post-process property name to enable.
		 */
		void EnableOverrideSetting( const FName& PropertyName );

		/**
		 * Checks the override setting for the given post-process setting.
		 *
		 * @param	PropertyName	The post-process property name to enable.
		 */
		UBOOL IsOverrideSetting( const FName& PropertyName );

		/**
		 * Disables the override setting for the given post-process setting.
		 *
		 * @param	PropertyName	The post-process property name to enable.
		 */
		void DisableOverrideSetting( const FName& PropertyName );

		/**
		 * Sets all override values to false, which prevents overriding of this struct.
		 *
		 * @note	Overrides can be enabled again. 
		 */
		void DisableAllOverrides();

		/**
		 * Enables bloom for the post process settings.
		 */
		FORCEINLINE void EnableBloom()
		{
			bOverride_EnableBloom = TRUE;
			bEnableBloom = TRUE;
		}

		/**
		 * Enables DOF for the post process settings.
		 */
		FORCEINLINE void EnableDOF()
		{
			bOverride_EnableDOF = TRUE;
			bEnableDOF = TRUE;
		}

		/**
		 * Enables motion blur for the post process settings.
		 */
		FORCEINLINE void EnableMotionBlur()
		{
			bOverride_EnableMotionBlur = TRUE;
			bEnableMotionBlur = TRUE;
		}

		/**
		 * Enables scene effects for the post process settings.
		 */
		FORCEINLINE void EnableSceneEffect()
		{
			bOverride_EnableSceneEffect = TRUE;
			bEnableSceneEffect = TRUE;
		}

		/**
		 * Enables rim shader color for the post process settings.
		 */
		FORCEINLINE void EnableRimShader()
		{
			bOverride_OverrideRimShaderColor = TRUE;
			bOverrideRimShaderColor = TRUE;
		}

		/**
		 * Disables the override to enable bloom if no overrides are set for bloom settings.
		 */
		void DisableBloomOverrideConditional();

		/**
		 * Disables the override to enable DOF if no overrides are set for DOF settings.
		 */
		void DisableDOFOverrideConditional();

		/**
		 * Disables the override to enable motion blur if no overrides are set for motion blur settings.
		 */
		void DisableMotionBlurOverrideConditional();

		/**
		 * Disables the override to enable scene effect if no overrides are set for scene effect settings.
		 */
		void DisableSceneEffectOverrideConditional();

		/**
		 * Disables the override to enable rim shader if no overrides are set for rim shader settings.
		 */
		void DisableRimShaderOverrideConditional();

		/**
		 * Disables the override to enable mobile bloom if no bloom overrides are set.
		 */
		void DisableMobileBloomOverrideConditional();

		/**
		 * Disables the override to enable mobile DOF if no DOF overrides are set.
		 */
		void DisableMobileDOFOverrideConditional();
	
};

class APostProcessVolume : public AVolume
{
public:
    //## BEGIN PROPS PostProcessVolume
    FLOAT Priority;
    BITFIELD bOverrideWorldPostProcessChain:1;
    BITFIELD bEnabled:1;
    SCRIPT_ALIGN;
    struct FPostProcessSettings Settings;
    class APostProcessVolume* NextLowerPriorityVolume;
    //## END PROPS PostProcessVolume

    DECLARE_CLASS(APostProcessVolume,AVolume,0,Engine)
	/**
	 * Routes ClearComponents call to Super and removes volume from linked list in world info.
	 */
	virtual void ClearComponents();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();
protected:
	/**
	 * Routes UpdateComponents call to Super and adds volume to linked list in world info.
	 */
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:
};

class APrecomputedVisibilityOverrideVolume : public AVolume
{
public:
    //## BEGIN PROPS PrecomputedVisibilityOverrideVolume
    TArrayNoInit<class AActor*> OverrideVisibleActors;
    TArrayNoInit<class AActor*> OverrideInvisibleActors;
    //## END PROPS PrecomputedVisibilityOverrideVolume

    DECLARE_CLASS(APrecomputedVisibilityOverrideVolume,AVolume,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(APrecomputedVisibilityOverrideVolume)
};

class APrecomputedVisibilityVolume : public AVolume
{
public:
    //## BEGIN PROPS PrecomputedVisibilityVolume
    //## END PROPS PrecomputedVisibilityVolume

    DECLARE_CLASS(APrecomputedVisibilityVolume,AVolume,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(APrecomputedVisibilityVolume)
};

struct FReverbSettings
{
    BITFIELD bApplyReverb:1;
    SCRIPT_ALIGN;
    BYTE ReverbType;
    FLOAT Volume;
    FLOAT FadeTime;

    /** Constructors */
    FReverbSettings() {}
    FReverbSettings(EEventParm)
    {
        appMemzero(this, sizeof(FReverbSettings));
    }
};

class AReverbVolume : public AVolume
{
public:
    //## BEGIN PROPS ReverbVolume
    FLOAT Priority;
    BITFIELD bEnabled:1;
    SCRIPT_ALIGN;
    struct FReverbSettings Settings;
    FInteriorSettings AmbientZoneSettings;
    class AReverbVolume* NextLowerPriorityVolume;
    //## END PROPS ReverbVolume

    DECLARE_CLASS(AReverbVolume,AVolume,0,Engine)
	/**
	 * Removes the reverb volume to world info's list of reverb volumes.
	 */
	virtual void ClearComponents();

	/**
	 * callback for changed property
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

protected:
	/**
	 * Adds the reverb volume to world info's list of reverb volumes.
	 */
	virtual void UpdateComponentsInternal( UBOOL bCollisionUpdate = FALSE );
public:
};

class ATriggerVolume : public AVolume
{
public:
    //## BEGIN PROPS TriggerVolume
    //## END PROPS TriggerVolume

    DECLARE_CLASS(ATriggerVolume,AVolume,0,Engine)
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

struct DroppedPickup_eventSetPickupParticles_Parms
{
    class UParticleSystemComponent* PickupParticles;
    DroppedPickup_eventSetPickupParticles_Parms(EEventParm)
    {
    }
};
struct DroppedPickup_eventSetPickupMesh_Parms
{
    class UPrimitiveComponent* PickupMesh;
    DroppedPickup_eventSetPickupMesh_Parms(EEventParm)
    {
    }
};
class ADroppedPickup : public AActor
{
public:
    //## BEGIN PROPS DroppedPickup
    class AInventory* Inventory;
    class UClass* InventoryClass;
    class ANavigationPoint* PickupCache;
    BITFIELD bFadeOut:1;
    SCRIPT_ALIGN;
    //## END PROPS DroppedPickup

    void AddToNavigation();
    void RemoveFromNavigation();
    DECLARE_FUNCTION(execAddToNavigation)
    {
        P_FINISH;
        this->AddToNavigation();
    }
    DECLARE_FUNCTION(execRemoveFromNavigation)
    {
        P_FINISH;
        this->RemoveFromNavigation();
    }
    void eventSetPickupParticles(class UParticleSystemComponent* PickupParticles)
    {
        DroppedPickup_eventSetPickupParticles_Parms Parms(EC_EventParm);
        Parms.PickupParticles=PickupParticles;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPickupParticles),&Parms);
    }
    void eventSetPickupMesh(class UPrimitiveComponent* PickupMesh)
    {
        DroppedPickup_eventSetPickupMesh_Parms Parms(EC_EventParm);
        Parms.PickupMesh=PickupMesh;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPickupMesh),&Parms);
    }
    DECLARE_CLASS(ADroppedPickup,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ADroppedPickup)
};

class ADynamicSMActor : public AActor
{
public:
    //## BEGIN PROPS DynamicSMActor
    class UStaticMeshComponent* StaticMeshComponent;
    class UDynamicLightEnvironmentComponent* LightEnvironment;
    class UStaticMesh* ReplicatedMesh;
    class UMaterialInterface* ReplicatedMaterial0;
    class UMaterialInterface* ReplicatedMaterial1;
    BITFIELD bForceStaticDecals:1;
    BITFIELD bPawnCanBaseOn:1;
    BITFIELD bSafeBaseIfAsleep:1;
    SCRIPT_ALIGN;
    FVector ReplicatedMeshTranslation;
    FRotator ReplicatedMeshRotation;
    FVector ReplicatedMeshScale3D;
    //## END PROPS DynamicSMActor

    DECLARE_ABSTRACT_CLASS(ADynamicSMActor,AActor,0,Engine)
	/**
	* Function that gets called from within Map_Check to allow this actor to check itself
	* for any potential errors and register them with map check dialog.
	*/
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

protected:
#if USE_GAMEPLAY_PROFILER
    /** 
     * This function actually does the work for the GetProfilerAssetObject and is virtual.  
     * It should only be called from GetProfilerAssetObject as GetProfilerAssetObject is safe to call on NULL object pointers
     */
	virtual UObject* GetProfilerAssetObjectInternal() const;
#endif
	/**
     * This function actually does the work for the GetDetailInfo and is virtual.
     * It should only be called from GetDetailedInfo as GetDetailedInfo is safe to call on NULL object pointers
     */
	virtual FString GetDetailedInfoInternal() const;
};

class AInterpActor : public ADynamicSMActor
{
public:
    //## BEGIN PROPS InterpActor
    BITFIELD bShouldSaveForCheckpoint:1;
    BITFIELD bMonitorMover:1;
    BITFIELD bMonitorZVelocity:1;
    BITFIELD bDestroyProjectilesOnEncroach:1;
    BITFIELD bContinueOnEncroachPhysicsObject:1;
    BITFIELD bStopOnEncroach:1;
    BITFIELD bShouldShadowParentAllAttachedActors:1;
    BITFIELD bIsLift:1;
    class ANavigationPoint* MyMarker;
    FLOAT MaxZVelocity;
    FLOAT StayOpenTime;
    class USoundCue* OpenSound;
    class USoundCue* OpeningAmbientSound;
    class USoundCue* OpenedSound;
    class USoundCue* CloseSound;
    class USoundCue* ClosingAmbientSound;
    class USoundCue* ClosedSound;
    class UAudioComponent* AmbientSoundComponent;
    //## END PROPS InterpActor

    DECLARE_CLASS(AInterpActor,ADynamicSMActor,0,Engine)
	UBOOL ShouldTrace(UPrimitiveComponent* Primitive, AActor *SourceActor, DWORD TraceFlags);
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

struct Emitter_eventSetTemplate_Parms
{
    class UParticleSystem* NewTemplate;
    UBOOL bDestroyOnFinish;
    Emitter_eventSetTemplate_Parms(EEventParm)
    {
    }
};
class AEmitter : public AActor
{
public:
    //## BEGIN PROPS Emitter
    class UParticleSystemComponent* ParticleSystemComponent;
    class UDynamicLightEnvironmentComponent* LightEnvironment;
    BITFIELD bDestroyOnSystemFinish:1;
    BITFIELD bPostUpdateTickGroup:1;
    BITFIELD bCurrentlyActive:1;
    SCRIPT_ALIGN;
    //## END PROPS Emitter

    DECLARE_FUNCTION(execSetTemplate);
    void eventSetTemplate(class UParticleSystem* NewTemplate,UBOOL bDestroyOnFinish=FALSE)
    {
        Emitter_eventSetTemplate_Parms Parms(EC_EventParm);
        Parms.NewTemplate=NewTemplate;
        Parms.bDestroyOnFinish=bDestroyOnFinish ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetTemplate),&Parms);
    }
    DECLARE_CLASS(AEmitter,AActor,0,Engine)
	void SetTemplate(UParticleSystem* NewTemplate, UBOOL bDestroyOnFinish=false);
	void AutoPopulateInstanceProperties();

	// AActor interface.
	virtual void Spawned();
	virtual void PostBeginPlay();
	/**
	 *	ticks the actor
	 *	@param	DeltaTime	The time slice of this tick
	 *	@param	TickType	The type of tick that is happening
	 *
	 *	@return	TRUE if the actor was ticked, FALSE if it was aborted (e.g. because it's in stasis)
	 */
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

#if USE_GAMEPLAY_PROFILER
    /** 
     * This function actually does the work for the GetProfilerAssetObject and is virtual.  
     * It should only be called from GetProfilerAssetObject as GetProfilerAssetObject is safe to call on NULL object pointers
     */
	virtual UObject* GetProfilerAssetObjectInternal() const;
#endif

	/**
	 * This will return detail info about this specific object. (e.g. AudioComponent will return the name of the cue,
	 * ParticleSystemComponent will return the name of the ParticleSystem)  The idea here is that in many places
	 * you have a component of interest but what you really want is some characteristic that you can use to track
	 * down where it came from.
	 *
	 */
	virtual FString GetDetailedInfoInternal() const;

	/**
	 *	Called to reset the emitter actor in the level.
	 *	Intended for use in editor only
	 */
	void ResetInLevel();
};

struct FEmitterBaseInfo
{
    class UParticleSystemComponent* PSC;
    class AActor* Base;
    FVector RelativeLocation;
    FRotator RelativeRotation;
    BITFIELD bInheritBaseScale:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FEmitterBaseInfo() {}
    FEmitterBaseInfo(EEventParm)
    {
        appMemzero(this, sizeof(FEmitterBaseInfo));
    }
};

class AEmitterPool : public AActor
{
public:
    //## BEGIN PROPS EmitterPool
    class UParticleSystemComponent* PSCTemplate;
    TArrayNoInit<class UParticleSystemComponent*> PoolComponents;
    TArrayNoInit<class UParticleSystemComponent*> ActiveComponents;
    INT MaxActiveEffects;
    BITFIELD bLogPoolOverflow:1;
    BITFIELD bLogPoolOverflowList:1;
    TArrayNoInit<struct FEmitterBaseInfo> RelativePSCs;
    FLOAT SMC_MIC_ReductionTime;
    FLOAT SMC_MIC_CurrentReductionTime;
    INT IdealStaticMeshComponents;
    INT IdealMaterialInstanceConstants;
    TArrayNoInit<class UStaticMeshComponent*> FreeSMComponents;
    TArrayNoInit<class UMaterialInstanceConstant*> FreeMatInstConsts;
    //## END PROPS EmitterPool

    virtual void OnParticleSystemFinished(class UParticleSystemComponent* PSC);
    void ClearPoolComponents(UBOOL bClearActive=FALSE);
    void ReturnToPool(class UParticleSystemComponent* PSC);
    void FreeStaticMeshComponents(class UParticleSystemComponent* PSC);
    class UStaticMeshComponent* GetFreeStaticMeshComponent(UBOOL bCreateNewObject=TRUE);
    void FreeMaterialInstanceConstants(class UStaticMeshComponent* SMC);
    class UMaterialInstanceConstant* GetFreeMatInstConsts(UBOOL bCreateNewObject=TRUE);
    class UParticleSystemComponent* GetPooledComponent(class UParticleSystem* EmitterTemplate,UBOOL bAutoActivate);
    virtual class UParticleSystemComponent* SpawnEmitter(class UParticleSystem* EmitterTemplate,FVector SpawnLocation,FRotator SpawnRotation=FRotator(EC_EventParm),class AActor* AttachToActor=NULL,class AActor* InInstigator=NULL,INT MaxDLEPooledReuses=0,UBOOL bInheritScaleFromBase=FALSE);
    virtual class UParticleSystemComponent* SpawnEmitterMeshAttachment(class UParticleSystem* EmitterTemplate,class USkeletalMeshComponent* Mesh,FName AttachPointName,UBOOL bAttachToSocket=FALSE,FVector RelativeLoc=FVector(EC_EventParm),FRotator RelativeRot=FRotator(EC_EventParm));
    virtual class UParticleSystemComponent* SpawnEmitterCustomLifetime(class UParticleSystem* EmitterTemplate,UBOOL bSkipAutoActivate=FALSE);
    DECLARE_FUNCTION(execOnParticleSystemFinished)
    {
        P_GET_OBJECT(UParticleSystemComponent,PSC);
        P_FINISH;
        this->OnParticleSystemFinished(PSC);
    }
    DECLARE_FUNCTION(execClearPoolComponents)
    {
        P_GET_UBOOL_OPTX(bClearActive,FALSE);
        P_FINISH;
        this->ClearPoolComponents(bClearActive);
    }
    DECLARE_FUNCTION(execReturnToPool)
    {
        P_GET_OBJECT(UParticleSystemComponent,PSC);
        P_FINISH;
        this->ReturnToPool(PSC);
    }
    DECLARE_FUNCTION(execFreeStaticMeshComponents)
    {
        P_GET_OBJECT(UParticleSystemComponent,PSC);
        P_FINISH;
        this->FreeStaticMeshComponents(PSC);
    }
    DECLARE_FUNCTION(execGetFreeStaticMeshComponent)
    {
        P_GET_UBOOL_OPTX(bCreateNewObject,TRUE);
        P_FINISH;
        *(class UStaticMeshComponent**)Result=this->GetFreeStaticMeshComponent(bCreateNewObject);
    }
    DECLARE_FUNCTION(execFreeMaterialInstanceConstants)
    {
        P_GET_OBJECT(UStaticMeshComponent,SMC);
        P_FINISH;
        this->FreeMaterialInstanceConstants(SMC);
    }
    DECLARE_FUNCTION(execGetFreeMatInstConsts)
    {
        P_GET_UBOOL_OPTX(bCreateNewObject,TRUE);
        P_FINISH;
        *(class UMaterialInstanceConstant**)Result=this->GetFreeMatInstConsts(bCreateNewObject);
    }
    DECLARE_FUNCTION(execGetPooledComponent)
    {
        P_GET_OBJECT(UParticleSystem,EmitterTemplate);
        P_GET_UBOOL(bAutoActivate);
        P_FINISH;
        *(class UParticleSystemComponent**)Result=this->GetPooledComponent(EmitterTemplate,bAutoActivate);
    }
    DECLARE_FUNCTION(execSpawnEmitter)
    {
        P_GET_OBJECT(UParticleSystem,EmitterTemplate);
        P_GET_STRUCT(FVector,SpawnLocation);
        P_GET_STRUCT_OPTX(FRotator,SpawnRotation,FRotator(EC_EventParm));
        P_GET_OBJECT_OPTX(AActor,AttachToActor,NULL);
        P_GET_OBJECT_OPTX(AActor,InInstigator,NULL);
        P_GET_INT_OPTX(MaxDLEPooledReuses,0);
        P_GET_UBOOL_OPTX(bInheritScaleFromBase,FALSE);
        P_FINISH;
        *(class UParticleSystemComponent**)Result=this->SpawnEmitter(EmitterTemplate,SpawnLocation,SpawnRotation,AttachToActor,InInstigator,MaxDLEPooledReuses,bInheritScaleFromBase);
    }
    DECLARE_FUNCTION(execSpawnEmitterMeshAttachment)
    {
        P_GET_OBJECT(UParticleSystem,EmitterTemplate);
        P_GET_OBJECT(USkeletalMeshComponent,Mesh);
        P_GET_NAME(AttachPointName);
        P_GET_UBOOL_OPTX(bAttachToSocket,FALSE);
        P_GET_STRUCT_OPTX(FVector,RelativeLoc,FVector(EC_EventParm));
        P_GET_STRUCT_OPTX(FRotator,RelativeRot,FRotator(EC_EventParm));
        P_FINISH;
        *(class UParticleSystemComponent**)Result=this->SpawnEmitterMeshAttachment(EmitterTemplate,Mesh,AttachPointName,bAttachToSocket,RelativeLoc,RelativeRot);
    }
    DECLARE_FUNCTION(execSpawnEmitterCustomLifetime)
    {
        P_GET_OBJECT(UParticleSystem,EmitterTemplate);
        P_GET_UBOOL_OPTX(bSkipAutoActivate,FALSE);
        P_FINISH;
        *(class UParticleSystemComponent**)Result=this->SpawnEmitterCustomLifetime(EmitterTemplate,bSkipAutoActivate);
    }
    DECLARE_CLASS(AEmitterPool,AActor,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	virtual void TickSpecial(FLOAT DeltaTime);
};

struct FCanvasIcon
{
    class UTexture* Texture;
    FLOAT U;
    FLOAT V;
    FLOAT UL;
    FLOAT VL;

    /** Constructors */
    FCanvasIcon() {}
    FCanvasIcon(EEventParm)
    {
        appMemzero(this, sizeof(FCanvasIcon));
    }
};

struct FDepthFieldGlowInfo
{
    BITFIELD bEnableGlow:1;
    SCRIPT_ALIGN;
    FLinearColor GlowColor;
    FVector2D GlowOuterRadius;
    FVector2D GlowInnerRadius;

		FDepthFieldGlowInfo()
		{}
		FDepthFieldGlowInfo(EEventParm)
		{
			appMemzero(this, sizeof(FDepthFieldGlowInfo));
		}
		UBOOL operator==(const FDepthFieldGlowInfo& Other) const
		{
			if (Other.bEnableGlow != bEnableGlow)
			{
				return false;
			}
			else if (!bEnableGlow)
			{
				// if the glow is disabled on both, the other values don't matter
				return true;
			}
			else
			{
				return (Other.GlowColor == GlowColor && Other.GlowOuterRadius == GlowOuterRadius && Other.GlowInnerRadius == GlowInnerRadius);
			}
		}
		UBOOL operator!=(const FDepthFieldGlowInfo& Other) const
		{
			return !(*this == Other);
		}
	
};

struct FMobileDistanceFieldParams
{
    FLOAT Gamma;
    FLOAT AlphaRefVal;
    FLOAT SmoothWidth;
    BITFIELD EnableShadow:1;
    SCRIPT_ALIGN;
    FVector2D ShadowDirection;
    FLinearColor ShadowColor;
    FLOAT ShadowSmoothWidth;
    struct FDepthFieldGlowInfo GlowInfo;
    INT BlendMode;

		/** Constructors */
		FMobileDistanceFieldParams(
			FLOAT InGamma,
			FLOAT InAlphaRefVal,
			FLOAT InSmoothWidth,
			UBOOL InEnableShadow,
			FVector2D& InShadowDirection,
			FLinearColor& InShadowColor,
			FLOAT InShadowSmoothWidth,
			const FDepthFieldGlowInfo& InGlowInfo,
			INT InBlendMode
			)
			: Gamma(InGamma)
			, AlphaRefVal(InAlphaRefVal)
			, SmoothWidth(InSmoothWidth)
			, EnableShadow(InEnableShadow)
			, ShadowDirection(InShadowDirection)
			, ShadowColor(InShadowColor)
			, ShadowSmoothWidth(InShadowSmoothWidth)
			, GlowInfo(InGlowInfo)
			, BlendMode(InBlendMode)
		{
		}
	
};

struct FFontRenderInfo
{
    BITFIELD bClipText:1;
    BITFIELD bEnableShadow:1;
    SCRIPT_ALIGN;
    struct FDepthFieldGlowInfo GlowInfo;

    /** Constructors */
    FFontRenderInfo() {}
    FFontRenderInfo(EEventParm)
    {
        appMemzero(this, sizeof(FFontRenderInfo));
    }
};

struct FCanvasUVTri
{
    FVector2D V0_Pos;
    FVector2D V0_UV;
    FVector2D V1_Pos;
    FVector2D V1_UV;
    FVector2D V2_Pos;
    FVector2D V2_UV;

    /** Constructors */
    FCanvasUVTri() {}
    FCanvasUVTri(EEventParm)
    {
        appMemzero(this, sizeof(FCanvasUVTri));
    }
};

struct FTextSizingParameters
{
    FLOAT DrawX;
    FLOAT DrawY;
    FLOAT DrawXL;
    FLOAT DrawYL;
    FVector2D Scaling;
    class UFont* DrawFont;
    FVector2D SpacingAdjust;
    FLOAT ViewportHeight;

		FTextSizingParameters( FLOAT inDrawX, FLOAT inDrawY, FLOAT inDrawXL, FLOAT inDrawYL, UFont* inFont=NULL, FLOAT InViewportHeight=0.f )
		: DrawX(inDrawX), DrawY(inDrawY), DrawXL(inDrawXL), DrawYL(inDrawYL)
		, Scaling(1.f,1.f), DrawFont(inFont)
		, SpacingAdjust( 0.0f, 0.0f ), ViewportHeight(InViewportHeight)
		{
		}

		FTextSizingParameters( UFont* inFont, FLOAT ScaleX, FLOAT ScaleY, FLOAT InViewportHeight=0.f )
		: DrawX(0.f), DrawY(0.f), DrawXL(0.f), DrawYL(0.f)
		, Scaling(ScaleX,ScaleY), DrawFont(inFont)
		, SpacingAdjust( 0.0f, 0.0f ), ViewportHeight(InViewportHeight)
		{
		}
	
};

struct FWrappedStringElement
{
    FString Value;
    FVector2D LineExtent;

		/** Constructor */
		FWrappedStringElement( const TCHAR* InValue, FLOAT Width, FLOAT Height )
		: Value(InValue), LineExtent(Width,Height)
		{}
	
};

struct Canvas_eventReset_Parms
{
    UBOOL bKeepOrigin;
    Canvas_eventReset_Parms(EEventParm)
    {
    }
};
class UCanvas : public UObject
{
public:
    //## BEGIN PROPS Canvas
    class UFont* Font;
    FLOAT OrgX;
    FLOAT OrgY;
    FLOAT ClipX;
    FLOAT ClipY;
    FLOAT CurX;
    FLOAT CurY;
    FLOAT CurZ;
    FLOAT CurYL;
    FColor DrawColor;
    BITFIELD bCenter:1;
    BITFIELD bNoSmooth:1;
    INT SizeX;
    INT SizeY;
    FCanvas* Canvas;
    FSceneView* SceneView;
    FPlane ColorModulate;
    class UTexture2D* DefaultTexture;
    //## END PROPS Canvas

    void DrawRotatedTile(class UTexture* Tex,FRotator Rotation,FLOAT XL,FLOAT YL,FLOAT U,FLOAT V,FLOAT UL,FLOAT VL,FLOAT AnchorX=0.500000,FLOAT AnchorY=0.500000);
    void DrawRotatedMaterialTile(class UMaterialInterface* Mat,FRotator Rotation,FLOAT XL,FLOAT YL,FLOAT U=0.000000,FLOAT V=0.000000,FLOAT UL=0.000000,FLOAT VL=0.000000,FLOAT AnchorX=0.500000,FLOAT AnchorY=0.500000);
    void DrawTris(class UTexture* Tex,const TArray<struct FCanvasUVTri>& Triangles,FColor InColor);
    void SetPos(FLOAT PosX,FLOAT PosY,FLOAT PosZ=0.000000);
    void DrawBlendedTile(class UTexture* Tex,FLOAT XL,FLOAT YL,FLOAT U,FLOAT V,FLOAT UL,FLOAT VL,BYTE Blend);
    void SetDrawColor(BYTE R,BYTE G,BYTE B,BYTE A=255);
    void DrawTextureLine(FVector StartPoint,FVector EndPoint,FLOAT Perc,FLOAT Width,FColor LineColor,class UTexture* LineTexture,FLOAT U,FLOAT V,FLOAT UL,FLOAT VL);
    void DrawTextureDoubleLine(FVector StartPoint,FVector EndPoint,FLOAT Perc,FLOAT Spacing,FLOAT Width,FColor LineColor,FColor AltLineColor,class UTexture* Tex,FLOAT U,FLOAT V,FLOAT UL,FLOAT VL);
    DECLARE_FUNCTION(execDrawTile);
    DECLARE_FUNCTION(execPreOptimizeDrawTiles);
    DECLARE_FUNCTION(execDrawMaterialTile);
    DECLARE_FUNCTION(execDrawRotatedTile)
    {
        P_GET_OBJECT(UTexture,Tex);
        P_GET_STRUCT(FRotator,Rotation);
        P_GET_FLOAT(XL);
        P_GET_FLOAT(YL);
        P_GET_FLOAT(U);
        P_GET_FLOAT(V);
        P_GET_FLOAT(UL);
        P_GET_FLOAT(VL);
        P_GET_FLOAT_OPTX(AnchorX,0.500000);
        P_GET_FLOAT_OPTX(AnchorY,0.500000);
        P_FINISH;
        this->DrawRotatedTile(Tex,Rotation,XL,YL,U,V,UL,VL,AnchorX,AnchorY);
    }
    DECLARE_FUNCTION(execDrawRotatedMaterialTile)
    {
        P_GET_OBJECT(UMaterialInterface,Mat);
        P_GET_STRUCT(FRotator,Rotation);
        P_GET_FLOAT(XL);
        P_GET_FLOAT(YL);
        P_GET_FLOAT_OPTX(U,0.000000);
        P_GET_FLOAT_OPTX(V,0.000000);
        P_GET_FLOAT_OPTX(UL,0.000000);
        P_GET_FLOAT_OPTX(VL,0.000000);
        P_GET_FLOAT_OPTX(AnchorX,0.500000);
        P_GET_FLOAT_OPTX(AnchorY,0.500000);
        P_FINISH;
        this->DrawRotatedMaterialTile(Mat,Rotation,XL,YL,U,V,UL,VL,AnchorX,AnchorY);
    }
    DECLARE_FUNCTION(execDrawTimer);
    DECLARE_FUNCTION(execDrawTileStretched);
    DECLARE_FUNCTION(execDrawTris)
    {
        P_GET_OBJECT(UTexture,Tex);
        P_GET_TARRAY(struct FCanvasUVTri,Triangles);
        P_GET_STRUCT(FColor,InColor);
        P_FINISH;
        this->DrawTris(Tex,Triangles,InColor);
    }
    DECLARE_FUNCTION(execStrLen);
    DECLARE_FUNCTION(execTextSize);
    DECLARE_FUNCTION(execDrawText);
    DECLARE_FUNCTION(execProject);
    DECLARE_FUNCTION(execDeProject);
    DECLARE_FUNCTION(execPushTranslationMatrix);
    DECLARE_FUNCTION(execPopTransform);
    DECLARE_FUNCTION(execSetPos)
    {
        P_GET_FLOAT(PosX);
        P_GET_FLOAT(PosY);
        P_GET_FLOAT_OPTX(PosZ,0.000000);
        P_FINISH;
        this->SetPos(PosX,PosY,PosZ);
    }
    DECLARE_FUNCTION(execPushMaskRegion);
    DECLARE_FUNCTION(execPopMaskRegion);
    DECLARE_FUNCTION(execDrawBlendedTile)
    {
        P_GET_OBJECT(UTexture,Tex);
        P_GET_FLOAT(XL);
        P_GET_FLOAT(YL);
        P_GET_FLOAT(U);
        P_GET_FLOAT(V);
        P_GET_FLOAT(UL);
        P_GET_FLOAT(VL);
        P_GET_BYTE(Blend);
        P_FINISH;
        this->DrawBlendedTile(Tex,XL,YL,U,V,UL,VL,Blend);
    }
    DECLARE_FUNCTION(execSetDrawColor)
    {
        P_GET_BYTE(R);
        P_GET_BYTE(G);
        P_GET_BYTE(B);
        P_GET_BYTE_OPTX(A,255);
        P_FINISH;
        this->SetDrawColor(R,G,B,A);
    }
    DECLARE_FUNCTION(execDraw2DLine);
    DECLARE_FUNCTION(execDrawTextureLine)
    {
        P_GET_STRUCT(FVector,StartPoint);
        P_GET_STRUCT(FVector,EndPoint);
        P_GET_FLOAT(Perc);
        P_GET_FLOAT(Width);
        P_GET_STRUCT(FColor,LineColor);
        P_GET_OBJECT(UTexture,LineTexture);
        P_GET_FLOAT(U);
        P_GET_FLOAT(V);
        P_GET_FLOAT(UL);
        P_GET_FLOAT(VL);
        P_FINISH;
        this->DrawTextureLine(StartPoint,EndPoint,Perc,Width,LineColor,LineTexture,U,V,UL,VL);
    }
    DECLARE_FUNCTION(execDrawTextureDoubleLine)
    {
        P_GET_STRUCT(FVector,StartPoint);
        P_GET_STRUCT(FVector,EndPoint);
        P_GET_FLOAT(Perc);
        P_GET_FLOAT(Spacing);
        P_GET_FLOAT(Width);
        P_GET_STRUCT(FColor,LineColor);
        P_GET_STRUCT(FColor,AltLineColor);
        P_GET_OBJECT(UTexture,Tex);
        P_GET_FLOAT(U);
        P_GET_FLOAT(V);
        P_GET_FLOAT(UL);
        P_GET_FLOAT(VL);
        P_FINISH;
        this->DrawTextureDoubleLine(StartPoint,EndPoint,Perc,Spacing,Width,LineColor,AltLineColor,Tex,U,V,UL,VL);
    }
    void eventReset(UBOOL bKeepOrigin=FALSE)
    {
        Canvas_eventReset_Parms Parms(EC_EventParm);
        Parms.bKeepOrigin=bKeepOrigin ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_Reset),&Parms);
    }
    DECLARE_CLASS(UCanvas,UObject,0|CLASS_Transient,Engine)
	// UCanvas interface.
	void Init();
	void Update();

	void DrawTile(UTexture* Tex, FLOAT X, FLOAT Y, FLOAT Z, FLOAT XL, FLOAT YL, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL, const FLinearColor& Color,ECanvasBlendMode BlendMode);
	void DrawTile(UTexture* Tex, FLOAT X, FLOAT Y, FLOAT Z, FLOAT XL, FLOAT YL, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL, const FLinearColor& Color,EBlendMode BlendMode=BLEND_Translucent);
	void DrawMaterialTile(UMaterialInterface* Tex, FLOAT X, FLOAT Y, FLOAT Z, FLOAT XL, FLOAT YL, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL);
	static void ClippedStrLen(UFont* Font, FLOAT ScaleX, FLOAT ScaleY, INT& XL, INT& YL, const TCHAR* Text);
	void VARARGS WrappedStrLenf(UFont* Font, FLOAT ScaleX, FLOAT ScaleY, INT& XL, INT& YL, const TCHAR* Fmt, ...);
	INT WrappedPrint(UBOOL Draw, INT& XL, INT& YL, UFont* Font, FLOAT ScaleX, FLOAT ScaleY, UBOOL Center, const TCHAR* Text, const FFontRenderInfo& RenderInfo = FFontRenderInfo(EC_EventParm));
	void DrawText(const FString& Text);
	void DrawTileStretched(UTexture* Tex, FLOAT Left, FLOAT Top, FLOAT Depth, FLOAT AWidth, FLOAT AHeight, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL, FLinearColor DrawColor,UBOOL bStretchHorizontally=1,UBOOL bStretchVertically=1,FLOAT ScalingFactor=1.0);
	void DrawTimer(UTexture* Tex, FLOAT StartTime, FLOAT TotalTime, FLOAT X, FLOAT Y, FLOAT Z, FLOAT XL, FLOAT YL, FLOAT U, FLOAT V, FLOAT UL, FLOAT VL, const FLinearColor& Color,EBlendMode BlendMode=BLEND_Translucent);

	/**
	 * Calculates the size of the specified string.
	 *
	 * @param	Parameters	Used for various purposes
	 *							DrawXL:		[out] will be set to the width of the string
	 *							DrawYL:		[out] will be set to the height of the string
	 *							DrawFont:	[in] specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[out] specifies the amount of scaling to apply to the string
	 * @param	pText		the string to calculate the size for
	 * @param	EOL			a pointer to a single character that is used as the end-of-line marker in this string
	 * @param	bStripTrailingCharSpace
	 *						whether the inter-character spacing following the last character should be included in the calculated width of the result string
	 */
	static void CanvasStringSize( FTextSizingParameters& Parameters, const TCHAR* pText, const TCHAR* EOL=NULL, UBOOL bStripTrailingCharSpace=TRUE );


	/**
	 * Parses a single string into an array of strings that will fit inside the specified bounding region.
	 *
	 * @param	Parameters		Used for various purposes:
	 *							DrawX:		[in] specifies the pixel location of the start of the horizontal bounding region that should be used for wrapping.
	 *							DrawY:		[in] specifies the Y origin of the bounding region.  This should normally be set to 0, as this will be
	 *										     used as the base value for DrawYL.
	 *										[out] Will be set to the Y position (+YL) of the last line, i.e. the total height of all wrapped lines relative to the start of the bounding region
	 *							DrawXL:		[in] specifies the pixel location of the end of the horizontal bounding region that should be used for wrapping
	 *							DrawYL:		[in] specifies the height of the bounding region, in pixels.  A input value of 0 indicates that
	 *										     the bounding region height should not be considered.  Once the total height of lines reaches this
	 *										     value, the function returns and no further processing occurs.
	 *							DrawFont:	[in] specifies the font to use for retrieving the size of the characters in the string
	 *							Scale:		[in] specifies the amount of scaling to apply to the string
	 * @param	CurX			specifies the pixel location to begin the wrapping; usually equal to the X pos of the bounding region, unless wrapping is initiated
	 *								in the middle of the bounding region (i.e. indentation)
	 * @param	pText			the text that should be wrapped
	 * @param	out_Lines		[out] will contain an array of strings which fit inside the bounding region specified.  Does
	 *							not clear the array first.
	 * @param	EOL				a pointer to a single character that is used as the end-of-line marker in this string
	 * @param	MaxLines		the maximum number of lines that can be created.
	 */
	static void WrapString( FTextSizingParameters& Parameters, FLOAT CurX, const TCHAR* pText, TArray<struct FWrappedStringElement>& out_Lines, const TCHAR* EOL = NULL, INT MaxLines = MAXINT);
};

struct FConsoleMessage
{
    FStringNoInit Text;
    FColor TextColor;
    FLOAT MessageLife;
    class APlayerReplicationInfo* PRI;

    /** Constructors */
    FConsoleMessage() {}
    FConsoleMessage(EEventParm)
    {
        appMemzero(this, sizeof(FConsoleMessage));
    }
};

struct FHudLocalizedMessage
{
    class UClass* Message;
    FStringNoInit StringMessage;
    INT Switch;
    FLOAT EndOfLife;
    FLOAT Lifetime;
    FLOAT PosY;
    FColor DrawColor;
    INT FontSize;
    class UFont* StringFont;
    FLOAT DX;
    FLOAT DY;
    BITFIELD Drawn:1;
    INT Count;
    class UObject* OptionalObject;

    /** Constructors */
    FHudLocalizedMessage() {}
    FHudLocalizedMessage(EEventParm)
    {
        appMemzero(this, sizeof(FHudLocalizedMessage));
    }
};

struct FKismetDrawTextInfo
{
    FStringNoInit MessageText;
    FStringNoInit AppendedText;
    class UFont* MessageFont;
    FVector2D MessageFontScale;
    FVector2D MessageOffset;
    FColor MessageColor;
    FLOAT MessageEndTime;

    /** Constructors */
    FKismetDrawTextInfo() {}
    FKismetDrawTextInfo(EEventParm)
    {
        appMemzero(this, sizeof(FKismetDrawTextInfo));
    }
};

struct HUD_eventOnLostFocusPause_Parms
{
    UBOOL bEnable;
    HUD_eventOnLostFocusPause_Parms(EEventParm)
    {
    }
};
struct HUD_eventPostRender_Parms
{
    HUD_eventPostRender_Parms(EEventParm)
    {
    }
};
class AHUD : public AActor
{
public:
    //## BEGIN PROPS HUD
    FColor WhiteColor;
    FColor GreenColor;
    FColor RedColor;
    class APlayerController* PlayerOwner;
    BITFIELD bLostFocusPaused:1;
    BITFIELD bShowHUD:1;
    BITFIELD bShowScores:1;
    BITFIELD bShowDebugInfo:1;
    BITFIELD bShowBadConnectionAlert:1;
    BITFIELD bShowDirectorInfoDebug:1;
    BITFIELD bShowDirectorInfoHUD:1;
    BITFIELD bMessageBeep:1;
    BITFIELD bRenderFullScreen:1;
    BITFIELD bScaleCanvasForCinematicMode:1;
    BITFIELD bShowOverlays:1;
    FLOAT HudCanvasScale;
    TArrayNoInit<class AActor*> PostRenderedActors;
    TArrayNoInit<struct FConsoleMessage> ConsoleMessages;
    FColor ConsoleColor;
    INT ConsoleMessageCount;
    INT ConsoleFontSize;
    INT MessageFontOffset;
    INT MaxHUDAreaMessageCount;
    struct FHudLocalizedMessage LocalMessages[8];
    FLOAT ConsoleMessagePosX;
    FLOAT ConsoleMessagePosY;
    class UCanvas* Canvas;
    FLOAT LastHUDRenderTime;
    FLOAT RenderDelta;
    FLOAT SizeX;
    FLOAT SizeY;
    FLOAT CenterX;
    FLOAT CenterY;
    FLOAT RatioX;
    FLOAT RatioY;
    TArrayNoInit<FName> DebugDisplay;
    TArrayNoInit<struct FKismetDrawTextInfo> KismetTextInfo;
    //## END PROPS HUD

    void Draw3DLine(FVector Start,FVector End,FColor LineColor);
    void Draw2DLine(INT X1,INT Y1,INT X2,INT Y2,FColor LineColor);
    virtual void DrawActorOverlays(FVector ViewPoint,FRotator ViewRotation);
    DECLARE_FUNCTION(execDraw3DLine)
    {
        P_GET_STRUCT(FVector,Start);
        P_GET_STRUCT(FVector,End);
        P_GET_STRUCT(FColor,LineColor);
        P_FINISH;
        this->Draw3DLine(Start,End,LineColor);
    }
    DECLARE_FUNCTION(execDraw2DLine)
    {
        P_GET_INT(X1);
        P_GET_INT(Y1);
        P_GET_INT(X2);
        P_GET_INT(Y2);
        P_GET_STRUCT(FColor,LineColor);
        P_FINISH;
        this->Draw2DLine(X1,Y1,X2,Y2,LineColor);
    }
    DECLARE_FUNCTION(execDrawActorOverlays)
    {
        P_GET_STRUCT(FVector,ViewPoint);
        P_GET_STRUCT(FRotator,ViewRotation);
        P_FINISH;
        this->DrawActorOverlays(ViewPoint,ViewRotation);
    }
    void eventOnLostFocusPause(UBOOL bEnable)
    {
        HUD_eventOnLostFocusPause_Parms Parms(EC_EventParm);
        Parms.bEnable=bEnable ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_OnLostFocusPause),&Parms);
    }
    void eventPostRender()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostRender),NULL);
    }
    DECLARE_CLASS(AHUD,AActor,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(AHUD)
};

struct FKeyValuePair
{
    FString Key;
    FString Value;
    friend FArchive& operator<<(FArchive& Ar,FKeyValuePair& MyKeyValuePair)
    {
        return Ar << MyKeyValuePair.Key << MyKeyValuePair.Value;
    }

    /** Constructors */
    FKeyValuePair() {}
    FKeyValuePair(EEventParm)
    {
        appMemzero(this, sizeof(FKeyValuePair));
    }
};

struct FPlayerResponseLine
{
    INT PlayerNum;
    INT PlayerID;
    FString PlayerName;
    INT Ping;
    INT Score;
    INT StatsID;
    TArray<struct FKeyValuePair> PlayerInfo;
    friend FArchive& operator<<(FArchive& Ar,FPlayerResponseLine& MyPlayerResponseLine)
    {
        return Ar << MyPlayerResponseLine.PlayerNum << MyPlayerResponseLine.PlayerID << MyPlayerResponseLine.PlayerName << MyPlayerResponseLine.Ping << MyPlayerResponseLine.Score << MyPlayerResponseLine.StatsID << MyPlayerResponseLine.PlayerInfo;
    }

    /** Constructors */
    FPlayerResponseLine()
    : PlayerNum(0)
    , PlayerID(0)
    , Ping(0)
    , Score(0)
    , StatsID(0)
    {}
    FPlayerResponseLine(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerResponseLine));
    }
};

struct FServerResponseLine
{
    INT ServerID;
    FString IP;
    INT Port;
    INT QueryPort;
    FString ServerName;
    FString MapName;
    FString GameType;
    INT CurrentPlayers;
    INT MaxPlayers;
    INT Ping;
    TArray<struct FKeyValuePair> ServerInfo;
    TArray<struct FPlayerResponseLine> PlayerInfo;
    friend FArchive& operator<<(FArchive& Ar,FServerResponseLine& MyServerResponseLine)
    {
        return Ar << MyServerResponseLine.ServerID << MyServerResponseLine.IP << MyServerResponseLine.Port << MyServerResponseLine.QueryPort << MyServerResponseLine.ServerName << MyServerResponseLine.MapName << MyServerResponseLine.GameType << MyServerResponseLine.CurrentPlayers << MyServerResponseLine.MaxPlayers << MyServerResponseLine.Ping << MyServerResponseLine.ServerInfo << MyServerResponseLine.PlayerInfo;
    }

    /** Constructors */
    FServerResponseLine()
    : ServerID(0)
    , Port(0)
    , QueryPort(0)
    , CurrentPlayers(0)
    , MaxPlayers(0)
    , Ping(0)
    {}
    FServerResponseLine(EEventParm)
    {
        appMemzero(this, sizeof(FServerResponseLine));
    }
};

class AInfo : public AActor
{
public:
    //## BEGIN PROPS Info
    //## END PROPS Info

    DECLARE_ABSTRACT_CLASS(AInfo,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AInfo)
};

struct FLocalizedStringSetting
{
    INT Id;
    INT ValueIndex;
    BYTE AdvertisementType;
    SCRIPT_ALIGN;

    /** Constructors */
    FLocalizedStringSetting() {}
    FLocalizedStringSetting(EEventParm)
    {
        appMemzero(this, sizeof(FLocalizedStringSetting));
    }
};

struct FSettingsData
{
    BYTE Type;
    INT Value1;
    INT* Value2;

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(const FString& InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(const TCHAR* InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(INT InData);

		/**
		 * Copies the data and sets the type to DateTime
		 *
		 * @param InData1 the first part to assign
		 * @param InData2 the second part to assign
		 */
		void SetData(INT InData1,INT InData2);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(DOUBLE InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(FLOAT InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(const TArray<BYTE>& InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param Size the length of the buffer to copy
		 * @param InData the new data to assign
		 */
		void SetData(DWORD Size,const BYTE* InData);

		/**
		 * Copies the data and sets the type
		 *
		 * @param InData the new data to assign
		 */
		void SetData(QWORD InData);

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(FString& OutData) const;

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(INT& OutData) const;

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(QWORD& OutData) const;

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(FLOAT& OutData) const;

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(TArray<BYTE>& OutData) const;

		/**
		 * Copies the data after verifying the type.
		 * NOTE: Performs a deep copy so you are repsonsible for freeing the data
		 *
		 * @param OutSize out value that receives the size of the copied data
		 * @param OutData out value that receives the copied data
		 */
		void GetData(DWORD& OutSize,BYTE** OutData) const;

		/**
		 * Copies the data into the two fields after verifying the type is DateTime
		 *
		 * @param InData1 the first part to assign
		 * @param InData2 the second part to assign
		 */
		void GetData(INT& InData1,INT& InData2) const;

		/**
		 * Increments the value by the specified amount
		 *
		 * @param IncBy the amount to increment by
		 */
		template<typename TYPE,ESettingsDataType ENUM_TYPE>
		FORCEINLINE void Increment(TYPE IncBy)
		{
			checkSlow(Type == SDT_Int32 || Type == SDT_Int64 ||
				Type == SDT_Float || Type == SDT_Double);
			if (Type == ENUM_TYPE)
			{
				*(TYPE*)&Value1 += IncBy;
			}
		}

		/**
		 * Decrements the value by the specified amount
		 *
		 * @param DecBy the amount to decrement by
		 */
		template<typename TYPE,ESettingsDataType ENUM_TYPE>
		FORCEINLINE void Decrement(TYPE DecBy)
		{
			checkSlow(Type == SDT_Int32 || Type == SDT_Int64 ||
				Type == SDT_Float || Type == SDT_Double);
			if (Type == ENUM_TYPE)
			{
				*(TYPE*)&Value1 -= DecBy;
			}
		}

		/**
		 * Cleans up the existing data and sets the type to ODT_Empty
		 */
		void CleanUp(void);

		/** Does nothing (no init version) */
		FSettingsData(void)
		{
		}

		/**
		 * Zeroes members
		 */
		FSettingsData(EEventParm) :
			Type(SDT_Empty),
			Value1(0),
			Value2(0)
		{
		}

		/**
		 * Copy constructor. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FSettingsData(const FSettingsData& Other);

		/**
		 * Assignment operator. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FSettingsData& operator=(const FSettingsData& Other);

		/**
		 * Cleans up the data to prevent leaks
		 */
		~FSettingsData(void)
		{
			CleanUp();
		}

		/**
		 * Converts the data into a string representation
		 */
		FString ToString(void) const;

		/**
		 * Converts the string to the specified type of data for this setting
		 *
		 * @param NewValue the string value to convert
		 *
		 * @return TRUE if it was converted, FALSE otherwise
		 */
		UBOOL FromString(const FString& NewValue);

		/**
		 * Copies the data after verifying the type
		 *
		 * @param OutData out value that receives the copied data
		 */
		void GetData(DOUBLE& OutData) const;

		/** @return The type as a string */
		const TCHAR* GetTypeString(void) const
		{
			switch (Type)
			{
				case SDT_Empty: return TEXT("Empty");
				case SDT_Int32: return TEXT("Int32");
				case SDT_Int64: return TEXT("Int64");
				case SDT_Double: return TEXT("Double");
				case SDT_String: return TEXT("String");
				case SDT_Float: return TEXT("Float");
				case SDT_Blob: return TEXT("Blob");
				case SDT_DateTime: return TEXT("DateTime");
			};
			return TEXT("Empty");
		}

		/**
		 * Comparison of two settings data classes
		 *
		 * @param Other the other settings data to compare against
		 *
		 * @return TRUE if they are equal, FALSE otherwise
		 */
		UBOOL operator==(const FSettingsData& Other) const;
		UBOOL operator!=(const FSettingsData& Other) const;
	
};

struct FSettingsProperty
{
    INT PropertyId;
    struct FSettingsData Data;
    BYTE AdvertisementType;
    SCRIPT_ALIGN;

		/** Does nothing (no init version) */
		FSettingsProperty(void)
		{
		}

		/**
		 * Zeroes members
		 */
		FSettingsProperty(EEventParm) :
			PropertyId(0),
			Data(EC_EventParm),
			AdvertisementType(ODAT_DontAdvertise)
		{
		}

		/**
		 * Copy constructor. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FSettingsProperty(const FSettingsProperty& Other) :
			Data(EC_EventParm)
		{
			PropertyId = Other.PropertyId;
			AdvertisementType = Other.AdvertisementType;
			// This will do a deep copy
			Data = Other.Data;
		}

		/**
		 * Assignment operator. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FSettingsProperty& operator=(const FSettingsProperty& Other)
		{
			if (&Other != this)
			{
				PropertyId = Other.PropertyId;
				AdvertisementType = Other.AdvertisementType;
				// This will do a deep copy
				Data = Other.Data;
			}
			return *this;
		}
	
};

struct FStringIdToStringMapping
{
    INT Id;
    FName Name;
    BITFIELD bIsWildcard:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FStringIdToStringMapping() {}
    FStringIdToStringMapping(EEventParm)
    {
        appMemzero(this, sizeof(FStringIdToStringMapping));
    }
};

struct FLocalizedStringSettingMetaData
{
    INT Id;
    FName Name;
    FStringNoInit ColumnHeaderText;
    TArrayNoInit<struct FStringIdToStringMapping> ValueMappings;

    /** Constructors */
    FLocalizedStringSettingMetaData() {}
    FLocalizedStringSettingMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FLocalizedStringSettingMetaData));
    }
};

struct FIdToStringMapping
{
    INT Id;
    FName Name;

    /** Constructors */
    FIdToStringMapping() {}
    FIdToStringMapping(EEventParm)
    {
        appMemzero(this, sizeof(FIdToStringMapping));
    }
};

struct FSettingsPropertyPropertyMetaData
{
    INT Id;
    FName Name;
    FStringNoInit ColumnHeaderText;
    BYTE MappingType;
    TArrayNoInit<struct FIdToStringMapping> ValueMappings;
    TArrayNoInit<struct FSettingsData> PredefinedValues;
    FLOAT MinVal;
    FLOAT MaxVal;
    FLOAT RangeIncrement;

    /** Constructors */
    FSettingsPropertyPropertyMetaData() {}
    FSettingsPropertyPropertyMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FSettingsPropertyPropertyMetaData));
    }
};

class USettings : public UObject
{
public:
    //## BEGIN PROPS Settings
    TArrayNoInit<struct FLocalizedStringSetting> LocalizedSettings;
    TArrayNoInit<struct FSettingsProperty> Properties;
    TArrayNoInit<struct FLocalizedStringSettingMetaData> LocalizedSettingsMappings;
    TArrayNoInit<struct FSettingsPropertyPropertyMetaData> PropertyMappings;
    //## END PROPS Settings

    void SetSettingsDataFloat(struct FSettingsData& Data,FLOAT InFloat);
    void SetSettingsDataInt(struct FSettingsData& Data,INT InInt);
    void SetSettingsDataDateTime(struct FSettingsData& Data,INT InInt1,INT InInt2);
    void SetSettingsDataBlob(struct FSettingsData& Data,TArray<BYTE>& InBlob);
    void SetSettingsData(struct FSettingsData& Data,struct FSettingsData& Data2Copy);
    void EmptySettingsData(struct FSettingsData& Data);
    FLOAT GetSettingsDataFloat(struct FSettingsData& Data);
    INT GetSettingsDataInt(struct FSettingsData& Data);
    void GetSettingsDataBlob(struct FSettingsData& Data,TArray<BYTE>& OutBlob);
    void GetSettingsDataDateTime(struct FSettingsData& Data,INT& OutInt1,INT& OutInt2);
    virtual void SetStringSettingValue(INT StringSettingId,INT ValueIndex,UBOOL bShouldAutoAdd=FALSE);
    virtual UBOOL GetStringSettingValue(INT StringSettingId,INT& ValueIndex);
    virtual UBOOL IncrementStringSettingValue(INT StringSettingId,INT Direction,UBOOL bShouldWrap);
    virtual UBOOL GetStringSettingValueNames(INT StringSettingId,TArray<struct FIdToStringMapping>& Values);
    virtual void SetStringSettingValueByName(FName StringSettingName,INT ValueIndex,UBOOL bShouldAutoAdd);
    virtual UBOOL GetStringSettingValueByName(FName StringSettingName,INT& ValueIndex);
    virtual UBOOL GetStringSettingId(FName StringSettingName,INT& StringSettingId);
    virtual FName GetStringSettingName(INT StringSettingId);
    virtual FString GetStringSettingColumnHeader(INT StringSettingId);
    virtual UBOOL IsWildcardStringSetting(INT StringSettingId);
    virtual FName GetStringSettingValueName(INT StringSettingId,INT ValueIndex);
    virtual FName GetStringSettingValueNameByName(FName StringSettingName);
    virtual UBOOL SetStringSettingValueFromStringByName(FName StringSettingName,const FString& NewValue);
    virtual UBOOL GetPropertyId(FName PropertyName,INT& PropertyId);
    virtual FName GetPropertyName(INT PropertyId);
    virtual FString GetPropertyColumnHeader(INT PropertyId);
    virtual FString GetPropertyAsString(INT PropertyId);
    virtual FString GetPropertyAsStringByName(FName PropertyName);
    virtual UBOOL SetPropertyFromStringByName(FName PropertyName,const FString& NewValue);
    virtual void SetFloatProperty(INT PropertyId,FLOAT Value);
    virtual UBOOL GetFloatProperty(INT PropertyId,FLOAT& Value);
    virtual void SetIntProperty(INT PropertyId,INT Value);
    virtual UBOOL GetIntProperty(INT PropertyId,INT& Value);
    virtual void SetStringProperty(INT PropertyId,const FString& Value);
    virtual UBOOL GetStringProperty(INT PropertyId,FString& Value);
    virtual UBOOL SetPropertyValueId(INT PropertyId,INT ValueId);
    virtual UBOOL GetPropertyValueId(INT PropertyId,INT& ValueId);
    virtual BYTE GetPropertyType(INT PropertyId);
    virtual void UpdateStringSettings(const TArray<struct FLocalizedStringSetting>& Settings,UBOOL bShouldAddIfMissing=TRUE);
    virtual void UpdateProperties(const TArray<struct FSettingsProperty>& Props,UBOOL bShouldAddIfMissing=TRUE);
    virtual UBOOL HasProperty(INT PropertyId);
    virtual UBOOL HasStringSetting(INT SettingId);
    virtual UBOOL GetPropertyMappingType(INT PropertyId,BYTE& OutType);
    virtual UBOOL GetPropertyRange(INT PropertyId,FLOAT& OutMinValue,FLOAT& OutMaxValue,FLOAT& RangeIncrement,BYTE& bFormatAsInt);
    virtual UBOOL SetRangedPropertyValue(INT PropertyId,FLOAT NewValue);
    virtual UBOOL GetRangedPropertyValue(INT PropertyId,FLOAT& OutValue);
    virtual void GetQoSAdvertisedProperties(TArray<struct FSettingsProperty>& QoSProps);
    virtual void GetQoSAdvertisedStringSettings(TArray<struct FLocalizedStringSetting>& QoSSettings);
    virtual void AppendDataBindingsToURL(FString& URL);
    virtual void AppendPropertiesToURL(FString& URL);
    virtual void AppendContextsToURL(FString& URL);
    virtual void BuildURL(FString& URL);
    virtual void UpdateFromURL(const FString& URL,class AGameInfo* Game);
    DECLARE_FUNCTION(execSetSettingsDataFloat)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_FLOAT(InFloat);
        P_FINISH;
        this->SetSettingsDataFloat(Data,InFloat);
    }
    DECLARE_FUNCTION(execSetSettingsDataInt)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_INT(InInt);
        P_FINISH;
        this->SetSettingsDataInt(Data,InInt);
    }
    DECLARE_FUNCTION(execSetSettingsDataDateTime)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_INT(InInt1);
        P_GET_INT(InInt2);
        P_FINISH;
        this->SetSettingsDataDateTime(Data,InInt1,InInt2);
    }
    DECLARE_FUNCTION(execSetSettingsDataBlob)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_TARRAY_REF(BYTE,InBlob);
        P_FINISH;
        this->SetSettingsDataBlob(Data,InBlob);
    }
    DECLARE_FUNCTION(execSetSettingsData)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_STRUCT_REF(struct FSettingsData,Data2Copy);
        P_FINISH;
        this->SetSettingsData(Data,Data2Copy);
    }
    DECLARE_FUNCTION(execEmptySettingsData)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_FINISH;
        this->EmptySettingsData(Data);
    }
    DECLARE_FUNCTION(execGetSettingsDataFloat)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_FINISH;
        *(FLOAT*)Result=this->GetSettingsDataFloat(Data);
    }
    DECLARE_FUNCTION(execGetSettingsDataInt)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_FINISH;
        *(INT*)Result=this->GetSettingsDataInt(Data);
    }
    DECLARE_FUNCTION(execGetSettingsDataBlob)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_TARRAY_REF(BYTE,OutBlob);
        P_FINISH;
        this->GetSettingsDataBlob(Data,OutBlob);
    }
    DECLARE_FUNCTION(execGetSettingsDataDateTime)
    {
        P_GET_STRUCT_REF(struct FSettingsData,Data);
        P_GET_INT_REF(OutInt1);
        P_GET_INT_REF(OutInt2);
        P_FINISH;
        this->GetSettingsDataDateTime(Data,OutInt1,OutInt2);
    }
    DECLARE_FUNCTION(execSetStringSettingValue)
    {
        P_GET_INT(StringSettingId);
        P_GET_INT(ValueIndex);
        P_GET_UBOOL_OPTX(bShouldAutoAdd,FALSE);
        P_FINISH;
        this->SetStringSettingValue(StringSettingId,ValueIndex,bShouldAutoAdd);
    }
    DECLARE_FUNCTION(execGetStringSettingValue)
    {
        P_GET_INT(StringSettingId);
        P_GET_INT_REF(ValueIndex);
        P_FINISH;
        *(UBOOL*)Result=this->GetStringSettingValue(StringSettingId,ValueIndex);
    }
    DECLARE_FUNCTION(execIncrementStringSettingValue)
    {
        P_GET_INT(StringSettingId);
        P_GET_INT(Direction);
        P_GET_UBOOL(bShouldWrap);
        P_FINISH;
        *(UBOOL*)Result=this->IncrementStringSettingValue(StringSettingId,Direction,bShouldWrap);
    }
    DECLARE_FUNCTION(execGetStringSettingValueNames)
    {
        P_GET_INT(StringSettingId);
        P_GET_TARRAY_REF(struct FIdToStringMapping,Values);
        P_FINISH;
        *(UBOOL*)Result=this->GetStringSettingValueNames(StringSettingId,Values);
    }
    DECLARE_FUNCTION(execSetStringSettingValueByName)
    {
        P_GET_NAME(StringSettingName);
        P_GET_INT(ValueIndex);
        P_GET_UBOOL(bShouldAutoAdd);
        P_FINISH;
        this->SetStringSettingValueByName(StringSettingName,ValueIndex,bShouldAutoAdd);
    }
    DECLARE_FUNCTION(execGetStringSettingValueByName)
    {
        P_GET_NAME(StringSettingName);
        P_GET_INT_REF(ValueIndex);
        P_FINISH;
        *(UBOOL*)Result=this->GetStringSettingValueByName(StringSettingName,ValueIndex);
    }
    DECLARE_FUNCTION(execGetStringSettingId)
    {
        P_GET_NAME(StringSettingName);
        P_GET_INT_REF(StringSettingId);
        P_FINISH;
        *(UBOOL*)Result=this->GetStringSettingId(StringSettingName,StringSettingId);
    }
    DECLARE_FUNCTION(execGetStringSettingName)
    {
        P_GET_INT(StringSettingId);
        P_FINISH;
        *(FName*)Result=this->GetStringSettingName(StringSettingId);
    }
    DECLARE_FUNCTION(execGetStringSettingColumnHeader)
    {
        P_GET_INT(StringSettingId);
        P_FINISH;
        *(FString*)Result=this->GetStringSettingColumnHeader(StringSettingId);
    }
    DECLARE_FUNCTION(execIsWildcardStringSetting)
    {
        P_GET_INT(StringSettingId);
        P_FINISH;
        *(UBOOL*)Result=this->IsWildcardStringSetting(StringSettingId);
    }
    DECLARE_FUNCTION(execGetStringSettingValueName)
    {
        P_GET_INT(StringSettingId);
        P_GET_INT(ValueIndex);
        P_FINISH;
        *(FName*)Result=this->GetStringSettingValueName(StringSettingId,ValueIndex);
    }
    DECLARE_FUNCTION(execGetStringSettingValueNameByName)
    {
        P_GET_NAME(StringSettingName);
        P_FINISH;
        *(FName*)Result=this->GetStringSettingValueNameByName(StringSettingName);
    }
    DECLARE_FUNCTION(execSetStringSettingValueFromStringByName)
    {
        P_GET_NAME(StringSettingName);
        P_GET_STR_REF(NewValue);
        P_FINISH;
        *(UBOOL*)Result=this->SetStringSettingValueFromStringByName(StringSettingName,NewValue);
    }
    DECLARE_FUNCTION(execGetPropertyId)
    {
        P_GET_NAME(PropertyName);
        P_GET_INT_REF(PropertyId);
        P_FINISH;
        *(UBOOL*)Result=this->GetPropertyId(PropertyName,PropertyId);
    }
    DECLARE_FUNCTION(execGetPropertyName)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(FName*)Result=this->GetPropertyName(PropertyId);
    }
    DECLARE_FUNCTION(execGetPropertyColumnHeader)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(FString*)Result=this->GetPropertyColumnHeader(PropertyId);
    }
    DECLARE_FUNCTION(execGetPropertyAsString)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(FString*)Result=this->GetPropertyAsString(PropertyId);
    }
    DECLARE_FUNCTION(execGetPropertyAsStringByName)
    {
        P_GET_NAME(PropertyName);
        P_FINISH;
        *(FString*)Result=this->GetPropertyAsStringByName(PropertyName);
    }
    DECLARE_FUNCTION(execSetPropertyFromStringByName)
    {
        P_GET_NAME(PropertyName);
        P_GET_STR_REF(NewValue);
        P_FINISH;
        *(UBOOL*)Result=this->SetPropertyFromStringByName(PropertyName,NewValue);
    }
    DECLARE_FUNCTION(execSetFloatProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetFloatProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execGetFloatProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=this->GetFloatProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execSetIntProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_INT(Value);
        P_FINISH;
        this->SetIntProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execGetIntProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_INT_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=this->GetIntProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execSetStringProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_STR(Value);
        P_FINISH;
        this->SetStringProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execGetStringProperty)
    {
        P_GET_INT(PropertyId);
        P_GET_STR_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=this->GetStringProperty(PropertyId,Value);
    }
    DECLARE_FUNCTION(execSetPropertyValueId)
    {
        P_GET_INT(PropertyId);
        P_GET_INT(ValueId);
        P_FINISH;
        *(UBOOL*)Result=this->SetPropertyValueId(PropertyId,ValueId);
    }
    DECLARE_FUNCTION(execGetPropertyValueId)
    {
        P_GET_INT(PropertyId);
        P_GET_INT_REF(ValueId);
        P_FINISH;
        *(UBOOL*)Result=this->GetPropertyValueId(PropertyId,ValueId);
    }
    DECLARE_FUNCTION(execGetPropertyType)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(BYTE*)Result=this->GetPropertyType(PropertyId);
    }
    DECLARE_FUNCTION(execUpdateStringSettings)
    {
        P_GET_TARRAY_REF(struct FLocalizedStringSetting,Settings);
        P_GET_UBOOL_OPTX(bShouldAddIfMissing,TRUE);
        P_FINISH;
        this->UpdateStringSettings(Settings,bShouldAddIfMissing);
    }
    DECLARE_FUNCTION(execUpdateProperties)
    {
        P_GET_TARRAY_REF(struct FSettingsProperty,Props);
        P_GET_UBOOL_OPTX(bShouldAddIfMissing,TRUE);
        P_FINISH;
        this->UpdateProperties(Props,bShouldAddIfMissing);
    }
    DECLARE_FUNCTION(execHasProperty)
    {
        P_GET_INT(PropertyId);
        P_FINISH;
        *(UBOOL*)Result=this->HasProperty(PropertyId);
    }
    DECLARE_FUNCTION(execHasStringSetting)
    {
        P_GET_INT(SettingId);
        P_FINISH;
        *(UBOOL*)Result=this->HasStringSetting(SettingId);
    }
    DECLARE_FUNCTION(execGetPropertyMappingType)
    {
        P_GET_INT(PropertyId);
        P_GET_BYTE_REF(OutType);
        P_FINISH;
        *(UBOOL*)Result=this->GetPropertyMappingType(PropertyId,OutType);
    }
    DECLARE_FUNCTION(execGetPropertyRange)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT_REF(OutMinValue);
        P_GET_FLOAT_REF(OutMaxValue);
        P_GET_FLOAT_REF(RangeIncrement);
        P_GET_BYTE_REF(bFormatAsInt);
        P_FINISH;
        *(UBOOL*)Result=this->GetPropertyRange(PropertyId,OutMinValue,OutMaxValue,RangeIncrement,bFormatAsInt);
    }
    DECLARE_FUNCTION(execSetRangedPropertyValue)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT(NewValue);
        P_FINISH;
        *(UBOOL*)Result=this->SetRangedPropertyValue(PropertyId,NewValue);
    }
    DECLARE_FUNCTION(execGetRangedPropertyValue)
    {
        P_GET_INT(PropertyId);
        P_GET_FLOAT_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetRangedPropertyValue(PropertyId,OutValue);
    }
    DECLARE_FUNCTION(execGetQoSAdvertisedProperties)
    {
        P_GET_TARRAY_REF(struct FSettingsProperty,QoSProps);
        P_FINISH;
        this->GetQoSAdvertisedProperties(QoSProps);
    }
    DECLARE_FUNCTION(execGetQoSAdvertisedStringSettings)
    {
        P_GET_TARRAY_REF(struct FLocalizedStringSetting,QoSSettings);
        P_FINISH;
        this->GetQoSAdvertisedStringSettings(QoSSettings);
    }
    DECLARE_FUNCTION(execAppendDataBindingsToURL)
    {
        P_GET_STR_REF(URL);
        P_FINISH;
        this->AppendDataBindingsToURL(URL);
    }
    DECLARE_FUNCTION(execAppendPropertiesToURL)
    {
        P_GET_STR_REF(URL);
        P_FINISH;
        this->AppendPropertiesToURL(URL);
    }
    DECLARE_FUNCTION(execAppendContextsToURL)
    {
        P_GET_STR_REF(URL);
        P_FINISH;
        this->AppendContextsToURL(URL);
    }
    DECLARE_FUNCTION(execBuildURL)
    {
        P_GET_STR_REF(URL);
        P_FINISH;
        this->BuildURL(URL);
    }
    DECLARE_FUNCTION(execUpdateFromURL)
    {
        P_GET_STR_REF(URL);
        P_GET_OBJECT(AGameInfo,Game);
        P_FINISH;
        this->UpdateFromURL(URL,Game);
    }
    DECLARE_ABSTRACT_CLASS(USettings,UObject,0,Engine)
	/**
	 * Finds the specified property
	 *
	 * @param PropertyId to search for
	 *
	 * @return pointer to the property or NULL if not found
	 */
	FORCEINLINE FSettingsProperty* FindProperty(INT PropertyId)
	{
		for (INT PropertyIndex = 0; PropertyIndex < Properties.Num(); PropertyIndex++)
		{
			FSettingsProperty& Property = Properties(PropertyIndex);
			if (Property.PropertyId == PropertyId)
			{
				return &Property;
			}
		}
		return NULL;
	}

	/**
	 * Finds the specified localized string setting
	 *
	 * @param SettingId id of the setting to search for
	 *
	 * @return pointer to the string setting or NULL if not found
	 */
	FORCEINLINE FLocalizedStringSetting* FindStringSetting(INT SettingId)
	{
		for (INT SettingsIndex = 0; SettingsIndex < LocalizedSettings.Num(); SettingsIndex++)
		{
			FLocalizedStringSetting& Setting = LocalizedSettings(SettingsIndex);
			if (Setting.Id == SettingId)
			{
				return &Setting;
			}
		}
		return NULL;
	}

	/**
	 * Finds the specified localized string setting's meta data
	 *
	 * @param SettingId id of the setting to search the meta data for
	 *
	 * @return pointer to the string meta data or NULL if not found
	 */
	FORCEINLINE FLocalizedStringSettingMetaData* FindStringSettingMetaData(INT SettingId)
	{
		for (INT MetaDataIndex = 0; MetaDataIndex < LocalizedSettingsMappings.Num(); MetaDataIndex++)
		{
			FLocalizedStringSettingMetaData& MetaData = LocalizedSettingsMappings(MetaDataIndex);
			if (MetaData.Id == SettingId)
			{
				return &MetaData;
			}
		}
		return NULL;
	}

	/**
	 * Finds the specified property's meta data
	 *
	 * @param PropertyId id of the property to search the meta data for
	 *
	 * @return pointer to the property meta data or NULL if not found
	 */
	FORCEINLINE FSettingsPropertyPropertyMetaData* FindPropertyMetaData(INT PropertyId)
	{
		for (INT MetaDataIndex = 0; MetaDataIndex < PropertyMappings.Num(); MetaDataIndex++)
		{
			FSettingsPropertyPropertyMetaData& MetaData = PropertyMappings(MetaDataIndex);
			if (MetaData.Id == PropertyId)
			{
				return &MetaData;
			}
		}
		return NULL;
	}

	/** Finalize the clean up process */
	virtual void FinishDestroy(void);
};

struct FUniqueNetId
{
    QWORD Uid;

		/**
		 * The noinit version of the ctor
		 */
		FORCEINLINE FUniqueNetId(void)
		{
		}

		/**
		 * Zeros the data in the struct
		 *
		 * @param ignored. only present to allow zeroing of data
		 */
		FORCEINLINE FUniqueNetId(EEventParm)
		{
			Uid = (QWORD)0;
		}

		/**
		 * Zeros the data in the struct
		 *
		 * @param ignored. only present to allow zeroing of data
		 */
		FORCEINLINE FUniqueNetId(DWORD)
		{
			Uid = (QWORD)0;
		}

		/**
		 * Initialize from a QWORD
		 *
		 * @param InQWORD	The QWORD the UID should be initialized to
		 */
		FORCEINLINE FUniqueNetId(QWORD InQWORD)
		{
			Uid = InQWORD;
		}

		/** Copy constructor */
		FORCEINLINE FUniqueNetId(const FUniqueNetId& Other)
		{
			Uid = Other.Uid;
		}

		/**
		 * Compares the IDs for equality
		 *
		 * @param Id the value to compare
		 *
		 * @returns TRUE if they are equal, FALSE otherwise
		 */
		FORCEINLINE UBOOL operator==(const FUniqueNetId& Id) const
		{
			return Uid == Id.Uid;
		}

		/**
		 * Compares the IDs for inequality
		 *
		 * @param Id the value to compare
		 *
		 * @returns TRUE if they are not equal, FALSE otherwise
		 */
		FORCEINLINE UBOOL operator!=(const FUniqueNetId& Id) const
		{
			return Uid != Id.Uid;
		}

		/**
		 * Converts a DWORD into our type in network byte order
		 *
		 * @param Id the value to assign
		 */
		FORCEINLINE FUniqueNetId& operator=(const DWORD Id)
		{
#if WITH_PANORAMA || XBOX || WITH_STEAMWORKS
			check(0 && "Bad conversion loses data");
#else
			Uid = Id;
#endif
			return *this;
		}

		/**
		 * Converts a QWORD into our type in network byte order
		 *
		 * @param Id the value to assign
		 */
		FORCEINLINE FUniqueNetId& operator=(const QWORD Id)
		{
			Uid = Id;
			return *this;
		}

		/**
		 * Converts the unique id to a DWORD
		 *
		 * @return unique id as a DWORD
		 */
		FORCEINLINE DWORD ToDWORD(void) const
		{
#if WITH_PANORAMA || XBOX || WITH_STEAMWORKS
			check(0 && "Bad conversion loses data");
			return 0;
#else
			return Uid & 0xFFFFFFFF;
#endif
		}

		/**
		 * Accessor for determining whether this net id has been assigned a value.
		 */
		FORCEINLINE UBOOL HasValue() const
		{
			return (QWORD)0 != Uid;
		}

		/** serialization interface */
		friend FArchive& operator<<(FArchive& Ar, FUniqueNetId& Id)
		{
			Ar << Id.Uid;
			return Ar;
		}
	
};

struct FFriendsQuery
{
    struct FUniqueNetId UniqueId;
    BITFIELD bIsFriend:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FFriendsQuery() {}
    FFriendsQuery(EEventParm)
    {
        appMemzero(this, sizeof(FFriendsQuery));
    }
};

struct FOnlineFriend
{
    struct FUniqueNetId UniqueId;
    QWORD SessionId;
    FStringNoInit NickName;
    FStringNoInit PresenceInfo;
    BYTE FriendState;
    SCRIPT_ALIGN;
    BITFIELD bIsOnline:1;
    BITFIELD bIsPlaying:1;
    BITFIELD bIsPlayingThisGame:1;
    BITFIELD bIsJoinable:1;
    BITFIELD bHasVoiceSupport:1;
    BITFIELD bHaveInvited:1;
    BITFIELD bHasInvitedYou:1;
    SCRIPT_ALIGN;

		/**
		 * Zeroes members
		 */
		FOnlineFriend(void)
		{
			appMemzero(this,sizeof(FOnlineFriend));
		}

		/**
		 * Copy constructor. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FOnlineFriend(const FOnlineFriend& Other)
		{
			appMemzero(this,sizeof(FOnlineFriend));
			appMemcpy(&UniqueId,&Other.UniqueId,sizeof(FUniqueNetId));
			SessionId = Other.SessionId;
			NickName = Other.NickName;
			PresenceInfo = Other.PresenceInfo;
			FriendState = Other.FriendState;
			bIsOnline = Other.bIsOnline;
			bIsPlaying = Other.bIsPlaying;
			bIsPlayingThisGame = Other.bIsPlayingThisGame;
			bIsJoinable = Other.bIsJoinable;
			bHasVoiceSupport = Other.bHasVoiceSupport;
			bHaveInvited = Other.bHaveInvited;
			bHasInvitedYou = Other.bHasInvitedYou;
		}

		/**
		 * Assignment operator. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FOnlineFriend& operator=(const FOnlineFriend& Other)
		{
			if (this != &Other)
			{
				appMemcpy(&UniqueId,&Other.UniqueId,sizeof(FUniqueNetId));
				SessionId = Other.SessionId;
				NickName = Other.NickName;
				PresenceInfo = Other.PresenceInfo;
				FriendState = Other.FriendState;
				bIsOnline = Other.bIsOnline;
				bIsPlaying = Other.bIsPlaying;
				bIsPlayingThisGame = Other.bIsPlayingThisGame;
				bIsJoinable = Other.bIsJoinable;
				bHasVoiceSupport = Other.bHasVoiceSupport;
				bHaveInvited = Other.bHaveInvited;
				bHasInvitedYou = Other.bHasInvitedYou;
			}
			return *this;
		}
	
};

struct FOnlineContent
{
    BYTE ContentType;
    BYTE UserIndex;
    SCRIPT_ALIGN;
    BITFIELD bIsCorrupt:1;
    INT DeviceID;
    INT LicenseMask;
    FStringNoInit FriendlyName;
    FStringNoInit Filename;
    FStringNoInit ContentPath;
    TArrayNoInit<FString> ContentPackages;
    TArrayNoInit<FString> ContentFiles;

    /** Constructors */
    FOnlineContent() {}
    FOnlineContent(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineContent));
    }
};

struct FOnlineCrossTitleContent : public FOnlineContent
{
    INT TitleId;

    /** Constructors */
    FOnlineCrossTitleContent() {}
    FOnlineCrossTitleContent(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineCrossTitleContent));
    }
};

struct FOnlineRegistrant
{
    struct FUniqueNetId PlayerNetId;

		/**
		 * The noinit version of the ctor
		 */
		FORCEINLINE FOnlineRegistrant(void)
		{
		}

		/**
		 * Inits it to the player id specified
		 *
		 * @param InId sets the player id
		 */
		FORCEINLINE FOnlineRegistrant(const FUniqueNetId InId) :
			PlayerNetId(InId)
		{
		}

		/**
		 * Compares the player IDs for equality
		 *
		 * @param Id the value to compare
		 *
		 * @returns TRUE if they are equal, FALSE otherwise
		 */
		FORCEINLINE UBOOL operator==(const FOnlineRegistrant& Other) const
		{
			return PlayerNetId == Other.PlayerNetId;
		}
	
};

struct FOnlineArbitrationRegistrant : public FOnlineRegistrant
{
    QWORD MachineId;
    INT Trustworthiness;

    /** Constructors */
    FOnlineArbitrationRegistrant() {}
    FOnlineArbitrationRegistrant(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineArbitrationRegistrant));
    }
};

struct FOnlinePlayerScore
{
    struct FUniqueNetId PlayerID;
    INT TeamID;
    INT Score;

    /** Constructors */
    FOnlinePlayerScore() {}
    FOnlinePlayerScore(EEventParm)
    {
        appMemzero(this, sizeof(FOnlinePlayerScore));
    }
};

struct FLocalTalker
{
    BITFIELD bHasVoice:1;
    BITFIELD bHasNetworkedVoice:1;
    BITFIELD bIsRecognizingSpeech:1;
    BITFIELD bWasTalking:1;
    BITFIELD bIsTalking:1;
    BITFIELD bIsRegistered:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FLocalTalker() {}
    FLocalTalker(EEventParm)
    {
        appMemzero(this, sizeof(FLocalTalker));
    }
};

struct FRemoteTalker
{
    struct FUniqueNetId TalkerId;
    FLOAT LastNotificationTime;
    BITFIELD bWasTalking:1;
    BITFIELD bIsTalking:1;
    BITFIELD bIsRegistered:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FRemoteTalker() {}
    FRemoteTalker(EEventParm)
    {
        appMemzero(this, sizeof(FRemoteTalker));
    }
};

struct FOnlineFriendMessage
{
    struct FUniqueNetId SendingPlayerId;
    FStringNoInit SendingPlayerNick;
    BITFIELD bIsFriendInvite:1;
    BITFIELD bIsGameInvite:1;
    BITFIELD bWasAccepted:1;
    BITFIELD bWasDenied:1;
    FStringNoInit Message;

    /** Constructors */
    FOnlineFriendMessage() {}
    FOnlineFriendMessage(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineFriendMessage));
    }
};

struct FNamedInterface
{
    FName InterfaceName;
    class UObject* InterfaceObject;

    /** Constructors */
    FNamedInterface() {}
    FNamedInterface(EEventParm)
    {
        appMemzero(this, sizeof(FNamedInterface));
    }
};

struct FNamedInterfaceDef
{
    FName InterfaceName;
    FStringNoInit InterfaceClassName;

    /** Constructors */
    FNamedInterfaceDef() {}
    FNamedInterfaceDef(EEventParm)
    {
        appMemzero(this, sizeof(FNamedInterfaceDef));
    }
};

struct FEmsFile
{
    FStringNoInit Hash;
    FStringNoInit DLName;
    FStringNoInit Filename;
    INT FileSize;

    /** Constructors */
    FEmsFile() {}
    FEmsFile(EEventParm)
    {
        appMemzero(this, sizeof(FEmsFile));
    }
};

struct FTitleFile
{
    FStringNoInit Filename;
    BYTE AsyncState;
    TArrayNoInit<BYTE> Data;

    /** Constructors */
    FTitleFile() {}
    FTitleFile(EEventParm)
    {
        appMemzero(this, sizeof(FTitleFile));
    }
};

struct FCommunityContentFile
{
    INT ContentId;
    INT FileId;
    INT ContentType;
    INT FileSize;
    struct FUniqueNetId Owner;
    INT DownloadCount;
    FLOAT AverageRating;
    INT RatingCount;
    INT LastRatingGiven;
    FStringNoInit LocalFilePath;

    /** Constructors */
    FCommunityContentFile() {}
    FCommunityContentFile(EEventParm)
    {
        appMemzero(this, sizeof(FCommunityContentFile));
    }
};

struct FCommunityContentMetadata
{
    INT ContentType;
    TArrayNoInit<struct FSettingsProperty> MetadataItems;

    /** Constructors */
    FCommunityContentMetadata() {}
    FCommunityContentMetadata(EEventParm)
    {
        appMemzero(this, sizeof(FCommunityContentMetadata));
    }
};

struct FNamedSession
{
    FName SessionName;
    void* SessionInfo;
    class UOnlineGameSettings* GameSettings;
    TArrayNoInit<struct FOnlineRegistrant> Registrants;
    TArrayNoInit<struct FOnlineArbitrationRegistrant> ArbitrationRegistrants;

    /** Constructors */
    FNamedSession() {}
    FNamedSession(EEventParm)
    {
        appMemzero(this, sizeof(FNamedSession));
    }
};

struct FAchievementDetails
{
    INT Id;
    FStringNoInit AchievementName;
    FStringNoInit Description;
    FStringNoInit HowTo;
    class USurface* Image;
    BYTE MonthEarned;
    BYTE DayEarned;
    BYTE YearEarned;
    BYTE DayOfWeekEarned;
    INT GamerPoints;
    BITFIELD bIsSecret:1;
    BITFIELD bWasAchievedOnline:1;
    BITFIELD bWasAchievedOffline:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FAchievementDetails() {}
    FAchievementDetails(EEventParm)
    {
        appMemzero(this, sizeof(FAchievementDetails));
    }
};

struct FOnlinePartyMember
{
    struct FUniqueNetId UniqueId;
    FStringNoInit NickName;
    BYTE LocalUserNum;
    BYTE NatType;
    INT TitleId;
    BITFIELD bIsLocal:1;
    BITFIELD bIsInPartyVoice:1;
    BITFIELD bIsTalking:1;
    BITFIELD bIsInGameSession:1;
    BITFIELD bIsPlayingThisGame:1;
    SCRIPT_ALIGN;
    QWORD SessionId;
    INT Data1;
    INT Data2;
    INT Data3;
    INT Data4;

    /** Constructors */
    FOnlinePartyMember() {}
    FOnlinePartyMember(EEventParm)
    {
        appMemzero(this, sizeof(FOnlinePartyMember));
    }
};

struct FSocialPostPrivileges
{
    BITFIELD bCanPostImage:1;
    BITFIELD bCanPostLink:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FSocialPostPrivileges() {}
    FSocialPostPrivileges(EEventParm)
    {
        appMemzero(this, sizeof(FSocialPostPrivileges));
    }
};

struct FSocialPostImageFlags
{
    BITFIELD bIsUserGeneratedImage:1;
    BITFIELD bIsGameGeneratedImage:1;
    BITFIELD bIsAchievementImage:1;
    BITFIELD bIsMediaImage:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FSocialPostImageFlags() {}
    FSocialPostImageFlags(EEventParm)
    {
        appMemzero(this, sizeof(FSocialPostImageFlags));
    }
};

struct FSocialPostImageInfo
{
    struct FSocialPostImageFlags Flags;
    FStringNoInit MessageText;
    FStringNoInit TitleText;
    FStringNoInit PictureCaption;
    FStringNoInit PictureDescription;

    /** Constructors */
    FSocialPostImageInfo() {}
    FSocialPostImageInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSocialPostImageInfo));
    }
};

struct FSocialPostLinkInfo : public FSocialPostImageInfo
{
    FStringNoInit TitleURL;
    FStringNoInit PictureURL;

    /** Constructors */
    FSocialPostLinkInfo() {}
    FSocialPostLinkInfo(EEventParm)
    {
        appMemzero(this, sizeof(FSocialPostLinkInfo));
    }
};

struct OnlineSubsystem_eventGetPlayerUniqueNetIdFromIndex_Parms
{
    INT UserIndex;
    struct FUniqueNetId ReturnValue;
    OnlineSubsystem_eventGetPlayerUniqueNetIdFromIndex_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventGetNamedInterface_Parms
{
    FName InterfaceName;
    class UObject* ReturnValue;
    OnlineSubsystem_eventGetNamedInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetNamedInterface_Parms
{
    FName InterfaceName;
    class UObject* NewInterface;
    OnlineSubsystem_eventSetNamedInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetSharedCloudInterface_Parms
{
    class UObject* InCloudInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetSharedCloudInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetUserCloudInterface_Parms
{
    class UObject* InCloudInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetUserCloudInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetAuthInterface_Parms
{
    class UObject* InAuthInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetAuthInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetSocialInterface_Parms
{
    class UObject* InSocialInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetSocialInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetTitleFileCacheInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetTitleFileCacheInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetTitleFileInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetTitleFileInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetPartyChatInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetPartyChatInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetNewsInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetNewsInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetStatsInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetStatsInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetVoiceInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetVoiceInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetContentInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetContentInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetGameInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetGameInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetSystemInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetSystemInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetPlayerInterfaceEx_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetPlayerInterfaceEx_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetPlayerInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetPlayerInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventSetAccountInterface_Parms
{
    class UObject* NewInterface;
    UBOOL ReturnValue;
    OnlineSubsystem_eventSetAccountInterface_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventExit_Parms
{
    OnlineSubsystem_eventExit_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventPostInit_Parms
{
    UBOOL ReturnValue;
    OnlineSubsystem_eventPostInit_Parms(EEventParm)
    {
    }
};
struct OnlineSubsystem_eventInit_Parms
{
    UBOOL ReturnValue;
    OnlineSubsystem_eventInit_Parms(EEventParm)
    {
    }
};
class UOnlineSubsystem : public UObject, public FTickableObject
{
public:
    //## BEGIN PROPS OnlineSubsystem
    TScriptInterface<class IInterface> AccountInterface;
    TScriptInterface<class IInterface> PlayerInterface;
    TScriptInterface<class IInterface> PlayerInterfaceEx;
    TScriptInterface<class IInterface> SystemInterface;
    TScriptInterface<class IInterface> GameInterface;
    TScriptInterface<class IInterface> ContentInterface;
    TScriptInterface<class IInterface> VoiceInterface;
    TScriptInterface<class IInterface> StatsInterface;
    TScriptInterface<class IInterface> NewsInterface;
    TScriptInterface<class IInterface> PartyChatInterface;
    TScriptInterface<class IInterface> TitleFileInterface;
    TScriptInterface<class IInterface> TitleFileCacheInterface;
    TScriptInterface<class IInterface> UserCloudInterface;
    TScriptInterface<class IInterface> SharedCloudInterface;
    TScriptInterface<class IInterface> SocialInterface;
    TScriptInterface<class IOnlineAuthInterface> AuthInterface;
    TArrayNoInit<struct FNamedInterface> NamedInterfaces;
    TArrayNoInit<struct FNamedInterfaceDef> NamedInterfaceDefs;
    TArrayNoInit<struct FNamedSession> Sessions;
    BITFIELD bUseBuildIdOverride:1;
    INT BuildIdOverride;
    FStringNoInit IniLocPatcherClassName;
    class UIniLocPatcher* Patcher;
    FLOAT AsyncMinCompletionTime;
    //## END PROPS OnlineSubsystem

    virtual UBOOL Init();
    virtual INT GetBuildUniqueId();
    INT GetNumSupportedLogins();
    DECLARE_FUNCTION(execInit)
    {
        P_FINISH;
        *(UBOOL*)Result=this->Init();
    }
    DECLARE_FUNCTION(execUniqueNetIdToString)
    {
        P_GET_STRUCT_REF(struct FUniqueNetId,IdToConvert);
        P_FINISH;
        *(FString*)Result=this->UniqueNetIdToString(IdToConvert);
    }
    DECLARE_FUNCTION(execStringToUniqueNetId)
    {
        P_GET_STR(UniqueNetIdString);
        P_GET_STRUCT_REF(struct FUniqueNetId,out_UniqueId);
        P_FINISH;
        *(UBOOL*)Result=this->StringToUniqueNetId(UniqueNetIdString,out_UniqueId);
    }
    DECLARE_FUNCTION(execGetBuildUniqueId)
    {
        P_FINISH;
        *(INT*)Result=this->GetBuildUniqueId();
    }
    DECLARE_FUNCTION(execGetNumSupportedLogins)
    {
        P_FINISH;
        *(INT*)Result=this->GetNumSupportedLogins();
    }
    struct FUniqueNetId eventGetPlayerUniqueNetIdFromIndex(INT UserIndex)
    {
        OnlineSubsystem_eventGetPlayerUniqueNetIdFromIndex_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.UserIndex=UserIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_GetPlayerUniqueNetIdFromIndex),&Parms);
        return Parms.ReturnValue;
    }
    class UObject* eventGetNamedInterface(FName InterfaceName)
    {
        OnlineSubsystem_eventGetNamedInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.InterfaceName=InterfaceName;
        ProcessEvent(FindFunctionChecked(ENGINE_GetNamedInterface),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetNamedInterface(FName InterfaceName,class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetNamedInterface_Parms Parms(EC_EventParm);
        Parms.InterfaceName=InterfaceName;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetNamedInterface),&Parms);
    }
    UBOOL eventSetSharedCloudInterface(class UObject* InCloudInterface)
    {
        OnlineSubsystem_eventSetSharedCloudInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.InCloudInterface=InCloudInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetSharedCloudInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetUserCloudInterface(class UObject* InCloudInterface)
    {
        OnlineSubsystem_eventSetUserCloudInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.InCloudInterface=InCloudInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetUserCloudInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetAuthInterface(class UObject* InAuthInterface)
    {
        OnlineSubsystem_eventSetAuthInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.InAuthInterface=InAuthInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetAuthInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetSocialInterface(class UObject* InSocialInterface)
    {
        OnlineSubsystem_eventSetSocialInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.InSocialInterface=InSocialInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetSocialInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetTitleFileCacheInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetTitleFileCacheInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetTitleFileCacheInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetTitleFileInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetTitleFileInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetTitleFileInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetPartyChatInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetPartyChatInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPartyChatInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetNewsInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetNewsInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetNewsInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetStatsInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetStatsInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetStatsInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetVoiceInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetVoiceInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetVoiceInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetContentInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetContentInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetContentInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetGameInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetGameInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetGameInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetSystemInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetSystemInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetSystemInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetPlayerInterfaceEx(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetPlayerInterfaceEx_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPlayerInterfaceEx),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetPlayerInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetPlayerInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetPlayerInterface),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSetAccountInterface(class UObject* NewInterface)
    {
        OnlineSubsystem_eventSetAccountInterface_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewInterface=NewInterface;
        ProcessEvent(FindFunctionChecked(ENGINE_SetAccountInterface),&Parms);
        return Parms.ReturnValue;
    }
    void eventExit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Exit),NULL);
    }
    UBOOL eventPostInit()
    {
        OnlineSubsystem_eventPostInit_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_PostInit),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInit()
    {
        OnlineSubsystem_eventInit_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_Init),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UOnlineSubsystem,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

// FTickableObject interface

	/**
	 * Returns whether it is okay to tick this object. E.g. objects being loaded in the background shouldn't be ticked
	 * till they are finalized and unreachable objects cannot be ticked either.
	 *
	 * @return	TRUE if tickable, FALSE otherwise
	 */
	virtual UBOOL IsTickable() const
	{
		// We cannot tick objects that are unreachable or are in the process of being loaded in the background.
		return !HasAnyFlags( RF_Unreachable | RF_AsyncLoading );
	}

	/**
	 * Used to determine if an object should be ticked when the game is paused.
	 *
	 * @return always TRUE as networking needs to be ticked even when paused
	 */
	virtual UBOOL IsTickableWhenPaused() const
	{
		return TRUE;
	}

	/**
	 * Here to complete the interface but needs to be overriden
	 *
	 * @param ignored
	 */
	virtual void Tick(FLOAT)
	{
		check(0 && "Must be overridden");
	}

	/**
	 * Generates a string representation of a UniqueNetId struct.
	 *
	 * @param	IdToConvert		the unique net id that should be converted to a string.
	 *
	 * @return	the specified UniqueNetId represented as a string.
	 */
	static FString UniqueNetIdToString( const FUniqueNetId& IdToConvert );

	/**
	 * Converts a string representing a UniqueNetId into a UniqueNetId struct.
	 *
	 * @param	UniqueNetIdString	the string containing the text representation of the unique id.
	 * @param	out_UniqueId		will receive the UniqueNetId generated from the string.
	 *
	 * @return	TRUE if the string was successfully converted into a UniqueNetId; FALSE if the string was not a valid UniqueNetId.
	 */
	static UBOOL StringToUniqueNetId( const FString& UniqueNetIdString, FUniqueNetId& out_UniqueId );

	/**
	 * Searches the named session array for the specified session
	 *
	 * @param SessionName the name to search for
	 *
	 * @return pointer to the struct if found, NULL otherwise
	 */
	inline FNamedSession* GetNamedSession(FName SessionName)
	{
		for (INT SearchIndex = 0; SearchIndex < Sessions.Num(); SearchIndex++)
		{
			if (Sessions(SearchIndex).SessionName == SessionName)
			{
				return &Sessions(SearchIndex);
			}
		}
		return NULL;
	}

	/**
	 * Searches the named session array for the specified session
	 *
	 * @param SessionName the name to search for
	 *
	 * @return TRUE if found, FALSE otherwise
	 */
	inline UBOOL HasNamedSession(FName SessionName)
	{
		return GetNamedSession(SessionName) != NULL;
	}

	/**
	 * Adds a new named session to the list
	 *
	 * @param SessionName the name to search for
	 * @param GameSettings the game settings to add
	 *
	 * @return a pointer to the struct that was added
	 */
	inline FNamedSession* AddNamedSession(FName SessionName,UOnlineGameSettings* GameSettings)
	{
		INT AddIndex = Sessions.AddZeroed();
		Sessions(AddIndex).SessionName = SessionName;
		Sessions(AddIndex).GameSettings = GameSettings;
		return &Sessions(AddIndex);
	}

	/**
	 * Searches the named session array for the specified session and removes it
	 *
	 * @param SessionName the name to search for
	 */
	virtual void RemoveNamedSession(FName SessionName)
	{
		for (INT SearchIndex = 0; SearchIndex < Sessions.Num(); SearchIndex++)
		{
			if (Sessions(SearchIndex).SessionName == SessionName)
			{
				Sessions.Remove(SearchIndex);
				return;
			}
		}
	}

	/**
	 * @return platform specific id for a session
	 */
	virtual QWORD GetSessionId(FName SessionName)
	{
		return 0;
	}

	/**
	 * @return platform specific id for a session from a search result
	 */
	virtual QWORD GetSearchResultSessionId(const struct FOnlineGameSearchResult* SearchResult)
	{
		return 0;
	}

	/**
	 * Notification sent to OnlineSubsystem that pre-travel cleanup is occuring
	 *
	 * @param bSessionEnded		whether or not the game session has ended
	 */
	virtual void NotifyCleanupWorld(UBOOL bSessionEnded)
	{
	}
};

struct FBaseAuthSession
{
    INT EndPointIP;
    INT EndPointPort;
    struct FUniqueNetId EndPointUID;

    /** Constructors */
    FBaseAuthSession() {}
    FBaseAuthSession(EEventParm)
    {
        appMemzero(this, sizeof(FBaseAuthSession));
    }
};

struct FLocalAuthSession : public FBaseAuthSession
{
    INT SessionUID;

    /** Constructors */
    FLocalAuthSession() {}
    FLocalAuthSession(EEventParm)
    {
        appMemzero(this, sizeof(FLocalAuthSession));
    }
};

struct FAuthSession : public FBaseAuthSession
{
    BYTE AuthStatus;
    INT AuthTicketUID;

    /** Constructors */
    FAuthSession() {}
    FAuthSession(EEventParm)
    {
        appMemzero(this, sizeof(FAuthSession));
    }
};

class UOnlineAuthInterface : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UOnlineAuthInterface,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineAuthInterface)
};

class IOnlineAuthInterface
{
protected:
	virtual ~IOnlineAuthInterface() {}
public:
	typedef UOnlineAuthInterface UClassType;
	virtual UObject* GetUObjectInterfaceOnlineAuthInterface()=0;
    virtual void delegateOnServerConnectionClose(class UPlayer* ServerConnection)=0;
    virtual void delegateOnClientConnectionClose(class UPlayer* ClientConnection)=0;
    virtual void delegateOnServerAuthRetryRequest(class UPlayer* ClientConnection)=0;
    virtual void delegateOnClientAuthEndSessionRequest(class UPlayer* ServerConnection)=0;
    virtual void delegateOnServerAuthComplete(UBOOL bSuccess,struct FUniqueNetId ServerUID,class UPlayer* ServerConnection,const FString& ExtraInfo)=0;
    virtual void delegateOnClientAuthComplete(UBOOL bSuccess,struct FUniqueNetId ClientUID,class UPlayer* ClientConnection,const FString& ExtraInfo)=0;
    virtual void delegateOnServerAuthResponse(struct FUniqueNetId ServerUID,INT ServerIP,INT AuthTicketUID)=0;
    virtual void delegateOnClientAuthResponse(struct FUniqueNetId ClientUID,INT ClientIP,INT AuthTicketUID)=0;
    virtual void delegateOnServerAuthRequest(class UPlayer* ClientConnection,struct FUniqueNetId ClientUID,INT ClientIP,INT ClientPort)=0;
    virtual void delegateOnClientAuthRequest(struct FUniqueNetId ServerUID,INT ServerIP,INT ServerPort,UBOOL bSecure)=0;
    virtual void delegateOnAuthReady()=0;
    NO_DEFAULT_CONSTRUCTOR(IOnlineAuthInterface)
};

struct AutoTestManager_eventStartAutomatedMapTestTimer_Parms
{
    AutoTestManager_eventStartAutomatedMapTestTimer_Parms(EEventParm)
    {
    }
};
class AAutoTestManager : public AInfo
{
public:
    //## BEGIN PROPS AutoTestManager
    BITFIELD bAutomatedPerfTesting:1;
    BITFIELD bAutoContinueToNextRound:1;
    BITFIELD bUsingAutomatedTestingMapList:1;
    BITFIELD bAutomatedTestingWithOpen:1;
    BITFIELD bExitOnCyclesComplete:1;
    BITFIELD bCheckingForFragmentation:1;
    BITFIELD bCheckingForMemLeaks:1;
    BITFIELD bDoingASentinelRun:1;
    BITFIELD bSentinelStreamingLevelStillLoading:1;
    INT AutomatedPerfRemainingTime;
    INT AutomatedTestingMapIndex;
    TArrayNoInit<FString> AutomatedMapTestingList;
    INT NumAutomatedMapTestingCycles;
    INT NumberOfMatchesPlayed;
    INT NumMapListCyclesDone;
    FStringNoInit AutomatedTestingExecCommandToRunAtStartMatch;
    FStringNoInit AutomatedMapTestingTransitionMap;
    FStringNoInit SentinelTaskDescription;
    FStringNoInit SentinelTaskParameter;
    FStringNoInit SentinelTagDesc;
    class APlayerController* SentinelPC;
    TArrayNoInit<FVector> SentinelTravelArray;
    INT SentinelNavigationIdx;
    INT SentinelIdx;
    INT NumRotationsIncrement;
    INT TravelPointsIncrement;
    INT NumMinutesPerMap;
    TArrayNoInit<FString> CommandsToRunAtEachTravelTheWorldNode;
    FStringNoInit CommandStringToExec;
    //## END PROPS AutoTestManager

    virtual void BeginSentinelRun(const FString& TaskDescription,const FString& TaskParameter,const FString& TagDesc);
    virtual void AddSentinelPerTimePeriodStats(const FVector InLocation,const FRotator InRotation);
    virtual void EndSentinelRun(BYTE RunResult);
    virtual void DoSentinelActionPerLoadedMap();
    virtual void HandlePerLoadedMapAudioStats();
    virtual void GetTravelLocations(FName LevelName,class APlayerController* PC,TArray<FVector>& TravelPoints);
    virtual void DoSentinel_MemoryAtSpecificLocation(const FVector InLocation,const FRotator InRotation);
    virtual void DoSentinel_PerfAtSpecificLocation(const FVector& InLocation,const FRotator& InRotation);
    virtual void DoSentinel_ViewDependentMemoryAtSpecificLocation(const FVector& InLocation,const FRotator& InRotation);
    virtual void DoMemoryTracking();
    DECLARE_FUNCTION(execBeginSentinelRun)
    {
        P_GET_STR(TaskDescription);
        P_GET_STR(TaskParameter);
        P_GET_STR(TagDesc);
        P_FINISH;
        this->BeginSentinelRun(TaskDescription,TaskParameter,TagDesc);
    }
    DECLARE_FUNCTION(execAddSentinelPerTimePeriodStats)
    {
        P_GET_STRUCT(FVector,InLocation);
        P_GET_STRUCT(FRotator,InRotation);
        P_FINISH;
        this->AddSentinelPerTimePeriodStats(InLocation,InRotation);
    }
    DECLARE_FUNCTION(execEndSentinelRun)
    {
        P_GET_BYTE(RunResult);
        P_FINISH;
        this->EndSentinelRun(RunResult);
    }
    DECLARE_FUNCTION(execDoSentinelActionPerLoadedMap)
    {
        P_FINISH;
        this->DoSentinelActionPerLoadedMap();
    }
    DECLARE_FUNCTION(execHandlePerLoadedMapAudioStats)
    {
        P_FINISH;
        this->HandlePerLoadedMapAudioStats();
    }
    DECLARE_FUNCTION(execGetTravelLocations)
    {
        P_GET_NAME(LevelName);
        P_GET_OBJECT(APlayerController,PC);
        P_GET_TARRAY_REF(FVector,TravelPoints);
        P_FINISH;
        this->GetTravelLocations(LevelName,PC,TravelPoints);
    }
    DECLARE_FUNCTION(execDoSentinel_MemoryAtSpecificLocation)
    {
        P_GET_STRUCT(FVector,InLocation);
        P_GET_STRUCT(FRotator,InRotation);
        P_FINISH;
        this->DoSentinel_MemoryAtSpecificLocation(InLocation,InRotation);
    }
    DECLARE_FUNCTION(execDoSentinel_PerfAtSpecificLocation)
    {
        P_GET_STRUCT_REF(FVector,InLocation);
        P_GET_STRUCT_REF(FRotator,InRotation);
        P_FINISH;
        this->DoSentinel_PerfAtSpecificLocation(InLocation,InRotation);
    }
    DECLARE_FUNCTION(execDoSentinel_ViewDependentMemoryAtSpecificLocation)
    {
        P_GET_STRUCT_REF(FVector,InLocation);
        P_GET_STRUCT_REF(FRotator,InRotation);
        P_FINISH;
        this->DoSentinel_ViewDependentMemoryAtSpecificLocation(InLocation,InRotation);
    }
    DECLARE_FUNCTION(execDoMemoryTracking)
    {
        P_FINISH;
        this->DoMemoryTracking();
    }
    void eventStartAutomatedMapTestTimer()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StartAutomatedMapTestTimer),NULL);
    }
    DECLARE_CLASS(AAutoTestManager,AInfo,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(AAutoTestManager)
};

#define UCONST_BLOCKEDPATHCOST 10000000

class UReachSpec : public UObject
{
public:
    //## BEGIN PROPS ReachSpec
    struct FNavigationOctreeObject* NavOctreeObject;
    INT Distance;
    FVector Direction;
    class ANavigationPoint* Start;
    struct FActorReference End;
    INT CollisionRadius;
    INT CollisionHeight;
    INT reachFlags;
    INT MaxLandingVelocity;
    BYTE bPruned;
    BYTE PathColorIndex;
    SCRIPT_ALIGN;
    BITFIELD bAddToNavigationOctree:1;
    BITFIELD bCanCutCorners:1;
    BITFIELD bCheckForObstructions:1;
    BITFIELD bSkipPrune:1;
    BITFIELD bDisabled:1;
    TArrayNoInit<class UClass*> PruneSpecList;
    class AActor* BlockedBy;
    //## END PROPS ReachSpec

    DECLARE_FUNCTION(execCostFor);
    DECLARE_FUNCTION(execGetEnd);
    DECLARE_FUNCTION(execGetDirection);
    DECLARE_CLASS(UReachSpec,UObject,0,Engine)
	/*
	supports() -
	returns true if it supports the requirements of aPawn.  Distance is not considered.
	*/
	inline UBOOL supports (INT iRadius, INT iHeight, INT moveFlags, INT iMaxFallVelocity)
	{
		return ( (CollisionRadius >= iRadius)
			&& (CollisionHeight >= iHeight)
			&& ((reachFlags & moveFlags) == reachFlags)
			&& (MaxLandingVelocity <= iMaxFallVelocity) );
	}

	FVector GetDirection();

	/** CostFor()
	Returns the "cost" in unreal units
	for Pawn P to travel from the start to the end of this reachspec
	*/
	virtual INT CostFor( APawn* P );
	/** AdjustedCostFor
	*	Used by NewBestPathTo for heuristic weighting
	*/
	virtual INT AdjustedCostFor( APawn* P, const FVector& StartToGoalDir, ANavigationPoint* Goal, INT Cost );
	virtual UBOOL PrepareForMove( AController * C );
	virtual UBOOL IsForced() { return false; }
	virtual UBOOL IsProscribed() const { return false; }
	virtual INT defineFor (class ANavigationPoint *begin, class ANavigationPoint * dest, class APawn * Scout);
	int operator<= (const UReachSpec &Spec);
	virtual FPlane PathColor();
	virtual void AddToDebugRenderProxy(class FDebugRenderSceneProxy* DRSP);
	int findBestReachable(class AScout *Scout);
	UBOOL ShouldPruneAgainst( UReachSpec* Spec );

	/** If bAddToNavigationOctree is true, adds the ReachSpec to the navigation octree */
	void AddToNavigationOctree();
	void RemoveFromNavigationOctree();
	/** returns whether TestBox overlaps the path this ReachSpec represents
	 * @note this function assumes that TestBox has already passed a bounding box overlap check
	 * @param TestBox the box to check
	 * @return true if the box doesn't overlap this path, false if it does
	 */
	UBOOL NavigationOverlapCheck(const FBox& TestBox);
	/** returns whether Point is within MaxDist units of the path this ReachSpec represents
	 * @param Point the point to check
	 * @param MaxDist the maximum distance the point can be from the path
	 * @return true if the point is within MaxDist units, false otherwise
	 */
	UBOOL IsOnPath(const FVector& Point, FLOAT MaxDist);
	/** returns whether this path is currently blocked and unusable to the given pawn */
	UBOOL IsBlockedFor(APawn* P);

	virtual void FinishDestroy();

	/** Get path size for a forced path between Start/End */
	virtual FVector GetForcedPathSize( class ANavigationPoint* Start, class ANavigationPoint* End, class AScout* Scout );

	/** return TRUE if it's safe to skip ahead past this edge, FALSE otherwise */
	virtual UBOOL CanBeSkipped( APawn* P )
	{
		return TRUE;
	}

	//debug
	FString PrintDebugInfo();
};

#define UCONST_INFINITE_PATH_COST 10000000

struct FNavigationOctreeObject
{
    FBox BoundingBox;
    FVector BoxCenter;
    class FNavigationOctreeNode* OctreeNode;
    SCRIPT_ALIGN;

	 enum ENavOctreeObjectType
	 {
	 	NAV_NavigationPoint = 0x01,
	 	NAV_ReachSpec = 0x02,
	 };
	 private:
	 	UObject* Owner;
	 	BYTE OwnerType;
	 public:
	 	/** constructor, makes sure OctreeNode is NULL */
	 	FNavigationOctreeObject()
	 	: OctreeNode(NULL), Owner(NULL), OwnerType(0)
	 	{}
	 	/** destructor, removes us from the octree if we're still there */
	 	~FNavigationOctreeObject();
		/** sets the object's owner and initializes the OwnerType for fast cast to common types */
		void SetOwner(UObject* InOwner);

		/** sets the object's bounding box
		 * if the object is currently in the octree, re-adds it
		 * @param InBoundingBox the new bounding box to use
		 */
		void SetBox(const FBox& InBoundingBox);

		/** overlap check function called after the axis aligned bounding box check succeeds
		 * allows for more precise checks for certain object types
		 * @param TestBox the box to check
		 * @return true if the box doesn't overlap this object, false if it does
		 */
		UBOOL OverlapCheck(const FBox& TestBox);

		/** templated accessor to Owner, to avoid casting for common cases
		 * @note T must be UObject or a subclass, or this function will not compile
		 */
		template<class T> FORCEINLINE T* GetOwner()
		{
			return Cast<T>(Owner);
		}
		//@note the specializations for this template are in UnPath.h because they must be outside the struct definition

		void Serialize(FArchive& Ar);
	
};

struct FDebugNavCost
{
    FStringNoInit Desc;
    INT Cost;

		/** constructors */
		FDebugNavCost() {}
		FDebugNavCost(EEventParm)
		{
			appMemzero(this, sizeof(FDebugNavCost));
		}
		UBOOL operator==(const FDebugNavCost& Other)
		{
			return (Other.Cost == Cost && Other.Desc == Desc);
		}
	
};

struct NavigationPoint_eventGetDebugAbbrev_Parms
{
    FString ReturnValue;
    NavigationPoint_eventGetDebugAbbrev_Parms(EEventParm)
    {
    }
};
struct NavigationPoint_eventSuggestMovePreparation_Parms
{
    class APawn* Other;
    UBOOL ReturnValue;
    NavigationPoint_eventSuggestMovePreparation_Parms(EEventParm)
    {
    }
};
struct NavigationPoint_eventDetourWeight_Parms
{
    class APawn* Other;
    FLOAT PathWeight;
    FLOAT ReturnValue;
    NavigationPoint_eventDetourWeight_Parms(EEventParm)
    {
    }
};
struct NavigationPoint_eventAccept_Parms
{
    class AActor* Incoming;
    class AActor* Source;
    UBOOL ReturnValue;
    NavigationPoint_eventAccept_Parms(EEventParm)
    {
    }
};
struct NavigationPoint_eventSpecialCost_Parms
{
    class APawn* Seeker;
    class UReachSpec* Path;
    INT ReturnValue;
    NavigationPoint_eventSpecialCost_Parms(EEventParm)
    {
    }
};
class ANavigationPoint : public AActor
{
public:
    //## BEGIN PROPS NavigationPoint
    BITFIELD bEndPoint:1;
    BITFIELD bTransientEndPoint:1;
    BITFIELD bHideEditorPaths:1;
    BITFIELD bCanReach:1;
    BITFIELD bBlocked:1;
    BITFIELD bOneWayPath:1;
    BITFIELD bNeverUseStrafing:1;
    BITFIELD bAlwaysUseStrafing:1;
    BITFIELD bForceNoStrafing:1;
    BITFIELD bAutoBuilt:1;
    BITFIELD bSpecialMove:1;
    BITFIELD bNoAutoConnect:1;
    BITFIELD bNotBased:1;
    BITFIELD bPathsChanged:1;
    BITFIELD bDestinationOnly:1;
    BITFIELD bSourceOnly:1;
    BITFIELD bSpecialForced:1;
    BITFIELD bMustBeReachable:1;
    BITFIELD bBlockable:1;
    BITFIELD bFlyingPreferred:1;
    BITFIELD bMayCausePain:1;
    BITFIELD bAlreadyVisited:1;
    BITFIELD bVehicleDestination:1;
    BITFIELD bMakeSourceOnly:1;
    BITFIELD bMustTouchToReach:1;
    BITFIELD bCanWalkOnToReach:1;
    BITFIELD bBuildLongPaths:1;
    BITFIELD bBlockedForVehicles:1;
    BITFIELD bPreferredVehiclePath:1;
    BITFIELD bHasCrossLevelPaths:1;
    BITFIELD bShouldSaveForCheckpoint:1;
    SCRIPT_ALIGN;
    struct FNavigationOctreeObject NavOctreeObject;
    TArrayNoInit<class UReachSpec*> PathList;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<struct FActorReference> EditorProscribedPaths;
    TArrayNoInit<struct FActorReference> EditorForcedPaths;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<struct FActorReference> Volumes;
    INT visitedWeight;
    INT bestPathWeight;
    class ANavigationPoint* nextNavigationPoint;
    class ANavigationPoint* nextOrdered;
    class ANavigationPoint* prevOrdered;
    class ANavigationPoint* previousPath;
    INT Cost;
    INT ExtraCost;
    INT TransientCost;
    INT FearCost;
    TArrayNoInit<struct FDebugNavCost> CostArray;
    class ADroppedPickup* InventoryCache;
    FLOAT InventoryDist;
    FLOAT LastDetourWeight;
    class UCylinderComponent* CylinderComponent;
    FCylinder MaxPathSize;
    FGuid NavGuid;
    class USpriteComponent* GoodSprite;
    class USpriteComponent* BadSprite;
    INT NetworkID;
    class APawn* AnchoredPawn;
    FLOAT LastAnchoredPawnTime;
    //## END PROPS NavigationPoint

    virtual void GetBoundingCylinder(FLOAT& CollisionRadius,FLOAT& CollisionHeight) const;
    class UReachSpec* GetReachSpecTo(class ANavigationPoint* Nav,class UClass* SpecClass=NULL);
    virtual UBOOL IsUsableAnchorFor(class APawn* P);
    virtual UBOOL CanTeleport(class AActor* A);
    UBOOL GetAllNavInRadius(class AActor* ChkActor,FVector ChkPoint,FLOAT Radius,TArray<class ANavigationPoint*>& out_NavList,UBOOL bSkipBlocked=FALSE,INT inNetworkID=-1,FCylinder MinSize=FCylinder(EC_EventParm));
    UBOOL IsOnDifferentNetwork(class ANavigationPoint* Nav);
    DECLARE_FUNCTION(execGetReachSpecTo)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_GET_OBJECT_OPTX(UClass,SpecClass,NULL);
        P_FINISH;
        *(class UReachSpec**)Result=this->GetReachSpecTo(Nav,SpecClass);
    }
    DECLARE_FUNCTION(execIsUsableAnchorFor)
    {
        P_GET_OBJECT(APawn,P);
        P_FINISH;
        *(UBOOL*)Result=this->IsUsableAnchorFor(P);
    }
    DECLARE_FUNCTION(execCanTeleport)
    {
        P_GET_OBJECT(AActor,A);
        P_FINISH;
        *(UBOOL*)Result=this->CanTeleport(A);
    }
    DECLARE_FUNCTION(execGetAllNavInRadius)
    {
        P_GET_OBJECT(AActor,ChkActor);
        P_GET_STRUCT(FVector,ChkPoint);
        P_GET_FLOAT(Radius);
        P_GET_TARRAY_REF(class ANavigationPoint*,out_NavList);
        P_GET_UBOOL_OPTX(bSkipBlocked,FALSE);
        P_GET_INT_OPTX(inNetworkID,-1);
        P_GET_STRUCT_OPTX(FCylinder,MinSize,FCylinder(EC_EventParm));
        P_FINISH;
        *(UBOOL*)Result=this->GetAllNavInRadius(ChkActor,ChkPoint,Radius,out_NavList,bSkipBlocked,inNetworkID,MinSize);
    }
    DECLARE_FUNCTION(execIsOnDifferentNetwork)
    {
        P_GET_OBJECT(ANavigationPoint,Nav);
        P_FINISH;
        *(UBOOL*)Result=this->IsOnDifferentNetwork(Nav);
    }
    FString eventGetDebugAbbrev()
    {
        NavigationPoint_eventGetDebugAbbrev_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetDebugAbbrev),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventSuggestMovePreparation(class APawn* Other)
    {
        NavigationPoint_eventSuggestMovePreparation_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_SuggestMovePreparation),&Parms);
        return Parms.ReturnValue;
    }
    FLOAT eventDetourWeight(class APawn* Other,FLOAT PathWeight)
    {
        NavigationPoint_eventDetourWeight_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Other=Other;
        Parms.PathWeight=PathWeight;
        ProcessEvent(FindFunctionChecked(ENGINE_DetourWeight),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventAccept(class AActor* Incoming,class AActor* Source)
    {
        NavigationPoint_eventAccept_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Incoming=Incoming;
        Parms.Source=Source;
        ProcessEvent(FindFunctionChecked(ENGINE_Accept),&Parms);
        return Parms.ReturnValue;
    }
    INT eventSpecialCost(class APawn* Seeker,class UReachSpec* Path)
    {
        NavigationPoint_eventSpecialCost_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.Seeker=Seeker;
        Parms.Path=Path;
        ProcessEvent(FindFunctionChecked(ENGINE_SpecialCost),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(ANavigationPoint,AActor,0,Engine)
	virtual UClass* GetReachSpecClass( ANavigationPoint* Nav, UClass* DefaultReachSpecClass ) { return DefaultReachSpecClass; }

	virtual void ClearPaths();
	virtual void FindBase();
	virtual void PostScriptDestroyed();
protected:
 	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:
	void PostEditMove(UBOOL bFinished);
	void Spawned();
	void UpdateMaxPathSize();
	UBOOL FindAlternatePath(UReachSpec* StraightPath, INT AccumulatedDistance);
	virtual UBOOL ShouldBeBased();

	/** Checks to make sure the navigation is at a valid point */
	virtual void Validate();

	virtual void TogglePathRendering(UBOOL bShouldDrawPaths);

#if WITH_EDITOR
	virtual void CheckForErrors();


	/**
	 * Sets the network ID for this nav and all connected navs.
	 */
	virtual void SetNetworkID(INT InNetworkID);
	static void BuildNetworkIDs();

	virtual void ReviewPath(APawn* Scout);
	virtual UBOOL CheckSatisfactoryConnection(ANavigationPoint* Other);

	void CleanUpPruned();
	INT PrunePaths();
	// more aggressive (and expensive) path pruning routine ( should only be called from editor )
	INT AggressivePrunePaths();
	INT SecondPassAggressivePrunePaths();
	virtual UBOOL CanPrunePath(INT index) { return TRUE; }

	virtual void AddForcedSpecs( AScout *Scout );

	virtual UReachSpec* ForcePathTo(ANavigationPoint *Nav, AScout *Scout = NULL, UClass* ReachSpecClass = NULL );
	virtual UBOOL ProscribePathTo(ANavigationPoint *Nav, AScout *Scout = NULL);

	/** builds long range paths (> MAXPATHDIST) between this node and all other reachable nodes
	 * for which a straight path would be significantly shorter or the only way to reach that node
	 * done in a separate pass at the end because it's expensive and so we want to early out in the maximum number
	 * of cases (e.g. if suitable short range paths already get there)
	 */
	void AddLongPaths(AScout* Scout, UBOOL bOnlyChanged);

	virtual void	addReachSpecs(class AScout *Scout, UBOOL bOnlyChanged=0);
	virtual INT AddMyMarker(AActor *S);
	/** returns whether a ReachSpec can be built from this node to Nav
	 * @param Nav the NavigationPoint to check if we can build a path to
	 * @param bCheckDistance whether or not we should check if Nav is close enough (MAXPATHDIST)
	 * @return true if a ReachSpec can be built from this node to Nav, false otherwise
	 */
	virtual UBOOL CanConnectTo(ANavigationPoint* Nav, UBOOL bCheckDistance);

	virtual void OnAddToPrefab();

#endif

	virtual void InitForPathFinding() {};
	virtual void ClearForPathFinding();

	UBOOL CanReach(ANavigationPoint *Dest, FLOAT Dist, UBOOL bUseFlag, UBOOL bAllowFlying);
	virtual class APickupFactory* GetAPickupFactory() { return NULL; }
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	virtual void SetVolumes();
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual UBOOL TouchReachSucceeded(APawn *P, const FVector& TestPosition);
	virtual UBOOL GetUpDir( FVector &V ) { return 0; }


	virtual void AddToNavigationOctree();
	virtual void RemoveFromNavigationOctree();
	virtual UBOOL PlaceScout(class AScout *Scout);

	/** returns the position the AI should move toward to reach this actor */
	FVector GetDestination(AController* C);

	/** sorts the PathList by distance, shortest first */
	void SortPathList();

	/**
	 * Fills the array of any nav references needing to be fixed up.
	 */
	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel);
	virtual void ClearCrossLevelReferences();
	virtual FGuid* GetGuid() { return &NavGuid; }


	virtual ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder);

	/**
	 * Works through the component arrays marking entries as pending kill so references to them
	 * will be NULL'ed.
	 *
	 * @param	bAllowComponentOverride		Whether to allow component to override marking the setting
	 */
	virtual void MarkComponentsAsPendingKill(UBOOL bAllowComponentOverride = FALSE);
};

class UEditorLinkSelectionInterface : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UEditorLinkSelectionInterface,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UEditorLinkSelectionInterface)
};

class IEditorLinkSelectionInterface
{
protected:
	virtual ~IEditorLinkSelectionInterface() {}
public:
	typedef UEditorLinkSelectionInterface UClassType;
	virtual UObject* GetUObjectInterfaceEditorLinkSelectionInterface()=0;
	virtual void LinkSelection(USelection* SelectedObjects){}
	virtual void UnLinkSelection(USelection* SelectedObjects){}
};

class UInterface_NavigationHandle : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UInterface_NavigationHandle,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterface_NavigationHandle)
};

class IInterface_NavigationHandle
{
protected:
	virtual ~IInterface_NavigationHandle() {}
public:
	typedef UInterface_NavigationHandle UClassType;
	virtual UObject* GetUObjectInterfaceInterface_NavigationHandle()=0;
    virtual void eventNotifyPathChanged()=0;
	/** >>>>> here lie functions which take input, and thus can not be cached */
	virtual UBOOL	CanCoverSlip(class ACoverLink* Link, INT SlotIdx)	{ return FALSE; }

	/**
	 * returns the offset from the edge move point this entity should move toward (e.g. how high off the ground we should move to)
	 * @param Edge - the edge we're moving to
	 * @return - the offset to use
	 */
	virtual FVector GetEdgeZAdjust(struct FNavMeshEdgeBase* Edge)=0;

	/**
	 * allows entities to do custom validation before OK'ing mantle edges
	 * @param Edge - the edge we're verifying
	 * @return TRUE if the passed edge is OK to traverse
	 */
	virtual UBOOL CheckMantleValidity(struct FNavMeshMantleEdge* Edge){ return TRUE; }
    /*** <<<<<< */


	/**
	 * this function is responsible for setting all the relevant parmeters used for pathfinding
	 * @param out_ParamCache - the output struct to populate params in
	 * @NOTE: ALL Params FNavMeshPathParams should be populated
	 * 
	 */
	virtual void SetupPathfindingParams( struct FNavMeshPathParams& out_ParamCache )=0;

	/**
	 * Called from FindPath() at the beginning of a path search to give this entity a chance to initialize transient data
	 */
	virtual void InitForPathfinding()=0;


	/**
	 * when this entity is using an edge (e.g. it has been marked active and is in this handle's pathcache) this function allows
	 * extra cost to be added for other entities trying to use that edge.  (e.g. to keep guys from using the same path)
	 * @param Edge - the edge we're about to mark as active
	 */
	virtual INT  ExtraEdgeCostToAddWhenActive(FNavMeshEdgeBase* Edge) { return 0; }

	/**
	 * DebugLog function which is called to log information specific to this AI (call NAVHANDLE_DEBUG_LOG macro, don't call this directly)
	 * @param LogText - text to log for this AI
	 */
	virtual void DebugLogInternal(const TCHAR* LogText) {}
};

struct FPolyReference
{
    struct FActorReference OwningPylon;
private:
    INT PolyId;
    struct FNavMeshPolyBase* CachedPoly;
public:

		FPolyReference()
		{
			SetPolyId(MAXWORD,MAXWORD);
		}
		FPolyReference(EEventParm)
		{
			appMemzero(this, sizeof(FPolyReference));
		}

		explicit FPolyReference(AActor* Pylon, INT InPolyId)
		{
			OwningPylon = FActorReference(Pylon,*Pylon->GetGuid());
			SetPolyId(InPolyId,MAXWORD);
		}

		explicit FPolyReference(struct FNavMeshPolyBase* InPoly);

		// overload various operators to make the reference struct as transparent as possible
		struct FNavMeshPolyBase* operator*();

		/**
		 * this will dereference the poly and return a pointer to it
		 * @param bEvenIfPylonDisabled - pass TRUE to this if you want the poly even if its pylon is bDisabled
		 * @return the poly assoicated with this poly ref
		 */
		struct FNavMeshPolyBase* GetPoly(UBOOL bEvenIfPylonDisabled=FALSE);

		FORCEINLINE struct FNavMeshPolyBase* operator->()
		{
			return *(*this);
		}
		FPolyReference* operator=(FNavMeshPolyBase* Poly);
		FORCEINLINE UBOOL operator==(const FPolyReference &Ref) const
		{
			return ((Ref.OwningPylon == OwningPylon) && Ref.GetTopLevelPolyId() == GetTopLevelPolyId() && Ref.GetSubPolyId() == GetSubPolyId());
		}
		FORCEINLINE UBOOL operator!=(const FPolyReference &Ref) const
		{
			return ((Ref.OwningPylon != OwningPylon) || Ref.GetTopLevelPolyId() != GetTopLevelPolyId() || Ref.GetSubPolyId() != GetSubPolyId());
		}

		/**
		 * returns TRUE if the passed poly matches this ref
		 * minimizes poly lookups for speed
		 * @param Poly - poly to match
		 * @return TRUE if poly matches the poly ref
		 */
		UBOOL operator==(FNavMeshPolyBase* Poly) const;

		operator UBOOL();
		UBOOL operator!();

		FORCEINLINE void Clear()
		{
			OwningPylon.Actor = NULL;
			OwningPylon.Guid  = FGuid(0,0,0,0);
			SetPolyId(MAXWORD,MAXWORD);
		}

		FORCEINLINE void ClearCachedPoly()
		{
			CachedPoly = NULL;
		}

		class APylon* Pylon();

		friend FArchive& operator<<( FArchive& Ar, FPolyReference& T );

		FORCEINLINE WORD GetTopLevelPolyId() const { return PolyId&65535; }
		FORCEINLINE WORD GetSubPolyId() const { return PolyId>>16; }
		FORCEINLINE void SetPolyId(WORD NewTopLevelPolyId, WORD NewSubPolyId) 
		{
			PolyId = NewTopLevelPolyId | (NewSubPolyId<<16); 
			CachedPoly=NULL;
		}

		friend DWORD GetTypeHash(const FPolyReference& Ref)
		{
			DWORD GuidVal = appMemCrc(&Ref.OwningPylon.Guid, sizeof(FGuid));
			
			return (GuidVal << 16) | (Ref.PolyId&65535);
		}


	
};

struct Pylon_eventIsEnabled_Parms
{
    UBOOL ReturnValue;
    Pylon_eventIsEnabled_Parms(EEventParm)
    {
    }
};
struct Pylon_eventSetEnabled_Parms
{
    UBOOL bEnabled;
    Pylon_eventSetEnabled_Parms(EEventParm)
    {
    }
};
struct Pylon_eventNotifyPathChanged_Parms
{
    Pylon_eventNotifyPathChanged_Parms(EEventParm)
    {
    }
};
class APylon : public ANavigationPoint, public IEditorLinkSelectionInterface, public IInterface_NavigationHandle
{
public:
    //## BEGIN PROPS Pylon
    class UNavigationMeshBase* NavMeshPtr;
    class UNavigationMeshBase* ObstacleMesh;
    class UNavigationMeshBase* DynamicObstacleMesh;
    TDoubleLinkedList<struct FNavMeshPolyBase*>* WorkingSetPtr;
    TArray<class IInterface_NavMeshPathObject*>* PathObjectsThatAffectThisPylon;
    TArrayNoInit<FVector> NextPassSeedList;
    FOctreeElementId OctreeId;
    void* OctreeIWasAddedTo;
    class APylon* NextPylon;
    TArrayNoInit<class AVolume*> ExpansionVolumes;
    FLOAT ExpansionRadius;
    FLOAT MaxExpansionRadius;
    class UDrawPylonRadiusComponent* PylonRadiusPreview;
    BITFIELD bImportedMesh:1;
    BITFIELD bUseExpansionSphereOverride:1;
    BITFIELD bNeedsCostCheck:1;
    BITFIELD bPylonInHighLevelPath:1;
    BITFIELD bUseRecast:1;
    BITFIELD bAllowRecastGenerator:1;
    BITFIELD bDrawEdgePolys:1;
    BITFIELD bDrawPolyBounds:1;
    BITFIELD bRenderInShowPaths:1;
    BITFIELD bDrawWalkableSurface:1;
    BITFIELD bDrawObstacleSurface:1;
    BITFIELD bSolidObstaclesInGame:1;
    BITFIELD bBuildThisPylon:1;
    BITFIELD bDisabled:1;
    BITFIELD bForceObstacleMeshCollision:1;
    SCRIPT_ALIGN;
    FVector ExpansionSphereCenter;
    class UNavMeshRenderingComponent* RenderingComp;
    class USpriteComponent* BrokenSprite;
    TArrayNoInit<class APylon*> ImposterPylons;
    TArrayNoInit<class AActor*> OnBuild_DisableCollisionForThese;
    TArrayNoInit<class AActor*> OnBuild_EnableCollisionForThese;
    FLOAT MaxPolyHeight_Optional;
    BYTE NavMeshGenerator;
    TArrayNoInit<FKAggregateGeom> VoxelFilterBounds;
    TArrayNoInit<FMatrix> VoxelFilterTM;
    INT DebugEdgeCount;
    FVector DebugPathExtent;
    FVector DebugPathStartLocation;
    //## END PROPS Pylon

    virtual void OnPylonStatusChange();
    virtual void UpdateMeshForPreExistingNavMeshObstacles();
    virtual void FlushDynamicEdges();
    virtual UBOOL CanReachPylon(class APylon* DestPylon,class AController* C);
    DECLARE_FUNCTION(execOnPylonStatusChange)
    {
        P_FINISH;
        this->OnPylonStatusChange();
    }
    DECLARE_FUNCTION(execUpdateMeshForPreExistingNavMeshObstacles)
    {
        P_FINISH;
        this->UpdateMeshForPreExistingNavMeshObstacles();
    }
    DECLARE_FUNCTION(execFlushDynamicEdges)
    {
        P_FINISH;
        this->FlushDynamicEdges();
    }
    DECLARE_FUNCTION(execCanReachPylon)
    {
        P_GET_OBJECT(APylon,DestPylon);
        P_GET_OBJECT(AController,C);
        P_FINISH;
        *(UBOOL*)Result=this->CanReachPylon(DestPylon,C);
    }
    UBOOL eventIsEnabled()
    {
        Pylon_eventIsEnabled_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsEnabled),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetEnabled(UBOOL bEnabled)
    {
        Pylon_eventSetEnabled_Parms Parms(EC_EventParm);
        Parms.bEnabled=bEnabled ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetEnabled),&Parms);
    }
    void eventNotifyPathChanged()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPathChanged),NULL);
    }
    DECLARE_CLASS(APylon,ANavigationPoint,0,Engine)
    virtual UObject* GetUObjectInterfaceEditorLinkSelectionInterface(){return this;}
    virtual UObject* GetUObjectInterfaceInterface_NavigationHandle(){return this;}
	typedef TDoubleLinkedList<struct FNavMeshPolyBase*> WSType;
	typedef TArray<class IInterface_NavMeshPathObject*> PathObjectList;

	// overidden ensure we're not in the pylon octree when we are deleted
	virtual void BeginDestroy();

	// removes this pylon from the global pylon octree
	void RemoveFromPylonOctree();

	// adds this pylon from the global pylon octree
	void AddToPylonOctree();

	FORCEINLINE class UNavigationMeshBase* GetNavMesh()
	{
		return NavMeshPtr;
	}

	UBOOL Explore_SeedWorkingSet( AScout* Scout, FVector& SeedLocation );
	UBOOL Explore_CreateGraph( AScout* Scout, FVector& SeedLocation );
	UBOOL DoesCoverSlotAffectMesh(const struct FCoverInfo& Slot);
	void GatherCoverReferences( AScout* Scout, TArray<struct FCoverInfo>& out_MeshAffectors );
	virtual void CreateExtraMeshData( AScout* Scout );

	void CreateMantleEdges( AScout* Scout );
	void CreateCoverSlipEdges( AScout* Scout );

	void ConvertStaticMeshToNavMesh( UStaticMesh* StaticMesh, FMatrix& ScaledLocalToWorld );
	void AddStaticMeshesToPylon( TArray<class AStaticMeshActor*>& SMActors );

	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditMove(UBOOL bFinished);
	virtual void Spawned();
		
	// overidden to clear navmesh data
	virtual void ClearPaths(); 

	/** overidden to clear bPylonInHighLevelPath */
	virtual void ClearForPathFinding();

	// clears out navmesh specific pathdata
	virtual void ClearNavMeshPathData();

	// ***** mesh generation functionality follows ****
	
	// structure to store diagonal expansion points for post-expansion
	struct FDiagTest 
	{
		FDiagTest(FVector inParentPos, FVector inPos)
		{
			ParentPos=inParentPos;
			Pos=inPos;
		}
		FVector ParentPos;
		FVector Pos;
	};

	// used when importing a mesh.  vertex color of red indicates obstacle geometry
	virtual UBOOL IsObstacleColor(FColor& VertColor);

	/**
	 * 
	 * will walk out in 8 directions from the passed node trying to add geometry to the mesh from each direction
	 * diags are points that should be tested later for expansion.  This is done to give cardinal directions priority, keeping
	 * non-diagonal and non-subdivided polys a priority
	 * @param ParentPoly - poly we are trying to expand from
	 * @param Scout      - Scout to use for tests/params
	 * @param Diags		 - diagonal expansions to test after cardinal expansions are tried
	 */
	void ExpandCurrentNode(FNavMeshPolyBase* ParentPoly, AScout* Scout, TArray<FDiagTest>& Diags);

	/**
	 * tries to find ground position below passed location and calls AddNewNode if there is nothing in the way of expansion, and the ground isn't too steep/etc..
	 * 
	 * @param NewNodeTestLocation		  - location to try and add a new node 
	 * @param CurrNodePosWithHeightOffset - predecessor node's position (offset from ground with height offset)
	 * @param CUrrNodePos				  - predecessor node's position without height offset
	 * @param Hit						  - output struct indicating values associated with the ground hit
	 * @param Scout						  - Scout to use for tests
	 * @param out_bIvalidSpot			  - out var indicating this spot was invalid due to out of bounds/something else
	 * @param SubdivisionIteration        - the current subdivision iteration
	 * @param bDiag						  - are we checking ground positiopn for a diagonal expansion
	 * @param ParentPoly				  - optional predecessor polygon we're expanding from
	 * @return - the new poly added if any
	 */
	struct FNavMeshPolyBase* ConditionalAddNodeHere(const FVector& NewNodeTestLocation,
		const FVector& CurrNodePosWithHeightOffset,
		const FVector& CurrNodePos,
		FCheckResult& Hit,
		AScout* Scout, 
		UBOOL& out_bInvalidSpot,
		INT SubdivisionIteration=0,
		UBOOL bDiag=FALSE,
		FNavMeshPolyBase* ParentPoly=NULL);

	/**
	 * will add a square poly to the mesh at the passed location unless it's already in the mesh
	 * @param NewLocation - location of new node
	 * @param HitNormal - normal of the hit which we're adding a node for
	 * @param out_bInvalidSpot - OPTIONAL out param indicating whether we couldn't add a node here due to it being out of bounds
	 * @param SubdivisionIteration - OPTIONAL param indicating what subdivision iteration we're adding for
	 * @return - the new poly we just added (NULL if not succesful)
	 */
	struct FNavMeshPolyBase* AddNewNode(const FVector& NewLocation, const FVector& HitNormal, UBOOL* out_bInvalidSpot=NULL, INT SubdivisionIteration=0);

	/**
	 * keeps track of edges which we could drop down but not climb up for later addition to the mesh
	 * 
	 * @param NewLocation - destination location of dropdown 
	 * @param OldLocation - source location of dropdown
	 * @param HitNormal   - normal of the ground hit causing this dropdown
	 * @param ParentPoly  - parent poly we're expending from 
	 * @param SubdivisionIteration - current subdivision iteration 
	 */
	void SavePossibleDropDownEdge(const FVector& NewLocation, const FVector& OldLocation, const FVector& HitNormal, FNavMeshPolyBase* ParentPoly, UBOOL bSkipPullBack);


	/**
	 * when zdelta is greater than step size, but less than the height change due to allowable slopes,
	 * this function is called ot do extra verification (to determine if it is just a slope, or if there is a big step)
	 * 
	 * @param Scout - scout to use for tests/params
	 * @param NewNodePos - new position of node we need to test step for 
	 * @param CurrNodePosWithHeightOffset - predecessor node's current position (with height offset from ground0
	 * @param StepSize - current step size (size of polys being added right now)
	 * @param out_ZDelta - out value of any ZDelta found
	 * @param ParentPoly - the parent (predecessor) Poly we're veryfing a step from
	 * @return - TRUE If step is valid
	 */
	UBOOL VerifySlopeStep(AScout* Scout,
		const FVector& NewNodePos,
		const FVector& CurrNodePosWithHeightOffset,
		FLOAT StepSize,
		FLOAT& out_ZDelta,
		FNavMeshPolyBase* ParentPoly);

	INT SubdivideExpandInternal( struct FNavMeshPolyBase* ParentPoly, 
		const FVector& NewNodeTestLocation,
		const FVector& CurrNodePosWithHeightOffset,
		const FVector& CurrNodePos,
		FCheckResult& Hit,
		AScout* Scout, 
		TArray<FNavMeshPolyBase*>& AddedPolys,
		UBOOL bDiag,
		INT SubdivisionIteration=0);

	struct FNavMeshPolyBase* SubdivideExpand( struct FNavMeshPolyBase* ParentPoly, 
		const FVector& NewNodeTestLocation,
		const FVector& CurrNodePosWithHeightOffset,
		const FVector& CurrNodePos,
		FCheckResult& Hit,
		AScout* Scout,
		UBOOL bDiag);

	// ** mesh generation stage functions **
	
	// intial raycast soup to discover topology of geo
	UBOOL NavMeshPass_InitialExploration();
	
	// second pass raycast soup expansion to expand from auxiliary seedpoints
	UBOOL NavMeshPass_ExpandSeeds();
	
	// fill in stairstep corner with triangles where possible
	UBOOL NavMeshPass_BackfillCorners();
	
	// remove uneccesary polys, by merging together polys that can be merged
	UBOOL NavMeshPass_SimplifyMesh();

	// split generated meshes around boundaries with imported meshes for good edge lineup
	UBOOL NavMeshPass_SplitForImportedMeshes();

	// split mesh around path objects that need splitting
	UBOOL NavMeshPass_SplitMeshAboutPathObjects();

	// convert mesh into serializable structures, and do final cleanup for save
	UBOOL NavMeshPass_FixupForSaving();

	// build edge connections between adjacent polys
	UBOOL NavMeshPass_CreateEdgeConnections();

	// build mesh that describes the boundaries or obstacles of the mesh
	UBOOL NavMeshPass_BuildObstacleMesh();

	// build navmesh polys using recast
	UBOOL NavMeshPass_Recast();

	// snap vertices to nearby navmesh
	UBOOL NavMeshPass_RecastSnap();

	UBOOL NavMesh_MungeVerts();
	virtual UBOOL NavMesh_MungeVertsInternal() { return TRUE; }

	// returns a bounding box for our expansion bounds (used when adding this pylon to the octree)
	FBox GetExpansionBounds();

	/**
	 * returns bounding box for this pylon's mesh
	 * @param bWorldSpace - ref frame the box should be in
	 */
	FBox GetBounds(UBOOL bWorldSpace);

	/**
	 * returns FALSE if the passed point is not within our expansion constraints
	 * @param Pt - the point to test against expansion bounds
	 * @param Buffer - used only when expansion bounds are spherical.. adds extra size to bounds to account for slight discrepancies 
	 */
	virtual UBOOL   IsPtWithinExpansionBounds(const FVector& Pt,FLOAT Buffer=0.f);

	/**
	 * this function will slide a box downward from a raised position until a position which is non-colliding, then multiple raycasts downward
	 * will be performed to ascertain the topology of the ground underneath the ground check.  This gives us a valid position for the ground at a given 
	 * expansion point, as well as valid normal data for the extent being swept downward
	 * @param TestBasePos - position to start testing from
	 * @param Result      - hit result describing information about the ground position found
	 * @param Scout       - scout instance to be used during this ground check
	 * @param SubdivisionIteration - the number of times to default stepsize has been subdivided for the current callchain
	 * @param out_bNeedsSlopeCheck - if a large gap is found while performing the second stage ground check, this will be turned on
	 *                               indicating a call to 'VerifySlopeStep' is necessary
	 * @return - TRUE if a valid ground posiiton was found
	 */
	virtual UBOOL FindGround(const FVector& TestBasePos, FCheckResult& Result,AScout* Scout, INT SubdivisionIteration=0, UBOOL* out_bNeedsSlopeCheck=NULL);

	// will find a position which is on the stepsize grid to start expanding from (snapped to grid so exploration from multiple pylons lines up)
	FVector SnapSeedLocation( AScout* Scout, FVector& Loc );

	/**
	 * will sweep up from ground position and find the maximum supporting height of a new poly
	 * 
	 * @param TestBasePos - base position of node to test ceiling height for
	 * @param Result	  - resulting hit 
	 * @param Scout		  - scout to use for params/tests
	 * @param Up		  - upward direction for this poly
	 * @param Extent	  - extent to use for linechecks
	 * @return - location of ceiling found
	 */
	virtual FVector FindCeiling(const FVector& TestBasePos, FCheckResult& Result,AScout* Scout, const FVector& Up, const FVector& Extent);

	// returns the 'upward' direction that should be used for this poly
	virtual FVector Up(FNavMeshPolyBase* Poly);

	/**
	 * returns whether or not this pylon should be built right now.. if FALSE this pylon will not rebuilt during this navmesh generation pass
	 * @param bOnlyBuildSelected - the value of 'only build selected' coming from the editor
	 * @return - TRUE if this pylon should be wiped and rebuilt
	 */
	virtual UBOOL ShouldBuildThisPylon(UBOOL bOnlyBuildSelected);
	/*************************** End Mesh Generation shiznaz *************************/


	// add and removal functionality for pylon nav octree
	virtual void AddToNavigationOctree();
	virtual void RemoveFromNavigationOctree();

	/**
	 * Queries the poly octree and fills in the passed array with a list of all the polys that intersect the passed in AABB
	 * @param Loc - center of extent to check
	 * @param Extent - extent of box to check
	 * @param out_Polys - output array of polys 
	 * @param bIgnoreDynamic - whether to ignore dynamically added submeshes or not
	 * @param bReturnBothDynamicAndStatic - if TRUE, BOTH dynamic and static polys will be returned.. using this is *DANGEROUS*! most of the time you should use dynamic polys if they exist
	 *                                      as they are the 'correct' representation of the mesh at that point
	 */
	void GetIntersectingPolys(const FVector& Loc,
							const FVector& Extent,
							TArray<FNavMeshPolyBase*>& out_Polys,
							UBOOL bIgnoreDynamic,
							UBOOL bReturnBothDynamicAndStatic=FALSE,
							DWORD TraceFlags=0
							);

	/**
	*	Do anything needed to clear out cross level references; Called from ULevel::PreSave
	*/
	virtual void ClearCrossLevelReferences();

	/**
	* Called when a level is loaded/unloaded, to get a list of all the crosslevel
	* paths that need to be fixed up.
	*/
	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel);

	/**
	* Callback used to allow object register its direct object references that are not already covered by
	* the token stream.
	*
	* @param ObjectArray	array to add referenced objects to via AddReferencedObject
	* - this is here to keep the navmesh from being GC'd at runtime
	*/
	virtual void AddReferencedObjects( TArray<UObject*>& ObjectArray );

	/**
	* returns the center of the expansion bounding sphere 
	*/
	FVector GetExpansionSphereCenter() const
	{
		return (bUseExpansionSphereOverride) ? ExpansionSphereCenter : Location;
	}

	void UpdateComponentsInternal(UBOOL bCollisionUpdate);

	/**
	 * Called from UpdateComponentsInternal when a transform update is needed (when this pylon has moved)
	 */
	virtual void PylonMoved();

	/**
	 * indicates whether static cross-pylon edges should be built for this pylon (pylons that move should return false)
	 */
	virtual UBOOL NeedsStaticCrossPylonEdgesBuilt(){ return TRUE; } 

	// indicates whether this pylon is valid to be used
	FORCEINLINE UBOOL IsValid() { return NavMeshPtr != NULL && !bDisabled; }

	////// EditorLinkSelectionInterface
	virtual void LinkSelection(USelection* SelectedActors);

	// overidden to set 'paths need to be rebuilt' warning 
	virtual void PostBeginPlay();
	
	// overidden to throw warnign when pylon is not within its own bounds
	// and throw warnings when pathdata is too out of date
#if WITH_EDITOR
	virtual void CheckForErrors();

	virtual UBOOL CanConnectTo(ANavigationPoint* Nav, UBOOL bCheckDistance)
	{
		return FALSE;
	}

	// build pylon to pylon reachspecs representing a super graph for quick "is this pylon connected to that one" checks
	UBOOL NavMeshPass_BuildPylonToPylonReachSpecs();

#endif

	virtual void TogglePathRendering(UBOOL bShouldDrawPaths);


	/** Checks to make sure the navigation is at a valid point */
	virtual void Validate();

	/**
	 * verifies that this pylon is not in conflict with other pylons (e.g. both their start locations are with each other's bounds)
	 * @param out_ConflictingPylons - (optional) list of pylons this pylon is in conflict with (optional)
	 * @return - TRUE if this pylon is not in conflict
	 */
	UBOOL CheckBoundsValidityWithOtherPylons(TArray<APylon*>* out_ConflictingPylons=NULL);


	/**
	 * returns TRUE if this pylon modified the cost of the edge
	 * @param Interface - the interface we're generating a cost for
	 * @param PreviousPoint - the previous point in the path we're pathing from
	 * @param out_PathEdgePoint - the point on the edge we're moving to
	 * @param Edge - the edge we're considering
	 * @param SourcePoly - the poly previous in the current path search
	 * @param out_Cost - the output cost for the edge
	 * @return - TRUE if we modified the cost
	 * NOTE: this function is only called when bNeedsCostCheck is TRUE
	 */ 
	virtual UBOOL CostFor(const struct FNavMeshPathParams& PathParams,
						 const FVector& PreviousPoint,
						 FVector& out_PathEdgePoint,
						 struct FNavMeshEdgeBase* Edge,
						 struct FNavMeshPolyBase* SourcePoly,
						 INT& out_Cost);


	/**
	 * this function returns the local to world matrix transform that should be used for navmeshes associated with this
	 * pylon 
	 */
	virtual FMatrix GetMeshLocalToWorld();

	/**
	 * this function returns the world to local matrix transform that should be used for navmeshes associated with this
	 * pylon 
	 */
	virtual FMatrix GetMeshWorldToLocal();

	// determines if this should be validated and based on objects below it
	UBOOL ShouldBeBased();

	virtual void HandleFailedAddNode( AScout* Scout, const FVector& StartPos, const FVector& EndPos ) {}

	#if WITH_EDITOR
	/**
	 * called when this pylon is about to be built
	 */
	virtual void NotifyPylonBuildStarting();

	/**
	 * called when this pylon is no longer being built 
	 * (either becuase it was cancelled or the build is finished)
	 */
	virtual void NotifyPylonBuildStopping();
	#endif
	
	/**
	 * Called when this actor is in a level which is being removed from the world (e.g. my level is getting UWorld::RemoveFromWorld called on it)
	 */
	virtual void OnRemoveFromWorld();


	/** 
	 *  is this pylon compatible with dynamic obstacles? (e.g. moving meshes aren't)
	 */
	virtual UBOOL CompatibleWithDynamicObstacles(){return TRUE;}

	/**
	 * will get a list of polys which should be affected by the passed obstacle boundary shape 
	 * @param Shape - the convex poly shape to test for
	 * @param ShapeBounds - the bounds of the shape we're asking about
	 * @param out_Polys - the list of polys which we should add to 
	 */
	virtual void GetPolysAffectedByObstacleShape(class IInterface_NavMeshPathObstacle* Obstacle, const TArray<FVector>& Shape, const FVector& ShapeBoundsCtr, const FVector& ShapeBoundsExtent, TArray<FNavMeshPolyBase*>& out_Polys);


	//////////////////////////////////////////////////////////////////////////
	// Interface_NavigationHandle
	// - we implement this interface here for debugging purposes 

	/**
	 * returns the offset from the edge move point this entity should move toward (e.g. how high off the ground we should move to)
	 * @param Edge - the edge we're moving to
	 * @return - the offset to use
	 */
	virtual FVector GetEdgeZAdjust(struct FNavMeshEdgeBase* Edge);



	/**
	 * this function is responsible for setting all the relevant parmeters used for pathfinding
	 * @param out_ParamCache - the output struct to populate params in
	 * @NOTE: ALL Params FNavMeshPathParams should be populated
	 * 
	 */
	virtual void SetupPathfindingParams( struct FNavMeshPathParams& out_ParamCache );

	/**
	 * Called from FindPath() at the beginning of a path search to give this entity a chance to initialize transient data
	 */
	virtual void InitForPathfinding();
	// END Interface_navigationhandle
	//////////////////////////////////////////////////////////////////////////

private:
	// NavMeshPass_Recast internal: marking areas with existing navmesh polys
	void NavMeshPass_Recast_MarkAlreadyBuiltAreas();

	// NavMeshPass_Recast internal: marking walkable seeds for culling inaccessible polys
	void NavMeshPass_Recast_MarkWalkableSeeds();

	// NavMeshPass_Recast internal: prepare voxel filter data
	void NavMeshPass_Recast_SetupFilters();

	/** 
	 * NavMeshPass_Recast internal: generating navmesh and importing its data
	 * @param GeomVerts - verts of collision geometry
	 * @param GeomFaces - list of vert indices for collision geometry triangles (3 entries for each)
	 */
	UBOOL NavMeshPass_Recast_GenerateAndImport(const TArray<FVector>& GeomVerts, const TArray<INT>& GeomFaces);
	
	/** 
	 * NavMeshPass_RecastSnap internal: snapping verts of this navmesh to verts of already built navmeshes
	 * @param UnprocessedVerts - indices of verts that were not snapped in this step
	 */
	void NavMeshPass_RecastSnap_VertToOtherVert(TArray<INT>& UnprocessedVerts);

	/** 
	 * NavMeshPass_RecastSnap internal: snapping verts of already built navmeshes to edges of this navmesh
	 * @param ModifiedPolys - list of modified polys on other navmeshes
	 */
	void NavMeshPass_RecastSnap_OtherVertToEdge(TArray<FNavMeshPolyBase*>& ModifiedPolys);

	/** 
	 * NavMeshPass_RecastSnap internal: snapping verts of this navmesh to edges of already build navmeshes
	 * @param VertsToSnap - indices of verts to consider
	 */
	void NavMeshPass_RecastSnap_VertToOtherEdge(const TArray<INT>& VertsToSnap);

	/** 
	 * NavMeshPass_RecastSnap internal: cutting overlapping and degenerated polys
	 * @param ModifiedPolys - list of modified polys on other navmeshes
	 */
	void NavMeshPass_RecastSnap_CutOverlapping(const TArray<FNavMeshPolyBase*>& ModifiedPolys);
};

#define UCONST_COVERLINK_DangerDist 1536.f
#define UCONST_COVERLINK_EdgeExposureDot 0.85f
#define UCONST_COVERLINK_EdgeCheckDot 0.25f
#define UCONST_COVERLINK_ExposureDot 0.4f

struct FCoverReference : public FActorReference
{
    INT SlotIdx;

		friend FArchive& operator<<( FArchive& Ar, FCoverReference& T );
	
};

struct FCoverInfo
{
    class ACoverLink* Link;
    INT SlotIdx;

		FCoverInfo()
		{
			Link = NULL;
			SlotIdx = 0;
		}
		FCoverInfo(EEventParm)
		{
			appMemzero(this, sizeof(FCoverInfo));
		}
		FCoverInfo(class ACoverLink* inLink, INT inSlotIdx)
		{
			Link = inLink;
			SlotIdx = inSlotIdx;
		}
		UBOOL operator==(const FCoverInfo &Other) const
		{
			return (this->Link == Other.Link && this->SlotIdx == Other.SlotIdx);
		}
		FString ToString() const;
	
};

struct FCovPosInfo
{
    class ACoverLink* Link;
    INT LtSlotIdx;
    INT RtSlotIdx;
    FLOAT LtToRtPct;
    FVector Location;
    FVector Normal;
    FVector Tangent;

    /** Constructors */
    FCovPosInfo() {}
    FCovPosInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCovPosInfo));
    }
};

struct FFireLinkItem
{
    MS_ALIGN(4) BYTE SrcType GCC_ALIGN(4); // Extra alignment flags needed because all properties are bytes
    BYTE SrcAction;
    BYTE DestType;
    BYTE DestAction;
    SCRIPT_ALIGN;

    /** Constructors */
    FFireLinkItem() {}
    FFireLinkItem(EEventParm)
    {
        appMemzero(this, sizeof(FFireLinkItem));
    }
};

struct FFireLink
{
    TArrayNoInit<BYTE> Interactions;
    INT PackedProperties_CoverPairRefAndDynamicInfo;
    BITFIELD bFallbackLink:1;
    BITFIELD bDynamicIndexInited:1;
    SCRIPT_ALIGN;

		/**
		  *  Updated DynamicLinkInfos array if source or destination is dynamic
		  */
		void UpdateDynamicLinkInfoFor(ACoverLink* MyLink, ACoverLink* TestLink, INT InSlotIdx, const FVector& LastSrcLocation);

		FVector GetLastTargetLocation(ACoverLink *MyLink);
		FVector GetLastSrcLocation(ACoverLink *MyLink);

		FORCEINLINE void SetFallbackLink( UBOOL bSet )
		{
			bFallbackLink = bSet;
		}

		FORCEINLINE UBOOL IsFallbackLink()
		{
			return bFallbackLink;
		}

		FORCEINLINE void SetDynamicIndexInited( UBOOL bSet )
		{
			bDynamicIndexInited = bSet;
		}

		FORCEINLINE UBOOL IsDynamicIndexInited()
		{
			return bDynamicIndexInited;
		}

		FORCEINLINE void SetCoverRefIdx( INT Val )
		{
			Val &= 0x0000FFFF;
			PackedProperties_CoverPairRefAndDynamicInfo &= ~(0x0000FFFF);
			PackedProperties_CoverPairRefAndDynamicInfo |= Val;
		}
		FORCEINLINE DWORD GetCoverRefIdx()
		{
			return (PackedProperties_CoverPairRefAndDynamicInfo & (0x0000FFFF));
		}

		FORCEINLINE void SetDynamicLinkInfoIndex( INT Val )
		{
			Val &= 0xFFFF0000;
			PackedProperties_CoverPairRefAndDynamicInfo &= ~(0xFFFF0000);
			PackedProperties_CoverPairRefAndDynamicInfo |= (Val << 16);
		}
		FORCEINLINE DWORD GetDynamicLinkInfoIndex()
		{
			return ((PackedProperties_CoverPairRefAndDynamicInfo & (0xFFFF0000)) >> 16);
		}
	
};

struct FDynamicLinkInfo
{
    FVector LastTargetLocation;
    FVector LastSrcLocation;

    /** Constructors */
    FDynamicLinkInfo() {}
    FDynamicLinkInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDynamicLinkInfo));
    }
};

struct FExposedLink
{
    struct FCoverReference TargetActor;
    BYTE ExposedScale;
    SCRIPT_ALIGN;

    /** Constructors */
    FExposedLink() {}
    FExposedLink(EEventParm)
    {
        appMemzero(this, sizeof(FExposedLink));
    }
};

struct FSlotMoveRef
{
    struct FPolyReference Poly;
    struct FBasedPosition Dest;
    INT Direction;

		void Clear()
		{
			Poly.Clear();
			Dest.Clear();
			Direction = 0;
		}
	
};

struct FCoverSlot
{
    class APawn* SlotOwner;
    FLOAT SlotValidAfterTime;
    BYTE ForceCoverType;
    BYTE CoverType;
    BYTE LocationDescription;
    SCRIPT_ALIGN;
    FVector LocationOffset;
    FRotator RotationOffset;
    TArrayNoInit<BYTE> Actions;
    TArrayNoInit<struct FFireLink> FireLinks;
    TArrayNoInit<struct FFireLink> RejectedFireLinks;
    TArrayNoInit<INT> ExposedCoverPackedProperties;
    INT TurnTargetPackedProperties;
    TArrayNoInit<struct FSlotMoveRef> SlipRefs;
    TArrayNoInit<struct FCoverInfo> OverlapClaimsList;
    BITFIELD bLeanLeft:1;
    BITFIELD bLeanRight:1;
    BITFIELD bForceCanPopUp:1;
    BITFIELD bCanPopUp:1;
    BITFIELD bCanMantle:1;
    BITFIELD bCanClimbUp:1;
    BITFIELD bForceCanCoverSlip_Left:1;
    BITFIELD bForceCanCoverSlip_Right:1;
    BITFIELD bCanCoverSlip_Left:1;
    BITFIELD bCanCoverSlip_Right:1;
    BITFIELD bCanSwatTurn_Left:1;
    BITFIELD bCanSwatTurn_Right:1;
    BITFIELD bEnabled:1;
    BITFIELD bAllowPopup:1;
    BITFIELD bAllowMantle:1;
    BITFIELD bAllowCoverSlip:1;
    BITFIELD bAllowClimbUp:1;
    BITFIELD bAllowSwatTurn:1;
    BITFIELD bForceNoGroundAdjust:1;
    BITFIELD bPlayerOnly:1;
    BITFIELD bPreferLeanOverPopup:1;
    BITFIELD bDestructible:1;
    BITFIELD bSelected:1;
    BITFIELD bFailedToFindSurface:1;
    SCRIPT_ALIGN;

		FORCEINLINE void SetExposedCoverRefIdx( INT Index, INT Val )
		{
			Val &= 0x0000FFFF;
			ExposedCoverPackedProperties(Index) &= ~(0x0000FFFF);
			ExposedCoverPackedProperties(Index) |= Val;
		}
		FORCEINLINE DWORD GetExposedCoverRefIdx( INT Index )
		{
			return (ExposedCoverPackedProperties(Index) & (0x0000FFFF));
		}

		FORCEINLINE void SetExposedScale( INT Index, INT Val )
		{
			Val &= 0x000000FF;
			ExposedCoverPackedProperties(Index) &= ~(0x00FF0000);
			ExposedCoverPackedProperties(Index) |= (Val << 16);
		}
		FORCEINLINE BYTE GetExposedScale( INT Index )
		{
			return ((ExposedCoverPackedProperties(Index) & (0x00FF0000)) >> 16);
		}

		FORCEINLINE void SetLeftTurnTargetCoverRefIdx( INT Val )
		{
			Val &= 0x0000FFFF;
			TurnTargetPackedProperties &= ~(0x0000FFFF);
			TurnTargetPackedProperties |= Val;
		}
		FORCEINLINE DWORD GetLeftTurnTargetCoverRefIdx()
		{
			return (TurnTargetPackedProperties & (0x0000FFFF));
		}
		FORCEINLINE void SetRightTurnTargetCoverRefIdx( INT Val )
		{
			Val &= 0x0000FFFF;
			TurnTargetPackedProperties &= ~(0xFFFF0000);
			TurnTargetPackedProperties |= (Val << 16);
		}
		FORCEINLINE DWORD GetRightTurnTargetCoverRefIdx()
		{
			return ((TurnTargetPackedProperties & (0xFFFF0000)) >> 16);
		}

		FORCEINLINE FFireLink& GetFireLinkRef( INT FireLinkIdx, BYTE ArrayID = 0 )
		{
			if( ArrayID == FLI_RejectedFireLink )
			{
				return RejectedFireLinks(FireLinkIdx);
			}
			else
			{
				return FireLinks(FireLinkIdx);
			}
		}
	
};

struct CoverLink_eventGetDebugString_Parms
{
    INT SlotIdx;
    FString ReturnValue;
    CoverLink_eventGetDebugString_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventSetSlotPlayerOnly_Parms
{
    INT SlotIdx;
    UBOOL bInPlayerOnly;
    CoverLink_eventSetSlotPlayerOnly_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventSetSlotEnabled_Parms
{
    INT SlotIdx;
    UBOOL bEnable;
    CoverLink_eventSetSlotEnabled_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventSetDisabled_Parms
{
    UBOOL bNewDisabled;
    CoverLink_eventSetDisabled_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventUnClaim_Parms
{
    class APawn* OldClaim;
    INT SlotIdx;
    UBOOL bUnclaimAll;
    UBOOL ReturnValue;
    CoverLink_eventUnClaim_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventClaim_Parms
{
    class APawn* NewClaim;
    INT SlotIdx;
    UBOOL ReturnValue;
    CoverLink_eventClaim_Parms(EEventParm)
    {
    }
};
struct CoverLink_eventSetInvalidUntil_Parms
{
    INT SlotIdx;
    FLOAT TimeToBecomeValid;
    CoverLink_eventSetInvalidUntil_Parms(EEventParm)
    {
    }
};
class ACoverLink : public ANavigationPoint
{
public:
    //## BEGIN PROPS CoverLink
    BITFIELD GLOBAL_bUseSlotMarkers:1;
    BITFIELD bDisabled:1;
    BITFIELD bClaimAllSlots:1;
    BITFIELD bAutoSort:1;
    BITFIELD bAutoAdjust:1;
    BITFIELD bCircular:1;
    BITFIELD bLooped:1;
    BITFIELD bPlayerOnly:1;
    BITFIELD bDynamicCover:1;
    BITFIELD bFractureOnTouch:1;
    BITFIELD bDebug_FireLinks:1;
    BITFIELD bDebug_ExposedLinks:1;
    BITFIELD bDebug_CoverGen:1;
    BITFIELD bDoAutoSlotDensityFixup:1;
    FLOAT LeanTraceDist;
    TArrayNoInit<struct FCoverSlot> Slots;
    TArrayNoInit<struct FDynamicLinkInfo> DynamicLinkInfos;
    TArrayNoInit<class APawn*> Claims;
    FLOAT InvalidateDistance;
    FLOAT MaxFireLinkDist;
    FVector CircularOrigin;
    FLOAT CircularRadius;
    FLOAT AlignDist;
    FLOAT AutoCoverSlotInterval;
    FLOAT StandHeight;
    FLOAT MidHeight;
    FVector StandingLeanOffset;
    FVector CrouchLeanOffset;
    FVector PopupOffset;
    FLOAT SlipDist;
    FLOAT TurnDist;
    FLOAT DangerScale;
    class ACoverLink* NextCoverLink;
    BYTE LocationDescription;
    SCRIPT_ALIGN;
    //## END PROPS CoverLink

    virtual UBOOL GetFireLinkTargetCoverInfo(INT SlotIdx,INT FireLinkIdx,struct FCoverInfo& out_Info,BYTE ArrayID=0);
    BYTE PackFireLinkInteractionInfo(BYTE SrcType,BYTE SrcAction,BYTE DestType,BYTE DestAction);
    void UnPackFireLinkInteractionInfo(const BYTE PackedByte,BYTE& SrcType,BYTE& SrcAction,BYTE& DestType,BYTE& DestAction);
    FVector GetSlotLocation(INT SlotIdx,UBOOL bForceUseOffset=FALSE);
    FRotator GetSlotRotation(INT SlotIdx,UBOOL bForceUseOffset=FALSE);
    FVector GetSlotViewPoint(INT SlotIdx,BYTE Type=0,BYTE Action=0);
    UBOOL IsExposedTo(INT SlotIdx,struct FCoverInfo ChkSlot,FLOAT& out_ExposedScale);
    UBOOL IsValidClaim(class APawn* ChkClaim,INT SlotIdx,UBOOL bSkipTeamCheck=FALSE,UBOOL bSkipOverlapCheck=FALSE);
    UBOOL IsValidClaimBetween(class APawn* ChkClaim,INT StartSlotIdx,INT EndSlotIdx,UBOOL bSkipTeamCheck=FALSE,UBOOL bSkipOverlapCheck=FALSE);
    UBOOL FindSlots(FVector CheckLocation,FLOAT MaxDistance,INT& LeftSlotIdx,INT& RightSlotIdx);
    UBOOL IsEdgeSlot(INT SlotIdx,UBOOL bIgnoreLeans=FALSE);
    UBOOL IsLeftEdgeSlot(INT SlotIdx,UBOOL bIgnoreLeans);
    UBOOL IsRightEdgeSlot(INT SlotIdx,UBOOL bIgnoreLeans);
    INT GetSlotIdxToLeft(INT SlotIdx,INT Cnt=1);
    INT GetSlotIdxToRight(INT SlotIdx,INT Cnt=1);
    void GetSlotActions(INT SlotIdx,TArray<BYTE>& Actions);
    UBOOL AutoAdjustSlot(INT SlotIdx,UBOOL bOnlyCheckLeans);
    UBOOL IsEnabled();
    virtual UBOOL GetSwatTurnTarget(INT SlotIdx,INT Direction,struct FCoverInfo& out_Info);
    INT AddCoverSlot(FVector SlotLocation,FRotator SlotRotation,INT SlotIdx=-1,UBOOL bForceSlotUpdate=FALSE,class AScout* Scout=NULL);
    BYTE GetLocationDescription(INT SlotIdx);
    DECLARE_FUNCTION(execGetFireLinkTargetCoverInfo)
    {
        P_GET_INT(SlotIdx);
        P_GET_INT(FireLinkIdx);
        P_GET_STRUCT_REF(struct FCoverInfo,out_Info);
        P_GET_BYTE_OPTX(ArrayID,0);
        P_FINISH;
        *(UBOOL*)Result=this->GetFireLinkTargetCoverInfo(SlotIdx,FireLinkIdx,out_Info,ArrayID);
    }
    DECLARE_FUNCTION(execPackFireLinkInteractionInfo)
    {
        P_GET_BYTE(SrcType);
        P_GET_BYTE(SrcAction);
        P_GET_BYTE(DestType);
        P_GET_BYTE(DestAction);
        P_FINISH;
        *(BYTE*)Result=this->PackFireLinkInteractionInfo(SrcType,SrcAction,DestType,DestAction);
    }
    DECLARE_FUNCTION(execUnPackFireLinkInteractionInfo)
    {
        P_GET_BYTE(PackedByte);
        P_GET_BYTE_REF(SrcType);
        P_GET_BYTE_REF(SrcAction);
        P_GET_BYTE_REF(DestType);
        P_GET_BYTE_REF(DestAction);
        P_FINISH;
        this->UnPackFireLinkInteractionInfo(PackedByte,SrcType,SrcAction,DestType,DestAction);
    }
    DECLARE_FUNCTION(execGetSlotLocation)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL_OPTX(bForceUseOffset,FALSE);
        P_FINISH;
        *(FVector*)Result=this->GetSlotLocation(SlotIdx,bForceUseOffset);
    }
    DECLARE_FUNCTION(execGetSlotRotation)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL_OPTX(bForceUseOffset,FALSE);
        P_FINISH;
        *(FRotator*)Result=this->GetSlotRotation(SlotIdx,bForceUseOffset);
    }
    DECLARE_FUNCTION(execGetSlotViewPoint)
    {
        P_GET_INT(SlotIdx);
        P_GET_BYTE_OPTX(Type,0);
        P_GET_BYTE_OPTX(Action,0);
        P_FINISH;
        *(FVector*)Result=this->GetSlotViewPoint(SlotIdx,Type,Action);
    }
    DECLARE_FUNCTION(execIsExposedTo)
    {
        P_GET_INT(SlotIdx);
        P_GET_STRUCT(struct FCoverInfo,ChkSlot);
        P_GET_FLOAT_REF(out_ExposedScale);
        P_FINISH;
        *(UBOOL*)Result=this->IsExposedTo(SlotIdx,ChkSlot,out_ExposedScale);
    }
    DECLARE_FUNCTION(execIsValidClaim)
    {
        P_GET_OBJECT(APawn,ChkClaim);
        P_GET_INT(SlotIdx);
        P_GET_UBOOL_OPTX(bSkipTeamCheck,FALSE);
        P_GET_UBOOL_OPTX(bSkipOverlapCheck,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->IsValidClaim(ChkClaim,SlotIdx,bSkipTeamCheck,bSkipOverlapCheck);
    }
    DECLARE_FUNCTION(execIsValidClaimBetween)
    {
        P_GET_OBJECT(APawn,ChkClaim);
        P_GET_INT(StartSlotIdx);
        P_GET_INT(EndSlotIdx);
        P_GET_UBOOL_OPTX(bSkipTeamCheck,FALSE);
        P_GET_UBOOL_OPTX(bSkipOverlapCheck,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->IsValidClaimBetween(ChkClaim,StartSlotIdx,EndSlotIdx,bSkipTeamCheck,bSkipOverlapCheck);
    }
    DECLARE_FUNCTION(execFindSlots)
    {
        P_GET_STRUCT(FVector,CheckLocation);
        P_GET_FLOAT(MaxDistance);
        P_GET_INT_REF(LeftSlotIdx);
        P_GET_INT_REF(RightSlotIdx);
        P_FINISH;
        *(UBOOL*)Result=this->FindSlots(CheckLocation,MaxDistance,LeftSlotIdx,RightSlotIdx);
    }
    DECLARE_FUNCTION(execIsEdgeSlot)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL_OPTX(bIgnoreLeans,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->IsEdgeSlot(SlotIdx,bIgnoreLeans);
    }
    DECLARE_FUNCTION(execIsLeftEdgeSlot)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL(bIgnoreLeans);
        P_FINISH;
        *(UBOOL*)Result=this->IsLeftEdgeSlot(SlotIdx,bIgnoreLeans);
    }
    DECLARE_FUNCTION(execIsRightEdgeSlot)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL(bIgnoreLeans);
        P_FINISH;
        *(UBOOL*)Result=this->IsRightEdgeSlot(SlotIdx,bIgnoreLeans);
    }
    DECLARE_FUNCTION(execGetSlotIdxToLeft)
    {
        P_GET_INT(SlotIdx);
        P_GET_INT_OPTX(Cnt,1);
        P_FINISH;
        *(INT*)Result=this->GetSlotIdxToLeft(SlotIdx,Cnt);
    }
    DECLARE_FUNCTION(execGetSlotIdxToRight)
    {
        P_GET_INT(SlotIdx);
        P_GET_INT_OPTX(Cnt,1);
        P_FINISH;
        *(INT*)Result=this->GetSlotIdxToRight(SlotIdx,Cnt);
    }
    DECLARE_FUNCTION(execGetFireLinkTo);
    DECLARE_FUNCTION(execHasFireLinkTo);
    DECLARE_FUNCTION(execGetSlotActions)
    {
        P_GET_INT(SlotIdx);
        P_GET_TARRAY_REF(BYTE,Actions);
        P_FINISH;
        this->GetSlotActions(SlotIdx,Actions);
    }
    DECLARE_FUNCTION(execAutoAdjustSlot)
    {
        P_GET_INT(SlotIdx);
        P_GET_UBOOL(bOnlyCheckLeans);
        P_FINISH;
        *(UBOOL*)Result=this->AutoAdjustSlot(SlotIdx,bOnlyCheckLeans);
    }
    DECLARE_FUNCTION(execIsEnabled)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsEnabled();
    }
    DECLARE_FUNCTION(execGetSwatTurnTarget)
    {
        P_GET_INT(SlotIdx);
        P_GET_INT(Direction);
        P_GET_STRUCT_REF(struct FCoverInfo,out_Info);
        P_FINISH;
        *(UBOOL*)Result=this->GetSwatTurnTarget(SlotIdx,Direction,out_Info);
    }
    DECLARE_FUNCTION(execAddCoverSlot)
    {
        P_GET_STRUCT(FVector,SlotLocation);
        P_GET_STRUCT(FRotator,SlotRotation);
        P_GET_INT_OPTX(SlotIdx,-1);
        P_GET_UBOOL_OPTX(bForceSlotUpdate,FALSE);
        P_GET_OBJECT_OPTX(AScout,Scout,NULL);
        P_FINISH;
        *(INT*)Result=this->AddCoverSlot(SlotLocation,SlotRotation,SlotIdx,bForceSlotUpdate,Scout);
    }
    DECLARE_FUNCTION(execGetLocationDescription)
    {
        P_GET_INT(SlotIdx);
        P_FINISH;
        *(BYTE*)Result=this->GetLocationDescription(SlotIdx);
    }
    FString eventGetDebugString(INT SlotIdx)
    {
        CoverLink_eventGetDebugString_Parms Parms(EC_EventParm);
        Parms.SlotIdx=SlotIdx;
        ProcessEvent(FindFunctionChecked(ENGINE_GetDebugString),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetSlotPlayerOnly(INT SlotIdx,UBOOL bInPlayerOnly)
    {
        CoverLink_eventSetSlotPlayerOnly_Parms Parms(EC_EventParm);
        Parms.SlotIdx=SlotIdx;
        Parms.bInPlayerOnly=bInPlayerOnly ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetSlotPlayerOnly),&Parms);
    }
    void eventSetSlotEnabled(INT SlotIdx,UBOOL bEnable)
    {
        CoverLink_eventSetSlotEnabled_Parms Parms(EC_EventParm);
        Parms.SlotIdx=SlotIdx;
        Parms.bEnable=bEnable ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetSlotEnabled),&Parms);
    }
    void eventSetDisabled(UBOOL bNewDisabled)
    {
        CoverLink_eventSetDisabled_Parms Parms(EC_EventParm);
        Parms.bNewDisabled=bNewDisabled ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetDisabled),&Parms);
    }
    UBOOL eventUnClaim(class APawn* OldClaim,INT SlotIdx,UBOOL bUnclaimAll)
    {
        CoverLink_eventUnClaim_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.OldClaim=OldClaim;
        Parms.SlotIdx=SlotIdx;
        Parms.bUnclaimAll=bUnclaimAll ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_UnClaim),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventClaim(class APawn* NewClaim,INT SlotIdx)
    {
        CoverLink_eventClaim_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.NewClaim=NewClaim;
        Parms.SlotIdx=SlotIdx;
        ProcessEvent(FindFunctionChecked(ENGINE_Claim),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetInvalidUntil(INT SlotIdx,FLOAT TimeToBecomeValid)
    {
        CoverLink_eventSetInvalidUntil_Parms Parms(EC_EventParm);
        Parms.SlotIdx=SlotIdx;
        Parms.TimeToBecomeValid=TimeToBecomeValid;
        ProcessEvent(FindFunctionChecked(ENGINE_SetInvalidUntil),&Parms);
    }
    DECLARE_CLASS(ACoverLink,ANavigationPoint,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	struct FFireLinkInfo
	{
		class ACoverLink*	Link;
		INT					SlotIdx;
		FCoverSlot*			Slot;
		FVector				SlotLocation;
		FRotator			SlotRotation;
		FVector				X, Y, Z;
		TArray<BYTE>		Types;
		TArray<BYTE>		Actions;

		INT*				out_FireLinkIdx;

		FFireLinkInfo( ACoverLink* InLink, INT InSlotIdx, INT* InIdx = NULL )
		{
			Link			= InLink;
			SlotIdx			= InSlotIdx;
			Slot			= &Link->Slots(SlotIdx);
			out_FireLinkIdx = InIdx;

			if( Slot->bLeanLeft )
			{
				Actions.AddItem( CA_LeanLeft );
			}
			if( Slot->bLeanRight )
			{
				Actions.AddItem( CA_LeanRight );
			}
			if( Slot->bCanPopUp && Slot->CoverType == CT_MidLevel )
			{
				Actions.AddItem( CA_PopUp );
			}

			Types.AddItem( Slot->CoverType );
			if( Slot->CoverType == CT_Standing )
			{
				Types.AddItem( CT_MidLevel );
			}

			SlotLocation = Link->GetSlotLocation(SlotIdx);
			SlotRotation = Link->GetSlotRotation(SlotIdx);
			FRotationMatrix(SlotRotation).GetAxes(X,Y,Z);
		}
	};

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void BuildSlotInfo( INT SlotIdx, UBOOL bSeedPylon = FALSE, AScout* Scout = NULL);
	virtual void BuildSlotInfoInternal( AScout* Scout, INT SlotIdx, UBOOL bSeedPylon = FALSE );

	/**Sorts the CoverSlots
		* @param LastSelectedSlot - the last coverslot the user has selected, the sort will update this value if passed in*/
	void SortSlots(FCoverSlot** LastSelectedSlot = NULL);
	void BuildFireLinks( AScout* Scout );
	void BuildOtherLinks( AScout* Scout );
	UBOOL GetFireActions( FFireLinkInfo& SrcInfo, ACoverLink* TestLink, INT TestSlotIdx, UBOOL bFill = TRUE );
	UBOOL CanFireLinkHit( const FVector &ViewPt, const FVector &TargetLoc, UBOOL bDebugLines = FALSE );

	UBOOL GetExposedInfo( ACoverLink* SrcLink, INT SrcSlotIdx, ACoverLink* DestLink, INT DestSlotIdx, FLOAT& out_ExposedScale );

	virtual UBOOL GetFireLinkTo( INT SlotIdx, const FCoverInfo& ChkCover, BYTE ChkActin, BYTE ChkType, INT& out_FireLinkIdx, TArray<INT>& Items );
	virtual UBOOL HasFireLinkTo( INT SlotIdx, const FCoverInfo& ChkCover, UBOOL bAllowFallbackLinks = FALSE );
	FLOAT GetSlotHeight(INT SlotIdx);
#if WITH_EDITOR
	/** Properly handles the mirroring of cover slots associated with this link */
	virtual void EditorApplyMirror(const FVector& MirrorScale, const FVector& PivotLocation);

	virtual void CheckForErrors();
	virtual INT AddMyMarker(AActor *S);
#endif
	virtual UBOOL IsFireLinkValid( INT SlotIdx, INT FireLinkIdx, BYTE ArrayID = 0 );
	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel);

	UBOOL IsOverlapSlotClaimed( APawn *ChkClaim, INT SlotIdx, UBOOL bSkipTeamCheck );

	static FCoverSlot* CoverInfoToSlotPtr( FCoverInfo& InSlot );
	static FCoverSlot* CoverRefToSlotPtr( FCoverReference& InRef );

	UBOOL FindCoverEdges(const FVector& StartLoc, FVector AxisX, FVector AxisY, FVector AxisZ);
	INT AddCoverSlot(FVector& SlotLocation, FRotator& SlotRotation, FCoverSlot Slot, INT SlotIdx = -1);
	void EditorAutoSetup(FVector Direction,FVector *HitL = NULL, FVector *HitN = NULL);
	void ClearExposedFireLinks();

	// called during navmesh generation to link this coverlink into the mesh
	virtual UBOOL LinkCoverSlotToNavigationMesh(INT SlotIdx, class UNavigationMeshBase* Mesh=NULL);

	virtual INT FindCoverReference( ACoverLink* TestLink, INT TestSlotIdx, UBOOL bAddIfNotFound = TRUE );
	virtual UBOOL GetCachedCoverInfo( INT RefIdx, FCoverInfo& out_Info );
	void FixupLevelCoverReferences();

	static FORCEINLINE void FireLinkInteraction_PackSrcType( BYTE SrcType, BYTE& PackedByte )
	{
		if( SrcType == CT_MidLevel ) { PackedByte |= (1<<0); }
	}
	static FORCEINLINE void FireLinkInteraction_PackSrcAction( BYTE SrcAction, BYTE& PackedByte )
	{
		PackedByte |= (SrcAction == CA_LeanLeft  ? (1<<1) :
					   SrcAction == CA_LeanRight ? (1<<2) :
					   SrcAction == CA_PopUp     ? (1<<3) :
													0);
	}
	static FORCEINLINE void FireLinkInteraction_PackDestType( BYTE DestType, BYTE& PackedByte )
	{
		if( DestType == CT_MidLevel ) { PackedByte |= (1<<4); }
	}
	static FORCEINLINE void FireLinkInteraction_PackDestAction( BYTE DestAction, BYTE& PackedByte )
	{
		PackedByte |= (DestAction == CA_LeanLeft  ? (1<<5) :
					   DestAction == CA_LeanRight ? (1<<6) :
					   DestAction == CA_PopUp     ? (1<<7) :
													0);
	}

	static FORCEINLINE BYTE FireLinkInteraction_UnpackSrcType( const BYTE PackedByte )
	{
		return (PackedByte & (1<<0)) ? CT_MidLevel : CT_Standing;
	}
	static FORCEINLINE BYTE FireLinkInteraction_UnpackSrcAction( const BYTE PackedByte )
	{
		return (PackedByte & (1<<1)) ? CA_LeanLeft  :
			   (PackedByte & (1<<2)) ? CA_LeanRight :
			   (PackedByte & (1<<3)) ? CA_PopUp :
				CA_Default;
	}
	static FORCEINLINE BYTE FireLinkInteraction_UnpackDestType( const BYTE PackedByte )
	{
		return (PackedByte & (1<<4)) ? CT_MidLevel : CT_Standing;
	}
	static FORCEINLINE BYTE FireLinkInteraction_UnpackDestAction( const BYTE PackedByte )
	{
		return (PackedByte & (1<<5)) ? CA_LeanLeft  :
			   (PackedByte & (1<<6)) ? CA_LeanRight :
			   (PackedByte & (1<<7)) ? CA_PopUp :
				CA_Default;
	}
};

class ACoverGroup : public AInfo
{
public:
    //## BEGIN PROPS CoverGroup
    TArrayNoInit<struct FActorReference> CoverLinkRefs;
    FLOAT AutoSelectRadius;
    FLOAT AutoSelectHeight;
    //## END PROPS CoverGroup

    virtual void EnableGroup();
    virtual void DisableGroup();
    virtual void ToggleGroup();
    DECLARE_FUNCTION(execEnableGroup)
    {
        P_FINISH;
        this->EnableGroup();
    }
    DECLARE_FUNCTION(execDisableGroup)
    {
        P_FINISH;
        this->DisableGroup();
    }
    DECLARE_FUNCTION(execToggleGroup)
    {
        P_FINISH;
        this->ToggleGroup();
    }
    DECLARE_CLASS(ACoverGroup,AInfo,0,Engine)
	void AutoFillGroup( ECoverGroupFillAction CGFA, TArray<class ACoverLink*>& Links );

	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel);

	virtual void PostLoad();
#if WITH_EDITOR
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
	virtual void CheckForErrors();
#endif
};

class AFileWriter : public AInfo
{
public:
    //## BEGIN PROPS FileWriter
    FArchive* ArchivePtr;
    FStringNoInit Filename;
    BYTE FileType;
    SCRIPT_ALIGN;
    BITFIELD bFlushEachWrite:1;
    BITFIELD bWantsAsyncWrites:1;
    SCRIPT_ALIGN;
    //## END PROPS FileWriter

    UBOOL OpenFile(const FString& InFilename,BYTE InFileType=0,const FString& InExtension=TEXT(""),UBOOL bUnique=FALSE,UBOOL bIncludeTimeStamp=FALSE);
    void CloseFile();
    void Logf(const FString& logString);
    DECLARE_FUNCTION(execOpenFile)
    {
        P_GET_STR(InFilename);
        P_GET_BYTE_OPTX(InFileType,0);
        P_GET_STR_OPTX(InExtension,TEXT(""));
        P_GET_UBOOL_OPTX(bUnique,FALSE);
        P_GET_UBOOL_OPTX(bIncludeTimeStamp,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->OpenFile(InFilename,InFileType,InExtension,bUnique,bIncludeTimeStamp);
    }
    DECLARE_FUNCTION(execCloseFile)
    {
        P_FINISH;
        this->CloseFile();
    }
    DECLARE_FUNCTION(execLogf)
    {
        P_GET_STR(logString);
        P_FINISH;
        this->Logf(logString);
    }
    DECLARE_CLASS(AFileWriter,AInfo,0,Engine)
	virtual void BeginDestroy();
};

class AFileLog : public AFileWriter
{
public:
    //## BEGIN PROPS FileLog
    //## END PROPS FileLog

    DECLARE_CLASS(AFileLog,AFileWriter,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AFileLog)
};

struct FGameClassShortName
{
    FStringNoInit ShortName;
    FStringNoInit GameClassName;

    /** Constructors */
    FGameClassShortName() {}
    FGameClassShortName(EEventParm)
    {
        appMemzero(this, sizeof(FGameClassShortName));
    }
};

struct FGameTypePrefix
{
    FStringNoInit Prefix;
    BITFIELD bUsesCommonPackage:1;
    FStringNoInit GameType;
    TArrayNoInit<FString> AdditionalGameTypes;
    TArrayNoInit<FString> ForcedObjects;

    /** Constructors */
    FGameTypePrefix() {}
    FGameTypePrefix(EEventParm)
    {
        appMemzero(this, sizeof(FGameTypePrefix));
    }
};

struct GameInfo_eventOnEngineHasLoaded_Parms
{
    GameInfo_eventOnEngineHasLoaded_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventStandbyCheatDetected_Parms
{
    BYTE StandbyType;
    GameInfo_eventStandbyCheatDetected_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventMatineeCancelled_Parms
{
    GameInfo_eventMatineeCancelled_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventHandleSeamlessTravelPlayer_Parms
{
    class AController* C;
    GameInfo_eventHandleSeamlessTravelPlayer_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPostSeamlessTravel_Parms
{
    GameInfo_eventPostSeamlessTravel_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventGetSeamlessTravelActorList_Parms
{
    UBOOL bToEntry;
    TArray<class AActor*> ActorList;
    GameInfo_eventGetSeamlessTravelActorList_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPostCommitMapChange_Parms
{
    GameInfo_eventPostCommitMapChange_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPreCommitMapChange_Parms
{
    FString PreviousMapName;
    FString NextMapName;
    GameInfo_eventPreCommitMapChange_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventBroadcastLocalizedTeam_Parms
{
    INT TeamIndex;
    class AActor* Sender;
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    GameInfo_eventBroadcastLocalizedTeam_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventBroadcastLocalized_Parms
{
    class AActor* Sender;
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
    GameInfo_eventBroadcastLocalized_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventBroadcast_Parms
{
    class AActor* Sender;
    FString msg;
    FName Type;
    GameInfo_eventBroadcast_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventAddDefaultInventory_Parms
{
    class APawn* P;
    GameInfo_eventAddDefaultInventory_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventAcceptInventory_Parms
{
    class APawn* PlayerPawn;
    GameInfo_eventAcceptInventory_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPreExit_Parms
{
    GameInfo_eventPreExit_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPostLogin_Parms
{
    class APlayerController* NewPlayer;
    GameInfo_eventPostLogin_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventLogin_Parms
{
    FString Portal;
    FString Options;
    struct FUniqueNetId UniqueId;
    FString ErrorMessage;
    class APlayerController* ReturnValue;
    GameInfo_eventLogin_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventPreLogin_Parms
{
    FString Options;
    FString Address;
    struct FUniqueNetId UniqueId;
    UBOOL bSupportsAuth;
    FString ErrorMessage;
    GameInfo_eventPreLogin_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventNotifyPendingConnectionLost_Parms
{
    GameInfo_eventNotifyPendingConnectionLost_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventInitGame_Parms
{
    FString Options;
    FString ErrorMessage;
    GameInfo_eventInitGame_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventSetGameType_Parms
{
    FString MapName;
    FString Options;
    FString Portal;
    class UClass* ReturnValue;
    GameInfo_eventSetGameType_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventGetDefaultGameClassPath_Parms
{
    FString MapName;
    FString Options;
    FString Portal;
    FString ReturnValue;
    GameInfo_eventGetDefaultGameClassPath_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventClearPause_Parms
{
    GameInfo_eventClearPause_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventCanUnpause_Parms
{
    UBOOL ReturnValue;
    GameInfo_eventCanUnpause_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventForceKickPlayer_Parms
{
    class APlayerController* PC;
    FString KickReason;
    GameInfo_eventForceKickPlayer_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventKickIdler_Parms
{
    class APlayerController* PC;
    GameInfo_eventKickIdler_Parms(EEventParm)
    {
    }
};
struct GameInfo_eventGameEnding_Parms
{
    GameInfo_eventGameEnding_Parms(EEventParm)
    {
    }
};
class AGameInfo : public AInfo
{
public:
    //## BEGIN PROPS GameInfo
    BITFIELD bRestartLevel:1;
    BITFIELD bPauseable:1;
    BITFIELD bTeamGame:1;
    BITFIELD bGameEnded:1;
    BITFIELD bOverTime:1;
    BITFIELD bDelayedStart:1;
    BITFIELD bWaitingToStartMatch:1;
    BITFIELD bChangeLevels:1;
    BITFIELD bAlreadyChanged:1;
    BITFIELD bAdminCanPause:1;
    BITFIELD bGameRestarted:1;
    BITFIELD bLevelChange:1;
    BITFIELD bKickLiveIdlers:1;
    BITFIELD bUsingArbitration:1;
    BITFIELD bHasArbitratedHandshakeBegun:1;
    BITFIELD bNeedsEndGameHandshake:1;
    BITFIELD bIsEndGameHandshakeComplete:1;
    BITFIELD bHasEndGameHandshakeBegun:1;
    BITFIELD bFixedPlayerStart:1;
    BITFIELD bDoFearCostFallOff:1;
    BITFIELD bUseSeamlessTravel:1;
    BITFIELD bHasNetworkError:1;
    BITFIELD bRequiresPushToTalk:1;
    BITFIELD bIsStandbyCheckingEnabled:1;
    BITFIELD bIsStandbyCheckingOn:1;
    BITFIELD bHasStandbyCheatTriggered:1;
    FStringNoInit CauseEventCommand;
    FStringNoInit BugLocString;
    FStringNoInit BugRotString;
    TArrayNoInit<class APlayerController*> PendingArbitrationPCs;
    TArrayNoInit<class APlayerController*> ArbitrationPCs;
    FLOAT ArbitrationHandshakeTimeout;
    FLOAT GameDifficulty;
    INT GoreLevel;
    FLOAT GameSpeed;
    class UClass* DefaultPawnClass;
    class UClass* HUDType;
    class UClass* SecondaryHUDType;
    INT MaxSpectators;
    INT MaxSpectatorsAllowed;
    INT NumSpectators;
    INT MaxPlayers;
    INT MaxPlayersAllowed;
    INT NumPlayers;
    INT NumBots;
    INT NumTravellingPlayers;
    INT CurrentID;
    FStringNoInit DefaultPlayerName;
    FStringNoInit GameName;
    FLOAT FearCostFallOff;
    INT GoalScore;
    INT MaxLives;
    INT TimeLimit;
    class UClass* DeathMessageClass;
    class UClass* GameMessageClass;
    class AMutator* BaseMutator;
    class UClass* AccessControlClass;
    class AAccessControl* AccessControl;
    class UClass* BroadcastHandlerClass;
    class ABroadcastHandler* BroadcastHandler;
    class UClass* AutoTestManagerClass;
    class AAutoTestManager* MyAutoTestManager;
    class UClass* PlayerControllerClass;
    class UClass* PlayerReplicationInfoClass;
    class UClass* GameReplicationInfoClass;
    class AGameReplicationInfo* GameReplicationInfo;
    class ACrowdPopulationManagerBase* PopulationManager;
    class UClass* PopulationManagerClass;
    FLOAT MaxIdleTime;
    FLOAT MaxTimeMargin;
    FLOAT TimeMarginSlack;
    FLOAT MinTimeMargin;
    TArrayNoInit<class APlayerReplicationInfo*> InactivePRIArray;
    TArrayNoInit<FScriptDelegate> Pausers;
    class UOnlineSubsystem* OnlineSub;
    TScriptInterface<class IInterface> GameInterface;
    class UClass* OnlineStatsWriteClass;
    INT LeaderboardId;
    INT ArbitratedLeaderboardId;
    class ACoverReplicator* CoverReplicatorBase;
    class UClass* OnlineGameSettingsClass;
    FStringNoInit ServerOptions;
    INT AdjustedNetSpeed;
    FLOAT LastNetSpeedUpdateTime;
    INT TotalNetBandwidth;
    INT MinDynamicBandwidth;
    INT MaxDynamicBandwidth;
    FLOAT StandbyRxCheatTime;
    FLOAT StandbyTxCheatTime;
    INT BadPingThreshold;
    FLOAT PercentMissingForRxStandby;
    FLOAT PercentMissingForTxStandby;
    FLOAT PercentForBadPing;
    FLOAT JoinInProgressStandbyWaitTime;
    class UMaterial* StreamingPauseIcon;
    TArrayNoInit<struct FGameClassShortName> GameInfoClassAliases;
    FStringNoInit DefaultGameType;
    TArrayNoInit<struct FGameTypePrefix> DefaultMapPrefixes;
    TArrayNoInit<struct FGameTypePrefix> CustomMapPrefixes;
    INT AnimTreePoolSize;
    FScriptDelegate __CanUnpause__Delegate;
    //## END PROPS GameInfo

    virtual UBOOL GetSupportedGameTypes(const FString& InFilename,struct FGameTypePrefix& OutGameType,UBOOL bCheckExt=FALSE) const;
    virtual UBOOL GetMapCommonPackageName(const FString& InFilename,FString& OutCommonPackageName) const;
    UBOOL ShouldStartInCinematicMode(INT& OutHidePlayer,INT& OutHideHud,INT& OutDisableMovement,INT& OutDisableTurning,INT& OutDisableInput);
    void DoNavFearCostFallOff();
    virtual FString GetNetworkNumber();
    void ForceClearUnpauseDelegates(class AActor* PauseActor);
    class UPlayer* PauseLogin();
    void ResumeLogin(class UPlayer* InPlayer);
    void RejectLogin(class UPlayer* InPlayer,const FString& Error);
    INT GetNextPlayerID();
    void SwapPlayerControllers(class APlayerController* OldPC,class APlayerController* NewPC);
    virtual void SetBandwidthLimit(FLOAT AsyncIOBandwidthLimit);
    virtual void EnableStandbyCheatDetection(UBOOL bIsEnabled);
    DECLARE_FUNCTION(execGetSupportedGameTypes)
    {
        P_GET_STR_REF(InFilename);
        P_GET_STRUCT_INIT_REF(struct FGameTypePrefix,OutGameType);
        P_GET_UBOOL_OPTX(bCheckExt,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->GetSupportedGameTypes(InFilename,OutGameType,bCheckExt);
    }
    DECLARE_FUNCTION(execGetMapCommonPackageName)
    {
        P_GET_STR_REF(InFilename);
        P_GET_STR_REF(OutCommonPackageName);
        P_FINISH;
        *(UBOOL*)Result=this->GetMapCommonPackageName(InFilename,OutCommonPackageName);
    }
    DECLARE_FUNCTION(execShouldStartInCinematicMode)
    {
        P_GET_INT_REF(OutHidePlayer);
        P_GET_INT_REF(OutHideHud);
        P_GET_INT_REF(OutDisableMovement);
        P_GET_INT_REF(OutDisableTurning);
        P_GET_INT_REF(OutDisableInput);
        P_FINISH;
        *(UBOOL*)Result=this->ShouldStartInCinematicMode(OutHidePlayer,OutHideHud,OutDisableMovement,OutDisableTurning,OutDisableInput);
    }
    DECLARE_FUNCTION(execDoNavFearCostFallOff)
    {
        P_FINISH;
        this->DoNavFearCostFallOff();
    }
    DECLARE_FUNCTION(execGetNetworkNumber)
    {
        P_FINISH;
        *(FString*)Result=this->GetNetworkNumber();
    }
    DECLARE_FUNCTION(execForceClearUnpauseDelegates)
    {
        P_GET_OBJECT(AActor,PauseActor);
        P_FINISH;
        this->ForceClearUnpauseDelegates(PauseActor);
    }
    DECLARE_FUNCTION(execPauseLogin)
    {
        P_FINISH;
        *(class UPlayer**)Result=this->PauseLogin();
    }
    DECLARE_FUNCTION(execResumeLogin)
    {
        P_GET_OBJECT(UPlayer,InPlayer);
        P_FINISH;
        this->ResumeLogin(InPlayer);
    }
    DECLARE_FUNCTION(execRejectLogin)
    {
        P_GET_OBJECT(UPlayer,InPlayer);
        P_GET_STR(Error);
        P_FINISH;
        this->RejectLogin(InPlayer,Error);
    }
    DECLARE_FUNCTION(execGetNextPlayerID)
    {
        P_FINISH;
        *(INT*)Result=this->GetNextPlayerID();
    }
    DECLARE_FUNCTION(execSwapPlayerControllers)
    {
        P_GET_OBJECT(APlayerController,OldPC);
        P_GET_OBJECT(APlayerController,NewPC);
        P_FINISH;
        this->SwapPlayerControllers(OldPC,NewPC);
    }
    DECLARE_FUNCTION(execSetBandwidthLimit)
    {
        P_GET_FLOAT(AsyncIOBandwidthLimit);
        P_FINISH;
        this->SetBandwidthLimit(AsyncIOBandwidthLimit);
    }
    DECLARE_FUNCTION(execEnableStandbyCheatDetection)
    {
        P_GET_UBOOL(bIsEnabled);
        P_FINISH;
        this->EnableStandbyCheatDetection(bIsEnabled);
    }
    void eventOnEngineHasLoaded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnEngineHasLoaded),NULL);
    }
    void eventStandbyCheatDetected(BYTE StandbyType)
    {
        GameInfo_eventStandbyCheatDetected_Parms Parms(EC_EventParm);
        Parms.StandbyType=StandbyType;
        ProcessEvent(FindFunctionChecked(ENGINE_StandbyCheatDetected),&Parms);
    }
    void eventMatineeCancelled()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MatineeCancelled),NULL);
    }
    void eventHandleSeamlessTravelPlayer(class AController*& C)
    {
        GameInfo_eventHandleSeamlessTravelPlayer_Parms Parms(EC_EventParm);
        Parms.C=C;
        ProcessEvent(FindFunctionChecked(ENGINE_HandleSeamlessTravelPlayer),&Parms);
        C=Parms.C;
    }
    void eventPostSeamlessTravel()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostSeamlessTravel),NULL);
    }
    void eventGetSeamlessTravelActorList(UBOOL bToEntry,TArray<class AActor*>& ActorList)
    {
        GameInfo_eventGetSeamlessTravelActorList_Parms Parms(EC_EventParm);
        Parms.bToEntry=bToEntry ? FIRST_BITFIELD : FALSE;
        Parms.ActorList=ActorList;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSeamlessTravelActorList),&Parms);
        ActorList=Parms.ActorList;
    }
    void eventPostCommitMapChange()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostCommitMapChange),NULL);
    }
    void eventPreCommitMapChange(const FString& PreviousMapName,const FString& NextMapName)
    {
        GameInfo_eventPreCommitMapChange_Parms Parms(EC_EventParm);
        Parms.PreviousMapName=PreviousMapName;
        Parms.NextMapName=NextMapName;
        ProcessEvent(FindFunctionChecked(ENGINE_PreCommitMapChange),&Parms);
    }
    void eventBroadcastLocalizedTeam(INT TeamIndex,class AActor* Sender,class UClass* Message,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        GameInfo_eventBroadcastLocalizedTeam_Parms Parms(EC_EventParm);
        Parms.TeamIndex=TeamIndex;
        Parms.Sender=Sender;
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalizedTeam),&Parms);
    }
    void eventBroadcastLocalized(class AActor* Sender,class UClass* Message,INT Switch=0,class APlayerReplicationInfo* RelatedPRI_1=NULL,class APlayerReplicationInfo* RelatedPRI_2=NULL,class UObject* OptionalObject=NULL)
    {
        GameInfo_eventBroadcastLocalized_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalized),&Parms);
    }
    void eventBroadcast(class AActor* Sender,const FString& msg,FName Type=NAME_None)
    {
        GameInfo_eventBroadcast_Parms Parms(EC_EventParm);
        Parms.Sender=Sender;
        Parms.msg=msg;
        Parms.Type=Type;
        ProcessEvent(FindFunctionChecked(ENGINE_Broadcast),&Parms);
    }
    void eventAddDefaultInventory(class APawn* P)
    {
        GameInfo_eventAddDefaultInventory_Parms Parms(EC_EventParm);
        Parms.P=P;
        ProcessEvent(FindFunctionChecked(ENGINE_AddDefaultInventory),&Parms);
    }
    void eventAcceptInventory(class APawn* PlayerPawn)
    {
        GameInfo_eventAcceptInventory_Parms Parms(EC_EventParm);
        Parms.PlayerPawn=PlayerPawn;
        ProcessEvent(FindFunctionChecked(ENGINE_AcceptInventory),&Parms);
    }
    void eventPreExit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PreExit),NULL);
    }
    void eventPostLogin(class APlayerController* NewPlayer)
    {
        GameInfo_eventPostLogin_Parms Parms(EC_EventParm);
        Parms.NewPlayer=NewPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_PostLogin),&Parms);
    }
    class APlayerController* eventLogin(const FString& Portal,const FString& Options,const struct FUniqueNetId UniqueId,FString& ErrorMessage)
    {
        GameInfo_eventLogin_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.Portal=Portal;
        Parms.Options=Options;
        Parms.UniqueId=UniqueId;
        Parms.ErrorMessage=ErrorMessage;
        ProcessEvent(FindFunctionChecked(ENGINE_Login),&Parms);
        ErrorMessage=Parms.ErrorMessage;
        return Parms.ReturnValue;
    }
    void eventPreLogin(const FString& Options,const FString& Address,const struct FUniqueNetId UniqueId,UBOOL bSupportsAuth,FString& ErrorMessage)
    {
        GameInfo_eventPreLogin_Parms Parms(EC_EventParm);
        Parms.Options=Options;
        Parms.Address=Address;
        Parms.UniqueId=UniqueId;
        Parms.bSupportsAuth=bSupportsAuth ? FIRST_BITFIELD : FALSE;
        Parms.ErrorMessage=ErrorMessage;
        ProcessEvent(FindFunctionChecked(ENGINE_PreLogin),&Parms);
        ErrorMessage=Parms.ErrorMessage;
    }
    void eventNotifyPendingConnectionLost()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPendingConnectionLost),NULL);
    }
    void eventInitGame(const FString& Options,FString& ErrorMessage)
    {
        GameInfo_eventInitGame_Parms Parms(EC_EventParm);
        Parms.Options=Options;
        Parms.ErrorMessage=ErrorMessage;
        ProcessEvent(FindFunctionChecked(ENGINE_InitGame),&Parms);
        ErrorMessage=Parms.ErrorMessage;
    }
    class UClass* eventSetGameType(const FString& MapName,const FString& Options,const FString& Portal)
    {
        GameInfo_eventSetGameType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.MapName=MapName;
        Parms.Options=Options;
        Parms.Portal=Portal;
        ProcessEvent(FindFunctionChecked(ENGINE_SetGameType),&Parms);
        return Parms.ReturnValue;
    }
    FString eventGetDefaultGameClassPath(const FString& MapName,const FString& Options,const FString& Portal)
    {
        GameInfo_eventGetDefaultGameClassPath_Parms Parms(EC_EventParm);
        Parms.MapName=MapName;
        Parms.Options=Options;
        Parms.Portal=Portal;
        ProcessEvent(FindFunctionChecked(ENGINE_GetDefaultGameClassPath),&Parms);
        return Parms.ReturnValue;
    }
    void eventClearPause()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClearPause),NULL);
    }
    UBOOL delegateCanUnpause()
    {
        GameInfo_eventCanUnpause_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessDelegate(ENGINE_CanUnpause,&__CanUnpause__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    void eventForceKickPlayer(class APlayerController* PC,const FString& KickReason)
    {
        GameInfo_eventForceKickPlayer_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        Parms.KickReason=KickReason;
        ProcessEvent(FindFunctionChecked(ENGINE_ForceKickPlayer),&Parms);
    }
    void eventKickIdler(class APlayerController* PC)
    {
        GameInfo_eventKickIdler_Parms Parms(EC_EventParm);
        Parms.PC=PC;
        ProcessEvent(FindFunctionChecked(ENGINE_KickIdler),&Parms);
    }
    void eventGameEnding()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_GameEnding),NULL);
    }
    DECLARE_CLASS(AGameInfo,AInfo,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

	/** called on the default object of the class specified by DefaultGame in the [Engine.GameInfo] section of Game.ini
	 * whenever worlds are saved.
	 * Gives the game a chance to add supported gametypes to the WorldInfo's GameTypesSupportedOnThisMap array
	 * (used for console cooking)
	 * @param Info: the WorldInfo of the world being saved
	 */
	virtual void AddSupportedGameTypes(AWorldInfo* Info, const TCHAR* WorldFilename, TArray<FString>& AdditionalPackagesToCook) const
	{
	}

	/** Allows for game classname remapping and/or aliasing (e.g. for shorthand names) */
	static FString StaticGetRemappedGameClassName(FString const& GameClassName);
};

class AMutator : public AInfo
{
public:
    //## BEGIN PROPS Mutator
    class AMutator* NextMutator;
    TArrayNoInit<FString> GroupNames;
    BITFIELD bUserAdded:1;
    SCRIPT_ALIGN;
    //## END PROPS Mutator

    DECLARE_ABSTRACT_CLASS(AMutator,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AMutator)
};

class APotentialClimbWatcher : public AInfo
{
public:
    //## BEGIN PROPS PotentialClimbWatcher
    //## END PROPS PotentialClimbWatcher

    DECLARE_CLASS(APotentialClimbWatcher,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(APotentialClimbWatcher)
};

class ARoute : public AInfo, public IEditorLinkSelectionInterface
{
public:
    //## BEGIN PROPS Route
    BYTE RouteType;
    TArrayNoInit<struct FActorReference> RouteList;
    FLOAT FudgeFactor;
    INT RouteIndexOffset;
    //## END PROPS Route

    INT ResolveRouteIndex(INT Idx,BYTE RouteDirection,BYTE& out_bComplete,BYTE& out_bReverse);
    INT MoveOntoRoutePath(class APawn* P,BYTE RouteDirection=0,FLOAT DistFudgeFactor=1.000000);
    DECLARE_FUNCTION(execResolveRouteIndex)
    {
        P_GET_INT(Idx);
        P_GET_BYTE(RouteDirection);
        P_GET_BYTE_REF(out_bComplete);
        P_GET_BYTE_REF(out_bReverse);
        P_FINISH;
        *(INT*)Result=this->ResolveRouteIndex(Idx,RouteDirection,out_bComplete,out_bReverse);
    }
    DECLARE_FUNCTION(execMoveOntoRoutePath)
    {
        P_GET_OBJECT(APawn,P);
        P_GET_BYTE_OPTX(RouteDirection,0);
        P_GET_FLOAT_OPTX(DistFudgeFactor,1.000000);
        P_FINISH;
        *(INT*)Result=this->MoveOntoRoutePath(P,RouteDirection,DistFudgeFactor);
    }
    DECLARE_CLASS(ARoute,AInfo,0,Engine)
    virtual UObject* GetUObjectInterfaceEditorLinkSelectionInterface(){return this;}
	void AutoFillRoute( ERouteFillAction RFA, TArray<AActor*>& Points );
	virtual void GetActorReferences(TArray<FActorReference*> &ActorRefs, UBOOL bIsRemovingLevel);
#if WITH_EDITOR
	virtual void CheckForErrors();
	virtual UBOOL HasRefToActor( AActor* A, INT* out_Idx = NULL );
#endif

	////// EditorLinkSelectionInterface
	virtual void LinkSelection(USelection* SelectedActors);

};

class AWindPointSource : public AInfo
{
public:
    //## BEGIN PROPS WindPointSource
    class UWindPointSourceComponent* Component;
    //## END PROPS WindPointSource

    DECLARE_CLASS(AWindPointSource,AInfo,0,Engine)
#if WITH_EDITOR
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
#endif
};

class AZoneInfo : public AInfo
{
public:
    //## BEGIN PROPS ZoneInfo
    FLOAT KillZ;
    FLOAT SoftKill;
    class UClass* KillZDamageType;
    BITFIELD bSoftKillZ:1;
    SCRIPT_ALIGN;
    //## END PROPS ZoneInfo

    DECLARE_CLASS(AZoneInfo,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AZoneInfo)
};

class AInventory : public AActor
{
public:
    //## BEGIN PROPS Inventory
    class AInventory* Inventory;
    class AInventoryManager* InvManager;
    FStringNoInit ItemName;
    BITFIELD bDropOnDeath:1;
    BITFIELD bDelayedSpawn:1;
    BITFIELD bPredictRespawns:1;
    FLOAT RespawnTime;
    FLOAT MaxDesireability;
    FStringNoInit PickupMessage;
    class USoundCue* PickupSound;
    FStringNoInit PickupForce;
    class UClass* DroppedPickupClass;
    class UPrimitiveComponent* DroppedPickupMesh;
    class UPrimitiveComponent* PickupFactoryMesh;
    class UParticleSystemComponent* DroppedPickupParticles;
    //## END PROPS Inventory

    DECLARE_ABSTRACT_CLASS(AInventory,AActor,0|CLASS_NativeReplication,Engine)
	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

struct Weapon_eventGetPhysicalFireStartLoc_Parms
{
    FVector AimDir;
    FVector ReturnValue;
    Weapon_eventGetPhysicalFireStartLoc_Parms(EEventParm)
    {
    }
};
struct Weapon_eventGetMuzzleLoc_Parms
{
    FVector ReturnValue;
    Weapon_eventGetMuzzleLoc_Parms(EEventParm)
    {
    }
};
struct Weapon_eventGetTraceRange_Parms
{
    FLOAT ReturnValue;
    Weapon_eventGetTraceRange_Parms(EEventParm)
    {
    }
};
struct Weapon_eventStopWeaponAnimation_Parms
{
    Weapon_eventStopWeaponAnimation_Parms(EEventParm)
    {
    }
};
struct Weapon_eventPlayWeaponAnimation_Parms
{
    FName Sequence;
    FLOAT fDesiredDuration;
    UBOOL bLoop;
    class USkeletalMeshComponent* SkelMesh;
    Weapon_eventPlayWeaponAnimation_Parms(EEventParm)
    {
    }
};
struct Weapon_eventIsFiring_Parms
{
    UBOOL ReturnValue;
    Weapon_eventIsFiring_Parms(EEventParm)
    {
    }
};
class AWeapon : public AInventory
{
public:
    //## BEGIN PROPS Weapon
    BYTE CurrentFireMode;
    TArrayNoInit<FName> FiringStatesArray;
    TArrayNoInit<BYTE> WeaponFireTypes;
    TArrayNoInit<class UClass*> WeaponProjectiles;
    TArrayNoInit<FLOAT> FireInterval;
    TArrayNoInit<FLOAT> Spread;
    TArrayNoInit<FLOAT> InstantHitDamage;
    TArrayNoInit<FLOAT> InstantHitMomentum;
    TArrayNoInit<class UClass*> InstantHitDamageTypes;
    FLOAT EquipTime;
    FLOAT PutDownTime;
    FVector FireOffset;
    BITFIELD bWeaponPutDown:1;
    BITFIELD bCanThrow:1;
    BITFIELD bWasOptionalSet:1;
    BITFIELD bWasDoNotActivate:1;
    BITFIELD bInstantHit:1;
    BITFIELD bMeleeWeapon:1;
    FLOAT WeaponRange;
    class UMeshComponent* Mesh;
    FLOAT DefaultAnimSpeed;
    FLOAT Priority;
    class AAIController* AIController;
    TArrayNoInit<BYTE> ShouldFireOnRelease;
    FLOAT AIRating;
    FLOAT CachedMaxRange;
    //## END PROPS Weapon

    virtual FVector GetPhysicalFireStartLoc(FVector AimDir=FVector(EC_EventParm));
    DECLARE_FUNCTION(execGetPhysicalFireStartLoc)
    {
        P_GET_STRUCT_OPTX(FVector,AimDir,FVector(EC_EventParm));
        P_FINISH;
        *(FVector*)Result=this->GetPhysicalFireStartLoc(AimDir);
    }
    FVector eventGetPhysicalFireStartLoc(FVector AimDir=FVector(EC_EventParm))
    {
        Weapon_eventGetPhysicalFireStartLoc_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.AimDir=AimDir;
        ProcessEvent(FindFunctionChecked(ENGINE_GetPhysicalFireStartLoc),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetMuzzleLoc()
    {
        Weapon_eventGetMuzzleLoc_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetMuzzleLoc),&Parms);
        return Parms.ReturnValue;
    }
    FLOAT eventGetTraceRange()
    {
        Weapon_eventGetTraceRange_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetTraceRange),&Parms);
        return Parms.ReturnValue;
    }
    void eventStopWeaponAnimation()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StopWeaponAnimation),NULL);
    }
    void eventPlayWeaponAnimation(FName Sequence,FLOAT fDesiredDuration,UBOOL bLoop=FALSE,class USkeletalMeshComponent* SkelMesh=NULL)
    {
        Weapon_eventPlayWeaponAnimation_Parms Parms(EC_EventParm);
        Parms.Sequence=Sequence;
        Parms.fDesiredDuration=fDesiredDuration;
        Parms.bLoop=bLoop ? FIRST_BITFIELD : FALSE;
        Parms.SkelMesh=SkelMesh;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayWeaponAnimation),&Parms);
    }
    UBOOL eventIsFiring()
    {
        Weapon_eventIsFiring_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_IsFiring),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AWeapon,AInventory,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    NO_DEFAULT_CONSTRUCTOR(AWeapon)
};

struct InventoryManager_eventDiscardInventory_Parms
{
    InventoryManager_eventDiscardInventory_Parms(EEventParm)
    {
    }
};
struct InventoryManager_eventFindInventoryType_Parms
{
    class UClass* DesiredClass;
    UBOOL bAllowSubclass;
    class AInventory* ReturnValue;
    InventoryManager_eventFindInventoryType_Parms(EEventParm)
    {
    }
};
class AInventoryManager : public AActor
{
public:
    //## BEGIN PROPS InventoryManager
    class AInventory* InventoryChain;
    class AWeapon* PendingWeapon;
    class AWeapon* LastAttemptedSwitchToWeapon;
    BITFIELD bMustHoldWeapon:1;
    TArrayNoInit<INT> PendingFire;
    //## END PROPS InventoryManager

    DECLARE_FUNCTION(execInventoryActors);
    void eventDiscardInventory()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_DiscardInventory),NULL);
    }
    class AInventory* eventFindInventoryType(class UClass* DesiredClass,UBOOL bAllowSubclass=FALSE)
    {
        InventoryManager_eventFindInventoryType_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.DesiredClass=DesiredClass;
        Parms.bAllowSubclass=bAllowSubclass ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_FindInventoryType),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AInventoryManager,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AInventoryManager)
};

class AKeypoint : public AActor
{
public:
    //## BEGIN PROPS Keypoint
    class USpriteComponent* SpriteComp;
    //## END PROPS Keypoint

    DECLARE_ABSTRACT_CLASS(AKeypoint,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AKeypoint)
};

class ATargetPoint : public AKeypoint
{
public:
    //## BEGIN PROPS TargetPoint
#if WITH_EDITORONLY_DATA
    class UTexture2D* SpawnSpriteTexture;
#endif // WITH_EDITORONLY_DATA
    INT SpawnRefCount;
    //## END PROPS TargetPoint

    DECLARE_CLASS(ATargetPoint,AKeypoint,0,Engine)
	/** Increment the number of spawning systems referencing this target point */
	void IncrementSpawnRef();
	/** Decrement the number of spawning systems referencing this target point */
	void DecrementSpawnRef();
};

class AMaterialInstanceActor : public AActor
{
public:
    //## BEGIN PROPS MaterialInstanceActor
    class UMaterialInstanceConstant* MatInst;
    //## END PROPS MaterialInstanceActor

    DECLARE_CLASS(AMaterialInstanceActor,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AMaterialInstanceActor)
};

#define UCONST_MAX_AIGROUP_NUMBER 10

struct MatineeActor_eventUpdate_Parms
{
    MatineeActor_eventUpdate_Parms(EEventParm)
    {
    }
};
class AMatineeActor : public AActor
{
public:
    //## BEGIN PROPS MatineeActor
    class USeqAct_Interp* InterpAction;
    BITFIELD bIsPlaying:1;
    BITFIELD bReversePlayback:1;
    BITFIELD bPaused:1;
    BITFIELD AllAIGroupsInitialized:1;
    FLOAT PlayRate;
    FLOAT Position;
    FName AIGroupNames[10];
    class APawn* AIGroupPawns[10];
    INT AIGroupInitStage[10];
    FLOAT ClientSidePositionErrorTolerance;
    //## END PROPS MatineeActor

    virtual void AddAIGroupActor(class UInterpGroupInstAI* AIGroupInst);
    DECLARE_FUNCTION(execAddAIGroupActor)
    {
        P_GET_OBJECT(UInterpGroupInstAI,AIGroupInst);
        P_FINISH;
        this->AddAIGroupActor(AIGroupInst);
    }
    void eventUpdate()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Update),NULL);
    }
    DECLARE_CLASS(AMatineeActor,AActor,0|CLASS_NativeReplication,Engine)
	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);
	virtual INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual void TickSpecial(FLOAT DeltaTime);
	virtual void PreNetReceive();
	virtual void PostNetReceive();
	// returns group index
	INT GetGroupActor(FName GroupName);
	UBOOL ClientInitializeAIGroupActors();
};

class ADoorMarker : public ANavigationPoint
{
public:
    //## BEGIN PROPS DoorMarker
    class AInterpActor* MyDoor;
    BYTE DoorType;
    class AActor* DoorTrigger;
    BITFIELD bWaitUntilCompletelyOpened:1;
    BITFIELD bInitiallyClosed:1;
    BITFIELD bBlockedWhenClosed:1;
    BITFIELD bDoorOpen:1;
    BITFIELD bTempDisabledCollision:1;
    SCRIPT_ALIGN;
    //## END PROPS DoorMarker

    DECLARE_CLASS(ADoorMarker,ANavigationPoint,0,Engine)
	virtual AActor* AssociatedLevelGeometry();
	virtual UBOOL HasAssociatedLevelGeometry(AActor* Other);
	virtual void PrePath();
	virtual void PostPath();
	virtual void FindBase();
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class ADynamicAnchor : public ANavigationPoint
{
public:
    //## BEGIN PROPS DynamicAnchor
    class AController* CurrentUser;
    //## END PROPS DynamicAnchor

    DECLARE_CLASS(ADynamicAnchor,ANavigationPoint,0,Engine)
	/** initializes us with the given user and creates ReachSpecs to connect ourselves to the given endpoints,
	 * using the given ReachSpec as a template
	 * @param InUser the Controller that will be using us for navigation
	 * @param Point1 the first NavigationPoint to connect to
	 * @param Point2 the second NavigationPoint to connect to
	 * @param SpecTemplate the ReachSpec to use as a template for the ReachSpecs we create
	 */
	void Initialize(AController* InUser, ANavigationPoint* Point1, ANavigationPoint* Point2, UReachSpec* SpecTemplate);
	void InitHelper( ANavigationPoint* Start, ANavigationPoint* End, INT NewHeight, INT NewRadius, UReachSpec* SpecTemplate );

	virtual void PostScriptDestroyed();

	virtual void TickSpecial(FLOAT DeltaSeconds);
};

class ALadder : public ANavigationPoint
{
public:
    //## BEGIN PROPS Ladder
    class ALadderVolume* MyLadder;
    class ALadder* LadderList;
    //## END PROPS Ladder

    DECLARE_CLASS(ALadder,ANavigationPoint,0,Engine)
#if WITH_EDITOR
	virtual UBOOL CanConnectTo(ANavigationPoint* Dest, UBOOL bCheckDistance);
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
#endif
	void InitForPathFinding();
	void ClearPaths();
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
};

class AAutoLadder : public ALadder
{
public:
    //## BEGIN PROPS AutoLadder
    //## END PROPS AutoLadder

    DECLARE_CLASS(AAutoLadder,ALadder,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AAutoLadder)
};

class ALiftCenter : public ANavigationPoint
{
public:
    //## BEGIN PROPS LiftCenter
    class AInterpActor* MyLift;
    FLOAT MaxDist2D;
    FVector LiftOffset;
    BITFIELD bJumpLift:1;
    FLOAT CollisionHeight;
    class ATrigger* LiftTrigger;
    //## END PROPS LiftCenter

    DECLARE_CLASS(ALiftCenter,ANavigationPoint,0,Engine)
	virtual UBOOL ShouldBeBased();
#if WITH_EDITOR
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged);
	virtual void ReviewPath(APawn* Scout);
#endif
	void FindBase();
};

class ALiftExit : public ANavigationPoint
{
public:
    //## BEGIN PROPS LiftExit
    class ALiftCenter* MyLiftCenter;
    BITFIELD bExitOnly:1;
    SCRIPT_ALIGN;
    //## END PROPS LiftExit

    DECLARE_CLASS(ALiftExit,ANavigationPoint,0,Engine)
	virtual void ReviewPath(APawn* Scout);
};

class APathNode : public ANavigationPoint
{
public:
    //## BEGIN PROPS PathNode
    //## END PROPS PathNode

    DECLARE_CLASS(APathNode,ANavigationPoint,0,Engine)
#if WITH_EDITOR
	virtual INT AddMyMarker(AActor *S);
#endif
};

class AVolumePathNode : public APathNode
{
public:
    //## BEGIN PROPS VolumePathNode
    FLOAT StartingRadius;
    FLOAT StartingHeight;
    //## END PROPS VolumePathNode

    DECLARE_CLASS(AVolumePathNode,APathNode,0,Engine)
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual UBOOL ShouldBeBased();
	virtual void InitForPathFinding();
#if WITH_EDITOR
	virtual void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged);
	virtual void ReviewPath(APawn* Scout);
	virtual UBOOL CanPrunePath(INT index);
#endif
};

class APickupFactory : public ANavigationPoint
{
public:
    //## BEGIN PROPS PickupFactory
    BITFIELD bOnlyReplicateHidden:1;
    BITFIELD bPickupHidden:1;
    BITFIELD bPredictRespawns:1;
    BITFIELD bIsSuperItem:1;
    BITFIELD bRespawnPaused:1;
    class UClass* InventoryType;
    FLOAT RespawnEffectTime;
    FLOAT MaxDesireability;
    class UPrimitiveComponent* PickupMesh;
    class APickupFactory* ReplacementFactory;
    class APickupFactory* OriginalFactory;
    //## END PROPS PickupFactory

    DECLARE_ABSTRACT_CLASS(APickupFactory,ANavigationPoint,0|CLASS_NativeReplication,Engine)
	virtual APickupFactory* GetAPickupFactory() { return this; }
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder);
};

class APlayerStart : public ANavigationPoint
{
public:
    //## BEGIN PROPS PlayerStart
    BITFIELD bEnabled:1;
    BITFIELD bPrimaryStart:1;
    BITFIELD bBestStart:1;
    INT TeamIndex;
    INT Score;
    INT SelectionIndex;
    //## END PROPS PlayerStart

    DECLARE_CLASS(APlayerStart,ANavigationPoint,0,Engine)
#if WITH_EDITOR
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
#endif
};

class APortalMarker : public ANavigationPoint
{
public:
    //## BEGIN PROPS PortalMarker
    class APortalTeleporter* MyPortal;
    //## END PROPS PortalMarker

    virtual UBOOL CanTeleport(class AActor* A);
    DECLARE_CLASS(APortalMarker,ANavigationPoint,0,Engine)
#if WITH_EDITOR
	virtual void addReachSpecs(AScout* Scout, UBOOL bOnlyChanged);
#endif
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
};

class AAISwitchablePylon : public APylon
{
public:
    //## BEGIN PROPS AISwitchablePylon
    BITFIELD bOpen:1;
    SCRIPT_ALIGN;
    //## END PROPS AISwitchablePylon

    DECLARE_CLASS(AAISwitchablePylon,APylon,0,Engine)
	/** returns TRUE if the path from Poly back to start has an edge which is linked to a switch which is linked to this 
	 * pylon
	 * @param Edge - the edge linking Poly to the next neighbor in question
	 * @param Poly - the source poly (the current end-of-line poly in the chain)
	 * @return - TRUE if the previousPath chain of Poly has a switch linked to this pylon in it
	 */
	UBOOL HasSwitchLinkedToMeInPath(struct FNavMeshEdgeBase* Edge, struct FNavMeshPolyBase* Poly);

	// overidden to deny access to edges when we're disabled and the path doesn't incorporate a switch linked to this pylon
	virtual UBOOL CostFor( const FNavMeshPathParams& PathParams,
						 const FVector& PreviousPoint,
						 FVector& out_PathEdgePoint,
						 struct FNavMeshEdgeBase* Edge,
						 struct FNavMeshPolyBase* SourcePoly,
						 INT& out_Cost);

};

struct DynamicPylon_eventStoppedMoving_Parms
{
    DynamicPylon_eventStoppedMoving_Parms(EEventParm)
    {
    }
};
struct DynamicPylon_eventStartedMoving_Parms
{
    DynamicPylon_eventStartedMoving_Parms(EEventParm)
    {
    }
};
class ADynamicPylon : public APylon
{
public:
    //## BEGIN PROPS DynamicPylon
    BITFIELD bMoving:1;
    SCRIPT_ALIGN;
    //## END PROPS DynamicPylon

    virtual void RebuildDynamicEdges();
    virtual void FlushDynamicEdges();
    DECLARE_FUNCTION(execRebuildDynamicEdges)
    {
        P_FINISH;
        this->RebuildDynamicEdges();
    }
    void eventStoppedMoving()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StoppedMoving),NULL);
    }
    void eventStartedMoving()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StartedMoving),NULL);
    }
    DECLARE_CLASS(ADynamicPylon,APylon,0,Engine)
   /**
	 * indicates whether static cross-pylon edges should be built for this pylon (pylons that move should return false)
	 */
	virtual UBOOL NeedsStaticCrossPylonEdgesBuilt(){ return FALSE; } 

	
	/**
	 * Called from UpdateComponentsInternal when a transform update is needed (when this pylon has moved)
	 */
	virtual void PylonMoved();

	virtual void PreBeginPlay();

	virtual void FindBase();

	/** 
	 *  is this pylon compatible with dynamic obstacles? (e.g. moving meshes aren't)
	 */
	virtual UBOOL CompatibleWithDynamicObstacles(){return FALSE;}

	void ApplyDynamicSnap();

#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class ATeleporter : public ANavigationPoint
{
public:
    //## BEGIN PROPS Teleporter
    FStringNoInit URL;
    FName ProductRequired;
    BITFIELD bChangesVelocity:1;
    BITFIELD bChangesYaw:1;
    BITFIELD bReversesX:1;
    BITFIELD bReversesY:1;
    BITFIELD bReversesZ:1;
    BITFIELD bEnabled:1;
    BITFIELD bCanTeleportVehicles:1;
    SCRIPT_ALIGN;
    FVector TargetVelocity;
    FLOAT LastFired;
    //## END PROPS Teleporter

    virtual UBOOL CanTeleport(class AActor* A);
    DECLARE_CLASS(ATeleporter,ANavigationPoint,0,Engine)
#if WITH_EDITOR
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
#endif
};

class ANote : public AActor
{
public:
    //## BEGIN PROPS Note
#if WITH_EDITORONLY_DATA
    FStringNoInit Text;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS Note

    DECLARE_CLASS(ANote,AActor,0,Engine)
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class AProjectile : public AActor
{
public:
    //## BEGIN PROPS Projectile
    FLOAT Speed;
    FLOAT MaxSpeed;
    BITFIELD bSwitchToZeroCollision:1;
    BITFIELD bBlockedByInstigator:1;
    BITFIELD bBegunPlay:1;
    BITFIELD bRotationFollowsVelocity:1;
    BITFIELD bIgnoreFoliageTouch:1;
    class AActor* ZeroCollider;
    class UPrimitiveComponent* ZeroColliderComponent;
    FLOAT Damage;
    FLOAT DamageRadius;
    FLOAT MomentumTransfer;
    class UClass* MyDamageType;
    class USoundCue* SpawnSound;
    class USoundCue* ImpactSound;
    class AController* InstigatorController;
    class AActor* ImpactedActor;
    FLOAT NetCullDistanceSquared;
    class UCylinderComponent* CylinderComponent;
    //## END PROPS Projectile

    virtual void Init(FVector Direction);
    virtual BYTE GetTeamNum();
    DECLARE_FUNCTION(execInit)
    {
        P_GET_STRUCT(FVector,Direction);
        P_FINISH;
        this->Init(Direction);
    }
    DECLARE_ABSTRACT_CLASS(AProjectile,AActor,0,Engine)
	void BoundProjectileVelocity();
	virtual UBOOL ShrinkCollision(AActor *HitActor, UPrimitiveComponent* HitComponent, const FVector &StartLocation);
	virtual void GrowCollision();
	virtual AProjectile* GetAProjectile() { return this; }
	virtual const AProjectile* GetAProjectile() const { return this; }
	virtual void processHitWall(FCheckResult const& Hit, FLOAT TimeSlice=0.f);
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);
	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);
	virtual UBOOL IgnoreBlockingBy( const AActor *Other) const;
	virtual void physProjectile(FLOAT DeltaTime, INT Iterations);
};

class ARigidBodyBase : public AActor
{
public:
    //## BEGIN PROPS RigidBodyBase
    //## END PROPS RigidBodyBase

    DECLARE_ABSTRACT_CLASS(ARigidBodyBase,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ARigidBodyBase)
};

class ASceneCaptureActor : public AActor
{
public:
    //## BEGIN PROPS SceneCaptureActor
    class USceneCaptureComponent* SceneCapture;
    //## END PROPS SceneCaptureActor

    DECLARE_ABSTRACT_CLASS(ASceneCaptureActor,AActor,0,Engine)
	/** 
	* Update any components used by this actor
	*/
	virtual void SyncComponents() {}

	// UObject interface

	/** 
	* Callback for a property change
	* @param PropertyThatChanged - updated property
	*/
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** 
	* Called after object load
	*/
	virtual void PostLoad();

	// AActor interface.

	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class ASceneCapture2DActor : public ASceneCaptureActor
{
public:
    //## BEGIN PROPS SceneCapture2DActor
    class UDrawFrustumComponent* DrawFrustum;
    //## END PROPS SceneCapture2DActor

    DECLARE_CLASS(ASceneCapture2DActor,ASceneCaptureActor,0,Engine)
	// SceneCaptureActor interface

	/** 
	* Update any components used by this actor
	*/
	virtual void SyncComponents();
};

class ASceneCaptureCubeMapActor : public ASceneCaptureActor
{
public:
    //## BEGIN PROPS SceneCaptureCubeMapActor
    class UStaticMeshComponent* StaticMesh;
    class UMaterialInstanceConstant* CubeMaterialInst;
    //## END PROPS SceneCaptureCubeMapActor

    DECLARE_CLASS(ASceneCaptureCubeMapActor,ASceneCaptureActor,0,Engine)
	// SceneCaptureActor interface

	/** 
	* Update any components used by this actor
	*/
	virtual void SyncComponents();

	// AActor interface

	virtual void Spawned();

	// UObject interface

	virtual void FinishDestroy();
	virtual void PostLoad();

private:

	/**
	* Init the helper components 
	*/
	virtual void Init();
};

class ASceneCaptureReflectActor : public ASceneCaptureActor
{
public:
    //## BEGIN PROPS SceneCaptureReflectActor
    class UStaticMeshComponent* StaticMesh;
    class UMaterialInstanceConstant* ReflectMaterialInst;
    //## END PROPS SceneCaptureReflectActor

    DECLARE_CLASS(ASceneCaptureReflectActor,ASceneCaptureActor,0,Engine)
	// SceneCaptureActor interface

	/**
	* Update any components used by this actor
	*/
	virtual void SyncComponents();

	// AActor interface

	virtual void Spawned();

	// UObject interface

	virtual void FinishDestroy();
	virtual void PostLoad();

private:

	/**
	* Init the helper components
	*/
	virtual void Init();
};

class ASceneCapturePortalActor : public ASceneCaptureReflectActor
{
public:
    //## BEGIN PROPS SceneCapturePortalActor
    //## END PROPS SceneCapturePortalActor

    DECLARE_CLASS(ASceneCapturePortalActor,ASceneCaptureReflectActor,0,Engine)
	// SceneCaptureActor interface

	/** 
	* Update any components used by this actor
	*/
	virtual void SyncComponents();
};

class APortalTeleporter : public ASceneCapturePortalActor
{
public:
    //## BEGIN PROPS PortalTeleporter
    class APortalTeleporter* SisterPortal;
    INT TextureResolutionX;
    INT TextureResolutionY;
    class APortalMarker* MyMarker;
    BITFIELD bMovablePortal:1;
    BITFIELD bAlwaysTeleportNonPawns:1;
    BITFIELD bCanTeleportVehicles:1;
    SCRIPT_ALIGN;
    //## END PROPS PortalTeleporter

    UBOOL TransformActor(class AActor* A);
    FVector TransformVectorDir(FVector V);
    FVector TransformHitLocation(FVector HitLocation);
    class UTextureRenderTarget2D* CreatePortalTexture();
    DECLARE_FUNCTION(execTransformActor)
    {
        P_GET_OBJECT(AActor,A);
        P_FINISH;
        *(UBOOL*)Result=this->TransformActor(A);
    }
    DECLARE_FUNCTION(execTransformVectorDir)
    {
        P_GET_STRUCT(FVector,V);
        P_FINISH;
        *(FVector*)Result=this->TransformVectorDir(V);
    }
    DECLARE_FUNCTION(execTransformHitLocation)
    {
        P_GET_STRUCT(FVector,HitLocation);
        P_FINISH;
        *(FVector*)Result=this->TransformHitLocation(HitLocation);
    }
    DECLARE_FUNCTION(execCreatePortalTexture)
    {
        P_FINISH;
        *(class UTextureRenderTarget2D**)Result=this->CreatePortalTexture();
    }
    DECLARE_ABSTRACT_CLASS(APortalTeleporter,ASceneCapturePortalActor,0,Engine)
	virtual APortalTeleporter* GetAPortalTeleporter() { return this; };
	virtual void Spawned();
	virtual void PostLoad();
#if WITH_EDITOR
	virtual void CheckForErrors();
	virtual INT AddMyMarker(AActor* S);
#endif
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void TickSpecial(FLOAT DeltaTime);
	UBOOL CanTeleport(AActor* A);
};

class AStaticMeshActorBase : public AActor
{
public:
    //## BEGIN PROPS StaticMeshActorBase
    //## END PROPS StaticMeshActorBase

    DECLARE_ABSTRACT_CLASS(AStaticMeshActorBase,AActor,0,Engine)
	/**
	 * Initializes this actor when play begins.  This version marks the actor as ready to execute script, but skips
	 * the rest of the stuff that actors normally do in PostBeginPlay().
	 */
	virtual void PostBeginPlay();
};

class AStaticMeshActor : public AStaticMeshActorBase
{
public:
    //## BEGIN PROPS StaticMeshActor
    class UStaticMeshComponent* StaticMeshComponent;
    BITFIELD bDisableAutoBaseOnProcBuilding:1;
    BITFIELD bProxy:1;
    BITFIELD bHiddenByProxy:1;
    BITFIELD OldCastShadow:1;
    BITFIELD OldAcceptsLights:1;
    SCRIPT_ALIGN;
#if WITH_EDITORONLY_DATA
    BYTE OldCollisionType;
#endif // WITH_EDITORONLY_DATA
    SCRIPT_ALIGN;
    //## END PROPS StaticMeshActor

    DECLARE_CLASS(AStaticMeshActor,AStaticMeshActorBase,0,Engine)
	/**
	 * Function that gets called from within Map_Check to allow this actor to check itself
	 * for any potential errors and register them with map check dialog.
	 */
#if WITH_EDITOR
	virtual void CheckForErrors();
	
	/** tells this Actor to set its collision for the path building state
	 * for normally colliding Actors that AI should path through (e.g. doors) or vice versa
	 * @param bNowPathBuilding - whether we are now building paths
	 */
	virtual void SetCollisionForPathBuilding(UBOOL bNowPathBuilding);
	/**
	 * Show or hide the actors the proxy actor
	 *
	 * @param	bShow		If TRUE, show the actors; if FALSE, hide them
	 * @param bIncProxyFlag If TRUE, set the flag which indicates this was hidden by the proxy
	 */
	void ShowProxy(const UBOOL bShow, const UBOOL bIncProxyFlag);

	/**
	 * Flag that this mesh is a proxy
	 */
	void SetProxy(const UBOOL Proxy);

	/**
	 * Get whether this is a proxy
	 */
	UBOOL IsProxy() const;

	/**
	 * Flag that this mesh is hidden because we have a proxy in it's place
	 */
	void SetHiddenByProxy(const UBOOL HiddenByProxy);

	/**
	 * Get whether this is a hidden because we have a proxy
	 */
	UBOOL IsHiddenByProxy() const;
#endif

	/** Used to parent this StaticMeshComponent to a base building's low LOD. */
	virtual void SetBase(AActor *NewBase, FVector NewFloor = FVector(0,0,1), INT bNotifyActor=1, USkeletalMeshComponent* SkelComp=NULL, FName BoneName=NAME_None );

	virtual void PostEditMove( UBOOL bFinished );

protected:
#if USE_GAMEPLAY_PROFILER
    /** 
     * This function actually does the work for the GetProfilerAssetObject and is virtual.  
     * It should only be called from GetProfilerAssetObject as GetProfilerAssetObject is safe to call on NULL object pointers
     */
	virtual UObject* GetProfilerAssetObjectInternal() const;
#endif
	/** 
	 * This function actually does the work for the GetDetailInfo and is virtual.  
	 * It should only be called from GetDetailedInfo as GetDetailedInfo is safe to call on NULL object pointers
	 */
	virtual FString GetDetailedInfoInternal() const;
};

class AStaticMeshCollectionActor : public AStaticMeshActorBase
{
public:
    //## BEGIN PROPS StaticMeshCollectionActor
    TArrayNoInit<class UStaticMeshComponent*> StaticMeshComponents;
    INT MaxStaticMeshComponents;
    //## END PROPS StaticMeshCollectionActor

    DECLARE_CLASS(AStaticMeshCollectionActor,AStaticMeshActorBase,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/* === UObject interface === */
	/**
	 * Serializes the LocalToWorld transforms for the StaticMeshComponents contained in this actor.
	 */
	virtual void Serialize( FArchive& Ar );

	/**
	  * Used by Octree ActorRadius check to determine whether to return a component even if the actor owning the component has already been returned.
	  * Make sure all static mesh components which can become dynamic are returned
	  */
	virtual UBOOL ForceReturnComponent(UPrimitiveComponent* TestPrimitive);
};

struct FSMMaterialSetterDatum
{
    INT MaterialIndex;
    class UMaterialInterface* TheMaterial;

    /** Constructors */
    FSMMaterialSetterDatum() {}
    FSMMaterialSetterDatum(EEventParm)
    {
        appMemzero(this, sizeof(FSMMaterialSetterDatum));
    }
};

class AStaticMeshActorBasedOnExtremeContent : public AActor
{
public:
    //## BEGIN PROPS StaticMeshActorBasedOnExtremeContent
    class UStaticMeshComponent* StaticMeshComponent;
    TArrayNoInit<struct FSMMaterialSetterDatum> ExtremeContent;
    TArrayNoInit<struct FSMMaterialSetterDatum> NonExtremeContent;
    //## END PROPS StaticMeshActorBasedOnExtremeContent

    DECLARE_CLASS(AStaticMeshActorBasedOnExtremeContent,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AStaticMeshActorBasedOnExtremeContent)
};

class ATrigger : public AActor
{
public:
    //## BEGIN PROPS Trigger
    class UCylinderComponent* CylinderComponent;
    BITFIELD bRecentlyTriggered:1;
    FLOAT AITriggerDelay;
    //## END PROPS Trigger

    DECLARE_CLASS(ATrigger,AActor,0,Engine)
#if WITH_EDITOR
	// AActor interface.
	virtual void EditorApplyScale(const FVector& DeltaScale, const FMatrix& ScaleMatrix, const FVector* PivotLocation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
	virtual void CheckForErrors();
#endif
};

class ATrigger_PawnsOnly : public ATrigger
{
public:
    //## BEGIN PROPS Trigger_PawnsOnly
    //## END PROPS Trigger_PawnsOnly

    DECLARE_CLASS(ATrigger_PawnsOnly,ATrigger,0,Engine)
	virtual UBOOL ShouldTrace( UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags );
};

class USplineAudioComponent : public UAudioComponent
{
public:
    //## BEGIN PROPS SplineAudioComponent
    FLOAT ListenerScopeRadius;
    INT ClosestPointOnSplineIndex;
    TArray<FInterpPointOnSpline> Points;
    //## END PROPS SplineAudioComponent

    DECLARE_CLASS(USplineAudioComponent,UAudioComponent,0,Engine)
	/** 
	 * @param InListeners all listeners list
	 * @param ClosestListenerIndexOut through this variable index of the closest listener is returned 
	 * @return Closest RELATIVE location of sound (relative to position of the closest listener). 
	 */
	virtual FVector FindClosestLocation( const TArray<struct FListener>& InListeners, INT& ClosestListenerIndexOut );

	/**
	 * @return  point, that should be used for evaluation distance, between listener, and sound source. That distance is used for attenuation.
	 * The function is needed when the speaker sound's position is estimated from a shape (AmbientSoundSpline)
	 */
	virtual FVector GetPointForDistanceEval();

	/**
	 * The function generates Points.
	 */
	UBOOL SetSplineData(const FInterpCurveVector& SplineData, FLOAT DistanceBetweenPoints);

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

public:
	/**
	 *  Math helper function
	 *  @param Points - parray of points
	 *  @param Listener - position of listener
	 *  @param Radius - scope of listener
	 *  @param ClosestPointIndex - out - index of the closest point, if none point is inside the listener's scope -1 is returned
	 *  @return mean virtual speaker position, with respect to distance from listener 
	 */ 
	static FVector FindVirtualSpeakerPosition(const TArray< FInterpPointOnSpline >& Points, FVector Listener, FLOAT Radius, INT * ClosestPointIndex = NULL);
};

struct FMultiCueSplineSoundSlot
{
    class USoundCue* SoundCue;
    FLOAT PitchScale;
    FLOAT VolumeScale;
    INT StartPoint;
    INT EndPoint;
    DOUBLE LastUpdateTime;
    FLOAT SourceInteriorVolume;
    FLOAT SourceInteriorLPF;
    FLOAT CurrentInteriorVolume;
    FLOAT CurrentInteriorLPF;
    BITFIELD bPlaying:1;
    SCRIPT_ALIGN;

		FMultiCueSplineSoundSlot()
		{
			SoundCue = NULL;
			PitchScale = 1.0f;
			VolumeScale = 1.0f;
			StartPoint = -1;
			EndPoint = -1;

			LastUpdateTime = 0.0;
			SourceInteriorVolume = 1.0f;
			SourceInteriorLPF = 1.0f;
			CurrentInteriorVolume = 1.0f;
			CurrentInteriorLPF = 1.0f;
			bPlaying=FALSE;
		}
	
};

class UMultiCueSplineAudioComponent : public USplineAudioComponent
{
public:
    //## BEGIN PROPS MultiCueSplineAudioComponent
    TArray<struct FMultiCueSplineSoundSlot> SoundSlots;
    INT CurrentSlotIndex;
    //## END PROPS MultiCueSplineAudioComponent

    DECLARE_CLASS(UMultiCueSplineAudioComponent,USplineAudioComponent,0,Engine)
	/**
	 * Dissociates component from audio device and deletes wave instances.
	 */
	virtual void Cleanup( void );
	virtual void Play( void );
	virtual void Stop( void );

	virtual void UpdateWaveInstances( UAudioDevice* AudioDevice, TArray<FWaveInstance*> &WaveInstances, const TArray<struct FListener>& InListeners, FLOAT DeltaTime );

	/** 
	 * @param InListeners all listeners list
	 * @param ClosestListenerIndexOut through this variable index of the closest listener is returned 
	 * @return Closest RELATIVE location of sound (relative to position of the closest listener). 
	 */
	virtual FVector FindClosestLocation( const TArray<struct FListener>& InListeners, INT& ClosestListenerIndexOut );

	FLOAT GetDuration( );

	
	/**
	 *  Math helper function
	 *  @param Points - parray of points
	 *  @param Listener - position of listener
	 *  @param Radius - scope of listener
	 *  @param Slot - info about the sound range along spline
	 *  @param OutScaledDistance - out - distance , that should be used for attenuation calculation
	 *  @return mean virtual speaker position, with respect to distance from listener 
	 */ 
	static FVector FindVirtualSpeakerScaledPosition( const TArray< FInterpCurveVector::FPointOnSpline >& Points, FVector Listener, FLOAT Radius, const FMultiCueSplineSoundSlot& Slot, FLOAT& OutScaledDistance, INT& OutClosestPointOnSplineIndex );


};

struct FSplineSoundSlot
{
    class USoundNodeWave* Wave;
    FLOAT PitchScale;
    FLOAT VolumeScale;
    INT StartPoint;
    INT EndPoint;
    FLOAT Weight;
    DOUBLE LastUpdateTime;
    FLOAT SourceInteriorVolume;
    FLOAT SourceInteriorLPF;
    FLOAT CurrentInteriorVolume;
    FLOAT CurrentInteriorLPF;

		FSplineSoundSlot()
		{
			Wave = NULL;
			PitchScale = 1.0f;
			VolumeScale = 1.0f;
			StartPoint = -1;
			EndPoint = -1;
			Weight = 1.0f;

			LastUpdateTime = 0.0;
			SourceInteriorVolume = 1.0f;
			SourceInteriorLPF = 1.0f;
			CurrentInteriorVolume = 1.0f;
			CurrentInteriorLPF = 1.0f;
		}
	
};

class USimpleSplineAudioComponent : public USplineAudioComponent
{
public:
    //## BEGIN PROPS SimpleSplineAudioComponent
    BITFIELD bAttenuateWithLPF:1;
    FLOAT LPFRadiusMin;
    FLOAT LPFRadiusMax;
    FLOAT dBAttenuationAtMax;
    FLOAT FlattenAttenuationRadius;
    BYTE DistanceAlgorithm;
    FLOAT RadiusMin;
    FLOAT RadiusMax;
    TArray<struct FSplineSoundSlot> SoundSlots;
    class USoundNode* NotifyBufferFinishedHook;
    //## END PROPS SimpleSplineAudioComponent

    DECLARE_CLASS(USimpleSplineAudioComponent,USplineAudioComponent,0,Engine)
	/**
	 * Dissociates component from audio device and deletes wave instances.
	 */
	virtual void Cleanup( void );
	virtual void UpdateWaveInstances( UAudioDevice* AudioDevice, TArray<FWaveInstance*> &WaveInstances, const TArray<struct FListener>& InListeners, FLOAT DeltaTime );

	/** 
	 * @param InListeners all listeners list
	 * @param ClosestListenerIndexOut through this variable index of the closest listener is returned 
	 * @return Closest RELATIVE location of sound (relative to position of the closest listener). 
	 */
	virtual FVector FindClosestLocation( const TArray<struct FListener>& InListeners, INT& ClosestListenerIndexOut );

	/**
	 * @return  point, that should be used for evaluation distance, between listener, and sound source. That distance is used for attenuation.
	 * The function is needed when the speaker sound's position is estimated from a shape (AmbientSoundSpline)
	 */
	virtual FVector GetPointForDistanceEval();

	/**
	 *  Math helper function
	 *  @param Points - parray of points
	 *  @param Listener - position of listener
	 *  @param Radius - scope of listener
	 *  @param Slot - info about the sound range along spline
	 *  @param OutScaledDistance - out - distance , that should be used for attenuation calculation
	 *  @return mean virtual speaker position, with respect to distance from listener 
	 */ 
	static FVector FindVirtualSpeakerScaledPosition( const TArray< FInterpCurveVector::FPointOnSpline >& Points, FVector Listener, FLOAT Radius, const FSplineSoundSlot& Slot, FLOAT& OutScaledDistance, INT& OutClosestPointOnSplineIndex );

protected:

	/**
	 * Inner function, handles single slot in UpdateWaveInstances.
	 */
	virtual void HandleSoundSlot( UAudioDevice* AudioDevice, TArray<FWaveInstance*> &WaveInstances, const TArray<struct FListener>& InListeners, FSplineSoundSlot& Slot, INT ChildIndex);
};

class USimpleSplineNonLoopAudioComponent : public USimpleSplineAudioComponent
{
public:
    //## BEGIN PROPS SimpleSplineNonLoopAudioComponent
    FLOAT DelayMin;
    FLOAT DelayMax;
    FLOAT PitchMin;
    FLOAT PitchMax;
    FLOAT VolumeMin;
    FLOAT VolumeMax;
    INT CurrentSlotIndex;
    FLOAT UsedVolumeModulation;
    FLOAT UsedPitchModulation;
    FLOAT NextSoundTime;
    //## END PROPS SimpleSplineNonLoopAudioComponent

    DECLARE_CLASS(USimpleSplineNonLoopAudioComponent,USimpleSplineAudioComponent,0,Engine)
	/**
	 * Reassign all randomized fields
	 */
	void Reshuffle();

	// following methods must call Reshuffle(), because they reset PlaybackTime variable
	virtual void Play( void );
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

protected:
	/**
	 * Inner function, handles single slot in UpdateWaveInstances.
	 */
	virtual void HandleSoundSlot( UAudioDevice* AudioDevice, TArray<FWaveInstance*> &WaveInstances, const TArray<struct FListener>& InListeners, FSplineSoundSlot& Slot, INT ChildIndex);

};

class UHeightFogComponent : public UActorComponent
{
public:
    //## BEGIN PROPS HeightFogComponent
    BITFIELD bEnabled:1;
    FLOAT Height;
    FLOAT Density;
    FLOAT LightBrightness;
    FColor LightColor;
    FLOAT ExtinctionDistance;
    FLOAT StartDistance;
    //## END PROPS HeightFogComponent

    void SetEnabled(UBOOL bSetEnabled);
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bSetEnabled);
        P_FINISH;
        this->SetEnabled(bSetEnabled);
    }
    DECLARE_CLASS(UHeightFogComponent,UActorComponent,0,Engine)
protected:
	// ActorComponent interface.
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );
public:
};

class UDrawConeComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS DrawConeComponent
    FColor ConeColor;
    FLOAT ConeRadius;
    FLOAT ConeAngle;
    INT ConeSides;
    //## END PROPS DrawConeComponent

    DECLARE_CLASS(UDrawConeComponent,UPrimitiveComponent,0,Engine)
	// UPrimitiveComponent interface.
	/**
	 * Creates a proxy to represent the primitive to the scene manager in the rendering thread.
	 * @return The proxy object.
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
};

class UDrawPylonRadiusComponent : public UDrawSphereComponent
{
public:
    //## BEGIN PROPS DrawPylonRadiusComponent
    //## END PROPS DrawPylonRadiusComponent

    DECLARE_CLASS(UDrawPylonRadiusComponent,UDrawSphereComponent,0,Engine)
	FPrimitiveSceneProxy* CreateSceneProxy();
	void UpdateBounds();
	void Attach();
};

class ULevelGridVolumeRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LevelGridVolumeRenderingComponent
    //## END PROPS LevelGridVolumeRenderingComponent

    DECLARE_CLASS(ULevelGridVolumeRenderingComponent,UPrimitiveComponent,0,Engine)
	/**
	 * Creates a new scene proxy for the path rendering component.
	 * @return	Pointer to the FPathRenderingSceneProxy
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	/** Sets the bounds of this primitive */
	virtual void UpdateBounds();
};

class USpriteComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS SpriteComponent
    class UTexture2D* Sprite;
    BITFIELD bIsScreenSizeScaled:1;
    FLOAT ScreenSize;
    FLOAT U;
    FLOAT UL;
    FLOAT V;
    FLOAT VL;
#if WITH_EDITORONLY_DATA
    FName SpriteCategoryName;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS SpriteComponent

    virtual void SetSprite(class UTexture2D* NewSprite);
    virtual void SetUV(INT NewU,INT NewUL,INT NewV,INT NewVL);
    virtual void SetSpriteAndUV(class UTexture2D* NewSprite,INT NewU,INT NewUL,INT NewV,INT NewVL);
    DECLARE_FUNCTION(execSetSprite)
    {
        P_GET_OBJECT(UTexture2D,NewSprite);
        P_FINISH;
        this->SetSprite(NewSprite);
    }
    DECLARE_FUNCTION(execSetUV)
    {
        P_GET_INT(NewU);
        P_GET_INT(NewUL);
        P_GET_INT(NewV);
        P_GET_INT(NewVL);
        P_FINISH;
        this->SetUV(NewU,NewUL,NewV,NewVL);
    }
    DECLARE_FUNCTION(execSetSpriteAndUV)
    {
        P_GET_OBJECT(UTexture2D,NewSprite);
        P_GET_INT(NewU);
        P_GET_INT(NewUL);
        P_GET_INT(NewV);
        P_GET_INT(NewVL);
        P_FINISH;
        this->SetSpriteAndUV(NewSprite,NewU,NewUL,NewV,NewVL);
    }
    DECLARE_CLASS(USpriteComponent,UPrimitiveComponent,0,Engine)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
};

class URadialBlurComponent : public UActorComponent
{
public:
    //## BEGIN PROPS RadialBlurComponent
    class UMaterialInterface* Material;
    BYTE DepthPriorityGroup;
    FLOAT BlurScale;
    FLOAT BlurFalloffExponent;
    FLOAT BlurOpacity;
    FLOAT MaxCullDistance;
    FLOAT DistanceFalloffExponent;
    BITFIELD bRenderAsVelocity:1;
    BITFIELD bEnabled:1;
    SCRIPT_ALIGN;
    FMatrix LocalToWorld;
    //## END PROPS RadialBlurComponent

    virtual void SetMaterial(class UMaterialInterface* InMaterial);
    virtual void SetBlurScale(FLOAT InBlurScale);
    virtual void SetBlurFalloffExponent(FLOAT InBlurFalloffExponent);
    virtual void SetBlurOpacity(FLOAT InBlurOpacity);
    virtual void SetEnabled(UBOOL bInEnabled);
    DECLARE_FUNCTION(execSetMaterial)
    {
        P_GET_OBJECT(UMaterialInterface,InMaterial);
        P_FINISH;
        this->SetMaterial(InMaterial);
    }
    DECLARE_FUNCTION(execSetBlurScale)
    {
        P_GET_FLOAT(InBlurScale);
        P_FINISH;
        this->SetBlurScale(InBlurScale);
    }
    DECLARE_FUNCTION(execSetBlurFalloffExponent)
    {
        P_GET_FLOAT(InBlurFalloffExponent);
        P_FINISH;
        this->SetBlurFalloffExponent(InBlurFalloffExponent);
    }
    DECLARE_FUNCTION(execSetBlurOpacity)
    {
        P_GET_FLOAT(InBlurOpacity);
        P_FINISH;
        this->SetBlurOpacity(InBlurOpacity);
    }
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bInEnabled);
        P_FINISH;
        this->SetEnabled(bInEnabled);
    }
    DECLARE_CLASS(URadialBlurComponent,UActorComponent,0,Engine)
protected:
	// ActorComponent interface.
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Attach();
	virtual void UpdateTransform();
	virtual void Detach( UBOOL bWillReattach = FALSE );
};

class USceneCaptureComponent : public UActorComponent
{
public:
    //## BEGIN PROPS SceneCaptureComponent
    BITFIELD bEnabled:1;
    BITFIELD bEnablePostProcess:1;
    BITFIELD bEnableFog:1;
    BITFIELD bUseMainScenePostProcessSettings:1;
    BITFIELD bSkipUpdateIfTextureUsersOccluded:1;
    BITFIELD bSkipUpdateIfOwnerOccluded:1;
    BITFIELD bSkipRenderingDepthPrepass:1;
    SCRIPT_ALIGN;
    FColor ClearColor;
    BYTE ViewMode;
    INT SceneLOD;
    FLOAT FrameRate;
    class UPostProcessChain* PostProcess;
    FLOAT MaxUpdateDist;
    FLOAT MaxViewDistanceOverride;
    FLOAT MaxStreamingUpdateDist;
    FCaptureSceneInfo* CaptureInfo;
    FSceneViewStateInterface* ViewState;
    TArrayNoInit<class FPostProcessSceneProxy*> PostProcessProxies;
    //## END PROPS SceneCaptureComponent

    void SetFrameRate(FLOAT NewFrameRate);
    void SetEnabled(UBOOL bEnable);
    DECLARE_FUNCTION(execSetFrameRate)
    {
        P_GET_FLOAT(NewFrameRate);
        P_FINISH;
        this->SetFrameRate(NewFrameRate);
    }
    DECLARE_FUNCTION(execSetEnabled)
    {
        P_GET_UBOOL(bEnable);
        P_FINISH;
        this->SetEnabled(bEnable);
    }
    DECLARE_ABSTRACT_CLASS(USceneCaptureComponent,UActorComponent,0,Engine)
protected:

	/**
	* Constructor
	*/
	USceneCaptureComponent();

	// UActorComponent interface.

	/**
	* Adds a capture proxy for this component to the scene
	*/
	virtual void Attach();

	/**
	* Removes a capture proxy for this component from the scene
	*/
	virtual void Detach( UBOOL bWillReattach = FALSE );

	virtual void UpdateTransform();

	/**
	* Tick the component to handle updates
	*/
	virtual void Tick(FLOAT DeltaTime);

	virtual void FinishDestroy();

public:
	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe() { return NULL; }

	/**
	* Map the various capture view settings to show flags.
	*/
	virtual EShowFlags GetSceneShowFlags();
};

class USceneCapture2DComponent : public USceneCaptureComponent
{
public:
    //## BEGIN PROPS SceneCapture2DComponent
    class UTextureRenderTarget2D* TextureTarget;
    FLOAT FieldOfView;
    FLOAT NearPlane;
    FLOAT FarPlane;
    BITFIELD bUpdateMatrices:1;
    SCRIPT_ALIGN;
    FMatrix ViewMatrix;
    FMatrix ProjMatrix;
    //## END PROPS SceneCapture2DComponent

    void SetView(FVector NewLocation,FRotator NewRotation);
    DECLARE_FUNCTION(execSetCaptureParameters);
    DECLARE_FUNCTION(execSetView)
    {
        P_GET_STRUCT(FVector,NewLocation);
        P_GET_STRUCT(FRotator,NewRotation);
        P_FINISH;
        this->SetView(NewLocation,NewRotation);
    }
    DECLARE_CLASS(USceneCapture2DComponent,USceneCaptureComponent,0,Engine)
protected:

	// UActorComponent interface

	/**
	* Attach a new 2d capture component
	*/
	virtual void Attach();

	/**
	 * Sets the ParentToWorld transform the component is attached to.
	 * @param ParentToWorld - The ParentToWorld transform the component is attached to.
	 */
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);

public:

	/**
	* Constructor
	*/
	USceneCapture2DComponent() :
		ViewMatrix(FMatrix::Identity),
		ProjMatrix(FMatrix::Identity)
		{}

	/**
	* Update the projection matrix using the fov,near,far,aspect
	*/
	void UpdateProjMatrix();

	// SceneCaptureComponent interface

	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe();
};

class USceneCapture2DHitMaskComponent : public USceneCaptureComponent
{
public:
    //## BEGIN PROPS SceneCapture2DHitMaskComponent
    class UTextureRenderTarget2D* TextureTarget;
    class USkeletalMeshComponent* SkeletalMeshComp;
    INT MaterialIndex;
    INT ForceLOD;
    INT HitMaskCullDistance;
    FLOAT FadingStartTimeSinceHit;
    FLOAT FadingPercentage;
    FLOAT FadingDurationTime;
    FLOAT FadingIntervalTime;
    //## END PROPS SceneCapture2DHitMaskComponent

    DECLARE_FUNCTION(execSetCaptureTargetTexture);
    DECLARE_FUNCTION(execSetCaptureParameters);
    DECLARE_FUNCTION(execSetFadingStartTimeSinceHit);
    DECLARE_CLASS(USceneCapture2DHitMaskComponent,USceneCaptureComponent,0,Engine)
protected:

	// UActorComponent interface

	/**
	* Attach a new 2d capture component
	*/
	virtual void Attach();

public:

	/**
	* Constructor
	*/
	USceneCapture2DHitMaskComponent()
		{}

	// SceneCaptureComponent interface

	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe();

	/** Set Capture Parameters 
	 *  This sent message to render thread with parameter information
	 *  Render thread will modify the texture
	 */
	void SetCaptureParameters( const FVector & InMaskPosition, const FLOAT InMaskRadius, const FVector& InStartupPosition, const UBOOL bOnlyWhenFacing );
	/** Set Fading Start Time Since Hit
	 *  Will update the value in render thread - SceneProbe
	 */
	void SetFadingStartTimeSinceHit( const FLOAT InFadingStartTimeSinceHit );
	/**
	 * Sets the ParentToWorld transform the component is attached to.
	 * @param ParentToWorld - The ParentToWorld transform the component is attached to.
	 */
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);

	/** When parent transforms, to prevent super behavior of re-attaching **/
	virtual void UpdateTransform();

};

class USceneCaptureCubeMapComponent : public USceneCaptureComponent
{
public:
    //## BEGIN PROPS SceneCaptureCubeMapComponent
    class UTextureRenderTargetCube* TextureTarget;
    FLOAT NearPlane;
    FLOAT FarPlane;
    FVector WorldLocation;
    //## END PROPS SceneCaptureCubeMapComponent

    DECLARE_CLASS(USceneCaptureCubeMapComponent,USceneCaptureComponent,0,Engine)
protected:

	// UActorComponent interface.

	/**
	* Attach a new cube capture component
	*/
	virtual void Attach();

	/**
	 * Sets the ParentToWorld transform the component is attached to.
	 * @param ParentToWorld - The ParentToWorld transform the component is attached to.
	 */
	virtual void SetParentToWorld(const FMatrix& ParentToWorld);

public:
	
	// SceneCaptureComponent interface

	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe();
};

class USceneCapturePortalComponent : public USceneCaptureComponent
{
public:
    //## BEGIN PROPS SceneCapturePortalComponent
    class UTextureRenderTarget2D* TextureTarget;
    FLOAT ScaleFOV;
    class AActor* ViewDestination;
    //## END PROPS SceneCapturePortalComponent

    DECLARE_FUNCTION(execSetCaptureParameters);
    DECLARE_CLASS(USceneCapturePortalComponent,USceneCaptureComponent,0,Engine)
public:

	// UActorComponent interface

	/**
	* Attach a new portal capture component
	*/
	virtual void Attach();

	// SceneCaptureComponent interface

	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe();
};

class USceneCaptureReflectComponent : public USceneCaptureComponent
{
public:
    //## BEGIN PROPS SceneCaptureReflectComponent
    class UTextureRenderTarget2D* TextureTarget;
    FLOAT ScaleFOV;
    //## END PROPS SceneCaptureReflectComponent

    DECLARE_CLASS(USceneCaptureReflectComponent,USceneCaptureComponent,0,Engine)
public:

	// UActorComponent interface

	/**
	* Attach a new reflect capture component
	*/
	virtual void Attach();

	// SceneCaptureComponent interface

	/**
	* Create a new probe with info needed to render the scene
	*/
	virtual class FSceneCaptureProbe* CreateSceneCaptureProbe();
};

class UWindDirectionalSourceComponent : public UActorComponent
{
public:
    //## BEGIN PROPS WindDirectionalSourceComponent
    FWindSourceSceneProxy* SceneProxy;
    FLOAT Strength;
    FLOAT Phase_DEPRECATED;
    FLOAT Frequency_DEPRECATED;
    FLOAT Speed;
    //## END PROPS WindDirectionalSourceComponent

    DECLARE_CLASS(UWindDirectionalSourceComponent,UActorComponent,0,Engine)
protected:
	// UActorComponent interface.
	virtual void Attach();
	virtual void Detach( UBOOL bWillReattach = FALSE );
	virtual void UpdateTransform();
public:
	
	/**
	 * Creates a proxy to represent the wind source to the scene manager in the rendering thread.
	 * @return The proxy object.
	 */
	 virtual class FWindSourceSceneProxy* CreateSceneProxy() const;
};

class UWindPointSourceComponent : public UWindDirectionalSourceComponent
{
public:
    //## BEGIN PROPS WindPointSourceComponent
    class UDrawSphereComponent* PreviewRadiusComponent;
    FLOAT Radius;
    //## END PROPS WindPointSourceComponent

    DECLARE_CLASS(UWindPointSourceComponent,UWindDirectionalSourceComponent,0,Engine)
protected:
	void UpdatePreviewRadius();
	// UActorComponent interface.
	virtual void Attach();
	virtual void UpdateTransform();
public:
	/**
	 * Creates a proxy to represent the wind source to the scene manager in the rendering thread.
	 * @return The proxy object.
	 */
	 virtual class FWindSourceSceneProxy* CreateSceneProxy() const;
};

struct ActorFactory_eventPostCreateActor_Parms
{
    class AActor* NewActor;
    const class USeqAct_ActorFactory* ActorFactoryData;
    ActorFactory_eventPostCreateActor_Parms(EEventParm)
    {
    }
};
class UActorFactory : public UObject
{
public:
    //## BEGIN PROPS ActorFactory
    class UClass* GameplayActorClass;
    FStringNoInit MenuName;
    INT MenuPriority;
    INT AlternateMenuPriority_DEPRECATED;
    FStringNoInit NewActorClassName;
    class UClass* NewActorClass;
    BITFIELD bPlaceable:1;
    BITFIELD bShowInEditorQuickMenu:1;
    SCRIPT_ALIGN;
    //## END PROPS ActorFactory

    void eventPostCreateActor(class AActor* NewActor,const class USeqAct_ActorFactory* ActorFactoryData=NULL)
    {
        ActorFactory_eventPostCreateActor_Parms Parms(EC_EventParm);
        Parms.NewActor=NewActor;
        Parms.ActorFactoryData=ActorFactoryData;
        ProcessEvent(FindFunctionChecked(ENGINE_PostCreateActor),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UActorFactory,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/** Called to actual create an actor at the supplied location/rotation, using the properties in the ActorFactory */
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );

	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	/** Fill in parameters automatically, possibly using the specified selection set. */
	virtual void AutoFillFields(class USelection* Selection) {}

	/**
	 * Clears references to resources [usually set by the call to AutoFillFields] when the factory has done its work.  The default behavior
	 * (which is to call AutoFillFields() with an empty selection set) should be sufficient for most factories, but this method is provided
	 * to allow customized behavior.
	 */
	virtual void ClearFields();

	/** Name to put on context menu. */
	virtual FString GetMenuName() { return MenuName; }

	/** Initialize NewActorClass if necessary, and return default actor for that class. */
	virtual AActor* GetDefaultActor();

    protected:
	/**
		 * This will check whether there is enough space to spawn an character.
		 * Additionally it will check the ActorFactoryData to for any overrides
		 * ( e.g. bCheckSpawnCollision )
		 *
		 * @return if there is enough space to spawn character at this location
		 **/
		UBOOL IsEnoughRoomToSpawnPawn( const FVector* const Location, const class USeqAct_ActorFactory* const ActorFactoryData ) const;

};

class UActorFactoryActor : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryActor
    class UClass* ActorClass;
    //## END PROPS ActorFactoryActor

    DECLARE_CLASS(UActorFactoryActor,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );

	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual AActor* GetDefaultActor();
};

class UActorFactoryAI : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryAI
    class UClass* ControllerClass;
    class UClass* PawnClass;
    FStringNoInit PawnName;
    BITFIELD bGiveDefaultInventory:1;
    TArrayNoInit<class UClass*> InventoryList;
    INT TeamIndex;
    //## END PROPS ActorFactoryAI

    DECLARE_CLASS(UActorFactoryAI,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );

	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual AActor* GetDefaultActor();
};

class UActorFactoryAmbientSound : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryAmbientSound
    class USoundCue* AmbientSoundCue;
    //## END PROPS ActorFactoryAmbientSound

    DECLARE_CLASS(UActorFactoryAmbientSound,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual void AutoFillFields( class USelection* Selection );

	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual FString GetMenuName( void );
	
	void SetSoundCue( class AAmbientSound* NewSound );
};

class UActorFactoryAmbientSoundMovable : public UActorFactoryAmbientSound
{
public:
    //## BEGIN PROPS ActorFactoryAmbientSoundMovable
    //## END PROPS ActorFactoryAmbientSoundMovable

    DECLARE_CLASS(UActorFactoryAmbientSoundMovable,UActorFactoryAmbientSound,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
};

class UActorFactoryAmbientSoundSimple : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryAmbientSoundSimple
    class USoundNodeWave* SoundNodeWave;
    //## END PROPS ActorFactoryAmbientSoundSimple

    DECLARE_CLASS(UActorFactoryAmbientSoundSimple,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual void AutoFillFields( class USelection* Selection );

	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual FString GetMenuName( void );
	
	void SetSoundSlot( class AAmbientSoundSimple* NewSound );
};

class UActorFactoryAmbientSoundNonLoop : public UActorFactoryAmbientSoundSimple
{
public:
    //## BEGIN PROPS ActorFactoryAmbientSoundNonLoop
    //## END PROPS ActorFactoryAmbientSoundNonLoop

    DECLARE_CLASS(UActorFactoryAmbientSoundNonLoop,UActorFactoryAmbientSoundSimple,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
};

class UActorFactoryAmbientSoundSimpleToggleable : public UActorFactoryAmbientSoundSimple
{
public:
    //## BEGIN PROPS ActorFactoryAmbientSoundSimpleToggleable
    //## END PROPS ActorFactoryAmbientSoundSimpleToggleable

    DECLARE_CLASS(UActorFactoryAmbientSoundSimpleToggleable,UActorFactoryAmbientSoundSimple,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
};

class UActorFactoryAmbientSoundNonLoopingToggleable : public UActorFactoryAmbientSoundSimpleToggleable
{
public:
    //## BEGIN PROPS ActorFactoryAmbientSoundNonLoopingToggleable
    //## END PROPS ActorFactoryAmbientSoundNonLoopingToggleable

    DECLARE_CLASS(UActorFactoryAmbientSoundNonLoopingToggleable,UActorFactoryAmbientSoundSimpleToggleable,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
};

class UActorFactoryApexDestructible : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryApexDestructible
    BITFIELD bStartAwake:1;
    SCRIPT_ALIGN;
    BYTE RBChannel;
    SCRIPT_ALIGN;
    FRBCollisionChannelContainer CollideWithChannels;
    class UApexDestructibleAsset* DestructibleAsset;
    //## END PROPS ActorFactoryApexDestructible

    DECLARE_CLASS(UActorFactoryApexDestructible,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	virtual UBOOL CanCreateActor(FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE);
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryArchetype : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryArchetype
    class AActor* ArchetypeActor;
    //## END PROPS ActorFactoryArchetype

    DECLARE_CLASS(UActorFactoryArchetype,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	
	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
	virtual AActor* GetDefaultActor();
};

class UActorFactoryCoverLink : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryCoverLink
    //## END PROPS ActorFactoryCoverLink

    DECLARE_CLASS(UActorFactoryCoverLink,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryCoverLink)
};

class UActorFactoryDominantDirectionalLight : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryDominantDirectionalLight
    //## END PROPS ActorFactoryDominantDirectionalLight

    DECLARE_CLASS(UActorFactoryDominantDirectionalLight,UActorFactory,0|CLASS_Config,Engine)
	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );
};

class UActorFactoryDominantDirectionalLightMovable : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryDominantDirectionalLightMovable
    //## END PROPS ActorFactoryDominantDirectionalLightMovable

    DECLARE_CLASS(UActorFactoryDominantDirectionalLightMovable,UActorFactory,0|CLASS_Config,Engine)
	/**
	 * Returns whether the ActorFactory thinks it could create an Actor with the current settings.
	 * Can be used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If TRUE, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	TRUE if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );
};

class UActorFactoryDynamicSM : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryDynamicSM
    class UStaticMesh* StaticMesh;
    FVector DrawScale3D;
    BITFIELD bNoEncroachCheck:1;
    BITFIELD bNotifyRigidBodyCollision:1;
    BITFIELD bBlockRigidBody:1;
    BITFIELD bUseCompartment:1;
    BITFIELD bCastDynamicShadow:1;
    SCRIPT_ALIGN;
    BYTE CollisionType;
    SCRIPT_ALIGN;
    //## END PROPS ActorFactoryDynamicSM

    DECLARE_ABSTRACT_CLASS(UActorFactoryDynamicSM,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	
	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
	virtual void PostLoad();
};

class UActorFactoryMover : public UActorFactoryDynamicSM
{
public:
    //## BEGIN PROPS ActorFactoryMover
    //## END PROPS ActorFactoryMover

    DECLARE_CLASS(UActorFactoryMover,UActorFactoryDynamicSM,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryMover)
};

class UActorFactoryRigidBody : public UActorFactoryDynamicSM
{
public:
    //## BEGIN PROPS ActorFactoryRigidBody
    BITFIELD bStartAwake:1;
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bLocalSpaceInitialVelocity:1;
    BITFIELD bEnableStayUprightSpring:1;
    SCRIPT_ALIGN;
    FVector InitialVelocity;
    class UDistributionVector* AdditionalVelocity;
    class UDistributionVector* InitialAngularVelocity;
    BYTE RBChannel;
    FLOAT StayUprightTorqueFactor;
    FLOAT StayUprightMaxTorque;
    //## END PROPS ActorFactoryRigidBody

    DECLARE_CLASS(UActorFactoryRigidBody,UActorFactoryDynamicSM,0|CLASS_Config,Engine)
	// UObject interface
	virtual void PostLoad();

	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
};

class UActorFactoryEmitter : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryEmitter
    class UParticleSystem* ParticleSystem;
    //## END PROPS ActorFactoryEmitter

    DECLARE_CLASS(UActorFactoryEmitter,UActorFactory,0|CLASS_Config,Engine)

	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	
	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryFracturedStaticMesh : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryFracturedStaticMesh
    class UFracturedStaticMesh* FracturedStaticMesh;
    FVector DrawScale3D;
    //## END PROPS ActorFactoryFracturedStaticMesh

    DECLARE_CLASS(UActorFactoryFracturedStaticMesh,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	
	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );
	
	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryLensFlare : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryLensFlare
    class ULensFlare* LensFlareObject;
    //## END PROPS ActorFactoryLensFlare

    DECLARE_CLASS(UActorFactoryLensFlare,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );

	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryLight : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryLight
    //## END PROPS ActorFactoryLight

    DECLARE_CLASS(UActorFactoryLight,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryLight)
};

class UActorFactoryPathNode : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryPathNode
    //## END PROPS ActorFactoryPathNode

    DECLARE_CLASS(UActorFactoryPathNode,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryPathNode)
};

class UActorFactoryPhysicsAsset : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryPhysicsAsset
    class UPhysicsAsset* PhysicsAsset;
    class USkeletalMesh* SkeletalMesh;
    BITFIELD bStartAwake:1;
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bNotifyRigidBodyCollision:1;
    BITFIELD bUseCompartment:1;
    BITFIELD bCastDynamicShadow:1;
    SCRIPT_ALIGN;
    FVector InitialVelocity;
    FVector DrawScale3D;
    //## END PROPS ActorFactoryPhysicsAsset

    DECLARE_CLASS(UActorFactoryPhysicsAsset,UActorFactory,0|CLASS_Config,Engine)
	virtual void PreSave();

	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );

	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryPlayerStart : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryPlayerStart
    //## END PROPS ActorFactoryPlayerStart

    DECLARE_CLASS(UActorFactoryPlayerStart,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryPlayerStart)
};

class UActorFactoryPylon : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryPylon
    //## END PROPS ActorFactoryPylon

    DECLARE_CLASS(UActorFactoryPylon,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryPylon)
};

class UActorFactorySkeletalMesh : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactorySkeletalMesh
    class USkeletalMesh* SkeletalMesh;
    class UAnimSet* AnimSet;
    FName AnimSequenceName;
    //## END PROPS ActorFactorySkeletalMesh

    DECLARE_CLASS(UActorFactorySkeletalMesh,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	
	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryStaticMesh : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryStaticMesh
    class UStaticMesh* StaticMesh;
    FVector DrawScale3D;
    //## END PROPS ActorFactoryStaticMesh

    DECLARE_CLASS(UActorFactoryStaticMesh,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	
	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual void AutoFillFields(class USelection* Selection);
	virtual FString GetMenuName();
};

class UActorFactoryTrigger : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryTrigger
    //## END PROPS ActorFactoryTrigger

    DECLARE_CLASS(UActorFactoryTrigger,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryTrigger)
};

class UActorFactoryVehicle : public UActorFactory
{
public:
    //## BEGIN PROPS ActorFactoryVehicle
    class UClass* VehicleClass;
    //## END PROPS ActorFactoryVehicle

    DECLARE_CLASS(UActorFactoryVehicle,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor( const FVector* const Location, const FRotator* const Rotation, const class USeqAct_ActorFactory* const ActorFactoryData );
	
	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings.
	 * Can Used to determine if we should add to context menu or if the factory can be used for drag and drop.
	 *
	 * @param	OutErrorMsg		Receives localized error string name if returning FALSE.
	 * @param	bFromAssetOnly	If true, the actor factory will check that a valid asset has been assigned from selection.  If the factory always requires an asset to be selected, this param does not matter
	 * @return	True if the actor can be created with this factory
	 */
	virtual UBOOL CanCreateActor( FString& OutErrorMsg, UBOOL bFromAssetOnly = FALSE );

	virtual AActor* GetDefaultActor();
};

class UBookMark : public UObject
{
public:
    //## BEGIN PROPS BookMark
    FVector Location;
    FRotator Rotation;
    TArrayNoInit<FString> HiddenLevels;
    //## END PROPS BookMark

    DECLARE_CLASS(UBookMark,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UBookMark)
};

class UBookMark2D : public UObject
{
public:
    //## BEGIN PROPS BookMark2D
    FLOAT Zoom2D;
    FIntPoint Location;
    //## END PROPS BookMark2D

    DECLARE_CLASS(UBookMark2D,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UBookMark2D)
};

class UKismetBookMark : public UBookMark2D
{
public:
    //## BEGIN PROPS KismetBookMark
    FStringNoInit BookMarkSequencePathName;
    //## END PROPS KismetBookMark

    DECLARE_CLASS(UKismetBookMark,UBookMark2D,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UKismetBookMark)
};

class UCheatManager : public UObject
{
public:
    //## BEGIN PROPS CheatManager
    FStringNoInit ViewingFrom;
    FStringNoInit OwnCamera;
    //## END PROPS CheatManager

    virtual void LogPlaySoundCalls(UBOOL bShouldLog);
    virtual void LogParticleActivateSystemCalls(UBOOL bShouldLog);
    virtual void VerifyNavMeshObjects();
    virtual void DrawUnsupportingEdges(const FString& PawnClassName);
    virtual void PrintAllPathObjectEdges();
    virtual void PrintNavMeshObstacles();
    virtual void VerifyNavMeshCoverRefs();
    virtual void DumpCoverStats();
    virtual void GetAnalyticsUserId();
    DECLARE_FUNCTION(execLogPlaySoundCalls)
    {
        P_GET_UBOOL(bShouldLog);
        P_FINISH;
        this->LogPlaySoundCalls(bShouldLog);
    }
    DECLARE_FUNCTION(execLogParticleActivateSystemCalls)
    {
        P_GET_UBOOL(bShouldLog);
        P_FINISH;
        this->LogParticleActivateSystemCalls(bShouldLog);
    }
    DECLARE_FUNCTION(execVerifyNavMeshObjects)
    {
        P_FINISH;
        this->VerifyNavMeshObjects();
    }
    DECLARE_FUNCTION(execDrawUnsupportingEdges)
    {
        P_GET_STR(PawnClassName);
        P_FINISH;
        this->DrawUnsupportingEdges(PawnClassName);
    }
    DECLARE_FUNCTION(execPrintAllPathObjectEdges)
    {
        P_FINISH;
        this->PrintAllPathObjectEdges();
    }
    DECLARE_FUNCTION(execPrintNavMeshObstacles)
    {
        P_FINISH;
        this->PrintNavMeshObstacles();
    }
    DECLARE_FUNCTION(execVerifyNavMeshCoverRefs)
    {
        P_FINISH;
        this->VerifyNavMeshCoverRefs();
    }
    DECLARE_FUNCTION(execDumpCoverStats)
    {
        P_FINISH;
        this->DumpCoverStats();
    }
    DECLARE_FUNCTION(execGetAnalyticsUserId)
    {
        P_FINISH;
        this->GetAnalyticsUserId();
    }
    DECLARE_CLASS(UCheatManager,UObject,0,Engine)
    DECLARE_WITHIN(APlayerController)
    NO_DEFAULT_CONSTRUCTOR(UCheatManager)
};

class UClipPadEntry : public UObject
{
public:
    //## BEGIN PROPS ClipPadEntry
    FStringNoInit Title;
    FStringNoInit Text;
    //## END PROPS ClipPadEntry

    DECLARE_CLASS(UClipPadEntry,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UClipPadEntry)
};

#define UCONST_GET_SAVE_SLOT_INVALID -1
#define UCONST_GET_SAVE_SLOT_ERROR -2
#define UCONST_COMMON_DATA_SAVE_SLOT_INDEX -1
#define UCONST_SAVE_SYSTEM_VERSION_KEY TEXT("CloudSaveSystemVersion")
#define UCONST_SAVE_DATA_BLOB_NAME_KEY TEXT("DataBlobName")
#define UCONST_DATA_STORE_ID_KEY TEXT("DataStoreID")
#define UCONST_NUM_SAVE_SLOTS_KEY TEXT("NumSaveSlots")

struct FGetSaveDataCallbackStruct
{
    INT SlotIndex;
    FScriptDelegate Callback;

    /** Constructors */
    FGetSaveDataCallbackStruct() {}
    FGetSaveDataCallbackStruct(EEventParm)
    {
        appMemzero(this, sizeof(FGetSaveDataCallbackStruct));
    }
};

struct FSetSaveDataCallbackStruct
{
    INT SlotIndex;
    FScriptDelegate Callback;

    /** Constructors */
    FSetSaveDataCallbackStruct() {}
    FSetSaveDataCallbackStruct(EEventParm)
    {
        appMemzero(this, sizeof(FSetSaveDataCallbackStruct));
    }
};

struct FSaveSlotOperation
{
    INT SlotIndex;
    BYTE SlotOperation;
    SCRIPT_ALIGN;

    /** Constructors */
    FSaveSlotOperation() {}
    FSaveSlotOperation(EEventParm)
    {
        appMemzero(this, sizeof(FSaveSlotOperation));
    }
};

struct CloudSaveSystem_eventSaveSystemCallback_Parms
{
    UBOOL bWasSuccessful;
    INT SaveSlot;
    FString Error;
    CloudSaveSystem_eventSaveSystemCallback_Parms(EEventParm)
    {
    }
};
struct CloudSaveSystem_eventOnGetSaveDataCallback_Parms
{
    UBOOL bWasSuccessful;
    INT SaveSlot;
    TArray<BYTE> DataBlob;
    FString Error;
    CloudSaveSystem_eventOnGetSaveDataCallback_Parms(EEventParm)
    {
    }
};
class UCloudSaveSystem : public UObject
{
public:
    //## BEGIN PROPS CloudSaveSystem
    TScriptInterface<class IInterface> KeyValueStore;
    TScriptInterface<class IInterface> DataBlobStore;
    TArrayNoInit<struct FGetSaveDataCallbackStruct> OnGetSaveDataCallbacks;
    TArrayNoInit<struct FSetSaveDataCallbackStruct> OnSetSaveDataCallbacks;
    FScriptDelegate DeleteSaveDataCallback;
    INT ActiveSlotForDelete;
    TArrayNoInit<struct FSaveSlotOperation> ActiveSaveSlotOperations;
    FScriptDelegate __OnGetSaveDataCallback__Delegate;
    FScriptDelegate __SaveSystemCallback__Delegate;
    //## END PROPS CloudSaveSystem

    void SerializeObject(class UObject* ObjectToSerialize,TArray<BYTE>& Data,INT DataVersion);
    class UObject* DeserializeObject(class UClass* ObjectClass,TArray<BYTE>& Data,BYTE VersionSupport,INT DataVersion);
    DECLARE_FUNCTION(execSerializeObject)
    {
        P_GET_OBJECT(UObject,ObjectToSerialize);
        P_GET_TARRAY_REF(BYTE,Data);
        P_GET_INT(DataVersion);
        P_FINISH;
        this->SerializeObject(ObjectToSerialize,Data,DataVersion);
    }
    DECLARE_FUNCTION(execDeserializeObject)
    {
        P_GET_OBJECT(UClass,ObjectClass);
        P_GET_TARRAY_REF(BYTE,Data);
        P_GET_BYTE(VersionSupport);
        P_GET_INT(DataVersion);
        P_FINISH;
        *(class UObject**)Result=this->DeserializeObject(ObjectClass,Data,VersionSupport,DataVersion);
    }
    void delegateSaveSystemCallback(UBOOL bWasSuccessful,INT SaveSlot,const FString& Error)
    {
        CloudSaveSystem_eventSaveSystemCallback_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.SaveSlot=SaveSlot;
        Parms.Error=Error;
        ProcessDelegate(ENGINE_SaveSystemCallback,&__SaveSystemCallback__Delegate,&Parms);
    }
    void delegateOnGetSaveDataCallback(UBOOL bWasSuccessful,INT SaveSlot,TArray<BYTE>& DataBlob,const FString& Error)
    {
        CloudSaveSystem_eventOnGetSaveDataCallback_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.SaveSlot=SaveSlot;
        Parms.DataBlob=DataBlob;
        Parms.Error=Error;
        ProcessDelegate(ENGINE_OnGetSaveDataCallback,&__OnGetSaveDataCallback__Delegate,&Parms);
        DataBlob=Parms.DataBlob;
    }
    DECLARE_CLASS(UCloudSaveSystem,UObject,0,Engine)
public:
	void SerializeObject(class UObject* ObjectToSerialize, FMemoryWriter& MemoryWriter, int VersionNumber);
	UObject* DeserializeObject(class UClass* ObjectClass, FMemoryReader MemoryReader, BYTE VersionSupport, int VersionNumber);
};

class UCodecMovie : public UObject
{
public:
    //## BEGIN PROPS CodecMovie
    FLOAT PlaybackDuration;
    //## END PROPS CodecMovie

    DECLARE_ABSTRACT_CLASS(UCodecMovie,UObject,0|CLASS_Transient,Engine)
	// Can't have pure virtual functions in classes declared in *Classes.h due to DECLARE_CLASS macro being used.

	// CodecMovie interface

	/**
	* Not all codec implementations are available
	*
	* @return TRUE if the current codec is supported
	*/
	virtual UBOOL IsSupported() { return FALSE; }

	/**
	 * Returns the movie width.
	 *
	 * @return width of movie.
	 */
	virtual UINT GetSizeX() { return 0; }
	/**
	 * Returns the movie height.
	 *
	 * @return height of movie.
	 */
	virtual UINT GetSizeY()	{ return 0; }
	/** 
	 * Returns the movie format.
	 *
	 * @return format of movie.
	 */
	virtual EPixelFormat GetFormat();
	/**
	 * Returns the framerate the movie was encoded at.
	 *
	 * @return framerate the movie was encoded at.
	 */
	virtual FLOAT GetFrameRate() { return 0; }
	
	/**
	 * Initializes the decoder to stream from disk.
	 *
	 * @param	Filename	Filename of compressed media.
	 * @param	Offset		Offset into file to look for the beginning of the compressed data.
	 * @param	Size		Size of compressed data.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( const FString& Filename, DWORD Offset, DWORD Size ) { return FALSE; }
	/**
	 * Initializes the decoder to stream from memory.
	 *
	 * @param	Source		Beginning of memory block holding compressed data.
	 * @param	Size		Size of memory block.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( void* Source, DWORD Size ) { return FALSE; }	
	/**
	 * Tears down stream.
	 */	
	virtual void Close() {}

	/**
	 * Resets the stream to its initial state so it can be played again from the beginning.
	 */
	virtual void ResetStream() {}
	/**
	 * Queues the request to retrieve the next frame.
	 *
 	 * @param InTextureMovieResource - output from movie decoding is written to this resource
	 */
	virtual void GetFrame( class FTextureMovieResource* InTextureMovieResource ) {}
	/**
	 * Returns the playback time of the movie.
	 *
	 * @return playback duration of movie.
	 */
	virtual FLOAT GetDuration() { return PlaybackDuration; }
	/** 
	* Begin playback of the movie stream 
	*
	* @param bLooping - if TRUE then the movie loops back to the start when finished
	* @param bOneFrameOnly - if TRUE then the decoding is paused after the first frame is processed 
	* @param bResetOnLastFrame - if TRUE then the movie frame is set to 0 when playback finishes
	*/
	virtual void Play(UBOOL bLooping, UBOOL bOneFrameOnly, UBOOL bResetOnLastFrame) {}
	/** 
	* Pause or resume the movie playback.
	*
	* @param bPause - if TRUE then decoding will be paused otherwise it resumes
	*/
	virtual void Pause(UBOOL bPause) {}
	/**
	* Stop playback from the movie stream 
	*/ 
	virtual void Stop() {}
	
	/**
	* Release any dynamic rendering resources created by this codec
	*/
	virtual void ReleaseDynamicResources() {}
};

class UCodecMovieFallback : public UCodecMovie
{
public:
    //## BEGIN PROPS CodecMovieFallback
    FLOAT CurrentTime;
    //## END PROPS CodecMovieFallback

    DECLARE_CLASS(UCodecMovieFallback,UCodecMovie,0|CLASS_Transient,Engine)
	// CodecMovie interface

	/**
	* Not all codec implementations are available
	* @return TRUE if the current codec is supported
	*/
	virtual UBOOL IsSupported();
	/**
	 * Returns the movie width.
	 *
	 * @return width of movie.
	 */
	virtual UINT GetSizeX();
	/**
	 * Returns the movie height.
	 *
	 * @return height of movie.
	 */
	virtual UINT GetSizeY();
	/** 
	 * Returns the movie format.
	 *
	 * @return format of movie.
	 */
	virtual EPixelFormat GetFormat();
	/**
	 * Returns the framerate the movie was encoded at.
	 *
	 * @return framerate the movie was encoded at.
	 */
	virtual FLOAT GetFrameRate();	
	/**
	 * Initializes the decoder to stream from disk.
	 *
	 * @param	Filename	Filename of compressed media.
	 * @param	Offset		Offset into file to look for the beginning of the compressed data.
	 * @param	Size		Size of compressed data.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( const FString& Filename, DWORD Offset, DWORD Size );
	/**
	 * Initializes the decoder to stream from memory.
	 *
	 * @param	Source		Beginning of memory block holding compressed data.
	 * @param	Size		Size of memory block.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( void* Source, DWORD Size );
	/**
	* Resets the stream to its initial state so it can be played again from the beginning.
	*/
	virtual void ResetStream();
	/**
	* Queues the request to retrieve the next frame.
	*
	* @param InTextureMovieResource - output from movie decoding is written to this resource
	*/
	virtual void GetFrame( class FTextureMovieResource* InTextureMovieResource );
};

struct FPresetGeneratedPoint
{
    FLOAT KeyIn;
    FLOAT KeyOut;
    BITFIELD TangentsValid:1;
    FLOAT TangentIn;
    FLOAT TangentOut;
    BYTE IntepMode;
    SCRIPT_ALIGN;

    /** Constructors */
    FPresetGeneratedPoint() {}
    FPresetGeneratedPoint(EEventParm)
    {
        appMemzero(this, sizeof(FPresetGeneratedPoint));
    }
};

class UCurveEdPresetCurve : public UObject
{
public:
    //## BEGIN PROPS CurveEdPresetCurve
    FStringNoInit CurveName;
    TArrayNoInit<struct FPresetGeneratedPoint> Points;
    //## END PROPS CurveEdPresetCurve

    DECLARE_CLASS(UCurveEdPresetCurve,UObject,0,Engine)
	UBOOL	StoreCurvePoints(INT CurveIndex, FCurveEdInterface* Distribution);
};

class UCustomPropertyItemHandler : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UCustomPropertyItemHandler,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UCustomPropertyItemHandler)
};

class ICustomPropertyItemHandler
{
protected:
	virtual ~ICustomPropertyItemHandler() {}
public:
	typedef UCustomPropertyItemHandler UClassType;
	virtual UObject* GetUObjectInterfaceCustomPropertyItemHandler()=0;
	/**
	 * Determines whether the specified property value matches the current value of the property.  Called after the user
	 * has changed the value of a property handled by a custom property window item.  Is used to determine whether Pre/PostEditChange
	 * should be called for the selected objects.
	 *
	 * @param	InProperty			the property whose value is being checked.
	 * @param	NewPropertyValue	the value to compare against the current value of the property.
	 * @param	ArrayIndex			the array index for the element being compared; only relevant for array properties
	 *
	 * @return	TRUE if NewPropertyValue matches the current value of the property specified, indicating that no effective changes
	 *			were actually made.
	 */
	virtual UBOOL IsCustomPropertyValueIdentical( UProperty* InProperty, const union UPropertyValue& NewPropertyValue, INT ArrayIndex=INDEX_NONE )=0;

	/**
	 * Method for overriding the default behavior of applying property values received from a custom editor property window item.
	 *
	 * @param	InProperty		the property that is being edited
	 * @param	PropertyValue	the value to assign to the property
	 * @param	ArrayIndex		the array index for the element being changed; only relevant for array properties
	 *
	 * @return	TRUE if the property was handled by this object and the property value was successfully applied to the
	 *			object's data.
	 */
	virtual UBOOL EditorSetPropertyValue( UProperty* InProperty, const union UPropertyValue& PropertyValue, INT ArrayIndex=INDEX_NONE )=0;
};

class UDamageType : public UObject
{
public:
    //## BEGIN PROPS DamageType
    BITFIELD bArmorStops:1;
    BITFIELD bCausedByWorld:1;
    BITFIELD bExtraMomentumZ:1;
    BITFIELD bCausesFracture:1;
    BITFIELD bRadialDamageVelChange:1;
    FLOAT KDamageImpulse;
    FLOAT KDeathVel;
    FLOAT KDeathUpKick;
    FLOAT RadialDamageImpulse;
    FLOAT VehicleDamageScaling;
    FLOAT VehicleMomentumScaling;
    class UForceFeedbackWaveform* DamagedFFWaveform;
    class UForceFeedbackWaveform* KilledFFWaveform;
    FLOAT FracturedMeshDamage;
    //## END PROPS DamageType

    DECLARE_ABSTRACT_CLASS(UDamageType,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDamageType)
};

class UKillZDamageType : public UDamageType
{
public:
    //## BEGIN PROPS KillZDamageType
    //## END PROPS KillZDamageType

    DECLARE_ABSTRACT_CLASS(UKillZDamageType,UDamageType,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UKillZDamageType)
};

class UDistributionFloatConstant : public UDistributionFloat
{
public:
    //## BEGIN PROPS DistributionFloatConstant
    FLOAT Constant;
    //## END PROPS DistributionFloatConstant

    DECLARE_CLASS(UDistributionFloatConstant,UDistributionFloat,0,Engine)
	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL, class FRandomStream* InRandomStream = NULL );

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};

class UDistributionFloatParameterBase : public UDistributionFloatConstant
{
public:
    //## BEGIN PROPS DistributionFloatParameterBase
    FName ParameterName;
    FLOAT MinInput;
    FLOAT MaxInput;
    FLOAT MinOutput;
    FLOAT MaxOutput;
    BYTE ParamMode;
    SCRIPT_ALIGN;
    //## END PROPS DistributionFloatParameterBase

    DECLARE_ABSTRACT_CLASS(UDistributionFloatParameterBase,UDistributionFloatConstant,0,Engine)
	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL, class FRandomStream* InRandomStream = NULL );
	
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FLOAT& OutFloat) { return false; }

	virtual void GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);

	/**
	 * Return whether or not this distribution can be baked into a FRawDistribution lookup table
	 */
	virtual UBOOL CanBeBaked() const { return FALSE; }
};

class UDistributionFloatConstantCurve : public UDistributionFloat
{
public:
    //## BEGIN PROPS DistributionFloatConstantCurve
    FInterpCurveFloat ConstantCurve;
    //## END PROPS DistributionFloatConstantCurve

    DECLARE_CLASS(UDistributionFloatConstantCurve,UDistributionFloat,0,Engine)
	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL, class FRandomStream* InRandomStream = NULL );

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();
};

class UDistributionFloatUniform : public UDistributionFloat
{
public:
    //## BEGIN PROPS DistributionFloatUniform
    FLOAT Min;
    FLOAT Max;
    //## END PROPS DistributionFloatUniform

    DECLARE_CLASS(UDistributionFloatUniform,UDistributionFloat,0,Engine)
	virtual void PostLoad();

	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL, class FRandomStream* InRandomStream = NULL );

#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Fill out an array of floats and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 4 floats
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FLOAT* Values);
#endif

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
  	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};

class UDistributionFloatUniformCurve : public UDistributionFloat
{
public:
    //## BEGIN PROPS DistributionFloatUniformCurve
    FInterpCurveVector2D ConstantCurve;
    //## END PROPS DistributionFloatUniformCurve

    DECLARE_CLASS(UDistributionFloatUniformCurve,UDistributionFloat,0,Engine)
	virtual void PostLoad();

	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL, class FRandomStream* InRandomStream = NULL );

#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Fill out an array of floats and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 4 floats
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FLOAT* Values);
#endif

	virtual FVector2D GetMinMaxValue(FLOAT F = 0.f, UObject* Data = NULL);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
  	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();
};

class UDistributionFloatUniformRange : public UDistributionFloat
{
public:
    //## BEGIN PROPS DistributionFloatUniformRange
    FLOAT MaxHigh;
    FLOAT MaxLow;
    FLOAT MinHigh;
    FLOAT MinLow;
    BITFIELD bMirrorMaxMin:1;
    SCRIPT_ALIGN;
    //## END PROPS DistributionFloatUniformRange

    DECLARE_CLASS(UDistributionFloatUniformRange,UDistributionFloat,0,Engine)
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual FLOAT GetValue( FLOAT F = 0.f, UObject* Data = NULL, class FRandomStream* InRandomStream = NULL );

#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Fill out an array of floats and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 4 floats
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FLOAT* Values);
#endif

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
  	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};

class UDistributionVectorConstant : public UDistributionVector
{
public:
    //## BEGIN PROPS DistributionVectorConstant
    FVector Constant;
    BITFIELD bLockAxes:1;
    SCRIPT_ALIGN;
    BYTE LockedAxes;
    SCRIPT_ALIGN;
    //## END PROPS DistributionVectorConstant

    DECLARE_CLASS(UDistributionVectorConstant,UDistributionVector,0,Engine)
	virtual FVector	GetValue( FLOAT F = 0.f, UObject* Data = NULL, INT LastExtreme = 0, class FRandomStream* InRandomStream = NULL );

	// UObject interface
	virtual void Serialize(FArchive& Ar);
	
	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	// DistributionVector interface
	virtual	void	GetRange(FVector& OutMin, FVector& OutMax);
};

class UDistributionVectorParameterBase : public UDistributionVectorConstant
{
public:
    //## BEGIN PROPS DistributionVectorParameterBase
    FName ParameterName;
    FVector MinInput;
    FVector MaxInput;
    FVector MinOutput;
    FVector MaxOutput;
    BYTE ParamModes[3];
    SCRIPT_ALIGN;
    //## END PROPS DistributionVectorParameterBase

    DECLARE_ABSTRACT_CLASS(UDistributionVectorParameterBase,UDistributionVectorConstant,0,Engine)
	virtual FVector GetValue(FLOAT F = 0.f, UObject* Data = NULL, INT Extreme = 0, class FRandomStream* InRandomStream = NULL);
	
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FVector& OutVector) { return false; }

	virtual void GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);

	/**
	 * Return whether or not this distribution can be baked into a FRawDistribution lookup table
	 */
	virtual UBOOL CanBeBaked() const { return FALSE; }
};

class UDistributionVectorConstantCurve : public UDistributionVector
{
public:
    //## BEGIN PROPS DistributionVectorConstantCurve
    FInterpCurveVector ConstantCurve;
    BITFIELD bLockAxes:1;
    SCRIPT_ALIGN;
    BYTE LockedAxes;
    SCRIPT_ALIGN;
    //## END PROPS DistributionVectorConstantCurve

    DECLARE_CLASS(UDistributionVectorConstantCurve,UDistributionVector,0,Engine)
	virtual FVector	GetValue( FLOAT F = 0.f, UObject* Data = NULL, INT LastExtreme = 0, class FRandomStream* InRandomStream = NULL );

	// UObject interface
	virtual void Serialize(FArchive& Ar);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();

	// DistributionVector interface
	virtual	void	GetRange(FVector& OutMin, FVector& OutMax);
};

class UDistributionVectorUniform : public UDistributionVector
{
public:
    //## BEGIN PROPS DistributionVectorUniform
    FVector Max;
    FVector Min;
    BITFIELD bLockAxes:1;
    BITFIELD bUseExtremes:1;
    SCRIPT_ALIGN;
    BYTE LockedAxes;
    BYTE MirrorFlags[3];
    SCRIPT_ALIGN;
    //## END PROPS DistributionVectorUniform

    DECLARE_CLASS(UDistributionVectorUniform,UDistributionVector,0,Engine)
	virtual void PostLoad();

	virtual FVector	GetValue( FLOAT F = 0.f, UObject* Data = NULL, INT LastExtreme = 0, class FRandomStream* InRandomStream = NULL );

#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Return the lock flags used at runtime to calculate the final value
	 */
	virtual ERawDistributionLockFlags GetLockFlags(INT InIndex) 
	{
		if (InIndex != 0)
		{
			return RDL_None;
		}

		switch (LockedAxes)
		{
		case EDVLF_XY:		return RDL_XY;
		case EDVLF_XZ:		return RDL_XZ;
		case EDVLF_YZ:		return RDL_YZ;
		case EDVLF_XYZ:		return RDL_XYZ;
		}
		return RDL_None;
	}

	/**
	 * Fill out an array of vectors and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 2 vectors
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FVector* Values);
#endif
	
	/** These two functions will retrieve the Min/Max values respecting the Locked and Mirror flags. */
	virtual FVector GetMinValue();
	virtual FVector GetMaxValue();

	// UObject interface
	virtual void Serialize(FArchive& Ar);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	// DistributionVector interface
	virtual	void	GetRange(FVector& OutMin, FVector& OutMax);
};

class UDistributionVectorUniformCurve : public UDistributionVector
{
public:
    //## BEGIN PROPS DistributionVectorUniformCurve
    FInterpCurveTwoVectors ConstantCurve;
    BITFIELD bLockAxes1:1;
    BITFIELD bLockAxes2:1;
    BITFIELD bUseExtremes:1;
    SCRIPT_ALIGN;
    BYTE LockedAxes[2];
    BYTE MirrorFlags[3];
    SCRIPT_ALIGN;
    //## END PROPS DistributionVectorUniformCurve

    DECLARE_CLASS(UDistributionVectorUniformCurve,UDistributionVector,0,Engine)
	virtual void PostLoad();

	virtual FVector	GetValue( FLOAT F = 0.f, UObject* Data = NULL, INT LastExtreme = 0, class FRandomStream* InRandomStream = NULL );

#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Return the lock flags used at runtime to calculate the final value
	 */
	virtual ERawDistributionLockFlags GetLockFlags(INT InIndex) 
	{
		if ((InIndex >= 0) && (InIndex <= 1))
		{
			switch (LockedAxes[InIndex])
			{
			case EDVLF_XY:		return RDL_XY;
			case EDVLF_XZ:		return RDL_XZ;
			case EDVLF_YZ:		return RDL_YZ;
			case EDVLF_XYZ:		return RDL_XYZ;
			}
		}
		return RDL_None;
	}

	/**
	 * Return true if the distribution is a uniform curve
	 */
	virtual UBOOL IsUniformCurve() { return TRUE; }

	/**
	 * Fill out an array of vectors and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 2 vectors
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FVector* Values);
#endif
	virtual FTwoVectors GetMinMaxValue(FLOAT F = 0.f, UObject* Data = NULL);
	
	/** These two functions will retrieve the Min/Max values respecting the Locked and Mirror flags. */
	virtual FVector GetMinValue();
	virtual FVector GetMaxValue();

	// UObject interface
	virtual void Serialize(FArchive& Ar);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
	
	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();

	virtual void	LockAndMirror(FTwoVectors& Val);

	// DistributionVector interface
	virtual	void	GetRange(FVector& OutMin, FVector& OutMax);
};

class UDistributionVectorUniformRange : public UDistributionVector
{
public:
    //## BEGIN PROPS DistributionVectorUniformRange
    FVector MaxHigh;
    FVector MaxLow;
    FVector MinHigh;
    FVector MinLow;
    //## END PROPS DistributionVectorUniformRange

    DECLARE_CLASS(UDistributionVectorUniformRange,UDistributionVector,0,Engine)
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual FVector	GetValue( FLOAT F = 0.f, UObject* Data = NULL, INT LastExtreme = 0, class FRandomStream* InRandomStream = NULL );

#if !CONSOLE
	/**
	 * Return the operation used at runtime to calculate the final value
	 */
	virtual ERawDistributionOperation GetOperation();
	
	/**
	 * Fill out an array of vectors and return the number of elements in the entry
	 *
	 * @param Time The time to evaluate the distribution
	 * @param Values An array of values to be filled out, guaranteed to be big enough for 2 vectors
	 * @return The number of elements (values) set in the array
	 */
	virtual DWORD InitializeRawEntry(FLOAT Time, FVector* Values);
#endif
	
	/** These two functions will retrieve the Min/Max values respecting the Locked and Mirror flags. */
	virtual FVector GetMinValue();
	virtual FVector GetMaxValue();

	// UObject interface
	virtual void Serialize(FArchive& Ar);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	// DistributionVector interface
	virtual	void	GetRange(FVector& OutMin, FVector& OutMax);
};

class UEdCoordSystem : public UObject
{
public:
    //## BEGIN PROPS EdCoordSystem
    FMatrix M;
    FStringNoInit Desc;
    //## END PROPS EdCoordSystem

    DECLARE_CLASS(UEdCoordSystem,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UEdCoordSystem)
};

struct FSubtitleCue
{
    FStringNoInit Text;
    FLOAT Time;

    /** Constructors */
    FSubtitleCue() {}
    FSubtitleCue(EEventParm)
    {
        appMemzero(this, sizeof(FSubtitleCue));
    }
};

struct FLocalizedSubtitle
{
    FStringNoInit LanguageExt;
    TArrayNoInit<struct FSubtitleCue> Subtitles;
    BITFIELD bMature:1;
    BITFIELD bManualWordWrap:1;
    BITFIELD bSingleLine:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FLocalizedSubtitle() {}
    FLocalizedSubtitle(EEventParm)
    {
        appMemzero(this, sizeof(FLocalizedSubtitle));
    }
};

struct FDominantShadowInfo
{
    FMatrix WorldToLight;
    FMatrix LightToWorld;
    FBox LightSpaceImportanceBounds;
    INT ShadowMapSizeX;
    INT ShadowMapSizeY;

    /** Constructors */
    FDominantShadowInfo() {}
    FDominantShadowInfo(EEventParm)
    {
        appMemzero(this, sizeof(FDominantShadowInfo));
    }
};

struct FLightmassLightSettings
{
    FLOAT IndirectLightingScale;
    FLOAT IndirectLightingSaturation;
    FLOAT ShadowExponent;

    /** Constructors */
    FLightmassLightSettings() {}
    FLightmassLightSettings(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassLightSettings));
    }
};

struct FLightmassPointLightSettings : public FLightmassLightSettings
{
    FLOAT LightSourceRadius;

    /** Constructors */
    FLightmassPointLightSettings() {}
    FLightmassPointLightSettings(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassPointLightSettings));
    }
};

struct FLightmassDirectionalLightSettings : public FLightmassLightSettings
{
    FLOAT LightSourceAngle;

    /** Constructors */
    FLightmassDirectionalLightSettings() {}
    FLightmassDirectionalLightSettings(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassDirectionalLightSettings));
    }
};

struct FLightmassDebugOptions
{
    BITFIELD bDebugMode:1;
    BITFIELD bStatsEnabled:1;
    BITFIELD bGatherBSPSurfacesAcrossComponents:1;
    FLOAT CoplanarTolerance;
    BITFIELD bUseDeterministicLighting:1;
    BITFIELD bUseImmediateImport:1;
    BITFIELD bImmediateProcessMappings:1;
    BITFIELD bSortMappings:1;
    BITFIELD bDumpBinaryFiles:1;
    BITFIELD bDebugMaterials:1;
    BITFIELD bPadMappings:1;
    BITFIELD bDebugPaddings:1;
    BITFIELD bOnlyCalcDebugTexelMappings:1;
    BITFIELD bUseRandomColors:1;
    BITFIELD bColorBordersGreen:1;
    BITFIELD bColorByExecutionTime:1;
    FLOAT ExecutionTimeDivisor;
    BITFIELD bInitialized:1;
    SCRIPT_ALIGN;

		//@lmtodo. For some reason, the global instance is not initializing to the default settings...
		// Be sure to update this function to properly set the desired initial values!!!!
		void Touch();
	
};

struct FSwarmDebugOptions
{
    BITFIELD bDistributionEnabled:1;
    BITFIELD bForceContentExport:1;
    BITFIELD bInitialized:1;
    SCRIPT_ALIGN;

		//@lmtodo. For some reason, the global instance is not initializing to the default settings...
		// Be sure to update this function to properly set the desired initial values!!!!
		void Touch();
	
};

struct FRootMotionCurve
{
    FName AnimName;
    FInterpCurveVector Curve;
    FLOAT MaxCurveTime;

    /** Constructors */
    FRootMotionCurve() {}
    FRootMotionCurve(EEventParm)
    {
        appMemzero(this, sizeof(FRootMotionCurve));
    }
};

struct FPrimitiveMaterialRef
{
    class UPrimitiveComponent* Primitive;
    INT MaterialIndex;

		FPrimitiveMaterialRef()
		{}
		FPrimitiveMaterialRef(EEventParm)
		{
			appMemzero(this, sizeof(FPrimitiveMaterialRef));
		}
		FPrimitiveMaterialRef(UPrimitiveComponent* InPrimitive, INT InMaterialIndex)
		: Primitive(InPrimitive), MaterialIndex(InMaterialIndex)
		{}
	
};

struct FPostProcessMaterialRef
{
    class UMaterialEffect* Effect;

		FPostProcessMaterialRef()
		{}
		FPostProcessMaterialRef(EEventParm)
		{
			appMemzero(this, sizeof(FPostProcessMaterialRef));
		}
		FPostProcessMaterialRef(UMaterialEffect* InEffect)
		: Effect(InEffect)
		{}
	
};

struct FMaterialReferenceList
{
    class UMaterialInterface* TargetMaterial;
    TArrayNoInit<struct FPrimitiveMaterialRef> AffectedMaterialRefs;
    TArrayNoInit<struct FPostProcessMaterialRef> AffectedPPChainMaterialRefs;

    /** Constructors */
    FMaterialReferenceList() {}
    FMaterialReferenceList(EEventParm)
    {
        appMemzero(this, sizeof(FMaterialReferenceList));
    }
};

struct FVelocityObstacleStat
{
    FVector Position;
    FVector Velocity;
    FLOAT Radius;
    INT Priority;

    /** Constructors */
    FVelocityObstacleStat() {}
    FVelocityObstacleStat(EEventParm)
    {
        appMemzero(this, sizeof(FVelocityObstacleStat));
    }
};

class UEngineTypes : public UObject
{
public:
    //## BEGIN PROPS EngineTypes
    //## END PROPS EngineTypes

    DECLARE_ABSTRACT_CLASS(UEngineTypes,UObject,0,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    NO_DEFAULT_CONSTRUCTOR(UEngineTypes)
};

class UFaceFXAnimSet : public UObject
{
public:
    //## BEGIN PROPS FaceFXAnimSet
#if WITH_EDITORONLY_DATA
    class UFaceFXAsset* DefaultFaceFXAsset;
#endif // WITH_EDITORONLY_DATA
    FPointer InternalFaceFXAnimSet;
    TArrayNoInit<BYTE> RawFaceFXAnimSetBytes;
    TArrayNoInit<BYTE> RawFaceFXMiniSessionBytes;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class USoundCue*> ReferencedSoundCues;
#endif // WITH_EDITORONLY_DATA
    INT NumLoadErrors;
    //## END PROPS FaceFXAnimSet

    DECLARE_CLASS(UFaceFXAnimSet,UObject,0,Engine)
	/** Creates a new FaceFX AnimSet for the given FaceFX Asset.  This is only called from within the editor. */
	void CreateFxAnimSet( class UFaceFXAsset* FaceFXAsset );

	/** Get list of FaceFX animations in this AnimSet. Names are in the form GroupName.AnimName.*/
	void GetSequenceNames(TArray<FString>& OutNames);

#if WITH_FACEFX
	/** Returns the internal FaceFX representation of this FaceFX AnimSet. */
	class OC3Ent::Face::FxAnimSet* GetFxAnimSet( void );
#endif

	/** Fixes up the ReferencedSoundCue stuff. */
	void FixupReferencedSoundCues();

	// UObject interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();
	virtual void PostLoad();
	virtual void FinishDestroy();
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();

	/**
	 * Used by various commandlets to purge editor only and platform-specific data from various objects
	 * 
	 * @param PlatformsToKeep Platforms for which to keep platform-specific data
	 * @param bStripLargeEditorData If TRUE, data used in the editor, but large enough to bloat download sizes, will be removed
	 */
	virtual void StripData(UE3::EPlatformType PlatformsToKeep, UBOOL bStripLargeEditorData);
};

class UFaceFXAsset : public UObject
{
public:
    //## BEGIN PROPS FaceFXAsset
#if WITH_EDITORONLY_DATA
    class USkeletalMesh* DefaultSkelMesh;
#endif // WITH_EDITORONLY_DATA
    FPointer FaceFXActor;
    TArrayNoInit<BYTE> RawFaceFXActorBytes;
    TArrayNoInit<BYTE> RawFaceFXSessionBytes;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class UMorphTargetSet*> PreviewMorphSets;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<class UFaceFXAnimSet*> MountedFaceFXAnimSets;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class USoundCue*> ReferencedSoundCues;
#endif // WITH_EDITORONLY_DATA
    INT NumLoadErrors;
    //## END PROPS FaceFXAsset

    void MountFaceFXAnimSet(class UFaceFXAnimSet* AnimSet);
    void UnmountFaceFXAnimSet(class UFaceFXAnimSet* AnimSet);
    DECLARE_FUNCTION(execMountFaceFXAnimSet)
    {
        P_GET_OBJECT(UFaceFXAnimSet,AnimSet);
        P_FINISH;
        this->MountFaceFXAnimSet(AnimSet);
    }
    DECLARE_FUNCTION(execUnmountFaceFXAnimSet)
    {
        P_GET_OBJECT(UFaceFXAnimSet,AnimSet);
        P_FINISH;
        this->UnmountFaceFXAnimSet(AnimSet);
    }
    DECLARE_CLASS(UFaceFXAsset,UObject,0,Engine)
	/** Creates a new FaceFX Actor for this FaceFX Asset.  This is only called from within the editor. */
	void CreateFxActor( class USkeletalMesh* SkelMesh );

	/** 
	 *	Get list of FaceFX animations in this Asset. Names are in the form GroupName.AnimName.
	 *	@param bExcludeMountedGroups	If true, do not show animations that are in separate FaceFXAnimSets currently mounted to the Asset.
	 */
	void GetSequenceNames(UBOOL bExcludeMountedGroups, TArray<FString>& OutNames);

#if WITH_FACEFX
	/** Returns the internal FaceFX representation of this FaceFX Asset. */
	class OC3Ent::Face::FxActor* GetFxActor( void );
#endif

	/** Fixes up the ReferencedSoundCue stuff. */
	void FixupReferencedSoundCues();

	// UObject interface.

	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();
	virtual void PostLoad();
	virtual void FinishDestroy();
	virtual void Serialize(FArchive& Ar);

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();

	/**
	 * Used by various commandlets to purge editor only and platform-specific data from various objects
	 * 
	 * @param PlatformsToKeep Platforms for which to keep platform-specific data
	 * @param bStripLargeEditorData If TRUE, data used in the editor, but large enough to bloat download sizes, will be removed
	 */
	virtual void StripData(UE3::EPlatformType PlatformsToKeep, UBOOL bStripLargeEditorData);
};

struct FFontImportOptionsData
{
    FStringNoInit FontName;
    FLOAT Height;
    BITFIELD bEnableAntialiasing:1;
    BITFIELD bEnableBold:1;
    BITFIELD bEnableItalic:1;
    BITFIELD bEnableUnderline:1;
    BITFIELD bAlphaOnly:1;
    SCRIPT_ALIGN;
    BYTE CharacterSet;
    FStringNoInit Chars;
    FStringNoInit UnicodeRange;
    FStringNoInit CharsFilePath;
    FStringNoInit CharsFileWildcard;
    BITFIELD bCreatePrintableOnly:1;
    BITFIELD bIncludeASCIIRange:1;
    SCRIPT_ALIGN;
    FLinearColor ForegroundColor;
    BITFIELD bEnableDropShadow:1;
    INT TexturePageWidth;
    INT TexturePageMaxHeight;
    INT XPadding;
    INT YPadding;
    INT ExtendBoxTop;
    INT ExtendBoxBottom;
    INT ExtendBoxRight;
    INT ExtendBoxLeft;
    BITFIELD bEnableLegacyMode:1;
    INT Kerning;
    BITFIELD bUseDistanceFieldAlpha:1;
    INT DistanceFieldScaleFactor;
    FLOAT DistanceFieldScanRadiusScale;

    /** Constructors */
    FFontImportOptionsData() {}
    FFontImportOptionsData(EEventParm)
    {
        appMemzero(this, sizeof(FFontImportOptionsData));
    }
};

class UFontImportOptions : public UObject
{
public:
    //## BEGIN PROPS FontImportOptions
    struct FFontImportOptionsData Data;
    //## END PROPS FontImportOptions

    DECLARE_CLASS(UFontImportOptions,UObject,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UFontImportOptions)
};

#define UCONST_NULLCHARACTER 127

struct FFontCharacter
{
    INT StartU;
    INT StartV;
    INT USize;
    INT VSize;
    BYTE TextureIndex;
    INT VerticalOffset;

		// Serializer.
		friend FArchive& operator<<( FArchive& Ar, FFontCharacter& Ch )
		{
			Ar << Ch.StartU << Ch.StartV << Ch.USize << Ch.VSize << Ch.TextureIndex;

			if( Ar.Ver() < VER_FONT_FORMAT_AND_UV_TILING_CHANGES )
			{
				Ch.VerticalOffset = 0;
			}
			else
			{
				Ar << Ch.VerticalOffset;
			}

			return Ar;
		}
	
};

class UFont : public UObject
{
public:
    //## BEGIN PROPS Font
    TArrayNoInit<struct FFontCharacter> Characters;
    TArrayNoInit<class UTexture2D*> Textures;
    TMap< WORD,WORD > CharRemap;
    INT IsRemapped;
    FLOAT EmScale;
    FLOAT Ascent;
    FLOAT Descent;
    FLOAT Leading;
    INT Kerning;
    struct FFontImportOptionsData ImportOptions;
    INT NumCharacters;
    TArrayNoInit<INT> MaxCharHeight;
    FLOAT ScalingFactor;
    //## END PROPS Font

    virtual INT GetResolutionPageIndex(FLOAT HeightTest) const;
    virtual FLOAT GetScalingFactor(FLOAT HeightTest) const;
    virtual FLOAT GetAuthoredViewportHeight(FLOAT ViewportHeight) const;
    virtual FLOAT GetMaxCharHeight() const;
    virtual void GetStringHeightAndWidth(const FString& InString,INT& Height,INT& Width) const;
    DECLARE_FUNCTION(execGetResolutionPageIndex)
    {
        P_GET_FLOAT(HeightTest);
        P_FINISH;
        *(INT*)Result=this->GetResolutionPageIndex(HeightTest);
    }
    DECLARE_FUNCTION(execGetScalingFactor)
    {
        P_GET_FLOAT(HeightTest);
        P_FINISH;
        *(FLOAT*)Result=this->GetScalingFactor(HeightTest);
    }
    DECLARE_FUNCTION(execGetAuthoredViewportHeight)
    {
        P_GET_FLOAT(ViewportHeight);
        P_FINISH;
        *(FLOAT*)Result=this->GetAuthoredViewportHeight(ViewportHeight);
    }
    DECLARE_FUNCTION(execGetMaxCharHeight)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetMaxCharHeight();
    }
    DECLARE_FUNCTION(execGetStringHeightAndWidth)
    {
        P_GET_STR_REF(InString);
        P_GET_INT_REF(Height);
        P_GET_INT_REF(Width);
        P_FINISH;
        this->GetStringHeightAndWidth(InString,Height,Width);
    }
    DECLARE_CLASS(UFont,UObject,0,Engine)
	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return		Size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	// UFont interface
	FORCEINLINE TCHAR RemapChar(TCHAR CharCode) const
	{
		const WORD UCode = ToUnicode(CharCode);
		if ( IsRemapped )
		{
			// currently, fonts are only remapped if they contain Unicode characters.
			// For remapped fonts, all characters in the CharRemap map are valid, so
			// if the characters exists in the map, it's safe to use - otherwise, return
			// the null character (an empty square on windows)
			const WORD* FontChar = CharRemap.Find(UCode);
			if ( FontChar == NULL )
				return UCONST_NULLCHARACTER;

			return (TCHAR)*FontChar;
		}

		// Otherwise, our Characters array will contains 256 members, and is
		// a one-to-one mapping of character codes to array indexes, though
		// not every character is a valid character.
		if ( UCode >= NumCharacters )
		{
			return UCONST_NULLCHARACTER;
		}

		// If the character's size is 0, it's non-printable or otherwise unsupported by
		// the font.  Return the default null character (an empty square on windows).
		if ( Characters(UCode).VSize == 0 && UCode >= TEXT(' ') )
		{
			return UCONST_NULLCHARACTER;
		}

		return CharCode;
	}

	FORCEINLINE void GetCharSize(TCHAR InCh, FLOAT& Width, FLOAT& Height, INT ResolutionPageIndex=0) const
	{
		Width = Height = 0.f;

		const INT Ch = (INT)RemapChar(InCh) + ResolutionPageIndex;
		if( Ch < Characters.Num() )
		{
			const FFontCharacter& Char = Characters(Ch);
			if( Char.TextureIndex < Textures.Num() && Textures(Char.TextureIndex) != NULL )
			{
				Width = Char.USize;
				
				// The height of the character will always be the maximum height of any character in this
				// font.  This ensures consistent vertical alignment of text.  For example, we don't want
				// vertically centered text to visually shift up and down as characters are added to a string.
				// NOTE: This also gives us consistent alignment with fonts generated by the legacy importer.
				const INT MultiFontIndex = Ch / NumCharacters;
				Height = MaxCharHeight( MultiFontIndex );
			}
		}
	}

	/**
	 * Calculate the width of the string using this font's default size and scale.
	 *
	 * @param	Text					the string to size
	 * @param	ResolutionPageIndex		the index for the multi-font page to use; get by calling GetResolutionPageIndex()
	 *
	 * @return	the width (in pixels) of the specified text, or 0 if Text was NULL.
	 */
	FORCEINLINE INT GetStringSize( const TCHAR *Text, INT ResolutionPageIndex=0 ) const
	{
		FLOAT	Width, Height, Total;

		Total = 0.0f;
		while( *Text )
		{
			GetCharSize( *Text++, Width, Height, ResolutionPageIndex );
			Total += Width;
		}

		return( appCeil( Total ) );
	}

	/**
	 * Calculate the width of the string using this font's default size and scale.
	 *
	 * @param	Text					the string to size
	 * @param	ResolutionPageIndex		the index for the multi-font page to use; get by calling GetResolutionPageIndex()
	 *
	 * @return	the width (in pixels) of the specified text, or 0 if Text was NULL.
	 */
	FORCEINLINE INT GetStringHeightSize( const TCHAR *Text, INT ResolutionPageIndex=0 ) const
	{
		FLOAT	Width, Height, Total;

		Total = 0.0f;
		while( *Text )
		{
			GetCharSize( *Text++, Width, Height, ResolutionPageIndex );
			Total = Max( Total, Height );
		}

		return( appCeil( Total ) );
	}

	// UObject interface

	/**
	* Serialize the object struct with the given archive
	*
	* @param Ar - archive to serialize with
	*/
	virtual void Serialize( FArchive& Ar );

	/**
	* Called after object and all its dependencies have been serialized.
	*/
	virtual void PostLoad();

    /**
     * Caches the character count and maximum character height for this font (as well as sub-fonts, in the multi-font case)
     */
    virtual void CacheCharacterCountAndMaxCharHeight();
    
	virtual UBOOL IsLocalizedResource();

	/**
	 *	Set the scaling factor
	 *
	 *	@param	InScalingFactor		The scaling factor to set
	 */
	virtual void SetFontScalingFactor(FLOAT InScalingFactor)
	{
		ScalingFactor = InScalingFactor;
	}

	/**
	 *	Get the scaling factor
	 *
	 *	@return	FLOAT		The scaling factor currently set
	 */
	virtual FLOAT GetFontScalingFactor()
	{
		return ScalingFactor;
	}
};

class UMultiFont : public UFont
{
public:
    //## BEGIN PROPS MultiFont
    TArrayNoInit<FLOAT> ResolutionTestTable;
    //## END PROPS MultiFont

    virtual INT GetResolutionTestTableIndex(FLOAT HeightTest) const;
    DECLARE_FUNCTION(execGetResolutionTestTableIndex)
    {
        P_GET_FLOAT(HeightTest);
        P_FINISH;
        *(INT*)Result=this->GetResolutionTestTableIndex(HeightTest);
    }
    DECLARE_CLASS(UMultiFont,UFont,0,Engine)
	void Serialize( FArchive& Ar );

	/**
	* Called after object and all its dependencies have been serialized.
	*/
	virtual void PostLoad();

    /**
     * Caches the character count and maximum character height for this font (as well as sub-fonts, in the multi-font case)
     */
    virtual void CacheCharacterCountAndMaxCharHeight();
    
	/**
	 * Calulate the index for the texture page containing the multi-font character set to use, based on the specified screen resolution.
	 *
	 * @param	HeightTest	the height (in pixels) of the viewport being rendered to.
	 *
	 * @return	the index of the multi-font "subfont" that most closely matches the specified resolution.  this value is used
	 *			as the value for "ResolutionPageIndex" when calling other font-related methods.
	 */
	virtual INT GetResolutionPageIndex(FLOAT HeightTest) const;

	/**
	 * Determine the height of the mutli-font resolution page which will be used for the specified resolution.
	 *
	 * @param	ViewportHeight	the height (in pixels) of the viewport being rendered to.
	 */
	virtual FLOAT GetAuthoredViewportHeight( float ViewportHeight ) const;

	/**
	 * Calculate the amount of scaling necessary to match the authored resolution for the multi-font level which most closely matches
	 * the specified resolution.
	 *
	 * @param	HeightTest	the height (in pixels) of the viewport being rendered to.
	 *
	 * @return	the percentage scale required to match the size of the multi-font's closest matching subfont.
	 */
	virtual FLOAT GetScalingFactor(FLOAT HeightTest) const;
};

class UForceFeedbackManager : public UObject
{
public:
    //## BEGIN PROPS ForceFeedbackManager
    BITFIELD bAllowsForceFeedback:1;
    BITFIELD bIsPaused:1;
    class UForceFeedbackWaveform* FFWaveform;
    INT CurrentSample;
    FLOAT ElapsedTime;
    FLOAT ScaleAllWaveformsBy;
    class AActor* WaveformInstigator;
    //## END PROPS ForceFeedbackManager

    DECLARE_ABSTRACT_CLASS(UForceFeedbackManager,UObject,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(APlayerController)
protected:
	/**
	 * Update the currently playing waveform sample
	 *
	 * @param DeltaTime The amount of elapsed time since the last update
	 */
	virtual void UpdateWaveformData(FLOAT DeltaTime);

public:
	/**
	 * Applies the current waveform data to the gamepad/mouse/etc
	 * This function is platform specific
	 *
	 * @param DeviceID The device that needs updating
	 * @param DeltaTime The amount of elapsed time since the last update
	 */
	virtual void ApplyForceFeedback(INT DeviceID,FLOAT DeltaTime) {}

	/** Clear any vibration going on this device right away. */
	virtual void ForceClearWaveformData(INT DeviceID) {}
};

struct FWaveformSample
{
    BYTE LeftAmplitude;
    BYTE RightAmplitude;
    BYTE LeftFunction;
    BYTE RightFunction;
    FLOAT Duration;

		friend FArchive& operator<<(FArchive& Ar,FWaveformSample& A)
		{	
			return	Ar << A.LeftAmplitude << A.RightAmplitude << A.LeftFunction
				<< A.RightFunction << A.Duration;
		}
	
};

class UForceFeedbackWaveform : public UObject
{
public:
    //## BEGIN PROPS ForceFeedbackWaveform
    BITFIELD bIsLooping:1;
    TArrayNoInit<struct FWaveformSample> Samples;
    FLOAT WaveformFalloffStartDistance;
    FLOAT MaxWaveformDistance;
    //## END PROPS ForceFeedbackWaveform

    DECLARE_CLASS(UForceFeedbackWaveform,UObject,0,Engine)
	void Serialize( FArchive& Ar )
	{
		Super::Serialize(Ar);
		if (Ar.IsLoading() && Ar.Ver() < VER_FORCEFEEDBACKWAVERFORM_NOEXPORT_CHANGE)
		{
			INT TempIsLooping = 0;
			Ar << TempIsLooping;
			bIsLooping = (TempIsLooping == 0) ? FALSE : TRUE;
			Ar << Samples;
		}
	}
};

#define UCONST_HeaderFlags_NoEventStrings 1

struct FGameStatGroup
{
    BYTE Group;
    INT Level;

		friend FArchive& operator<<( FArchive& Ar, FGameStatGroup& T );
	
};

struct FGameplayEventsHeader
{
    INT EngineVersion;
    INT StatsWriterVersion;
    INT StreamOffset;
    INT AggregateOffset;
    INT FooterOffset;
    INT TotalStreamSize;
    INT FileSize;
    FStringNoInit FilterClass;
    INT Flags;

    /** Constructors */
    FGameplayEventsHeader() {}
    FGameplayEventsHeader(EEventParm)
    {
        appMemzero(this, sizeof(FGameplayEventsHeader));
    }
};

struct FGameSessionInformation
{
    INT AppTitleID;
    INT PlatformType;
    FStringNoInit Language;
    FStringNoInit GameplaySessionTimestamp;
    FLOAT GameplaySessionStartTime;
    FLOAT GameplaySessionEndTime;
    BITFIELD bGameplaySessionInProgress:1;
    FStringNoInit GameplaySessionID;
    FStringNoInit GameClassName;
    FStringNoInit MapName;
    FStringNoInit MapURL;
    INT SessionInstance;
    INT GameTypeId;
    struct FUniqueNetId OwningNetId;
    INT PlaylistId;

		/** Constructors */
		FGameSessionInformation() {}
		FGameSessionInformation(EEventParm)
		{
			appMemzero(this, sizeof(FGameSessionInformation));
		}

		/** Return the unique key for this session */
		const FString GetSessionID() const { return FString::Printf(TEXT("%s:%d"), *GameplaySessionID, SessionInstance); }
	
};

struct FTeamInformation
{
    INT TeamIndex;
    FStringNoInit TeamName;
    FColor TeamColor;
    INT MaxSize;

		friend FArchive& operator<<( FArchive& Ar, FTeamInformation& T );
	
};

struct FPlayerInformation
{
    FName ControllerName;
    FStringNoInit PlayerName;
    struct FUniqueNetId UniqueId;
    BITFIELD bIsBot:1;
    SCRIPT_ALIGN;

		friend FArchive& operator<<( FArchive& Ar, FPlayerInformation& T );
	
};

struct FGameplayEventMetaData
{
    INT EventID;
    FName EventName;
    struct FGameStatGroup StatGroup;
    INT EventDataType;

		friend FArchive& operator<<( FArchive& Ar, FGameplayEventMetaData& T );
	
};

struct FWeaponClassEventData
{
    FName WeaponClassName;

		friend FArchive& operator<<( FArchive& Ar, FWeaponClassEventData& T );
	
};

struct FDamageClassEventData
{
    FName DamageClassName;

		friend FArchive& operator<<( FArchive& Ar, FDamageClassEventData& T );
	
};

struct FProjectileClassEventData
{
    FName ProjectileClassName;

		friend FArchive& operator<<( FArchive& Ar, FProjectileClassEventData& T );
	
};

struct FPawnClassEventData
{
    FName PawnClassName;

		friend FArchive& operator<<( FArchive& Ar, FPawnClassEventData& T );
	
};

struct GameplayEvents_eventGetFilename_Parms
{
    FString ReturnValue;
    GameplayEvents_eventGetFilename_Parms(EEventParm)
    {
    }
};
class UGameplayEvents : public UObject
{
public:
    //## BEGIN PROPS GameplayEvents
    FArchive* Archive;
    FStringNoInit StatsFileName;
    struct FGameplayEventsHeader Header;
    struct FGameSessionInformation CurrentSessionInfo;
    TArrayNoInit<struct FPlayerInformation> PlayerList;
    TArrayNoInit<struct FTeamInformation> TeamList;
    TArrayNoInit<struct FGameplayEventMetaData> SupportedEvents;
    TArrayNoInit<struct FWeaponClassEventData> WeaponClassArray;
    TArrayNoInit<struct FDamageClassEventData> DamageClassArray;
    TArrayNoInit<struct FProjectileClassEventData> ProjectileClassArray;
    TArrayNoInit<struct FPawnClassEventData> PawnClassArray;
    TArrayNoInit<FString> ActorArray;
    TArrayNoInit<FString> SoundCueArray;
    //## END PROPS GameplayEvents

    FString eventGetFilename()
    {
        GameplayEvents_eventGetFilename_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetFilename),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UGameplayEvents,UObject,0,Engine)
	/** Access the current session info */
	const FGameSessionInformation& GetSessionInfo() const
	{
		return CurrentSessionInfo;
	}

	/** Returns the metadata associated with the given index */
	virtual const FGameplayEventMetaData& GetEventMetaData(INT EventID) const;

	/** Returns the metadata associated with the given index */
	const FTeamInformation& GetTeamMetaData(INT TeamIndex) const;

	/** Returns the metadata associated with the given index */
	const FPlayerInformation& GetPlayerMetaData(INT PlayerIndex) const;

	/** Returns the metadata associated with the given index */
	const FPawnClassEventData& GetPawnMetaData(INT PawnClassIndex) const;

	/** Returns the metadata associated with the given index */
	const FWeaponClassEventData& GetWeaponMetaData(INT WeaponClassIndex) const;

	/** Returns the metadata associated with the given index */
	const FDamageClassEventData& GetDamageMetaData(INT DamageClassIndex) const;

	/** Returns the metadata associated with the given index */
	const FProjectileClassEventData& GetProjectileMetaData(INT ProjectileClassIndex) const;

	/**
	 * Returns the metadata associated with the given index
	 * @param ActorIndex the index of the actor being looked up
	 * @return the name of the actor at that index
	 */
	const FString& GetActorMetaData(INT ActorIndex) const
	{
		return ActorArray(ActorIndex);
	}

	/**
	 * Returns the metadata associated with the given index
	 * @param SoundIndex the index of the soundcue being looked up
	 * @return the name of the actor at that index
	 */
	const FString& GetSoundMetaData(INT SoundIndex) const
	{
		return SoundCueArray(SoundIndex);
	}
};

struct GameplayEventsReader_eventUnregisterHandler_Parms
{
    class UGameplayEventsHandler* ExistingHandler;
    GameplayEventsReader_eventUnregisterHandler_Parms(EEventParm)
    {
    }
};
struct GameplayEventsReader_eventRegisterHandler_Parms
{
    class UGameplayEventsHandler* NewHandler;
    GameplayEventsReader_eventRegisterHandler_Parms(EEventParm)
    {
    }
};
class UGameplayEventsReader : public UGameplayEvents
{
public:
    //## BEGIN PROPS GameplayEventsReader
    TArrayNoInit<class UGameplayEventsHandler*> RegisteredHandlers;
    //## END PROPS GameplayEventsReader

    virtual UBOOL OpenStatsFile(const FString& Filename);
    virtual void CloseStatsFile();
    virtual UBOOL SerializeHeader();
    virtual void ProcessStreamStart();
    virtual void ProcessStream();
    virtual void ProcessStreamEnd();
    virtual FString GetSessionID();
    virtual INT GetTitleID();
    virtual INT GetPlatform();
    virtual FString GetSessionTimestamp();
    virtual FLOAT GetSessionStart();
    virtual FLOAT GetSessionEnd();
    virtual FLOAT GetSessionDuration();
    DECLARE_FUNCTION(execOpenStatsFile)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->OpenStatsFile(Filename);
    }
    DECLARE_FUNCTION(execCloseStatsFile)
    {
        P_FINISH;
        this->CloseStatsFile();
    }
    DECLARE_FUNCTION(execSerializeHeader)
    {
        P_FINISH;
        *(UBOOL*)Result=this->SerializeHeader();
    }
    DECLARE_FUNCTION(execProcessStreamStart)
    {
        P_FINISH;
        this->ProcessStreamStart();
    }
    DECLARE_FUNCTION(execProcessStream)
    {
        P_FINISH;
        this->ProcessStream();
    }
    DECLARE_FUNCTION(execProcessStreamEnd)
    {
        P_FINISH;
        this->ProcessStreamEnd();
    }
    DECLARE_FUNCTION(execGetSessionID)
    {
        P_FINISH;
        *(FString*)Result=this->GetSessionID();
    }
    DECLARE_FUNCTION(execGetTitleID)
    {
        P_FINISH;
        *(INT*)Result=this->GetTitleID();
    }
    DECLARE_FUNCTION(execGetPlatform)
    {
        P_FINISH;
        *(INT*)Result=this->GetPlatform();
    }
    DECLARE_FUNCTION(execGetSessionTimestamp)
    {
        P_FINISH;
        *(FString*)Result=this->GetSessionTimestamp();
    }
    DECLARE_FUNCTION(execGetSessionStart)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetSessionStart();
    }
    DECLARE_FUNCTION(execGetSessionEnd)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetSessionEnd();
    }
    DECLARE_FUNCTION(execGetSessionDuration)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetSessionDuration();
    }
    void eventUnregisterHandler(class UGameplayEventsHandler* ExistingHandler)
    {
        GameplayEventsReader_eventUnregisterHandler_Parms Parms(EC_EventParm);
        Parms.ExistingHandler=ExistingHandler;
        ProcessEvent(FindFunctionChecked(ENGINE_UnregisterHandler),&Parms);
    }
    void eventRegisterHandler(class UGameplayEventsHandler* NewHandler)
    {
        GameplayEventsReader_eventRegisterHandler_Parms Parms(EC_EventParm);
        Parms.NewHandler=NewHandler;
        ProcessEvent(FindFunctionChecked(ENGINE_RegisterHandler),&Parms);
    }
    DECLARE_CLASS(UGameplayEventsReader,UGameplayEvents,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UGameplayEventsReader)
};

#define UCONST_GAMEEVENT_MAX_EVENTID 0x0000FFFF
#define UCONST_GAMEEVENT_GAME_SPECIFIC 1000
#define UCONST_GAMEEVENT_GENERIC_PARAM_LIST_END 400
#define UCONST_GAMEEVENT_GENERIC_PARAM_LIST_START 300
#define UCONST_GAMEEVENT_PLAYER_KILL_NORMAL 200
#define UCONST_GAMEEVENT_WEAPON_FIRED 152
#define UCONST_GAMEEVENT_WEAPON_DAMAGE_MELEE 151
#define UCONST_GAMEEVENT_WEAPON_DAMAGE 150
#define UCONST_GAMEEVENT_PLAYER_ROUND_STALEMATE 110
#define UCONST_GAMEEVENT_PLAYER_ROUND_WON 109
#define UCONST_GAMEEVENT_PLAYER_DEATH 108
#define UCONST_GAMEEVENT_PLAYER_KILL_STREAK 107
#define UCONST_GAMEEVENT_PLAYER_TEAMCHANGE 106
#define UCONST_GAMEEVENT_PLAYER_LOCATION_POLL 105
#define UCONST_GAMEEVENT_PLAYER_KILL 104
#define UCONST_GAMEEVENT_PLAYER_MATCH_WON 103
#define UCONST_GAMEEVENT_PLAYER_SPAWN 102
#define UCONST_GAMEEVENT_PLAYER_LOGOUT 101
#define UCONST_GAMEEVENT_PLAYER_LOGIN 100
#define UCONST_GAMEEVENT_TEAM_ROUND_STALEMATE 52
#define UCONST_GAMEEVENT_TEAM_ROUND_WON 5
#define UCONST_GAMEEVENT_TEAM_MATCH_WON 4
#define UCONST_GAMEEVENT_TEAM_GAME_SCORE 51
#define UCONST_GAMEEVENT_TEAM_CREATED 50
#define UCONST_GAMEEVENT_FRAMETIME_POLL 43
#define UCONST_GAMEEVENT_GPUFRAMETIME_POLL 42
#define UCONST_GAMEEVENT_GAMETHREAD_POLL 41
#define UCONST_GAMEEVENT_RENDERTHREAD_POLL 40
#define UCONST_GAMEEVENT_PING_POLL 39
#define UCONST_GAMEEVENT_NETWORKUSAGEOUT_POLL 38
#define UCONST_GAMEEVENT_NETWORKUSAGEIN_POLL 37
#define UCONST_GAMEEVENT_FRAMERATE_POLL 36
#define UCONST_GAMEEVENT_MEMORYUSAGE_POLL 35
#define UCONST_GAMEEVENT_GAME_MAPNAME 8
#define UCONST_GAMEEVENT_GAME_OPTION_URL 7
#define UCONST_GAMEEVENT_GAME_CLASS 6
#define UCONST_GAMEEVENT_ROUND_ENDED 3
#define UCONST_GAMEEVENT_ROUND_STARTED 2
#define UCONST_GAMEEVENT_MATCH_ENDED 1
#define UCONST_GAMEEVENT_MATCH_STARTED 0

struct GameplayEventsWriterBase_eventGetPlaylistId_Parms
{
    INT ReturnValue;
    GameplayEventsWriterBase_eventGetPlaylistId_Parms(EEventParm)
    {
    }
};
struct GameplayEventsWriterBase_eventGetGameTypeId_Parms
{
    INT ReturnValue;
    GameplayEventsWriterBase_eventGetGameTypeId_Parms(EEventParm)
    {
    }
};
struct GameplayEventsWriterBase_eventStopPolling_Parms
{
    GameplayEventsWriterBase_eventStopPolling_Parms(EEventParm)
    {
    }
};
struct GameplayEventsWriterBase_eventStartPolling_Parms
{
    FLOAT HearbeatDelta;
    GameplayEventsWriterBase_eventStartPolling_Parms(EEventParm)
    {
    }
};
class UGameplayEventsWriterBase : public UGameplayEvents
{
public:
    //## BEGIN PROPS GameplayEventsWriterBase
    class AGameInfo* Game;
    //## END PROPS GameplayEventsWriterBase

    INT eventGetPlaylistId()
    {
        GameplayEventsWriterBase_eventGetPlaylistId_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetPlaylistId),&Parms);
        return Parms.ReturnValue;
    }
    INT eventGetGameTypeId()
    {
        GameplayEventsWriterBase_eventGetGameTypeId_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetGameTypeId),&Parms);
        return Parms.ReturnValue;
    }
    void eventStopPolling()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_StopPolling),NULL);
    }
    void eventStartPolling(FLOAT HearbeatDelta)
    {
        GameplayEventsWriterBase_eventStartPolling_Parms Parms(EC_EventParm);
        Parms.HearbeatDelta=HearbeatDelta;
        ProcessEvent(FindFunctionChecked(ENGINE_StartPolling),&Parms);
    }
    DECLARE_CLASS(UGameplayEventsWriterBase,UGameplayEvents,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UGameplayEventsWriterBase)
};

class UGameplayEventsUploadAnalytics : public UGameplayEventsWriterBase
{
public:
    //## BEGIN PROPS GameplayEventsUploadAnalytics
    //## END PROPS GameplayEventsUploadAnalytics

    virtual void StartLogging(FLOAT HeartbeatDelta=0);
    virtual void ResetLogging(FLOAT HeartbeatDelta=0);
    virtual void EndLogging();
    virtual void LogGameIntEvent(INT EventID,INT Value);
    virtual void LogGameStringEvent(INT EventID,const FString& Value);
    virtual void LogGameFloatEvent(INT EventID,FLOAT Value);
    virtual void LogGamePositionEvent(INT EventID,const FVector& Position,FLOAT Value);
    virtual void LogTeamIntEvent(INT EventID,class ATeamInfo* Team,INT Value);
    virtual void LogTeamFloatEvent(INT EventID,class ATeamInfo* Team,FLOAT Value);
    virtual void LogTeamStringEvent(INT EventID,class ATeamInfo* Team,const FString& Value);
    virtual void LogPlayerIntEvent(INT EventID,class AController* Player,INT Value);
    virtual void LogPlayerFloatEvent(INT EventID,class AController* Player,FLOAT Value);
    virtual void LogPlayerStringEvent(INT EventID,class AController* Player,const FString& EventString);
    virtual void LogPlayerSpawnEvent(INT EventID,class AController* Player,class UClass* PawnClass,INT TeamID);
    virtual void LogPlayerLoginChange(INT EventID,class AController* Player,const FString& PlayerName,struct FUniqueNetId PlayerID,UBOOL bSplitScreen);
    virtual void LogAllPlayerPositionsEvent(INT EventID);
    virtual void LogPlayerKillDeath(INT EventID,INT KillType,class AController* Killer,class UClass* dmgType,class AController* Dead);
    virtual void LogPlayerPlayerEvent(INT EventID,class AController* Player,class AController* Target);
    virtual void LogWeaponIntEvent(INT EventID,class AController* Player,class UClass* WeaponClass,INT Value);
    virtual void LogDamageEvent(INT EventID,class AController* Player,class UClass* dmgType,class AController* Target,INT Amount);
    virtual void LogProjectileIntEvent(INT EventID,class AController* Player,class UClass* Proj,INT Value);
    DECLARE_FUNCTION(execStartLogging)
    {
        P_GET_FLOAT_OPTX(HeartbeatDelta,0);
        P_FINISH;
        this->StartLogging(HeartbeatDelta);
    }
    DECLARE_FUNCTION(execResetLogging)
    {
        P_GET_FLOAT_OPTX(HeartbeatDelta,0);
        P_FINISH;
        this->ResetLogging(HeartbeatDelta);
    }
    DECLARE_FUNCTION(execEndLogging)
    {
        P_FINISH;
        this->EndLogging();
    }
    DECLARE_FUNCTION(execLogGameIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_INT(Value);
        P_FINISH;
        this->LogGameIntEvent(EventID,Value);
    }
    DECLARE_FUNCTION(execLogGameStringEvent)
    {
        P_GET_INT(EventID);
        P_GET_STR(Value);
        P_FINISH;
        this->LogGameStringEvent(EventID,Value);
    }
    DECLARE_FUNCTION(execLogGameFloatEvent)
    {
        P_GET_INT(EventID);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->LogGameFloatEvent(EventID,Value);
    }
    DECLARE_FUNCTION(execLogGamePositionEvent)
    {
        P_GET_INT(EventID);
        P_GET_STRUCT_REF(FVector,Position);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->LogGamePositionEvent(EventID,Position,Value);
    }
    DECLARE_FUNCTION(execLogTeamIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(ATeamInfo,Team);
        P_GET_INT(Value);
        P_FINISH;
        this->LogTeamIntEvent(EventID,Team,Value);
    }
    DECLARE_FUNCTION(execLogTeamFloatEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(ATeamInfo,Team);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->LogTeamFloatEvent(EventID,Team,Value);
    }
    DECLARE_FUNCTION(execLogTeamStringEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(ATeamInfo,Team);
        P_GET_STR(Value);
        P_FINISH;
        this->LogTeamStringEvent(EventID,Team,Value);
    }
    DECLARE_FUNCTION(execLogPlayerIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_INT(Value);
        P_FINISH;
        this->LogPlayerIntEvent(EventID,Player,Value);
    }
    DECLARE_FUNCTION(execLogPlayerFloatEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->LogPlayerFloatEvent(EventID,Player,Value);
    }
    DECLARE_FUNCTION(execLogPlayerStringEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_STR(EventString);
        P_FINISH;
        this->LogPlayerStringEvent(EventID,Player,EventString);
    }
    DECLARE_FUNCTION(execLogPlayerSpawnEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(UClass,PawnClass);
        P_GET_INT(TeamID);
        P_FINISH;
        this->LogPlayerSpawnEvent(EventID,Player,PawnClass,TeamID);
    }
    DECLARE_FUNCTION(execLogPlayerLoginChange)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_STR(PlayerName);
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_UBOOL(bSplitScreen);
        P_FINISH;
        this->LogPlayerLoginChange(EventID,Player,PlayerName,PlayerID,bSplitScreen);
    }
    DECLARE_FUNCTION(execLogAllPlayerPositionsEvent)
    {
        P_GET_INT(EventID);
        P_FINISH;
        this->LogAllPlayerPositionsEvent(EventID);
    }
    DECLARE_FUNCTION(execLogPlayerKillDeath)
    {
        P_GET_INT(EventID);
        P_GET_INT(KillType);
        P_GET_OBJECT(AController,Killer);
        P_GET_OBJECT(UClass,dmgType);
        P_GET_OBJECT(AController,Dead);
        P_FINISH;
        this->LogPlayerKillDeath(EventID,KillType,Killer,dmgType,Dead);
    }
    DECLARE_FUNCTION(execLogPlayerPlayerEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(AController,Target);
        P_FINISH;
        this->LogPlayerPlayerEvent(EventID,Player,Target);
    }
    DECLARE_FUNCTION(execLogWeaponIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(UClass,WeaponClass);
        P_GET_INT(Value);
        P_FINISH;
        this->LogWeaponIntEvent(EventID,Player,WeaponClass,Value);
    }
    DECLARE_FUNCTION(execLogDamageEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(UClass,dmgType);
        P_GET_OBJECT(AController,Target);
        P_GET_INT(Amount);
        P_FINISH;
        this->LogDamageEvent(EventID,Player,dmgType,Target,Amount);
    }
    DECLARE_FUNCTION(execLogProjectileIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(UClass,Proj);
        P_GET_INT(Value);
        P_FINISH;
        this->LogProjectileIntEvent(EventID,Player,Proj,Value);
    }
    DECLARE_CLASS(UGameplayEventsUploadAnalytics,UGameplayEventsWriterBase,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UGameplayEventsUploadAnalytics)
};

class UGameplayEventsWriter : public UGameplayEventsWriterBase
{
public:
    //## BEGIN PROPS GameplayEventsWriter
    //## END PROPS GameplayEventsWriter

    virtual INT ResolvePlayerIndex(class AController* Player);
    virtual UBOOL OpenStatsFile(const FString& Filename);
    virtual void CloseStatsFile();
    virtual UBOOL SerializeHeader();
    virtual UBOOL SerializeFooter();
    virtual void StartLogging(FLOAT HeartbeatDelta=0);
    virtual void ResetLogging(FLOAT HeartbeatDelta=0);
    virtual void EndLogging();
    virtual void LogGameIntEvent(INT EventID,INT Value);
    virtual void LogGameStringEvent(INT EventID,const FString& Value);
    virtual void LogGameFloatEvent(INT EventID,FLOAT Value);
    virtual void LogGamePositionEvent(INT EventID,const FVector& Position,FLOAT Value);
    virtual void LogTeamIntEvent(INT EventID,class ATeamInfo* Team,INT Value);
    virtual void LogTeamFloatEvent(INT EventID,class ATeamInfo* Team,FLOAT Value);
    virtual void LogTeamStringEvent(INT EventID,class ATeamInfo* Team,const FString& Value);
    virtual void LogPlayerIntEvent(INT EventID,class AController* Player,INT Value);
    virtual void LogPlayerFloatEvent(INT EventID,class AController* Player,FLOAT Value);
    virtual void LogPlayerStringEvent(INT EventID,class AController* Player,const FString& EventString);
    virtual void LogPlayerSpawnEvent(INT EventID,class AController* Player,class UClass* PawnClass,INT TeamID);
    virtual void LogPlayerLoginChange(INT EventID,class AController* Player,const FString& PlayerName,struct FUniqueNetId PlayerID,UBOOL bSplitScreen);
    virtual void LogAllPlayerPositionsEvent(INT EventID);
    virtual void LogPlayerKillDeath(INT EventID,INT KillType,class AController* Killer,class UClass* dmgType,class AController* Dead);
    virtual void LogPlayerPlayerEvent(INT EventID,class AController* Player,class AController* Target);
    virtual void LogWeaponIntEvent(INT EventID,class AController* Player,class UClass* WeaponClass,INT Value);
    virtual void LogDamageEvent(INT EventID,class AController* Player,class UClass* dmgType,class AController* Target,INT Amount);
    virtual void LogProjectileIntEvent(INT EventID,class AController* Player,class UClass* Proj,INT Value);
    virtual void LogSystemPollEvents();
    virtual class UGenericParamListStatEntry* GetGenericParamListEntry();
    DECLARE_FUNCTION(execResolvePlayerIndex)
    {
        P_GET_OBJECT(AController,Player);
        P_FINISH;
        *(INT*)Result=this->ResolvePlayerIndex(Player);
    }
    DECLARE_FUNCTION(execOpenStatsFile)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(UBOOL*)Result=this->OpenStatsFile(Filename);
    }
    DECLARE_FUNCTION(execCloseStatsFile)
    {
        P_FINISH;
        this->CloseStatsFile();
    }
    DECLARE_FUNCTION(execSerializeHeader)
    {
        P_FINISH;
        *(UBOOL*)Result=this->SerializeHeader();
    }
    DECLARE_FUNCTION(execSerializeFooter)
    {
        P_FINISH;
        *(UBOOL*)Result=this->SerializeFooter();
    }
    DECLARE_FUNCTION(execStartLogging)
    {
        P_GET_FLOAT_OPTX(HeartbeatDelta,0);
        P_FINISH;
        this->StartLogging(HeartbeatDelta);
    }
    DECLARE_FUNCTION(execResetLogging)
    {
        P_GET_FLOAT_OPTX(HeartbeatDelta,0);
        P_FINISH;
        this->ResetLogging(HeartbeatDelta);
    }
    DECLARE_FUNCTION(execEndLogging)
    {
        P_FINISH;
        this->EndLogging();
    }
    DECLARE_FUNCTION(execLogGameIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_INT(Value);
        P_FINISH;
        this->LogGameIntEvent(EventID,Value);
    }
    DECLARE_FUNCTION(execLogGameStringEvent)
    {
        P_GET_INT(EventID);
        P_GET_STR(Value);
        P_FINISH;
        this->LogGameStringEvent(EventID,Value);
    }
    DECLARE_FUNCTION(execLogGameFloatEvent)
    {
        P_GET_INT(EventID);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->LogGameFloatEvent(EventID,Value);
    }
    DECLARE_FUNCTION(execLogGamePositionEvent)
    {
        P_GET_INT(EventID);
        P_GET_STRUCT_REF(FVector,Position);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->LogGamePositionEvent(EventID,Position,Value);
    }
    DECLARE_FUNCTION(execLogTeamIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(ATeamInfo,Team);
        P_GET_INT(Value);
        P_FINISH;
        this->LogTeamIntEvent(EventID,Team,Value);
    }
    DECLARE_FUNCTION(execLogTeamFloatEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(ATeamInfo,Team);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->LogTeamFloatEvent(EventID,Team,Value);
    }
    DECLARE_FUNCTION(execLogTeamStringEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(ATeamInfo,Team);
        P_GET_STR(Value);
        P_FINISH;
        this->LogTeamStringEvent(EventID,Team,Value);
    }
    DECLARE_FUNCTION(execLogPlayerIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_INT(Value);
        P_FINISH;
        this->LogPlayerIntEvent(EventID,Player,Value);
    }
    DECLARE_FUNCTION(execLogPlayerFloatEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->LogPlayerFloatEvent(EventID,Player,Value);
    }
    DECLARE_FUNCTION(execLogPlayerStringEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_STR(EventString);
        P_FINISH;
        this->LogPlayerStringEvent(EventID,Player,EventString);
    }
    DECLARE_FUNCTION(execLogPlayerSpawnEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(UClass,PawnClass);
        P_GET_INT(TeamID);
        P_FINISH;
        this->LogPlayerSpawnEvent(EventID,Player,PawnClass,TeamID);
    }
    DECLARE_FUNCTION(execLogPlayerLoginChange)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_STR(PlayerName);
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_UBOOL(bSplitScreen);
        P_FINISH;
        this->LogPlayerLoginChange(EventID,Player,PlayerName,PlayerID,bSplitScreen);
    }
    DECLARE_FUNCTION(execLogAllPlayerPositionsEvent)
    {
        P_GET_INT(EventID);
        P_FINISH;
        this->LogAllPlayerPositionsEvent(EventID);
    }
    DECLARE_FUNCTION(execLogPlayerKillDeath)
    {
        P_GET_INT(EventID);
        P_GET_INT(KillType);
        P_GET_OBJECT(AController,Killer);
        P_GET_OBJECT(UClass,dmgType);
        P_GET_OBJECT(AController,Dead);
        P_FINISH;
        this->LogPlayerKillDeath(EventID,KillType,Killer,dmgType,Dead);
    }
    DECLARE_FUNCTION(execLogPlayerPlayerEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(AController,Target);
        P_FINISH;
        this->LogPlayerPlayerEvent(EventID,Player,Target);
    }
    DECLARE_FUNCTION(execLogWeaponIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(UClass,WeaponClass);
        P_GET_INT(Value);
        P_FINISH;
        this->LogWeaponIntEvent(EventID,Player,WeaponClass,Value);
    }
    DECLARE_FUNCTION(execLogDamageEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(UClass,dmgType);
        P_GET_OBJECT(AController,Target);
        P_GET_INT(Amount);
        P_FINISH;
        this->LogDamageEvent(EventID,Player,dmgType,Target,Amount);
    }
    DECLARE_FUNCTION(execLogProjectileIntEvent)
    {
        P_GET_INT(EventID);
        P_GET_OBJECT(AController,Player);
        P_GET_OBJECT(UClass,Proj);
        P_GET_INT(Value);
        P_FINISH;
        this->LogProjectileIntEvent(EventID,Player,Proj,Value);
    }
    DECLARE_FUNCTION(execLogSystemPollEvents)
    {
        P_FINISH;
        this->LogSystemPollEvents();
    }
    DECLARE_FUNCTION(execGetGenericParamListEntry)
    {
        P_FINISH;
        *(class UGenericParamListStatEntry**)Result=this->GetGenericParamListEntry();
    }
    DECLARE_CLASS(UGameplayEventsWriter,UGameplayEventsWriterBase,0,Engine)
	/** 
	 * Turns a controller into a player index, possibly adding new information to the player array 
	 *  @param TeamInfo - TeamInfo class to resolve an index for
	 *	@return Index of the team in the team metadata array
	 */
	virtual INT ResolveTeamIndex(class ATeamInfo *TeamInfo);

	/** Turns a weapon class into an index, possibly adding new information to the array **/
	INT ResolveWeaponClassIndex(UClass* WeaponClass);

	/** Turns a damage class into an index, possibly adding new information to the array **/
	INT ResolveDamageClassIndex(UClass* DamageClass);

	/** Turns a projectile class into an index, possibly adding new information to the array **/
	INT ResolveProjectileClassIndex(UClass* ProjectileClass);

	/** Turns a pawn class into an index, possibly adding new information to the array **/
	INT ResolvePawnIndex(UClass* PawnClass);

	/**
	 * Turns an actor into an index
	 * @param Actor the actor to find in the array
	 * @return the index in the array for that actor
	 */
	INT ResolveActorIndex(AActor* Actor);

	/**
	 * Turns an sound cue into an index
	 *
	 * @param Cue the sound cue to find in the array
	 *
	 * @return the index in the array for that sound cue
	 */
	INT ResolveSoundCueIndex(USoundCue* Cue);
};

struct GameplayEventsHandler_eventResolveGroupFilters_Parms
{
    GameplayEventsHandler_eventResolveGroupFilters_Parms(EEventParm)
    {
    }
};
struct GameplayEventsHandler_eventPostProcessStream_Parms
{
    GameplayEventsHandler_eventPostProcessStream_Parms(EEventParm)
    {
    }
};
struct GameplayEventsHandler_eventPreProcessStream_Parms
{
    GameplayEventsHandler_eventPreProcessStream_Parms(EEventParm)
    {
    }
};
class UGameplayEventsHandler : public UObject
{
public:
    //## BEGIN PROPS GameplayEventsHandler
    TArrayNoInit<INT> EventIDFilter;
    TArrayNoInit<struct FGameStatGroup> GroupFilter;
protected:
    class UGameplayEventsReader* Reader;
public:
    //## END PROPS GameplayEventsHandler

    virtual void PreProcessStream();
    DECLARE_FUNCTION(execPreProcessStream)
    {
        P_FINISH;
        this->PreProcessStream();
    }
    void eventResolveGroupFilters()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ResolveGroupFilters),NULL);
    }
    void eventPostProcessStream()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostProcessStream),NULL);
    }
    void eventPreProcessStream()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PreProcessStream),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UGameplayEventsHandler,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("GameStats");}

	/** The function that does the actual handling of data (override with particular implementation) */
	virtual void HandleEvent(struct FGameEventHeader& GameEvent, class IGameEvent* GameEventData);

	/** Handlers for parsing the game stats stream */

	// Game Event Handling
	virtual void HandleGameStringEvent(struct FGameEventHeader& GameEvent, struct FGameStringEvent* GameEventData) {}
	virtual void HandleGameIntEvent(struct FGameEventHeader& GameEvent, struct FGameIntEvent* GameEventData) {}
	virtual void HandleGameFloatEvent(struct FGameEventHeader& GameEvent, struct FGameFloatEvent* GameEventData) {}
	virtual void HandleGamePositionEvent(struct FGameEventHeader& GameEvent, struct FGamePositionEvent* GameEventData) {}

	// Team Event Handling
	virtual void HandleTeamStringEvent(struct FGameEventHeader& GameEvent, struct FTeamStringEvent* GameEventData) {}
	virtual void HandleTeamIntEvent(struct FGameEventHeader& GameEvent, struct FTeamIntEvent* GameEventData) {}
	virtual void HandleTeamFloatEvent(struct FGameEventHeader& GameEvent, struct FTeamFloatEvent* GameEventData) {}

	// Player Event Handling
	virtual void HandlePlayerIntEvent(struct FGameEventHeader& GameEvent, struct FPlayerIntEvent* GameEventData) {}
	virtual void HandlePlayerFloatEvent(struct FGameEventHeader& GameEvent, struct FPlayerFloatEvent* GameEventData) {}
	virtual void HandlePlayerStringEvent(struct FGameEventHeader& GameEvent, struct FPlayerStringEvent* GameEventData) {}
	virtual void HandlePlayerSpawnEvent(struct FGameEventHeader& GameEvent, struct FPlayerSpawnEvent* GameEventData) {}
	virtual void HandlePlayerLoginEvent(struct FGameEventHeader& GameEvent, struct FPlayerLoginEvent* GameEventData) {}
	virtual void HandlePlayerKillDeathEvent(struct FGameEventHeader& GameEvent, struct FPlayerKillDeathEvent* GameEventData) {}
	virtual void HandlePlayerPlayerEvent(struct FGameEventHeader& GameEvent, struct FPlayerPlayerEvent* GameEventData) {}
	virtual void HandlePlayerLocationsEvent(struct FGameEventHeader& GameEvent, struct FPlayerLocationsEvent* GameEventData) {}
	virtual void HandleWeaponIntEvent(struct FGameEventHeader& GameEvent, struct FWeaponIntEvent* GameEventData) {}
	virtual void HandleDamageIntEvent(struct FGameEventHeader& GameEvent, struct FDamageIntEvent* GameEventData) {}
	virtual void HandleProjectileIntEvent(struct FGameEventHeader& GameEvent, struct FProjectileIntEvent* GameEventData) {}

	/** Access the current session info */
	const FGameSessionInformation& GetSessionInfo() const
	{
		check(Reader);
		return Reader->CurrentSessionInfo;
	}

	/** Returns the metadata associated with the given index */
	virtual const FGameplayEventMetaData& GetEventMetaData(INT EventID) const
	{
		check(Reader);
		return Reader->GetEventMetaData(EventID);
	}

	/** Returns the metadata associated with the given index */
	const FTeamInformation& GetTeamMetaData(INT TeamIndex) const
	{
		check(Reader);
		return Reader->GetTeamMetaData(TeamIndex);
	}

	/** Returns the metadata associated with the given index */
	const FPlayerInformation& GetPlayerMetaData(INT PlayerIndex) const
	{
		check(Reader);
		return Reader->GetPlayerMetaData(PlayerIndex);
	}

	/** Returns the metadata associated with the given index */
	const FPawnClassEventData& GetPawnMetaData(INT PawnClassIndex) const
	{
		check(Reader);
		return Reader->GetPawnMetaData(PawnClassIndex);
	}

	/** Returns the metadata associated with the given index */
	const FWeaponClassEventData& GetWeaponMetaData(INT WeaponClassIndex) const
	{
		check(Reader);
		return Reader->GetWeaponMetaData(WeaponClassIndex);
	}

	/** Returns the metadata associated with the given index */
	const FDamageClassEventData& GetDamageMetaData(INT DamageClassIndex) const
	{
		check(Reader);
		return Reader->GetDamageMetaData(DamageClassIndex);
	}

	/** Returns the metadata associated with the given index */
	const FProjectileClassEventData& GetProjectileMetaData(INT ProjectileClassIndex) const
	{
		check(Reader);
		return Reader->GetProjectileMetaData(ProjectileClassIndex);
	}

	/**
	 * Returns the metadata associated with the given index
	 * @param ActorIndex the index of the actor being looked up
	 * @return the name of the actor at that index
	 */
	const FString& GetActorMetaData(INT ActorIndex) const
	{
		check(Reader);
		return Reader->GetActorMetaData(ActorIndex);
	}

	/**
	 * Returns the metadata associated with the given index
	 * @param SoundIndex the index of the soundcue being looked up
	 * @return the name of the actor at that index
	 */
	const FString& GetSoundMetaData(INT SoundIndex) const
	{
		check(Reader);
		return Reader->GetSoundMetaData(SoundIndex);
	}

	/** Returns whether or not this processor handles this event */
	inline UBOOL IsEventFiltered(int EventID) const
	{
		return (EventIDFilter.FindItemIndex(EventID) != INDEX_NONE);
	}
};

class UGenericParamListStatEntry : public UObject
{
public:
    //## BEGIN PROPS GenericParamListStatEntry
    struct FGenericParamListEvent* StatEvent;
    class UGameplayEventsWriter* Writer;
    //## END PROPS GenericParamListStatEntry

    virtual void AddFloat(FName ParamName,FLOAT Value);
    virtual void AddInt(FName ParamName,INT Value);
    virtual void AddVector(FName ParamName,FVector Value);
    virtual void AddString(FName ParamName,const FString& Value);
    virtual UBOOL GetFloat(FName ParamName,FLOAT& out_Float);
    virtual UBOOL GetInt(FName ParamName,INT& out_int);
    virtual UBOOL GetVector(FName ParamName,FVector& out_vector);
    virtual UBOOL GetString(FName ParamName,FString& out_string);
    virtual void CommitToDisk();
    DECLARE_FUNCTION(execAddFloat)
    {
        P_GET_NAME(ParamName);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->AddFloat(ParamName,Value);
    }
    DECLARE_FUNCTION(execAddInt)
    {
        P_GET_NAME(ParamName);
        P_GET_INT(Value);
        P_FINISH;
        this->AddInt(ParamName,Value);
    }
    DECLARE_FUNCTION(execAddVector)
    {
        P_GET_NAME(ParamName);
        P_GET_STRUCT(FVector,Value);
        P_FINISH;
        this->AddVector(ParamName,Value);
    }
    DECLARE_FUNCTION(execAddString)
    {
        P_GET_NAME(ParamName);
        P_GET_STR(Value);
        P_FINISH;
        this->AddString(ParamName,Value);
    }
    DECLARE_FUNCTION(execGetFloat)
    {
        P_GET_NAME(ParamName);
        P_GET_FLOAT_REF(out_Float);
        P_FINISH;
        *(UBOOL*)Result=this->GetFloat(ParamName,out_Float);
    }
    DECLARE_FUNCTION(execGetInt)
    {
        P_GET_NAME(ParamName);
        P_GET_INT_REF(out_int);
        P_FINISH;
        *(UBOOL*)Result=this->GetInt(ParamName,out_int);
    }
    DECLARE_FUNCTION(execGetVector)
    {
        P_GET_NAME(ParamName);
        P_GET_STRUCT_REF(FVector,out_vector);
        P_FINISH;
        *(UBOOL*)Result=this->GetVector(ParamName,out_vector);
    }
    DECLARE_FUNCTION(execGetString)
    {
        P_GET_NAME(ParamName);
        P_GET_STR_REF(out_string);
        P_FINISH;
        *(UBOOL*)Result=this->GetString(ParamName,out_string);
    }
    DECLARE_FUNCTION(execCommitToDisk)
    {
        P_FINISH;
        this->CommitToDisk();
    }
    DECLARE_CLASS(UGenericParamListStatEntry,UObject,0,Engine)
	// don't leak the stat event if we get destroyed before disk-commit for some reason
	virtual void BeginDestroy();
};

class UHttpBaseInterface : public UObject
{
public:
    //## BEGIN PROPS HttpBaseInterface
    //## END PROPS HttpBaseInterface

    virtual FString GetHeader(const FString& HeaderName);
    virtual TArray<FString> GetHeaders();
    virtual FString GetURLParameter(const FString& ParameterName);
    virtual FString GetContentType();
    virtual INT GetContentLength();
    virtual FString GetURL();
    virtual void GetContent(TArray<BYTE>& Content);
    DECLARE_FUNCTION(execGetHeader)
    {
        P_GET_STR(HeaderName);
        P_FINISH;
        *(FString*)Result=this->GetHeader(HeaderName);
    }
    DECLARE_FUNCTION(execGetHeaders)
    {
        P_FINISH;
        *(TArray<FString>*)Result=this->GetHeaders();
    }
    DECLARE_FUNCTION(execGetURLParameter)
    {
        P_GET_STR(ParameterName);
        P_FINISH;
        *(FString*)Result=this->GetURLParameter(ParameterName);
    }
    DECLARE_FUNCTION(execGetContentType)
    {
        P_FINISH;
        *(FString*)Result=this->GetContentType();
    }
    DECLARE_FUNCTION(execGetContentLength)
    {
        P_FINISH;
        *(INT*)Result=this->GetContentLength();
    }
    DECLARE_FUNCTION(execGetURL)
    {
        P_FINISH;
        *(FString*)Result=this->GetURL();
    }
    DECLARE_FUNCTION(execGetContent)
    {
        P_GET_TARRAY_REF(BYTE,Content);
        P_FINISH;
        this->GetContent(Content);
    }
    DECLARE_ABSTRACT_CLASS(UHttpBaseInterface,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UHttpBaseInterface)
};

struct HttpRequestInterface_eventOnProcessRequestComplete_Parms
{
    class UHttpRequestInterface* OriginalRequest;
    class UHttpResponseInterface* InHttpResponse;
    UBOOL bDidSucceed;
    HttpRequestInterface_eventOnProcessRequestComplete_Parms(EEventParm)
    {
    }
};
class UHttpRequestInterface : public UHttpBaseInterface
{
public:
    //## BEGIN PROPS HttpRequestInterface
    FScriptDelegate __OnProcessRequestComplete__Delegate;
    //## END PROPS HttpRequestInterface

    virtual FString GetVerb();
    virtual class UHttpRequestInterface* SetVerb(const FString& Verb);
    virtual class UHttpRequestInterface* SetURL(const FString& URL);
    virtual class UHttpRequestInterface* SetContent(const TArray<BYTE>& ContentPayload);
    virtual class UHttpRequestInterface* SetContentAsString(const FString& ContentString);
    virtual class UHttpRequestInterface* SetHeader(const FString& HeaderName,const FString& HeaderValue);
    virtual UBOOL ProcessRequest();
    DECLARE_FUNCTION(execGetVerb)
    {
        P_FINISH;
        *(FString*)Result=this->GetVerb();
    }
    DECLARE_FUNCTION(execSetVerb)
    {
        P_GET_STR(Verb);
        P_FINISH;
        *(class UHttpRequestInterface**)Result=this->SetVerb(Verb);
    }
    DECLARE_FUNCTION(execSetURL)
    {
        P_GET_STR(URL);
        P_FINISH;
        *(class UHttpRequestInterface**)Result=this->SetURL(URL);
    }
    DECLARE_FUNCTION(execSetContent)
    {
        P_GET_TARRAY_REF(BYTE,ContentPayload);
        P_FINISH;
        *(class UHttpRequestInterface**)Result=this->SetContent(ContentPayload);
    }
    DECLARE_FUNCTION(execSetContentAsString)
    {
        P_GET_STR(ContentString);
        P_FINISH;
        *(class UHttpRequestInterface**)Result=this->SetContentAsString(ContentString);
    }
    DECLARE_FUNCTION(execSetHeader)
    {
        P_GET_STR(HeaderName);
        P_GET_STR(HeaderValue);
        P_FINISH;
        *(class UHttpRequestInterface**)Result=this->SetHeader(HeaderName,HeaderValue);
    }
    DECLARE_FUNCTION(execProcessRequest)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ProcessRequest();
    }
    void delegateOnProcessRequestComplete(class UHttpRequestInterface* OriginalRequest,class UHttpResponseInterface* InHttpResponse,UBOOL bDidSucceed)
    {
        HttpRequestInterface_eventOnProcessRequestComplete_Parms Parms(EC_EventParm);
        Parms.OriginalRequest=OriginalRequest;
        Parms.InHttpResponse=InHttpResponse;
        Parms.bDidSucceed=bDidSucceed ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_OnProcessRequestComplete,&__OnProcessRequestComplete__Delegate,&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UHttpRequestInterface,UHttpBaseInterface,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UHttpRequestInterface)
};

class UHttpResponseInterface : public UHttpBaseInterface
{
public:
    //## BEGIN PROPS HttpResponseInterface
    //## END PROPS HttpResponseInterface

    virtual INT GetResponseCode();
    virtual FString GetContentAsString();
    DECLARE_FUNCTION(execGetResponseCode)
    {
        P_FINISH;
        *(INT*)Result=this->GetResponseCode();
    }
    DECLARE_FUNCTION(execGetContentAsString)
    {
        P_FINISH;
        *(FString*)Result=this->GetContentAsString();
    }
    DECLARE_ABSTRACT_CLASS(UHttpResponseInterface,UHttpBaseInterface,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UHttpResponseInterface)
};

struct FIniLocFileEntry
{
    FStringNoInit Filename;
    FStringNoInit DLName;
    FStringNoInit HashCode;
    BITFIELD bIsUnicode:1;
    SCRIPT_ALIGN;
    BYTE ReadState;
    SCRIPT_ALIGN;

    /** Constructors */
    FIniLocFileEntry() {}
    FIniLocFileEntry(EEventParm)
    {
        appMemzero(this, sizeof(FIniLocFileEntry));
    }
};

struct IniLocPatcher_eventOnAllTitleFilesCompleted_Parms
{
    IniLocPatcher_eventOnAllTitleFilesCompleted_Parms(EEventParm)
    {
    }
};
struct IniLocPatcher_eventOnReadTitleFileComplete_Parms
{
    UBOOL bWasSuccessful;
    FString Filename;
    IniLocPatcher_eventOnReadTitleFileComplete_Parms(EEventParm)
    {
    }
};
class UIniLocPatcher : public UObject
{
public:
    //## BEGIN PROPS IniLocPatcher
    TArrayNoInit<struct FIniLocFileEntry> Files;
    BITFIELD bRequestEmsFileList:1;
    INT MaxCachedFileAge;
    TScriptInterface<class IInterface> TitleFileInterface;
    TScriptInterface<class IInterface> TitleFileCacheInterface;
    TArrayNoInit<FScriptDelegate> ReadTitleFileCompleteDelegates;
    FScriptDelegate __OnReadTitleFileComplete__Delegate;
    FScriptDelegate __OnAllTitleFilesCompleted__Delegate;
    //## END PROPS IniLocPatcher

    virtual void ProcessIniLocFile(const FString& Filename,UBOOL bIsUnicode,const TArray<BYTE>& FileData);
    virtual FString UpdateLocFileName(const FString& Filename);
    DECLARE_FUNCTION(execProcessIniLocFile)
    {
        P_GET_STR(Filename);
        P_GET_UBOOL(bIsUnicode);
        P_GET_TARRAY_REF(BYTE,FileData);
        P_FINISH;
        this->ProcessIniLocFile(Filename,bIsUnicode,FileData);
    }
    DECLARE_FUNCTION(execUpdateLocFileName)
    {
        P_GET_STR(Filename);
        P_FINISH;
        *(FString*)Result=this->UpdateLocFileName(Filename);
    }
    void delegateOnAllTitleFilesCompleted()
    {
        ProcessDelegate(ENGINE_OnAllTitleFilesCompleted,&__OnAllTitleFilesCompleted__Delegate,NULL);
    }
    void delegateOnReadTitleFileComplete(UBOOL bWasSuccessful,const FString& Filename)
    {
        IniLocPatcher_eventOnReadTitleFileComplete_Parms Parms(EC_EventParm);
        Parms.bWasSuccessful=bWasSuccessful ? FIRST_BITFIELD : FALSE;
        Parms.Filename=Filename;
        ProcessDelegate(ENGINE_OnReadTitleFileComplete,&__OnReadTitleFileComplete__Delegate,&Parms);
    }
    DECLARE_CLASS(UIniLocPatcher,UObject,0|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

    NO_DEFAULT_CONSTRUCTOR(UIniLocPatcher)
};

class UInterface_Speaker : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UInterface_Speaker,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterface_Speaker)
};

class IInterface_Speaker
{
protected:
	virtual ~IInterface_Speaker() {}
public:
	typedef UInterface_Speaker UClassType;
	virtual UObject* GetUObjectInterfaceInterface_Speaker()=0;
    virtual void eventSpeak(class USoundCue* Cue)=0;
    NO_DEFAULT_CONSTRUCTOR(IInterface_Speaker)
};

struct FCurveEdEntry
{
    class UObject* CurveObject;
    FColor CurveColor;
    FStringNoInit CurveName;
    INT bHideCurve;
    INT bColorCurve;
    INT bFloatingPointColorCurve;
    INT bClamp;
    FLOAT ClampLow;
    FLOAT ClampHigh;

    /** Constructors */
    FCurveEdEntry() {}
    FCurveEdEntry(EEventParm)
    {
        appMemzero(this, sizeof(FCurveEdEntry));
    }
};

struct FCurveEdTab
{
    FStringNoInit TabName;
    TArrayNoInit<struct FCurveEdEntry> Curves;
    FLOAT ViewStartInput;
    FLOAT ViewEndInput;
    FLOAT ViewStartOutput;
    FLOAT ViewEndOutput;

    /** Constructors */
    FCurveEdTab() {}
    FCurveEdTab(EEventParm)
    {
        appMemzero(this, sizeof(FCurveEdTab));
    }
};

class UInterpCurveEdSetup : public UObject
{
public:
    //## BEGIN PROPS InterpCurveEdSetup
    TArrayNoInit<struct FCurveEdTab> Tabs;
    INT ActiveTab;
    //## END PROPS InterpCurveEdSetup

    DECLARE_CLASS(UInterpCurveEdSetup,UObject,0,Engine)
	// UObject interface
	void PostLoad();
	void Serialize(FArchive& Ar);
	
	// InterpCurveEdSetup interface
	static FCurveEdInterface* GetCurveEdInterfacePointer(const FCurveEdEntry& Entry);
	void AddCurveToCurrentTab(UObject* InCurve, const FString& CurveName, const FColor& CurveColor, 
			UBOOL bInColorCurve=false, UBOOL bInFloatingPointColor=false, UBOOL bInClamp=false,
			FLOAT InClampLow=0.f, FLOAT InClampHigh=0.f);
	void RemoveCurve(UObject* InCurve);
	void ReplaceCurve(UObject* RemoveCurve, UObject* AddCurve);
	void CreateNewTab(const FString& InTabName);
	void RemoveTab(const FString& InTabName);
	UBOOL ShowingCurve(UObject* InCurve);

	void ChangeCurveColor(UObject* InCurve, const FColor& CurveColor);
	void ChangeCurveName(UObject* InCurve, const FString& NewCurveName);

	void ResetTabs();
};

class UJsonObject : public UObject
{
public:
    //## BEGIN PROPS JsonObject
    TMap<FString, FString> ValueMap;
    TMap<FString, UJsonObject*> ObjectMap;
    TArrayNoInit<FString> ValueArray;
    TArrayNoInit<class UJsonObject*> ObjectArray;
    //## END PROPS JsonObject

    virtual class UJsonObject* GetObject(const FString& Key);
    virtual FString GetStringValue(const FString& Key);
    virtual UBOOL HasKey(const FString& Key);
    virtual void SetObject(const FString& Key,class UJsonObject* Object);
    virtual void SetStringValue(const FString& Key,const FString& Value);
    FString EncodeJson(class UJsonObject* Root);
    class UJsonObject* DecodeJson(const FString& Str);
    DECLARE_FUNCTION(execGetObject)
    {
        P_GET_STR(Key);
        P_FINISH;
        *(class UJsonObject**)Result=this->GetObject(Key);
    }
    DECLARE_FUNCTION(execGetStringValue)
    {
        P_GET_STR(Key);
        P_FINISH;
        *(FString*)Result=this->GetStringValue(Key);
    }
    DECLARE_FUNCTION(execHasKey)
    {
        P_GET_STR(Key);
        P_FINISH;
        *(UBOOL*)Result=this->HasKey(Key);
    }
    DECLARE_FUNCTION(execSetObject)
    {
        P_GET_STR(Key);
        P_GET_OBJECT(UJsonObject,Object);
        P_FINISH;
        this->SetObject(Key,Object);
    }
    DECLARE_FUNCTION(execSetStringValue)
    {
        P_GET_STR(Key);
        P_GET_STR(Value);
        P_FINISH;
        this->SetStringValue(Key,Value);
    }
    DECLARE_FUNCTION(execEncodeJson)
    {
        P_GET_OBJECT(UJsonObject,Root);
        P_FINISH;
        *(FString*)Result=this->EncodeJson(Root);
    }
    DECLARE_FUNCTION(execDecodeJson)
    {
        P_GET_STR(Str);
        P_FINISH;
        *(class UJsonObject**)Result=this->DecodeJson(Str);
    }
    DECLARE_CLASS(UJsonObject,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UJsonObject)
};

class ULevelStreaming : public UObject
{
public:
    //## BEGIN PROPS LevelStreaming
    FName PackageName;
    class ULevel* LoadedLevel;
    FVector Offset;
    FMatrix LevelTransform;
    FVector OldOffset;
    BITFIELD bIsVisible:1;
    BITFIELD bHasLoadRequestPending:1;
    BITFIELD bHasUnloadRequestPending:1;
    BITFIELD bShouldBeVisibleInEditor:1;
    BITFIELD bBoundingBoxVisible:1;
    BITFIELD bLocked:1;
    BITFIELD bIsFullyStatic:1;
    BITFIELD bShouldBeLoaded:1;
    BITFIELD bShouldBeVisible:1;
    BITFIELD bShouldBlockOnLoad:1;
    BITFIELD bDrawOnLevelStatusMap:1;
    BITFIELD bIsRequestingUnloadAndRemoval:1;
    SCRIPT_ALIGN;
    FColor DrawColor;
    TArrayNoInit<class ALevelStreamingVolume*> EditorStreamingVolumes;
    FLOAT MinTimeBetweenVolumeUnloadRequests;
    FLOAT LastVolumeUnloadRequestTime;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<FString> Keywords;
#endif // WITH_EDITORONLY_DATA
    class ALevelGridVolume* EditorGridVolume;
    INT GridPosition[3];
    //## END PROPS LevelStreaming

    DECLARE_ABSTRACT_CLASS(ULevelStreaming,UObject,0,Engine)
	/**
	 * Returns whether this level should be present in memory which in turn tells the
	 * streaming code to stream it in. Please note that a change in value from FALSE
	 * to TRUE only tells the streaming code that it needs to START streaming it in
	 * so the code needs to return TRUE an appropriate amount of time before it is
	 * needed.
	 *
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if level should be loaded/ streamed in, FALSE otherwise
	 */
	virtual UBOOL ShouldBeLoaded( const FVector& ViewLocation );

	/**
	 * Returns whether this level should be visible/ associated with the world if it is
	 * loaded.
	 *
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if the level should be visible, FALSE otherwise
	 */
	virtual UBOOL ShouldBeVisible( const FVector& ViewLocation );

	/** Get a bounding box around the streaming volumes associated with this LevelStreaming object */
	FBox GetStreamingVolumeBounds();

	// UObject interface.
	virtual void PostEditChangeChainProperty(FPropertyChangedChainEvent& PropertyChangedEvent);
};

class ULevelStreamingAlwaysLoaded : public ULevelStreaming
{
public:
    //## BEGIN PROPS LevelStreamingAlwaysLoaded
    BITFIELD bIsProceduralBuildingLODLevel:1;
    SCRIPT_ALIGN;
    //## END PROPS LevelStreamingAlwaysLoaded

    DECLARE_CLASS(ULevelStreamingAlwaysLoaded,ULevelStreaming,0,Engine)
	/**
	* Returns whether this level should be present in memory which in turn tells the 
	* streaming code to stream it in. Please note that a change in value from FALSE 
	* to TRUE only tells the streaming code that it needs to START streaming it in 
	* so the code needs to return TRUE an appropriate amount of time before it is 
	* needed.
	*
	* @param ViewLocation	Location of the viewer
	* @return TRUE
	*/
	virtual UBOOL ShouldBeLoaded( const FVector& ViewLocation );
};

class ULevelStreamingDistance : public ULevelStreaming
{
public:
    //## BEGIN PROPS LevelStreamingDistance
    FVector Origin;
    FLOAT MaxDistance;
    //## END PROPS LevelStreamingDistance

    DECLARE_CLASS(ULevelStreamingDistance,ULevelStreaming,0,Engine)
	/**
	 * Returns whether this level should be present in memory which in turn tells the 
	 * streaming code to stream it in. Please note that a change in value from FALSE 
	 * to TRUE only tells the streaming code that it needs to START streaming it in 
	 * so the code needs to return TRUE an appropriate amount of time before it is 
	 * needed.
	 *
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if level should be loaded/ streamed in, FALSE otherwise
	 */
	virtual UBOOL ShouldBeLoaded( const FVector& ViewLocation );
};

class ULevelStreamingKismet : public ULevelStreaming
{
public:
    //## BEGIN PROPS LevelStreamingKismet
    //## END PROPS LevelStreamingKismet

    DECLARE_CLASS(ULevelStreamingKismet,ULevelStreaming,0,Engine)
	/**
	 * Returns whether this level should be present in memory which in turn tells the 
	 * streaming code to stream it in. Please note that a change in value from FALSE 
	 * to TRUE only tells the streaming code that it needs to START streaming it in 
	 * so the code needs to return TRUE an appropriate amount of time before it is 
	 * needed.
	 *
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if level should be loaded/ streamed in, FALSE otherwise
	 */
	virtual UBOOL ShouldBeLoaded( const FVector& ViewLocation );

	/**
	 * Returns whether this level should be visible/ associated with the world if it is
	 * loaded.
	 * 
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE if the level should be visible, FALSE otherwise
	 */
	virtual UBOOL ShouldBeVisible( const FVector& ViewLocation );
};

class ULevelStreamingPersistent : public ULevelStreaming
{
public:
    //## BEGIN PROPS LevelStreamingPersistent
    //## END PROPS LevelStreamingPersistent

    DECLARE_CLASS(ULevelStreamingPersistent,ULevelStreaming,0|CLASS_Transient,Engine)
	/**
	 * Returns whether this level should be present in memory which in turn tells the 
	 * streaming code to stream it in. Please note that a change in value from FALSE 
	 * to TRUE only tells the streaming code that it needs to START streaming it in 
	 * so the code needs to return TRUE an appropriate amount of time before it is 
	 * needed.
	 *
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE
	 */
	virtual UBOOL ShouldBeLoaded( const FVector& ViewLocation )
	{
		return TRUE;
	}

	/**
	 * Returns whether this level should be visible/ associated with the world if it is
	 * loaded.
	 * 
	 * @param ViewLocation	Location of the viewer
	 * @return TRUE
	 */
	virtual UBOOL ShouldBeVisible( const FVector& ViewLocation )
	{
		return TRUE;
	}
};

class ULightmappedSurfaceCollection : public UObject
{
public:
    //## BEGIN PROPS LightmappedSurfaceCollection
    class UModel* SourceModel;
    TArrayNoInit<INT> Surfaces;
    //## END PROPS LightmappedSurfaceCollection

    DECLARE_CLASS(ULightmappedSurfaceCollection,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ULightmappedSurfaceCollection)
};

class UDEPRECATED_LightmassLevelSettings : public UObject
{
public:
    //## BEGIN PROPS LightmassLevelSettings
    INT NumIndirectLightingBounces;
    FColor EnvironmentColor;
    FLOAT EnvironmentIntensity;
    FLOAT EmissiveBoost;
    FLOAT DiffuseBoost;
    FLOAT SpecularBoost;
    BITFIELD bUseAmbientOcclusion:1;
    BITFIELD bVisualizeAmbientOcclusion:1;
    FLOAT DirectIlluminationOcclusionFraction;
    FLOAT IndirectIlluminationOcclusionFraction;
    FLOAT OcclusionExponent;
    FLOAT FullyOccludedSamplesFraction;
    FLOAT MaxOcclusionDistance;
    //## END PROPS LightmassLevelSettings

    DECLARE_CLASS(UDEPRECATED_LightmassLevelSettings,UObject,0|CLASS_Deprecated,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDEPRECATED_LightmassLevelSettings)
};

class ULightmassPrimitiveSettingsObject : public UObject
{
public:
    //## BEGIN PROPS LightmassPrimitiveSettingsObject
    FLightmassPrimitiveSettings LightmassSettings;
    //## END PROPS LightmassPrimitiveSettingsObject

    DECLARE_CLASS(ULightmassPrimitiveSettingsObject,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ULightmassPrimitiveSettingsObject)
};

class UMapInfo : public UObject
{
public:
    //## BEGIN PROPS MapInfo
    //## END PROPS MapInfo

    DECLARE_ABSTRACT_CLASS(UMapInfo,UObject,0,Engine)
#if WITH_EDITOR
	virtual void CheckForErrors() {}
#endif
};

struct FMusicTrackStruct
{
    class USoundCue* TheSoundCue;
    BITFIELD bAutoPlay:1;
    BITFIELD bPersistentAcrossLevels:1;
    FLOAT FadeInTime;
    FLOAT FadeInVolumeLevel;
    FLOAT FadeOutTime;
    FLOAT FadeOutVolumeLevel;
    FStringNoInit MP3Filename;

    /** Constructors */
    FMusicTrackStruct() {}
    FMusicTrackStruct(EEventParm)
    {
        appMemzero(this, sizeof(FMusicTrackStruct));
    }
};

class UMusicTrackDataStructures : public UObject
{
public:
    //## BEGIN PROPS MusicTrackDataStructures
    //## END PROPS MusicTrackDataStructures

    DECLARE_CLASS(UMusicTrackDataStructures,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UMusicTrackDataStructures)
};

class UObjectReferencer : public UObject
{
public:
    //## BEGIN PROPS ObjectReferencer
    TArrayNoInit<class UObject*> ReferencedObjects;
    //## END PROPS ObjectReferencer

    DECLARE_CLASS(UObjectReferencer,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UObjectReferencer)
};

struct FOnlineGameSearchResult
{
    class UOnlineGameSettings* GameSettings;
    void* PlatformData;

		/** Default constructor does nothing and is here for NoInit types */
		FOnlineGameSearchResult()
		{
		}

		/** Zeroing constructor */
		FOnlineGameSearchResult(EEventParm) :
			GameSettings(NULL),
			PlatformData(NULL)
		{
		}
	
};

struct FOverrideSkill
{
    INT LeaderboardId;
    TArrayNoInit<struct FUniqueNetId> Players;
    TArrayNoInit<DOUBLE> Mus;
    TArrayNoInit<DOUBLE> Sigmas;

    /** Constructors */
    FOverrideSkill() {}
    FOverrideSkill(EEventParm)
    {
        appMemzero(this, sizeof(FOverrideSkill));
    }
};

struct FNamedObjectProperty
{
    FName ObjectPropertyName;
    FStringNoInit ObjectPropertyValue;

    /** Constructors */
    FNamedObjectProperty() {}
    FNamedObjectProperty(EEventParm)
    {
        appMemzero(this, sizeof(FNamedObjectProperty));
    }
};

struct FOnlineGameSearchParameter
{
    INT EntryId;
    FName ObjectPropertyName;
    BYTE EntryType;
    BYTE ComparisonType;
    SCRIPT_ALIGN;

    /** Constructors */
    FOnlineGameSearchParameter() {}
    FOnlineGameSearchParameter(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineGameSearchParameter));
    }
};

struct FOnlineGameSearchSortClause
{
    INT EntryId;
    FName ObjectPropertyName;
    BYTE EntryType;
    BYTE SortType;
    SCRIPT_ALIGN;

    /** Constructors */
    FOnlineGameSearchSortClause() {}
    FOnlineGameSearchSortClause(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineGameSearchSortClause));
    }
};

struct FOnlineGameSearchORClause
{
    TArrayNoInit<struct FOnlineGameSearchParameter> OrParams;

    /** Constructors */
    FOnlineGameSearchORClause() {}
    FOnlineGameSearchORClause(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineGameSearchORClause));
    }
};

struct FOnlineGameSearchQuery
{
    TArrayNoInit<struct FOnlineGameSearchORClause> OrClauses;
    TArrayNoInit<struct FOnlineGameSearchSortClause> SortClauses;

    /** Constructors */
    FOnlineGameSearchQuery() {}
    FOnlineGameSearchQuery(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineGameSearchQuery));
    }
};

struct OnlineGameSearch_eventSortSearchResults_Parms
{
    OnlineGameSearch_eventSortSearchResults_Parms(EEventParm)
    {
    }
};
class UOnlineGameSearch : public USettings
{
public:
    //## BEGIN PROPS OnlineGameSearch
    INT MaxSearchResults;
    struct FLocalizedStringSetting Query;
    BITFIELD bIsLanQuery:1;
    BITFIELD bUsesArbitration:1;
    BITFIELD bIsSearchInProgress:1;
    class UClass* GameSettingsClass;
    TArrayNoInit<struct FOnlineGameSearchResult> Results;
    struct FOverrideSkill ManualSkillOverride;
    TArrayNoInit<struct FNamedObjectProperty> NamedProperties;
    struct FOnlineGameSearchQuery FilterQuery;
    FStringNoInit AdditionalSearchCriteria;
    INT PingBucketSize;
    INT NumPingProbes;
    INT MaxPingBytes;
    //## END PROPS OnlineGameSearch

    virtual void SortSearchResults();
    DECLARE_FUNCTION(execSortSearchResults)
    {
        P_FINISH;
        this->SortSearchResults();
    }
    void eventSortSearchResults()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SortSearchResults),NULL);
    }
    DECLARE_CLASS(UOnlineGameSearch,USettings,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineGameSearch)
};

struct FMMStats_Timer
{
    BITFIELD bInProgress:1;
    SCRIPT_ALIGN;
    DOUBLE MSecs;

    /** Constructors */
    FMMStats_Timer() {}
    FMMStats_Timer(EEventParm)
    {
        appMemzero(this, sizeof(FMMStats_Timer));
    }
};

class UOnlineMatchmakingStats : public UObject
{
public:
    //## BEGIN PROPS OnlineMatchmakingStats
    //## END PROPS OnlineMatchmakingStats

    virtual void StartTimer(struct FMMStats_Timer& Timer);
    virtual void StopTimer(struct FMMStats_Timer& Timer);
    DECLARE_FUNCTION(execStartTimer)
    {
        P_GET_STRUCT_REF(struct FMMStats_Timer,Timer);
        P_FINISH;
        this->StartTimer(Timer);
    }
    DECLARE_FUNCTION(execStopTimer)
    {
        P_GET_STRUCT_REF(struct FMMStats_Timer,Timer);
        P_FINISH;
        this->StopTimer(Timer);
    }
    DECLARE_CLASS(UOnlineMatchmakingStats,UObject,0,Engine)
	virtual void ToXML(FString& OutXmlStr,const FUniqueNetId& UniqueId,const FString& XmlPlatformStr,UBOOL bShouldIndent)
	{
		check(0 && "not implemented");
	}
};

struct FOnlineProfileSetting
{
    BYTE Owner;
    SCRIPT_ALIGN;
    struct FSettingsProperty ProfileSetting;

		/** Does nothing (no init version) */
		FOnlineProfileSetting(void)
		{
		}

		/**
		 * Zeroes members
		 */
		FOnlineProfileSetting(EEventParm) :
			Owner(0),
			ProfileSetting(EC_EventParm)
		{
		}

		/**
		 * Copy constructor. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FOnlineProfileSetting(const FOnlineProfileSetting& Other) :
			Owner(0),
			ProfileSetting(EC_EventParm)
		{
			Owner = Other.Owner;
			ProfileSetting = Other.ProfileSetting;
		}

		/**
		 * Assignment operator. Copies the other into this object
		 *
		 * @param Other the other structure to copy
		 */
		FOnlineProfileSetting& operator=(const FOnlineProfileSetting& Other)
		{	
			if (&Other != this)
			{
				Owner = Other.Owner;
				ProfileSetting = Other.ProfileSetting;
			}
			return *this;
		}
	
};

struct OnlinePlayerStorage_eventSetToDefaults_Parms
{
    OnlinePlayerStorage_eventSetToDefaults_Parms(EEventParm)
    {
    }
};
class UOnlinePlayerStorage : public UObject
{
public:
    //## BEGIN PROPS OnlinePlayerStorage
    INT VersionNumber;
    INT VersionSettingsId;
    INT SaveCountSettingId;
    TArrayNoInit<struct FOnlineProfileSetting> ProfileSettings;
    TArrayNoInit<struct FSettingsPropertyPropertyMetaData> ProfileMappings;
    BYTE AsyncState;
    INT DeviceID;
    //## END PROPS OnlinePlayerStorage

    virtual UBOOL GetProfileSettingId(FName ProfileSettingName,INT& ProfileSettingId);
    virtual FName GetProfileSettingName(INT ProfileSettingId);
    virtual FString GetProfileSettingColumnHeader(INT ProfileSettingId);
    INT FindProfileSettingIndex(INT ProfileSettingId) const;
    INT FindProfileMappingIndex(INT ProfileSettingId) const;
    INT FindProfileMappingIndexByName(FName ProfileSettingName) const;
    INT FindDefaultProfileMappingIndexByName(FName ProfileSettingName) const;
    virtual UBOOL IsProfileSettingIdMapped(INT ProfileSettingId);
    virtual UBOOL GetProfileSettingValue(INT ProfileSettingId,FString& Value,INT ValueMapID=-1);
    virtual FName GetProfileSettingValueName(INT ProfileSettingId);
    virtual UBOOL GetProfileSettingValues(INT ProfileSettingId,TArray<FName>& Values);
    virtual UBOOL GetProfileSettingValueByName(FName ProfileSettingName,FString& Value);
    virtual UBOOL SetProfileSettingValueByName(FName ProfileSettingName,const FString& NewValue);
    virtual UBOOL SetProfileSettingValue(INT ProfileSettingId,const FString& NewValue);
    virtual UBOOL GetProfileSettingValueId(INT ProfileSettingId,INT& ValueId,INT* ListIndex=NULL);
    virtual UBOOL GetProfileSettingValueFromListIndex(INT ProfileSettingId,INT ListIndex,INT& Value);
    virtual UBOOL GetProfileSettingValueInt(INT ProfileSettingId,INT& Value);
    virtual UBOOL GetProfileSettingValueFloat(INT ProfileSettingId,FLOAT& Value);
    virtual UBOOL SetProfileSettingValueId(INT ProfileSettingId,INT Value);
    virtual UBOOL SetProfileSettingValueInt(INT ProfileSettingId,INT Value);
    virtual UBOOL SetProfileSettingValueFloat(INT ProfileSettingId,FLOAT Value);
    virtual UBOOL GetProfileSettingMappingType(INT ProfileId,BYTE& OutType);
    UBOOL GetProfileSettingMappingIds(INT ProfileId,TArray<INT>& Ids);
    virtual UBOOL GetProfileSettingRange(INT ProfileId,FLOAT& OutMinValue,FLOAT& OutMaxValue,FLOAT& RangeIncrement,BYTE& bFormatAsInt);
    virtual UBOOL SetRangedProfileSettingValue(INT ProfileId,FLOAT NewValue);
    virtual UBOOL GetRangedProfileSettingValue(INT ProfileId,FLOAT& OutValue);
    virtual void AddSettingInt(INT SettingId);
    virtual void AddSettingFloat(INT SettingId);
    virtual void SetToDefaults();
    virtual void AppendVersionToSettings();
    virtual INT GetVersionNumber();
    virtual void SetDefaultVersionNumber();
    DECLARE_FUNCTION(execGetProfileSettingId)
    {
        P_GET_NAME(ProfileSettingName);
        P_GET_INT_REF(ProfileSettingId);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingId(ProfileSettingName,ProfileSettingId);
    }
    DECLARE_FUNCTION(execGetProfileSettingName)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(FName*)Result=this->GetProfileSettingName(ProfileSettingId);
    }
    DECLARE_FUNCTION(execGetProfileSettingColumnHeader)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(FString*)Result=this->GetProfileSettingColumnHeader(ProfileSettingId);
    }
    DECLARE_FUNCTION(execFindProfileSettingIndex)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(INT*)Result=this->FindProfileSettingIndex(ProfileSettingId);
    }
    DECLARE_FUNCTION(execFindProfileMappingIndex)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(INT*)Result=this->FindProfileMappingIndex(ProfileSettingId);
    }
    DECLARE_FUNCTION(execFindProfileMappingIndexByName)
    {
        P_GET_NAME(ProfileSettingName);
        P_FINISH;
        *(INT*)Result=this->FindProfileMappingIndexByName(ProfileSettingName);
    }
    DECLARE_FUNCTION(execFindDefaultProfileMappingIndexByName)
    {
        P_GET_NAME(ProfileSettingName);
        P_FINISH;
        *(INT*)Result=this->FindDefaultProfileMappingIndexByName(ProfileSettingName);
    }
    DECLARE_FUNCTION(execIsProfileSettingIdMapped)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(UBOOL*)Result=this->IsProfileSettingIdMapped(ProfileSettingId);
    }
    DECLARE_FUNCTION(execGetProfileSettingValue)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_STR_REF(Value);
        P_GET_INT_OPTX(ValueMapID,-1);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingValue(ProfileSettingId,Value,ValueMapID);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueName)
    {
        P_GET_INT(ProfileSettingId);
        P_FINISH;
        *(FName*)Result=this->GetProfileSettingValueName(ProfileSettingId);
    }
    DECLARE_FUNCTION(execGetProfileSettingValues)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_TARRAY_REF(FName,Values);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingValues(ProfileSettingId,Values);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueByName)
    {
        P_GET_NAME(ProfileSettingName);
        P_GET_STR_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingValueByName(ProfileSettingName,Value);
    }
    DECLARE_FUNCTION(execSetProfileSettingValueByName)
    {
        P_GET_NAME(ProfileSettingName);
        P_GET_STR_REF(NewValue);
        P_FINISH;
        *(UBOOL*)Result=this->SetProfileSettingValueByName(ProfileSettingName,NewValue);
    }
    DECLARE_FUNCTION(execSetProfileSettingValue)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_STR_REF(NewValue);
        P_FINISH;
        *(UBOOL*)Result=this->SetProfileSettingValue(ProfileSettingId,NewValue);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueId)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT_REF(ValueId);
        P_GET_INT_OPTX_REF(ListIndex,0);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingValueId(ProfileSettingId,ValueId,pListIndex ? &ListIndex : NULL);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueFromListIndex)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT(ListIndex);
        P_GET_INT_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingValueFromListIndex(ProfileSettingId,ListIndex,Value);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueInt)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingValueInt(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execGetProfileSettingValueFloat)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_FLOAT_REF(Value);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingValueFloat(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execSetProfileSettingValueId)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT(Value);
        P_FINISH;
        *(UBOOL*)Result=this->SetProfileSettingValueId(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execSetProfileSettingValueInt)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT(Value);
        P_FINISH;
        *(UBOOL*)Result=this->SetProfileSettingValueInt(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execSetProfileSettingValueFloat)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_FLOAT(Value);
        P_FINISH;
        *(UBOOL*)Result=this->SetProfileSettingValueFloat(ProfileSettingId,Value);
    }
    DECLARE_FUNCTION(execGetProfileSettingMappingType)
    {
        P_GET_INT(ProfileId);
        P_GET_BYTE_REF(OutType);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingMappingType(ProfileId,OutType);
    }
    DECLARE_FUNCTION(execGetProfileSettingMappingIds)
    {
        P_GET_INT(ProfileId);
        P_GET_TARRAY_REF(INT,Ids);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingMappingIds(ProfileId,Ids);
    }
    DECLARE_FUNCTION(execGetProfileSettingRange)
    {
        P_GET_INT(ProfileId);
        P_GET_FLOAT_REF(OutMinValue);
        P_GET_FLOAT_REF(OutMaxValue);
        P_GET_FLOAT_REF(RangeIncrement);
        P_GET_BYTE_REF(bFormatAsInt);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingRange(ProfileId,OutMinValue,OutMaxValue,RangeIncrement,bFormatAsInt);
    }
    DECLARE_FUNCTION(execSetRangedProfileSettingValue)
    {
        P_GET_INT(ProfileId);
        P_GET_FLOAT(NewValue);
        P_FINISH;
        *(UBOOL*)Result=this->SetRangedProfileSettingValue(ProfileId,NewValue);
    }
    DECLARE_FUNCTION(execGetRangedProfileSettingValue)
    {
        P_GET_INT(ProfileId);
        P_GET_FLOAT_REF(OutValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetRangedProfileSettingValue(ProfileId,OutValue);
    }
    DECLARE_FUNCTION(execAddSettingInt)
    {
        P_GET_INT(SettingId);
        P_FINISH;
        this->AddSettingInt(SettingId);
    }
    DECLARE_FUNCTION(execAddSettingFloat)
    {
        P_GET_INT(SettingId);
        P_FINISH;
        this->AddSettingFloat(SettingId);
    }
    DECLARE_FUNCTION(execSetToDefaults)
    {
        P_FINISH;
        this->SetToDefaults();
    }
    DECLARE_FUNCTION(execAppendVersionToSettings)
    {
        P_FINISH;
        this->AppendVersionToSettings();
    }
    DECLARE_FUNCTION(execGetVersionNumber)
    {
        P_FINISH;
        *(INT*)Result=this->GetVersionNumber();
    }
    DECLARE_FUNCTION(execSetDefaultVersionNumber)
    {
        P_FINISH;
        this->SetDefaultVersionNumber();
    }
    void eventSetToDefaults()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SetToDefaults),NULL);
    }
    DECLARE_CLASS(UOnlinePlayerStorage,UObject,0,Engine)
public:
	/**
	 * Finds the specified profile setting
	 *
	 * @param SettingId to search for
	 *
	 * @return pointer to the setting or NULL if not found
	 */
	FORCEINLINE FOnlineProfileSetting* FindSetting(INT SettingId)
	{
		for (INT ProfileIndex = 0; ProfileIndex < ProfileSettings.Num(); ++ProfileIndex)
		{
			FOnlineProfileSetting& Setting = ProfileSettings(ProfileIndex);
			if (Setting.ProfileSetting.PropertyId == SettingId)
			{
				return &Setting;
			}
		}
		return NULL;
	}

	/**
	 * Finds the specified property's meta data
	 *
	 * @param PropertyId id of the property to search the meta data for
	 *
	 * @return pointer to the property meta data or NULL if not found
	 */
	FORCEINLINE FSettingsPropertyPropertyMetaData* FindProfileSettingMetaData(INT ProfileId)
	{
		for (INT MetaDataIndex = 0; MetaDataIndex < ProfileMappings.Num(); MetaDataIndex++)
		{
			FSettingsPropertyPropertyMetaData& MetaData = ProfileMappings(MetaDataIndex);
			if (MetaData.Id == ProfileId)
			{
				return &MetaData;
			}
		}
		return NULL;
	}

	/**
	 * Searches for the profile setting by id and sets the value
	 *
	 * @param ProfileSettingId the id of the profile setting to return
	 * @param Value the new value of the setting
	 *
	 * @return true if the profile setting was found and not id mapped, false otherwise
	 */
	template<typename TYPE>
	FORCEINLINE UBOOL SetProfileSettingTypedValue(INT ProfileSettingId,TYPE Value)
	{
		// Search for the profile setting id in the mappings
		for (INT Index = 0; Index < ProfileMappings.Num(); Index++)
		{
			const FSettingsPropertyPropertyMetaData& MetaData = ProfileMappings(Index);
			if (MetaData.Id == ProfileSettingId)
			{
				// Find the profile setting that matches this id
				for (INT Index2 = 0; Index2 < ProfileSettings.Num(); Index2++)
				{
					FOnlineProfileSetting& Setting = ProfileSettings(Index2);
					if (Setting.ProfileSetting.PropertyId == ProfileSettingId)
					{
						// If this is a raw value, then read it
						if (MetaData.MappingType == PVMT_RawValue)
						{
							Setting.ProfileSetting.Data.SetData(Value);
							return TRUE;
						}
						else
						{
							return FALSE;
						}
					}
				}
			}
		}
		return FALSE;
	}


	/**
	 * Searches for the profile setting by id and sets the value
	 *
	 * @param ProfileSettingId the id of the profile setting to return
	 * @param Value the new value of the setting
	 *
	 * @return true if the profile setting was found and not id mapped, false otherwise
	 */
	template<typename TYPE>
	FORCEINLINE void AddSettingTypedValue(INT ProfileSettingId)
	{
		// Don't add if it already exists
		if (FindSetting(ProfileSettingId) == NULL)
		{
			TYPE Type = 0;
			// Construct an zeroed setting of the right type
			FOnlineProfileSetting Setting(EC_EventParm);
			Setting.Owner = OPPO_Game;
			Setting.ProfileSetting.PropertyId = ProfileSettingId;
			Setting.ProfileSetting.Data.SetData(Type);
			// Now add this to the array
			ProfileSettings.AddItem(Setting);
		}
	}

	/** Finalize the clean up process */
	virtual void FinishDestroy(void);

	/**
	 * Increments the number of times this profile has been saved
	 *
	 * @param NewCount the new number to use as the save count
	 * @param ProfileSettings the array to search for the setting to update
	 */
	static void SetProfileSaveCount(INT NewCount,TArray<FOnlineProfileSetting>& ProfileSettings,INT SaveCountId);

	/**
	 * Reads the number of times this profile has been saved
	 *
	 * @param ProfileSettings the array to search for the value
	 *
	 * @return the number of times the profile data has been saved
	 */
	static INT GetProfileSaveCount(const TArray<FOnlineProfileSetting>& ProfileSettings,INT SaveCountId);
};

struct OnlineProfileSettings_eventModifyAvailableProfileSettings_Parms
{
    OnlineProfileSettings_eventModifyAvailableProfileSettings_Parms(EEventParm)
    {
    }
};
class UOnlineProfileSettings : public UOnlinePlayerStorage
{
public:
    //## BEGIN PROPS OnlineProfileSettings
    TArrayNoInit<INT> ProfileSettingIds;
    TArrayNoInit<struct FOnlineProfileSetting> DefaultSettings;
    TArrayNoInit<struct FIdToStringMapping> OwnerMappings;
    //## END PROPS OnlineProfileSettings

    virtual UBOOL GetProfileSettingDefaultId(INT ProfileSettingId,INT& DefaultId,INT& ListIndex);
    virtual UBOOL GetProfileSettingDefaultInt(INT ProfileSettingId,INT& DefaultInt);
    virtual UBOOL GetProfileSettingDefaultFloat(INT ProfileSettingId,FLOAT& DefaultFloat);
    virtual void SetToDefaults();
    virtual void AppendVersionToReadIds();
    DECLARE_FUNCTION(execGetProfileSettingDefaultId)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT_REF(DefaultId);
        P_GET_INT_REF(ListIndex);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingDefaultId(ProfileSettingId,DefaultId,ListIndex);
    }
    DECLARE_FUNCTION(execGetProfileSettingDefaultInt)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_INT_REF(DefaultInt);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingDefaultInt(ProfileSettingId,DefaultInt);
    }
    DECLARE_FUNCTION(execGetProfileSettingDefaultFloat)
    {
        P_GET_INT(ProfileSettingId);
        P_GET_FLOAT_REF(DefaultFloat);
        P_FINISH;
        *(UBOOL*)Result=this->GetProfileSettingDefaultFloat(ProfileSettingId,DefaultFloat);
    }
    DECLARE_FUNCTION(execAppendVersionToReadIds)
    {
        P_FINISH;
        this->AppendVersionToReadIds();
    }
    void eventModifyAvailableProfileSettings()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ModifyAvailableProfileSettings),NULL);
    }
    DECLARE_CLASS(UOnlineProfileSettings,UOnlinePlayerStorage,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineProfileSettings)
};

class UOnlineStats : public UObject
{
public:
    //## BEGIN PROPS OnlineStats
    TArrayNoInit<struct FStringIdToStringMapping> ViewIdMappings;
    //## END PROPS OnlineStats

    virtual UBOOL GetViewId(FName ViewName,INT& ViewId);
    virtual FName GetViewName(INT ViewId);
    DECLARE_FUNCTION(execGetViewId)
    {
        P_GET_NAME(ViewName);
        P_GET_INT_REF(ViewId);
        P_FINISH;
        *(UBOOL*)Result=this->GetViewId(ViewName,ViewId);
    }
    DECLARE_FUNCTION(execGetViewName)
    {
        P_GET_INT(ViewId);
        P_FINISH;
        *(FName*)Result=this->GetViewName(ViewId);
    }
    DECLARE_ABSTRACT_CLASS(UOnlineStats,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineStats)
};

struct FOnlineStatsColumn
{
    INT ColumnNo;
    struct FSettingsData StatValue;

    /** Constructors */
    FOnlineStatsColumn() {}
    FOnlineStatsColumn(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineStatsColumn));
    }
};

struct FOnlineStatsRow
{
    struct FUniqueNetId PlayerID;
    struct FSettingsData Rank;
    FStringNoInit NickName;
    TArrayNoInit<struct FOnlineStatsColumn> Columns;

    /** Constructors */
    FOnlineStatsRow() {}
    FOnlineStatsRow(EEventParm)
    {
        appMemzero(this, sizeof(FOnlineStatsRow));
    }
};

struct FColumnMetaData
{
    INT Id;
    FName Name;
    FStringNoInit ColumnName;

    /** Constructors */
    FColumnMetaData() {}
    FColumnMetaData(EEventParm)
    {
        appMemzero(this, sizeof(FColumnMetaData));
    }
};

struct OnlineStatsRead_eventOnReadComplete_Parms
{
    OnlineStatsRead_eventOnReadComplete_Parms(EEventParm)
    {
    }
};
class UOnlineStatsRead : public UOnlineStats
{
public:
    //## BEGIN PROPS OnlineStatsRead
    INT ViewId;
    INT SortColumnId;
    TArrayNoInit<INT> ColumnIds;
    INT TotalRowsInView;
    TArrayNoInit<struct FOnlineStatsRow> Rows;
    TArrayNoInit<struct FColumnMetaData> ColumnMappings;
    FStringNoInit ViewName;
    INT TitleId;
    //## END PROPS OnlineStatsRead

    virtual UBOOL GetIntStatValueForPlayer(struct FUniqueNetId PlayerID,INT StatColumnNo,INT& StatValue);
    virtual UBOOL SetIntStatValueForPlayer(struct FUniqueNetId PlayerID,INT StatColumnNo,INT StatValue);
    virtual UBOOL GetFloatStatValueForPlayer(struct FUniqueNetId PlayerID,INT StatColumnNo,FLOAT& StatValue);
    virtual UBOOL SetFloatStatValueForPlayer(struct FUniqueNetId PlayerID,INT StatColumnNo,FLOAT StatValue);
    virtual UBOOL GetStatValueForPlayerAsString(struct FUniqueNetId PlayerID,INT StatColumnNo,FString& StatValue);
    virtual UBOOL IsStatZero(struct FUniqueNetId PlayerID,INT StatColumnNo);
    virtual void AddPlayer(const FString& PlayerName,struct FUniqueNetId PlayerID);
    virtual INT GetRankForPlayer(struct FUniqueNetId PlayerID);
    DECLARE_FUNCTION(execGetIntStatValueForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_GET_INT_REF(StatValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetIntStatValueForPlayer(PlayerID,StatColumnNo,StatValue);
    }
    DECLARE_FUNCTION(execSetIntStatValueForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_GET_INT(StatValue);
        P_FINISH;
        *(UBOOL*)Result=this->SetIntStatValueForPlayer(PlayerID,StatColumnNo,StatValue);
    }
    DECLARE_FUNCTION(execGetFloatStatValueForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_GET_FLOAT_REF(StatValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetFloatStatValueForPlayer(PlayerID,StatColumnNo,StatValue);
    }
    DECLARE_FUNCTION(execSetFloatStatValueForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_GET_FLOAT(StatValue);
        P_FINISH;
        *(UBOOL*)Result=this->SetFloatStatValueForPlayer(PlayerID,StatColumnNo,StatValue);
    }
    DECLARE_FUNCTION(execGetStatValueForPlayerAsString)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_GET_STR_REF(StatValue);
        P_FINISH;
        *(UBOOL*)Result=this->GetStatValueForPlayerAsString(PlayerID,StatColumnNo,StatValue);
    }
    DECLARE_FUNCTION(execIsStatZero)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_GET_INT(StatColumnNo);
        P_FINISH;
        *(UBOOL*)Result=this->IsStatZero(PlayerID,StatColumnNo);
    }
    DECLARE_FUNCTION(execAddPlayer)
    {
        P_GET_STR(PlayerName);
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_FINISH;
        this->AddPlayer(PlayerName,PlayerID);
    }
    DECLARE_FUNCTION(execGetRankForPlayer)
    {
        P_GET_STRUCT(struct FUniqueNetId,PlayerID);
        P_FINISH;
        *(INT*)Result=this->GetRankForPlayer(PlayerID);
    }
    void eventOnReadComplete()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnReadComplete),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UOnlineStatsRead,UOnlineStats,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineStatsRead)
};

struct OnlineStatsWrite_eventOnStatsWriteComplete_Parms
{
    OnlineStatsWrite_eventOnStatsWriteComplete_Parms(EEventParm)
    {
    }
};
class UOnlineStatsWrite : public UOnlineStats
{
public:
    //## BEGIN PROPS OnlineStatsWrite
    TArrayNoInit<struct FStringIdToStringMapping> StatMappings;
    TArrayNoInit<struct FSettingsProperty> Properties;
    TArrayNoInit<INT> ViewIds;
    TArrayNoInit<INT> ArbitratedViewIds;
    INT RatingId;
    FScriptDelegate __OnStatsWriteComplete__Delegate;
    //## END PROPS OnlineStatsWrite

    virtual UBOOL GetStatId(FName StatName,INT& StatId);
    virtual FName GetStatName(INT StatId);
    virtual void SetFloatStat(INT StatId,FLOAT Value);
    virtual void SetIntStat(INT StatId,INT Value);
    virtual void IncrementFloatStat(INT StatId,FLOAT IncBy=1.000000);
    virtual void IncrementIntStat(INT StatId,INT IncBy=1);
    virtual void DecrementFloatStat(INT StatId,FLOAT DecBy=1.000000);
    virtual void DecrementIntStat(INT StatId,INT DecBy=1);
    DECLARE_FUNCTION(execGetStatId)
    {
        P_GET_NAME(StatName);
        P_GET_INT_REF(StatId);
        P_FINISH;
        *(UBOOL*)Result=this->GetStatId(StatName,StatId);
    }
    DECLARE_FUNCTION(execGetStatName)
    {
        P_GET_INT(StatId);
        P_FINISH;
        *(FName*)Result=this->GetStatName(StatId);
    }
    DECLARE_FUNCTION(execSetFloatStat)
    {
        P_GET_INT(StatId);
        P_GET_FLOAT(Value);
        P_FINISH;
        this->SetFloatStat(StatId,Value);
    }
    DECLARE_FUNCTION(execSetIntStat)
    {
        P_GET_INT(StatId);
        P_GET_INT(Value);
        P_FINISH;
        this->SetIntStat(StatId,Value);
    }
    DECLARE_FUNCTION(execIncrementFloatStat)
    {
        P_GET_INT(StatId);
        P_GET_FLOAT_OPTX(IncBy,1.000000);
        P_FINISH;
        this->IncrementFloatStat(StatId,IncBy);
    }
    DECLARE_FUNCTION(execIncrementIntStat)
    {
        P_GET_INT(StatId);
        P_GET_INT_OPTX(IncBy,1);
        P_FINISH;
        this->IncrementIntStat(StatId,IncBy);
    }
    DECLARE_FUNCTION(execDecrementFloatStat)
    {
        P_GET_INT(StatId);
        P_GET_FLOAT_OPTX(DecBy,1.000000);
        P_FINISH;
        this->DecrementFloatStat(StatId,DecBy);
    }
    DECLARE_FUNCTION(execDecrementIntStat)
    {
        P_GET_INT(StatId);
        P_GET_INT_OPTX(DecBy,1);
        P_FINISH;
        this->DecrementIntStat(StatId,DecBy);
    }
    void delegateOnStatsWriteComplete()
    {
        ProcessDelegate(ENGINE_OnStatsWriteComplete,&__OnStatsWriteComplete__Delegate,NULL);
    }
    DECLARE_ABSTRACT_CLASS(UOnlineStatsWrite,UOnlineStats,0,Engine)
	/**
	 * Finds the specified stat in the property list
	 *
	 * @param StatId the stat to search for
	 *
	 * @return pointer to the stat or NULL if not found
	 */
	FORCEINLINE FSettingsData* FindStat(INT StatId)
	{
		// Search for the individual stat
		for (INT PropertyIndex = 0; PropertyIndex < Properties.Num(); ++PropertyIndex)
		{
			FSettingsProperty& Stat = Properties(PropertyIndex);
			if (Stat.PropertyId == StatId)
			{
				return &Stat.Data;
			}
		}
		return NULL;
	}
};

class UPlayer : public UObject, public FExec
{
public:
    //## BEGIN PROPS Player
    class APlayerController* Actor;
    INT CurrentNetSpeed;
    INT ConfiguredInternetSpeed;
    INT ConfiguredLanSpeed;
    FLOAT PP_DesaturationMultiplier;
    FLOAT PP_HighlightsMultiplier;
    FLOAT PP_MidTonesMultiplier;
    FLOAT PP_ShadowsMultiplier;
    //## END PROPS Player

    virtual void SwitchController(class APlayerController* PC);
    DECLARE_FUNCTION(execSwitchController)
    {
        P_GET_OBJECT(APlayerController,PC);
        P_FINISH;
        this->SwitchController(PC);
    }
    DECLARE_CLASS(UPlayer,UObject,0|CLASS_Transient|CLASS_Config,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	// FExec interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);
};

struct FCurrentPostProcessVolumeInfo
{
    struct FPostProcessSettings LastSettings;
    class APostProcessVolume* LastVolumeUsed;
    FLOAT BlendStartTime;
    FLOAT LastBlendTime;

    /** Constructors */
    FCurrentPostProcessVolumeInfo() {}
    FCurrentPostProcessVolumeInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCurrentPostProcessVolumeInfo));
    }
};

struct FPostProcessSettingsOverride
{
    struct FPostProcessSettings Settings;
    BITFIELD bBlendingIn:1;
    BITFIELD bBlendingOut:1;
    FLOAT CurrentBlendInTime;
    FLOAT CurrentBlendOutTime;
    FLOAT BlendInDuration;
    FLOAT BlendOutDuration;
    FLOAT BlendStartTime;
    FInterpCurveFloat TimeAlphaCurve;

    /** Constructors */
    FPostProcessSettingsOverride() {}
    FPostProcessSettingsOverride(EEventParm)
    {
        appMemzero(this, sizeof(FPostProcessSettingsOverride));
    }
};

struct LocalPlayer_eventExit_Parms
{
    LocalPlayer_eventExit_Parms(EEventParm)
    {
    }
};
struct LocalPlayer_eventNotifyServerConnectionClose_Parms
{
    LocalPlayer_eventNotifyServerConnectionClose_Parms(EEventParm)
    {
    }
};
struct LocalPlayer_eventViewportClosed_Parms
{
    LocalPlayer_eventViewportClosed_Parms(EEventParm)
    {
    }
};
struct LocalPlayer_eventServerAuthTimedOut_Parms
{
    LocalPlayer_eventServerAuthTimedOut_Parms(EEventParm)
    {
    }
};
struct LocalPlayer_eventNotifyServerConnectionOpen_Parms
{
    LocalPlayer_eventNotifyServerConnectionOpen_Parms(EEventParm)
    {
    }
};
struct LocalPlayer_eventGetNickname_Parms
{
    FString ReturnValue;
    LocalPlayer_eventGetNickname_Parms(EEventParm)
    {
    }
};
struct LocalPlayer_eventGetUniqueNetId_Parms
{
    struct FUniqueNetId ReturnValue;
    LocalPlayer_eventGetUniqueNetId_Parms(EEventParm)
    {
    }
};
class ULocalPlayer : public UPlayer, public FObserverInterface
{
public:
    //## BEGIN PROPS LocalPlayer
    INT ControllerId;
    class UGameViewportClient* ViewportClient;
    FVector2D Origin;
    FVector2D Size;
    class UPostProcessChain* PlayerPostProcess;
    TArrayNoInit<class UPostProcessChain*> PlayerPostProcessChains;
    BITFIELD bForceDefaultPostProcessChain:1;
    BITFIELD bWantToResetToMapDefaultPP:1;
    BITFIELD bSentSplitJoin:1;
    BITFIELD bPendingServerAuth:1;
    SCRIPT_ALIGN;
    FSceneViewStateInterface* ViewState;
    FSceneViewStateInterface* ViewState2;
    FSynchronizedActorVisibilityHistory ActorVisibilityHistory;
    FVector LastViewLocation;
    struct FCurrentPostProcessVolumeInfo CurrentPPInfo;
    struct FCurrentPostProcessVolumeInfo LevelPPInfo;
    TArrayNoInit<struct FPostProcessSettingsOverride> ActivePPOverrides;
    BYTE AspectRatioAxisConstraint;
    FStringNoInit LastMap;
    class UTranslationContext* TagContext;
    TScriptInterface<class IOnlineAuthInterface> CachedAuthInt;
    FLOAT ServerAuthTimestamp;
    INT ServerAuthTimeout;
    INT ServerAuthRetryCount;
    INT MaxServerAuthRetryCount;
    struct FUniqueNetId ServerAuthUID;
    //## END PROPS LocalPlayer

    UBOOL SpawnPlayActor(const FString& URL,FString& OutError);
    void SendSplitJoin();
    UBOOL GetActorVisibility(class AActor* TestActor) const;
    virtual void OverridePostProcessSettings(struct FPostProcessSettings OverrideSettings,FLOAT BlendInTime=0);
    virtual void OverridePostProcessSettingsCurve(struct FPostProcessSettings OverrideSettings,const FInterpCurveFloat& Curve);
    virtual void ClearPostProcessSettingsOverride(FLOAT BlendOutTime=0);
    class UTranslationContext* GetTranslationContext();
    virtual UBOOL InsertPostProcessingChain(class UPostProcessChain* InChain,INT InIndex,UBOOL bInClone);
    virtual UBOOL RemovePostProcessingChain(INT InIndex);
    virtual UBOOL RemoveAllPostProcessingChains();
    virtual class UPostProcessChain* GetPostProcessChain(INT InIndex);
    virtual void TouchPlayerPostProcessChain();
    void DeProject(FVector2D RelativeScreenPos,FVector& WorldOrigin,FVector& WorldDirection);
    FVector2D Project(FVector WorldLoc);
    void FastDeProject(FVector2D RelativeScreenPos,FVector& WorldOrigin,FVector& WorldDirection);
    FVector2D FastProject(FVector WorldLoc);
    DECLARE_FUNCTION(execSpawnPlayActor)
    {
        P_GET_STR(URL);
        P_GET_STR_REF(OutError);
        P_FINISH;
        *(UBOOL*)Result=this->SpawnPlayActor(URL,OutError);
    }
    DECLARE_FUNCTION(execSendSplitJoin)
    {
        P_FINISH;
        this->SendSplitJoin();
    }
    DECLARE_FUNCTION(execGetActorVisibility)
    {
        P_GET_OBJECT(AActor,TestActor);
        P_FINISH;
        *(UBOOL*)Result=this->GetActorVisibility(TestActor);
    }
    DECLARE_FUNCTION(execOverridePostProcessSettings)
    {
        P_GET_STRUCT_INIT(struct FPostProcessSettings,OverrideSettings);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_FINISH;
        this->OverridePostProcessSettings(OverrideSettings,BlendInTime);
    }
    DECLARE_FUNCTION(execOverridePostProcessSettingsCurve)
    {
        P_GET_STRUCT_INIT(struct FPostProcessSettings,OverrideSettings);
        P_GET_STRUCT_INIT_REF(FInterpCurveFloat,Curve);
        P_FINISH;
        this->OverridePostProcessSettingsCurve(OverrideSettings,Curve);
    }
    DECLARE_FUNCTION(execClearPostProcessSettingsOverride)
    {
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_FINISH;
        this->ClearPostProcessSettingsOverride(BlendOutTime);
    }
    DECLARE_FUNCTION(execGetTranslationContext)
    {
        P_FINISH;
        *(class UTranslationContext**)Result=this->GetTranslationContext();
    }
    DECLARE_FUNCTION(execInsertPostProcessingChain)
    {
        P_GET_OBJECT(UPostProcessChain,InChain);
        P_GET_INT(InIndex);
        P_GET_UBOOL(bInClone);
        P_FINISH;
        *(UBOOL*)Result=this->InsertPostProcessingChain(InChain,InIndex,bInClone);
    }
    DECLARE_FUNCTION(execRemovePostProcessingChain)
    {
        P_GET_INT(InIndex);
        P_FINISH;
        *(UBOOL*)Result=this->RemovePostProcessingChain(InIndex);
    }
    DECLARE_FUNCTION(execRemoveAllPostProcessingChains)
    {
        P_FINISH;
        *(UBOOL*)Result=this->RemoveAllPostProcessingChains();
    }
    DECLARE_FUNCTION(execGetPostProcessChain)
    {
        P_GET_INT(InIndex);
        P_FINISH;
        *(class UPostProcessChain**)Result=this->GetPostProcessChain(InIndex);
    }
    DECLARE_FUNCTION(execTouchPlayerPostProcessChain)
    {
        P_FINISH;
        this->TouchPlayerPostProcessChain();
    }
    DECLARE_FUNCTION(execDeProject)
    {
        P_GET_STRUCT(FVector2D,RelativeScreenPos);
        P_GET_STRUCT_REF(FVector,WorldOrigin);
        P_GET_STRUCT_REF(FVector,WorldDirection);
        P_FINISH;
        this->DeProject(RelativeScreenPos,WorldOrigin,WorldDirection);
    }
    DECLARE_FUNCTION(execProject)
    {
        P_GET_STRUCT(FVector,WorldLoc);
        P_FINISH;
        *(FVector2D*)Result=this->Project(WorldLoc);
    }
    DECLARE_FUNCTION(execFastDeProject)
    {
        P_GET_STRUCT(FVector2D,RelativeScreenPos);
        P_GET_STRUCT_REF(FVector,WorldOrigin);
        P_GET_STRUCT_REF(FVector,WorldDirection);
        P_FINISH;
        this->FastDeProject(RelativeScreenPos,WorldOrigin,WorldDirection);
    }
    DECLARE_FUNCTION(execFastProject)
    {
        P_GET_STRUCT(FVector,WorldLoc);
        P_FINISH;
        *(FVector2D*)Result=this->FastProject(WorldLoc);
    }
    void eventExit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Exit),NULL);
    }
    void eventNotifyServerConnectionClose()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyServerConnectionClose),NULL);
    }
    void eventViewportClosed()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ViewportClosed),NULL);
    }
    void eventServerAuthTimedOut()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ServerAuthTimedOut),NULL);
    }
    void eventNotifyServerConnectionOpen()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyServerConnectionOpen),NULL);
    }
    FString eventGetNickname()
    {
        LocalPlayer_eventGetNickname_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetNickname),&Parms);
        return Parms.ReturnValue;
    }
    struct FUniqueNetId eventGetUniqueNetId()
    {
        LocalPlayer_eventGetUniqueNetId_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetUniqueNetId),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(ULocalPlayer,UPlayer,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UEngine)
	/** Is object propagation currently overriding our view? */
	static UBOOL bOverrideView;
	static FVector OverrideLocation;
	static FRotator OverrideRotation;

	// Constructor.
	ULocalPlayer();

	/**
	 * Tick tasks required for auth code
	 *
	 * @param DeltaTime	The time passed since the last tick
	 */
	virtual void Tick(FLOAT DeltaTime);

	/**
	 *	Rebuilds the PlayerPostProcessChain.
	 *	This should be called whenever the chain array has items inserted/removed.
	 */
	void RebuildPlayerPostProcessChain();

	/**
	 * Updates the post-process settings for the player's view.
	 * @param ViewLocation - The player's current view location.
	 */
	virtual void UpdatePostProcessSettings(const FVector& ViewLocation);

	/** Update a specific CurrentPostProcessVolumeInfo with the settings and volume specified
	 *
	 *	@param PPInfo - The CurrentPostProcessVolumeInfo struct to update
	 *	@param NewSettings - The PostProcessSettings to apply to PPInfo
	 *	@param NewVolume - The PostProcessVolume to apply to PPInfo
	 */
	virtual void UpdatePPSetting(FCurrentPostProcessVolumeInfo& PPVolume, FPostProcessSettings& NewSettings, const FLOAT CurrentWorldTime);

#if WITH_REALD
	FSceneView* CalcSceneViewOffs( FSceneViewFamily* ViewFamily, FVector& ViewLocation, FRotator& ViewRotation, FViewport* Viewport, FMatrix* Offset=NULL, FViewElementDrawer* ViewDrawer=NULL );
#endif

	/**
	 * Calculate the view settings for drawing from this view actor
	 *
	 * @param	View - output view struct
	 * @param	ViewLocation - output actor location
	 * @param	ViewRotation - output actor rotation
	 * @param	Viewport - current client viewport
	 * @param	ViewDrawer - optional drawing in the view
	 */
	FSceneView* CalcSceneView( FSceneViewFamily* ViewFamily, FVector& ViewLocation, FRotator& ViewRotation, FViewport* Viewport, FViewElementDrawer* ViewDrawer=NULL );

	// UObject interface.
	virtual void FinishDestroy();

	// FExec interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	void ExecMacro( const TCHAR* Filename, FOutputDevice& Ar );

	// FObserverInterface interface
	virtual FVector		GetObserverViewLocation()
	{
		return LastViewLocation;
	}

};

class UPostProcessChain : public UObject
{
public:
    //## BEGIN PROPS PostProcessChain
    TArrayNoInit<class UPostProcessEffect*> Effects;
    //## END PROPS PostProcessChain

    DECLARE_CLASS(UPostProcessChain,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UPostProcessChain)
};

class UAmbientOcclusionEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS AmbientOcclusionEffect
    FLinearColor OcclusionColor;
    FLOAT OcclusionPower;
    FLOAT OcclusionScale;
    FLOAT OcclusionBias;
    FLOAT MinOcclusion;
    BITFIELD SSAO2_DEPRECATED:1;
    BITFIELD bAngleBasedSSAO:1;
    FLOAT OcclusionRadius;
    FLOAT OcclusionAttenuation_DEPRECATED;
    BYTE OcclusionQuality;
    FLOAT OcclusionFadeoutMinDistance;
    FLOAT OcclusionFadeoutMaxDistance;
    FLOAT HaloDistanceThreshold;
    FLOAT HaloDistanceScale;
    FLOAT HaloOcclusion;
    FLOAT EdgeDistanceThreshold;
    FLOAT EdgeDistanceScale;
    FLOAT FilterDistanceScale;
    INT FilterSize_DEPRECATED;
    FLOAT HistoryConvergenceTime;
    FLOAT HistoryWeightConvergenceTime;
    //## END PROPS AmbientOcclusionEffect

    DECLARE_CLASS(UAmbientOcclusionEffect,UPostProcessEffect,0,Engine)
    // UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class UBlurEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS BlurEffect
    INT BlurKernelSize;
    //## END PROPS BlurEffect

    DECLARE_CLASS(UBlurEffect,UPostProcessEffect,0,Engine)
	// UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;

	// UObject inteface

	/** callback for changed property */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class UDOFAndBloomEffect : public UDOFEffect
{
public:
    //## BEGIN PROPS DOFAndBloomEffect
    FLOAT BloomScale;
    FLOAT BloomThreshold;
    FColor BloomTint;
    FLOAT BloomScreenBlendThreshold;
    FLOAT SceneMultiplier_DEPRECATED;
    FLOAT BlurBloomKernelSize;
    BITFIELD bEnableReferenceDOF_DEPRECATED:1;
    SCRIPT_ALIGN;
    BYTE DepthOfFieldType;
    BYTE DepthOfFieldQuality;
    class UTexture2D* BokehTexture;
    //## END PROPS DOFAndBloomEffect

    DECLARE_CLASS(UDOFAndBloomEffect,UDOFEffect,0,Engine)
	// UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;
	
	// UObject interface

	/**
	* Called after this instance has been serialized.  UberPostProcessEffect should only
	* ever exists in the SDPG_PostProcess scene
	*/
	virtual void PostLoad();

	/**
	* This allows to print a warning when the effect is used.
	*/
	virtual void OnPostProcessWarning(FString& OutWarning) const
	{
		OutWarning = TEXT("Warning: DOFAndBloom should no longer be used, use Uberpostprocess instead.");
	}
};

class UDOFBloomMotionBlurEffect : public UDOFAndBloomEffect
{
public:
    //## BEGIN PROPS DOFBloomMotionBlurEffect
    FLOAT MaxVelocity;
    FLOAT MotionBlurAmount;
    BITFIELD FullMotionBlur:1;
    FLOAT CameraRotationThreshold;
    FLOAT CameraTranslationThreshold;
    //## END PROPS DOFBloomMotionBlurEffect

    DECLARE_CLASS(UDOFBloomMotionBlurEffect,UDOFAndBloomEffect,0,Engine)
    // UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;
	
	/**
	* This allows to print a warning when the effect is used.
	*/
	virtual void OnPostProcessWarning(FString& OutWarning) const
	{
		OutWarning = TEXT("Warning: DOFAndBloomAndMotionBlur should no longer be used, use Uberpostprocess instead.");
	}
};

class UUberPostProcessEffect : public UDOFBloomMotionBlurEffect
{
public:
    //## BEGIN PROPS UberPostProcessEffect
    FVector SceneShadows;
    FVector SceneHighLights;
    FVector SceneMidTones;
    FLOAT SceneDesaturation;
    FVector SceneColorize;
    BYTE TonemapperType;
    BYTE PostProcessAAType;
    FLOAT TonemapperRange;
    FLOAT TonemapperToeFactor;
    FLOAT TonemapperScale;
    FLOAT MotionBlurSoftEdgeKernelSize;
    BITFIELD bEnableImageGrain:1;
    BITFIELD bScaleEffectsWithViewSize:1;
    BITFIELD bEnableHDRTonemapper_DEPRECATED:1;
    FLOAT SceneImageGrainScale;
    FLOAT BloomWeightSmall;
    FLOAT BloomWeightMedium;
    FLOAT BloomWeightLarge;
    FLOAT BloomSizeScaleSmall;
    FLOAT BloomSizeScaleMedium;
    FLOAT BloomSizeScaleLarge;
    FLOAT EdgeDetectionThreshold;
    struct FLUTBlender PreviousLUTBlender;
    FLOAT SceneHDRTonemapperScale_DEPRECATED;
    //## END PROPS UberPostProcessEffect

    DECLARE_CLASS(UUberPostProcessEffect,UDOFBloomMotionBlurEffect,0,Engine)
	// UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	// UObject interface

	/**
	* Called after this instance has been serialized.  UberPostProcessEffect should only
	* ever exists in the SDPG_PostProcess scene
	*/
	virtual void PostLoad();
	
	/**
	 * Called when properties change.  UberPostProcessEffect should only
	 * ever exists in the SDPG_PostProcess scene
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	* Tells the SceneRenderer is this effect includes the uber post process.
	*/
	virtual UBOOL IncludesUberpostprocess() const
	{
		return TRUE;
	}

	/**
	* This allows to print a warning when the effect is used.
	*/
	virtual void OnPostProcessWarning(FString& OutWarning) const
	{
		// we don't want to output any warning but derive from a effect that might do that.
	}
};

class UMaterialEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS MaterialEffect
    class UMaterialInterface* Material;
    //## END PROPS MaterialEffect

    DECLARE_CLASS(UMaterialEffect,UPostProcessEffect,0,Engine)
    // UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);
};

class UMotionBlurEffect : public UPostProcessEffect
{
public:
    //## BEGIN PROPS MotionBlurEffect
    FLOAT MaxVelocity;
    FLOAT MotionBlurAmount;
    BITFIELD FullMotionBlur:1;
    FLOAT CameraRotationThreshold;
    FLOAT CameraTranslationThreshold;
    //## END PROPS MotionBlurEffect

    DECLARE_CLASS(UMotionBlurEffect,UPostProcessEffect,0,Engine)
    // UPostProcessEffect interface

	/**
	 * Creates a proxy to represent the render info for a post process effect
	 * @param WorldSettings - The world's post process settings for the view.
	 * @return The proxy object.
	 */
	virtual class FPostProcessSceneProxy* CreateSceneProxy(const FPostProcessSettings* WorldSettings);

	/**
	 * @param View - current view
	 * @return TRUE if the effect should be rendered
	 */
	virtual UBOOL IsShown(const FSceneView* View) const;

	/**
	* @return TRUE if the effect requires the uber post process
	*/
	virtual UBOOL RequiresUberpostprocess() const 
	{ 
		return TRUE; 
	}

	/**
	* This allows to print a warning when the effect is used.
	*/
	virtual void OnPostProcessWarning(FString& OutWarning) const
	{
		OutWarning = TEXT("Warning: MotionBlur should no longer be used, use Uberpostprocess instead.");
	}
};

class UPrimitiveComponentFactory : public UObject
{
public:
    //## BEGIN PROPS PrimitiveComponentFactory
    BITFIELD CollideActors:1;
    BITFIELD BlockActors:1;
    BITFIELD BlockZeroExtent:1;
    BITFIELD BlockNonZeroExtent:1;
    BITFIELD BlockRigidBody:1;
    BITFIELD HiddenGame:1;
    BITFIELD HiddenEditor:1;
    BITFIELD CastShadow:1;
    SCRIPT_ALIGN;
    //## END PROPS PrimitiveComponentFactory

    DECLARE_ABSTRACT_CLASS(UPrimitiveComponentFactory,UObject,0,Engine)
	virtual UBOOL FactoryIsValid() { return 1; }
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter) { return NULL; }
};

class UMeshComponentFactory : public UPrimitiveComponentFactory
{
public:
    //## BEGIN PROPS MeshComponentFactory
    TArrayNoInit<class UMaterialInterface*> Materials;
    //## END PROPS MeshComponentFactory

    DECLARE_ABSTRACT_CLASS(UMeshComponentFactory,UPrimitiveComponentFactory,0,Engine)
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter) { return NULL; }
};

class UStaticMeshComponentFactory : public UMeshComponentFactory
{
public:
    //## BEGIN PROPS StaticMeshComponentFactory
    class UStaticMesh* StaticMesh;
    //## END PROPS StaticMeshComponentFactory

    DECLARE_CLASS(UStaticMeshComponentFactory,UMeshComponentFactory,0,Engine)
	virtual UBOOL FactoryIsValid() { return StaticMesh != NULL && Super::FactoryIsValid(); }
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter);
};

class UAdvancedReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS AdvancedReachSpec
    //## END PROPS AdvancedReachSpec

    DECLARE_CLASS(UAdvancedReachSpec,UReachSpec,0,Engine)
	virtual FPlane PathColor()
	{
		// purple path = advanced
		return FPlane(1.f,0.f,1.f, 0.f);
	}
	virtual INT CostFor(APawn* P);
};

class UCeilingReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS CeilingReachSpec
    //## END PROPS CeilingReachSpec

    DECLARE_CLASS(UCeilingReachSpec,UReachSpec,0,Engine)
	virtual INT CostFor( APawn* P );
	virtual INT AdjustedCostFor( APawn* P, const FVector& StartToGoalDir, ANavigationPoint* Goal, INT Cost );
};

class UForcedReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS ForcedReachSpec
    //## END PROPS ForcedReachSpec

    DECLARE_CLASS(UForcedReachSpec,UReachSpec,0,Engine)
	virtual FPlane PathColor()
	{
		// yellow for forced paths
		return FPlane(1.f, 1.f, 0.f, 0.f);
	}

	virtual UBOOL IsForced() { return true; }
	virtual UBOOL PrepareForMove( AController * C );
	virtual INT CostFor(APawn* P);
};

class UCoverSlipReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS CoverSlipReachSpec
    MS_ALIGN(4) BYTE SpecDirection GCC_ALIGN(4); // Extra alignment flags needed because all properties are bytes
    SCRIPT_ALIGN;
    //## END PROPS CoverSlipReachSpec

    DECLARE_CLASS(UCoverSlipReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
	virtual FVector GetForcedPathSize( class ANavigationPoint* Start, class ANavigationPoint* End, class AScout* Scout );
};

class UFloorToCeilingReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS FloorToCeilingReachSpec
    //## END PROPS FloorToCeilingReachSpec

    DECLARE_CLASS(UFloorToCeilingReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
	virtual INT AdjustedCostFor( APawn* P, const FVector& StartToGoalDir, ANavigationPoint* Goal, INT Cost );
};

class UMantleReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS MantleReachSpec
    BITFIELD bClimbUp:1;
    SCRIPT_ALIGN;
    //## END PROPS MantleReachSpec

    DECLARE_CLASS(UMantleReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
	virtual FVector GetForcedPathSize( class ANavigationPoint* Start, class ANavigationPoint* End, AScout* Scout );
	void ReInitialize();
	virtual UBOOL CanBeSkipped( APawn* P );
};

class USlotToSlotReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS SlotToSlotReachSpec
    MS_ALIGN(4) BYTE SpecDirection GCC_ALIGN(4); // Extra alignment flags needed because all properties are bytes
    SCRIPT_ALIGN;
    //## END PROPS SlotToSlotReachSpec

    DECLARE_CLASS(USlotToSlotReachSpec,UForcedReachSpec,0,Engine)
	virtual INT defineFor( class ANavigationPoint *begin, class ANavigationPoint * dest, class APawn * Scout );
	virtual INT CostFor(APawn* P);
	virtual UBOOL CanBeSkipped( APawn* P );
	virtual UBOOL PrepareForMove(AController * C);
};

class USwatTurnReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS SwatTurnReachSpec
    MS_ALIGN(4) BYTE SpecDirection GCC_ALIGN(4); // Extra alignment flags needed because all properties are bytes
    SCRIPT_ALIGN;
    //## END PROPS SwatTurnReachSpec

    DECLARE_CLASS(USwatTurnReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
	virtual INT defineFor( class ANavigationPoint *begin, class ANavigationPoint * dest, class APawn * Scout );
	virtual FVector GetForcedPathSize( class ANavigationPoint* Start, class ANavigationPoint* End, class AScout* Scout );
};

class UWallTransReachSpec : public UForcedReachSpec
{
public:
    //## BEGIN PROPS WallTransReachSpec
    //## END PROPS WallTransReachSpec

    DECLARE_CLASS(UWallTransReachSpec,UForcedReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
};

class ULadderReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS LadderReachSpec
    //## END PROPS LadderReachSpec

    DECLARE_CLASS(ULadderReachSpec,UReachSpec,0,Engine)
	virtual FPlane PathColor()
	{
		// light purple = ladder
		return FPlane(1.f,0.5f, 1.f,0.f);
	}
	virtual INT CostFor(APawn* P);
};

class UProscribedReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS ProscribedReachSpec
    //## END PROPS ProscribedReachSpec

    DECLARE_CLASS(UProscribedReachSpec,UReachSpec,0,Engine)
	virtual FPlane PathColor()
	{
		// red is reserved for proscribed paths
		return FPlane(1.f, 0.f, 0.f, 0.f);
	}

	virtual UBOOL IsProscribed() const { return TRUE; }
	virtual INT CostFor(APawn* P);
};

class UTeleportReachSpec : public UReachSpec
{
public:
    //## BEGIN PROPS TeleportReachSpec
    //## END PROPS TeleportReachSpec

    DECLARE_CLASS(UTeleportReachSpec,UReachSpec,0,Engine)
	virtual INT CostFor(APawn* P);
};

class USavedMove : public UObject
{
public:
    //## BEGIN PROPS SavedMove
    class USavedMove* NextMove;
    FLOAT TimeStamp;
    FLOAT Delta;
    BITFIELD bRun:1;
    BITFIELD bDuck:1;
    BITFIELD bPressedJump:1;
    BITFIELD bDoubleJump:1;
    BITFIELD bPreciseDestination:1;
    BITFIELD bForceRMVelocity:1;
    BITFIELD bForceMaxAccel:1;
    BITFIELD bRootMotionFromInterpCurve:1;
    SCRIPT_ALIGN;
    BYTE DoubleClickMove;
    BYTE SavedPhysics;
    BYTE RootMotionMode;
    SCRIPT_ALIGN;
    FVector StartLocation;
    FVector StartRelativeLocation;
    FVector StartVelocity;
    FVector StartFloor;
    FVector SavedLocation;
    FVector SavedVelocity;
    FVector SavedRelativeLocation;
    FVector RMVelocity;
    FVector Acceleration;
    FRotator Rotation;
    class AActor* StartBase;
    class AActor* EndBase;
    FLOAT CustomTimeDilation;
    FLOAT AccelDotThreshold;
    FLOAT RootMotionInterpCurrentTime;
    FVector RootMotionInterpCurveLastValue;
    //## END PROPS SavedMove

    DECLARE_CLASS(USavedMove,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(USavedMove)
};

class UDEPRECATED_SaveGameSummary : public UObject
{
public:
    //## BEGIN PROPS SaveGameSummary
    FName BaseLevel;
    FStringNoInit Description;
    //## END PROPS SaveGameSummary

    DECLARE_CLASS(UDEPRECATED_SaveGameSummary,UObject,0|CLASS_Deprecated,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDEPRECATED_SaveGameSummary)
};

class UScriptViewportClient : public UObject, public FViewportClient
{
public:
    //## BEGIN PROPS ScriptViewportClient
    //## END PROPS ScriptViewportClient

    DECLARE_CLASS(UScriptViewportClient,UObject,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UScriptViewportClient)
};

struct FShowFlags_Mirror
{
    QWORD flags0;
    QWORD flags1;

    /** Constructors */
    FShowFlags_Mirror() {}
    FShowFlags_Mirror(EEventParm)
    {
        appMemzero(this, sizeof(FShowFlags_Mirror));
    }
};

struct FTitleSafeZoneArea
{
    FLOAT MaxPercentX;
    FLOAT MaxPercentY;
    FLOAT RecommendedPercentX;
    FLOAT RecommendedPercentY;

    /** Constructors */
    FTitleSafeZoneArea() {}
    FTitleSafeZoneArea(EEventParm)
    {
        appMemzero(this, sizeof(FTitleSafeZoneArea));
    }
};

struct FPerPlayerSplitscreenData
{
    FLOAT SizeX;
    FLOAT SizeY;
    FLOAT OriginX;
    FLOAT OriginY;

    /** Constructors */
    FPerPlayerSplitscreenData() {}
    FPerPlayerSplitscreenData(EEventParm)
    {
        appMemzero(this, sizeof(FPerPlayerSplitscreenData));
    }
};

struct FSplitscreenData
{
    TArrayNoInit<struct FPerPlayerSplitscreenData> PlayerData;

    /** Constructors */
    FSplitscreenData() {}
    FSplitscreenData(EEventParm)
    {
        appMemzero(this, sizeof(FSplitscreenData));
    }
};

struct FDebugDisplayProperty
{
    class UObject* Obj;
    FName PropertyName;
    BITFIELD bSpecialProperty:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FDebugDisplayProperty() {}
    FDebugDisplayProperty(EEventParm)
    {
        appMemzero(this, sizeof(FDebugDisplayProperty));
    }
};

struct GameViewportClient_eventSetHardwareMouseCursorVisibility_Parms
{
    UBOOL bIsVisible;
    GameViewportClient_eventSetHardwareMouseCursorVisibility_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventSetProgressTime_Parms
{
    FLOAT T;
    GameViewportClient_eventSetProgressTime_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventSetProgressMessage_Parms
{
    BYTE MessageType;
    FString Message;
    FString Title;
    UBOOL bIgnoreFutureNetworkMessages;
    GameViewportClient_eventSetProgressMessage_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventPostRender_Parms
{
    class UCanvas* Canvas;
    GameViewportClient_eventPostRender_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventTick_Parms
{
    FLOAT DeltaTime;
    GameViewportClient_eventTick_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventGetSubtitleRegion_Parms
{
    FVector2D MinPos;
    FVector2D MaxPos;
    GameViewportClient_eventGetSubtitleRegion_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventLayoutPlayers_Parms
{
    GameViewportClient_eventLayoutPlayers_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventGameSessionEnded_Parms
{
    GameViewportClient_eventGameSessionEnded_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventInsertInteraction_Parms
{
    class UInteraction* NewInteraction;
    INT InIndex;
    INT ReturnValue;
    GameViewportClient_eventInsertInteraction_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventInit_Parms
{
    FString OutError;
    UBOOL ReturnValue;
    GameViewportClient_eventInit_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventFindPlayerByControllerId_Parms
{
    INT ControllerId;
    class ULocalPlayer* ReturnValue;
    GameViewportClient_eventFindPlayerByControllerId_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventRemovePlayer_Parms
{
    class ULocalPlayer* ExPlayer;
    UBOOL ReturnValue;
    GameViewportClient_eventRemovePlayer_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventCreatePlayer_Parms
{
    INT ControllerId;
    FString OutError;
    UBOOL bSpawnActor;
    class ULocalPlayer* ReturnValue;
    GameViewportClient_eventCreatePlayer_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventHandleInputChar_Parms
{
    INT ControllerId;
    FString Unicode;
    UBOOL ReturnValue;
    GameViewportClient_eventHandleInputChar_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventHandleInputAxis_Parms
{
    INT ControllerId;
    FName Key;
    FLOAT Delta;
    FLOAT DeltaTime;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    GameViewportClient_eventHandleInputAxis_Parms(EEventParm)
    {
    }
};
struct GameViewportClient_eventHandleInputKey_Parms
{
    INT ControllerId;
    FName Key;
    BYTE EventType;
    FLOAT AmountDepressed;
    UBOOL bGamepad;
    UBOOL ReturnValue;
    GameViewportClient_eventHandleInputKey_Parms(EEventParm)
    {
    }
};
class UGameViewportClient : public UScriptViewportClient, public FExec
{
public:
    //## BEGIN PROPS GameViewportClient
    FViewport* Viewport;
    FViewportFrame* ViewportFrame;
    TArray<class UInteraction*> GlobalInteractions;
    class UClass* UIControllerClass;
    class UUIInteraction* UIController;
    class UConsole* ViewportConsole;
    EShowFlags ShowFlags;
    FStringNoInit LoadingMessage;
    FStringNoInit SavingMessage;
    FStringNoInit ConnectingMessage;
    FStringNoInit PausedMessage;
    FStringNoInit PrecachingMessage;
    BITFIELD bShowTitleSafeZone:1;
    BITFIELD bDisplayHardwareMouseCursor:1;
    BITFIELD bOverrideDiffuseAndSpecular:1;
    BITFIELD bIsPlayInEditorViewport:1;
    BITFIELD bShowSystemMouseCursor:1;
    BITFIELD bDisableWorldRendering:1;
    BITFIELD bCapturedWorldRendering:1;
    BITFIELD bDebugNoGFxUI:1;
    SCRIPT_ALIGN;
    struct FTitleSafeZoneArea TitleSafeZone;
    TArrayNoInit<struct FSplitscreenData> SplitscreenInfo;
protected:
    BYTE DesiredSplitscreenType;
    BYTE ActiveSplitscreenType;
public:
    BYTE Default2PSplitType;
    BYTE Default3PSplitType;
    FStringNoInit ProgressMessage[2];
    FLOAT ProgressTimeOut;
    FLOAT ProgressFadeTime;
    TArrayNoInit<struct FDebugDisplayProperty> DebugProperties;
    UGFxInteraction* ScaleformInteraction;
    FScriptDelegate __HandleInputKey__Delegate;
    FScriptDelegate __HandleInputAxis__Delegate;
    FScriptDelegate __HandleInputChar__Delegate;
    //## END PROPS GameViewportClient

    virtual FString ConsoleCommand(const FString& Command);
    void GetViewportSize(FVector2D& out_ViewportSize);
    UBOOL IsFullScreenViewport();
    FVector2D GetMousePosition();
    UBOOL ShouldForceFullscreenViewport() const;
    virtual INT GetNumCustomInteractions();
    virtual class UClass* GetCustomInteractionClass(INT InIndex);
    virtual void SetCustomInteractionObject(class UInteraction* InInteraction);
    virtual void NotifySplitscreenLayoutChanged();
    virtual void ForceUpdateMouseCursor(UBOOL bSetCursor);
    virtual void SetMouse(INT X,INT Y);
    class ULocalPlayer* GetPlayerOwner(INT PlayerIndex);
    void FixupOwnerReferences(const TArray<INT>& IDMappings);
    void EnableScaleform();
    void DisableScaleform();
    UBOOL IsScaleformEnabled();
    virtual void DebugSetUISystemEnabled(UBOOL bOldUISystemActive,UBOOL bGFxUISystemActive);
    DECLARE_FUNCTION(execConsoleCommand)
    {
        P_GET_STR(Command);
        P_FINISH;
        *(FString*)Result=this->ConsoleCommand(Command);
    }
    DECLARE_FUNCTION(execGetViewportSize)
    {
        P_GET_STRUCT_REF(FVector2D,out_ViewportSize);
        P_FINISH;
        this->GetViewportSize(out_ViewportSize);
    }
    DECLARE_FUNCTION(execIsFullScreenViewport)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsFullScreenViewport();
    }
    DECLARE_FUNCTION(execGetMousePosition)
    {
        P_FINISH;
        *(FVector2D*)Result=this->GetMousePosition();
    }
    DECLARE_FUNCTION(execShouldForceFullscreenViewport)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ShouldForceFullscreenViewport();
    }
    DECLARE_FUNCTION(execGetNumCustomInteractions)
    {
        P_FINISH;
        *(INT*)Result=this->GetNumCustomInteractions();
    }
    DECLARE_FUNCTION(execGetCustomInteractionClass)
    {
        P_GET_INT(InIndex);
        P_FINISH;
        *(class UClass**)Result=this->GetCustomInteractionClass(InIndex);
    }
    DECLARE_FUNCTION(execSetCustomInteractionObject)
    {
        P_GET_OBJECT(UInteraction,InInteraction);
        P_FINISH;
        this->SetCustomInteractionObject(InInteraction);
    }
    DECLARE_FUNCTION(execNotifySplitscreenLayoutChanged)
    {
        P_FINISH;
        this->NotifySplitscreenLayoutChanged();
    }
    DECLARE_FUNCTION(execForceUpdateMouseCursor)
    {
        P_GET_UBOOL(bSetCursor);
        P_FINISH;
        this->ForceUpdateMouseCursor(bSetCursor);
    }
    DECLARE_FUNCTION(execSetMouse)
    {
        P_GET_INT(X);
        P_GET_INT(Y);
        P_FINISH;
        this->SetMouse(X,Y);
    }
    DECLARE_FUNCTION(execGetPlayerOwner)
    {
        P_GET_INT(PlayerIndex);
        P_FINISH;
        *(class ULocalPlayer**)Result=this->GetPlayerOwner(PlayerIndex);
    }
    DECLARE_FUNCTION(execFixupOwnerReferences)
    {
        P_GET_TARRAY(INT,IDMappings);
        P_FINISH;
        this->FixupOwnerReferences(IDMappings);
    }
    DECLARE_FUNCTION(execEnableScaleform)
    {
        P_FINISH;
        this->EnableScaleform();
    }
    DECLARE_FUNCTION(execDisableScaleform)
    {
        P_FINISH;
        this->DisableScaleform();
    }
    DECLARE_FUNCTION(execIsScaleformEnabled)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsScaleformEnabled();
    }
    DECLARE_FUNCTION(execDebugSetUISystemEnabled)
    {
        P_GET_UBOOL(bOldUISystemActive);
        P_GET_UBOOL(bGFxUISystemActive);
        P_FINISH;
        this->DebugSetUISystemEnabled(bOldUISystemActive,bGFxUISystemActive);
    }
    void eventSetHardwareMouseCursorVisibility(UBOOL bIsVisible)
    {
        GameViewportClient_eventSetHardwareMouseCursorVisibility_Parms Parms(EC_EventParm);
        Parms.bIsVisible=bIsVisible ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetHardwareMouseCursorVisibility),&Parms);
    }
    void eventSetProgressTime(FLOAT T)
    {
        GameViewportClient_eventSetProgressTime_Parms Parms(EC_EventParm);
        Parms.T=T;
        ProcessEvent(FindFunctionChecked(ENGINE_SetProgressTime),&Parms);
    }
    void eventSetProgressMessage(BYTE MessageType,const FString& Message,const FString& Title=TEXT(""),UBOOL bIgnoreFutureNetworkMessages=FALSE)
    {
        GameViewportClient_eventSetProgressMessage_Parms Parms(EC_EventParm);
        Parms.MessageType=MessageType;
        Parms.Message=Message;
        Parms.Title=Title;
        Parms.bIgnoreFutureNetworkMessages=bIgnoreFutureNetworkMessages ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetProgressMessage),&Parms);
    }
    void eventPostRender(class UCanvas* Canvas)
    {
        GameViewportClient_eventPostRender_Parms Parms(EC_EventParm);
        Parms.Canvas=Canvas;
        ProcessEvent(FindFunctionChecked(ENGINE_PostRender),&Parms);
    }
    void eventTick(FLOAT DeltaTime)
    {
        GameViewportClient_eventTick_Parms Parms(EC_EventParm);
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Tick),&Parms);
        }
    }
    void eventGetSubtitleRegion(FVector2D& MinPos,FVector2D& MaxPos)
    {
        GameViewportClient_eventGetSubtitleRegion_Parms Parms(EC_EventParm);
        Parms.MinPos=MinPos;
        Parms.MaxPos=MaxPos;
        ProcessEvent(FindFunctionChecked(ENGINE_GetSubtitleRegion),&Parms);
        MinPos=Parms.MinPos;
        MaxPos=Parms.MaxPos;
    }
    void eventLayoutPlayers()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_LayoutPlayers),NULL);
    }
    void eventGameSessionEnded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_GameSessionEnded),NULL);
    }
    INT eventInsertInteraction(class UInteraction* NewInteraction,INT InIndex=-1)
    {
        GameViewportClient_eventInsertInteraction_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.NewInteraction=NewInteraction;
        Parms.InIndex=InIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_InsertInteraction),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventInit(FString& OutError)
    {
        GameViewportClient_eventInit_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.OutError=OutError;
        ProcessEvent(FindFunctionChecked(ENGINE_Init),&Parms);
        OutError=Parms.OutError;
        return Parms.ReturnValue;
    }
    class ULocalPlayer* eventFindPlayerByControllerId(INT ControllerId)
    {
        GameViewportClient_eventFindPlayerByControllerId_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ControllerId=ControllerId;
        ProcessEvent(FindFunctionChecked(ENGINE_FindPlayerByControllerId),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventRemovePlayer(class ULocalPlayer* ExPlayer)
    {
        GameViewportClient_eventRemovePlayer_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ExPlayer=ExPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_RemovePlayer),&Parms);
        return Parms.ReturnValue;
    }
    class ULocalPlayer* eventCreatePlayer(INT ControllerId,FString& OutError,UBOOL bSpawnActor)
    {
        GameViewportClient_eventCreatePlayer_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.ControllerId=ControllerId;
        Parms.OutError=OutError;
        Parms.bSpawnActor=bSpawnActor ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_CreatePlayer),&Parms);
        OutError=Parms.OutError;
        return Parms.ReturnValue;
    }
    UBOOL delegateHandleInputChar(INT ControllerId,const FString& Unicode)
    {
        GameViewportClient_eventHandleInputChar_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Unicode=Unicode;
        ProcessDelegate(ENGINE_HandleInputChar,&__HandleInputChar__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateHandleInputAxis(INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime,UBOOL bGamepad)
    {
        GameViewportClient_eventHandleInputAxis_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.Delta=Delta;
        Parms.DeltaTime=DeltaTime;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_HandleInputAxis,&__HandleInputAxis__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    UBOOL delegateHandleInputKey(INT ControllerId,FName Key,BYTE EventType,FLOAT AmountDepressed,UBOOL bGamepad=FALSE)
    {
        GameViewportClient_eventHandleInputKey_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.ControllerId=ControllerId;
        Parms.Key=Key;
        Parms.EventType=EventType;
        Parms.AmountDepressed=AmountDepressed;
        Parms.bGamepad=bGamepad ? FIRST_BITFIELD : FALSE;
        ProcessDelegate(ENGINE_HandleInputKey,&__HandleInputKey__Delegate,&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(UGameViewportClient,UScriptViewportClient,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(UEngine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	/** Make sure that the UC mirror struct matches the size of EShowFlags */
	checkAtCompileTime( sizeof(FShowFlags_Mirror) == sizeof(EShowFlags), ShowFlags_Mirror__MustMatchSizeOfEShowFlags );

	// Constructor.
	UGameViewportClient();

	/**
	 * Cleans up all rooted or referenced objects created or managed by the GameViewportClient.  This method is called
	 * when this GameViewportClient has been disassociated with the game engine (i.e. is no longer the engine's GameViewport).
	 */
	virtual void DetachViewportClient();

	/**
	 * Called every frame to allow the game viewport to update time based state.
	 * @param	DeltaTime	The time since the last call to Tick.
	 */
	void Tick( FLOAT DeltaTime );

	// FViewportClient interface.
	virtual void RedrawRequested(FViewport* InViewport) {}

	/**
	 * Routes an input key event received from the viewport to the Interactions array for processing.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	gamepad/controller that generated this input event
	 * @param	Key				the name of the key which an event occured for (KEY_Up, KEY_Down, etc.)
	 * @param	EventType		the type of event which occured (pressed, released, etc.)
	 * @param	AmountDepressed	(analog keys only) the depression percent.
	 * @param	bGamepad - input came from gamepad (ie xbox controller)
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputKey(FViewport* Viewport,INT ControllerId,FName Key,EInputEvent EventType,FLOAT AmountDepressed=1.f,UBOOL bGamepad=FALSE);

	/**
	 * Routes an input axis (joystick, thumbstick, or mouse) event received from the viewport to the Interactions array for processing.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this input axis event
	 * @param	Key				the name of the axis that moved  (KEY_MouseX, KEY_XboxTypeS_LeftX, etc.)
	 * @param	Delta			the movement delta for the axis
	 * @param	DeltaTime		the time (in seconds) since the last axis update.
	 *
	 * @return	TRUE to consume the axis event, FALSE to pass it on.
	 */
	virtual UBOOL InputAxis(FViewport* Viewport,INT ControllerId,FName Key,FLOAT Delta,FLOAT DeltaTime, UBOOL bGamepad=FALSE);

	/**
	 * Routes a character input event (typing) received from the viewport to the Interactions array for processing.
	 *
	 * @param	Viewport		the viewport the input event was received from
	 * @param	ControllerId	the controller that generated this character input event
	 * @param	Character		the character that was typed
	 *
	 * @return	TRUE to consume the key event, FALSE to pass it on.
	 */
	virtual UBOOL InputChar(FViewport* Viewport,INT ControllerId,TCHAR Character);

	/**
	 * Check a key event received by the viewport.
	 * If the viewport client uses the event, it should return true to consume it.
	 * @param	Viewport - The viewport which the event is from.
	 * @param	ControllerId - The controller which the key event is from.
	 * @param	Handle - Identifier unique to this touch event
	 * @param	Type - What kind of touch event this is (see ETouchType)
	 * @param	TouchLocation - Screen position of the touch
	 * @param	DeviceTimestamp - Timestamp of the event
	 * @param	TouchpadIndex - For devices with multiple touchpads, this is the index of which one
	 * @return	True to consume the key event, false to pass it on.
	 */
	virtual UBOOL InputTouch(FViewport* Viewport, INT ControllerId, UINT Handle, BYTE Type, FVector2D TouchLocation, DOUBLE DeviceTimestamp, UINT TouchpadIndex=0);

	/**
	 * Each frame, the input system will update the motion data.
	 *
	 * @param Viewport - The viewport which the key event is from.
	 * @param ControllerId - The controller which the key event is from.
	 * @param Tilt			The current orientation of the device
	 * @param RotationRate	How fast the tilt is changing
	 * @param Gravity		Describes the current gravity of the device
	 * @param Acceleration  Describes the acceleration of the device
	 * @return	True to consume the motion event, false to pass it on.
	 */
	virtual UBOOL InputMotion(FViewport* Viewport, INT ControllerId, const FVector& Tilt, const FVector& RotationRate, const FVector& Gravity, const FVector& Acceleration);

	/** Returns the platform specific forcefeedback manager associated with this viewport */
	virtual class UForceFeedbackManager* GetForceFeedbackManager(INT ControllerId);

	/**
	 * @return	the splitscreen type that is currently being used
	 */
	FORCEINLINE ESplitScreenType GetCurrentSplitscreenType() const
	{
		return static_cast<ESplitScreenType>(ActiveSplitscreenType);
	}

	/**
	 * Retrieves the cursor that should be displayed by the OS
	 *
	 * @param	Viewport	the viewport that contains the cursor
	 * @param	X			the x position of the cursor
	 * @param	Y			the Y position of the cursor
	 *
	 * @return	the cursor that the OS should display
	 */
	virtual EMouseCursor GetCursor( FViewport* Viewport, INT X, INT Y );


	virtual void Precache();
	virtual void Draw(FViewport* Viewport,FCanvas* Canvas);
	virtual void LostFocus(FViewport* Viewport);
	virtual void ReceivedFocus(FViewport* Viewport);
	virtual UBOOL IsFocused(FViewport* Viewport);
	virtual void CloseRequested(FViewport* Viewport);
	virtual UBOOL RequiresHitProxyStorage() { return 0; }

	/**
	 * Determines whether this viewport client should receive calls to InputAxis() if the game's window is not currently capturing the mouse.
	 * Used by the UI system to easily receive calls to InputAxis while the viewport's mouse capture is disabled.
	 */
	virtual UBOOL RequiresUncapturedAxisInput() const;

	// FExec interface.
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);

	/**
	 * Helper function to toggles, enable or disable the specified show flag. Called by Exec().
	 *
	 * @param Cmd		Exec command line, as passed on from Exec().
	 * @param Ar		Output device used for reporting the result.
	 * @param SetMode	Specifies whether the flag should be toggled, enabled or disabled.
	 * @return			TRUE if the flag was modified.
	 */
	UBOOL SetShowFlags(const TCHAR* Cmd,FOutputDevice& Ar, ESetMode SetMode );

	/**
	 * Set this GameViewportClient's viewport and viewport frame to the viewport specified
	 */
	virtual void SetViewportFrame( FViewportFrame* InViewportFrame );

	/**
	 * Set this GameViewportClient's viewport to the viewport specified
	 */
	virtual void SetViewport( FViewport* InViewportFrame );

	/** sets bDropDetail and other per-frame detail level flags on the current WorldInfo
	 * @param DeltaSeconds - amount of time passed since last tick
	 */
	virtual void SetDropDetail(FLOAT DeltaSeconds);

	#if WITH_GFx
	    virtual UObject* GetUObject() { return this; }
	#endif
};

class UOnlineGameSettings : public USettings
{
public:
    //## BEGIN PROPS OnlineGameSettings
    INT NumPublicConnections;
    INT NumPrivateConnections;
    INT NumOpenPublicConnections;
    INT NumOpenPrivateConnections;
    QWORD ServerNonce;
    BITFIELD bShouldAdvertise:1;
    BITFIELD bIsLanMatch:1;
    BITFIELD bUsesStats:1;
    BITFIELD bAllowJoinInProgress:1;
    BITFIELD bAllowInvites:1;
    BITFIELD bUsesPresence:1;
    BITFIELD bAllowJoinViaPresence:1;
    BITFIELD bAllowJoinViaPresenceFriendsOnly:1;
    BITFIELD bUsesArbitration:1;
    BITFIELD bAntiCheatProtected:1;
    BITFIELD bWasFromInvite:1;
    BITFIELD bIsDedicated:1;
    BITFIELD bHasSkillUpdateInProgress:1;
    BITFIELD bShouldShrinkArbitratedSessions:1;
    FStringNoInit OwningPlayerName;
    struct FUniqueNetId OwningPlayerId;
    INT PingInMs;
    FLOAT MatchQuality;
    BYTE GameState;
    INT BuildUniqueId;
    //## END PROPS OnlineGameSettings

    DECLARE_CLASS(UOnlineGameSettings,USettings,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UOnlineGameSettings)
};

struct FSoundNodeEditorData
{
    INT NodePosX;
    INT NodePosY;
    friend FArchive& operator<<(FArchive& Ar,FSoundNodeEditorData& MySoundNodeEditorData)
    {
        return Ar << MySoundNodeEditorData.NodePosX << MySoundNodeEditorData.NodePosY;
    }

    /** Constructors */
    FSoundNodeEditorData() {}
    FSoundNodeEditorData(EEventParm)
    {
        appMemzero(this, sizeof(FSoundNodeEditorData));
    }
};

class USoundCue : public UObject
{
public:
    //## BEGIN PROPS SoundCue
    FName SoundClass;
    BYTE SoundClassName;
    SCRIPT_ALIGN;
    BITFIELD bDebug:1;
    class USoundNode* FirstNode;
    TMap< USoundNode*,FSoundNodeEditorData > EditorData;
    FLOAT MaxAudibleDistance;
    FLOAT VolumeMultiplier;
    FLOAT PitchMultiplier;
    FLOAT Duration;
    class UFaceFXAnimSet* FaceFXAnimSetRef;
    FStringNoInit FaceFXGroupName;
    FStringNoInit FaceFXAnimName;
    INT MaxConcurrentPlayCount;
    INT CurrentPlayCount;
    FName SoundGroup_DEPRECATED;
    //## END PROPS SoundCue

    FLOAT GetCueDuration();
    DECLARE_FUNCTION(execGetCueDuration)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetCueDuration();
    }
    DECLARE_CLASS(USoundCue,UObject,0,Engine)
    #include "USoundCue.h"
};

struct FRecognisableWord
{
    INT Id;
    FStringNoInit ReferenceWord;
    FStringNoInit PhoneticWord;

    /** Constructors */
    FRecognisableWord() {}
    FRecognisableWord(EEventParm)
    {
        appMemzero(this, sizeof(FRecognisableWord));
    }
};

struct FRecogVocabulary
{
    TArrayNoInit<struct FRecognisableWord> WhoDictionary;
    TArrayNoInit<struct FRecognisableWord> WhatDictionary;
    TArrayNoInit<struct FRecognisableWord> WhereDictionary;
    FStringNoInit VocabName;
    TArrayNoInit<BYTE> VocabData;
    TArrayNoInit<BYTE> WorkingVocabData;

		/**
		 * Creates the work data required for speech recognition
		 */
		UBOOL CreateSpeechRecognitionData( class USpeechRecognition* Owner, FString Folder, INT Index );

		/**
		 * Loads the created vocabulary after it has been modified by BuildVoice
		 */
		UBOOL LoadSpeechRecognitionData( void );

		/**
		 * Clear out all the created vocab data
		 */
		void Clear( void );

		/**
		 * Returns name of created vocab file
		 */
		FString GetVocabName( void );

		/**
		 * Returns address of converted vocab data
		 */
		void* GetVocabData( void );

		/**
		 * Return the number of items in this vocabulary
		 */
		INT GetNumItems( void );

		/**
		 * Return the number of bytes allocated by this resource
		 */
		INT GetResourceSize( void );

		/**
		 * Write dictionary to a text file
		 */
		void OutputDictionary( TArrayNoInit<struct FRecognisableWord>& Dictionary, FString& Line );
		UBOOL SaveDictionary( FString& TextFile );

		/**
		 * Looks up the word in the dictionary
		 */
		FString GetStringFromWordId( DWORD WordId );

		/**
		 * Initialise the recogniser
		 */
		UBOOL InitSpeechRecognition( class USpeechRecognition* Owner );
	
};

struct FRecogUserData
{
    INT ActiveVocabularies;
    TArrayNoInit<BYTE> UserData;

    /** Constructors */
    FRecogUserData() {}
    FRecogUserData(EEventParm)
    {
        appMemzero(this, sizeof(FRecogUserData));
    }
};

class USpeechRecognition : public UObject
{
public:
    //## BEGIN PROPS SpeechRecognition
    FStringNoInit Language;
    FLOAT ConfidenceThreshhold;
    TArrayNoInit<struct FRecogVocabulary> Vocabularies;
    TArrayNoInit<BYTE> VoiceData;
    TArrayNoInit<BYTE> WorkingVoiceData;
    TArrayNoInit<BYTE> UserData;
    struct FRecogUserData InstanceData[4];
    BITFIELD bDirty:1;
    BITFIELD bInitialised:1;
    SCRIPT_ALIGN;
    FPointer FnxVoiceData;
    //## END PROPS SpeechRecognition

    DECLARE_CLASS(USpeechRecognition,UObject,0,Engine)
	/**
	 * Initialise the recogniser
	 */
	UBOOL InitSpeechRecognition( INT MaxLocalTalkers );

	/**
	 * Validates a word from a dictionary
	 */
	UBOOL ValidateRecognitionItem( BYTE* UniqueIDs, FRecognisableWord& Word );

	/**
	 * Validates the source speech recognition data
	 */
	UBOOL ValidateRecognitionData( void );

	/**
	 * Creates the work data required for speech recognition
	 */
	UBOOL CreateSpeechRecognitionData( void );

	/**
	 * Process input samples
	 */
	DWORD RecogniseSpeech( DWORD UserIndex, SWORD* Samples, INT NumSamples );

	/**
	 * Select vocabularies
	 */
	UBOOL SelectVocabularies( DWORD LocalTalker, DWORD VocabBitField );

	/**
	 * Returns an array of recognised words based on the grammer rules $who $what [$where]
	 */
	UBOOL GetResult( DWORD UserIndex, TArray<struct FSpeechRecognizedWord>& Words );

	/**
	 * Looks up the word in the dictionary
	 */
	FString GetStringFromWordId( DWORD WordID );

	/**
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc( void );

	/**
	 * Returns detailed info to populate listview columns
	 */
	virtual FString GetDetailedDescription( INT InIndex );

	/**
	 * @return		The size of the asset.
	 */
	virtual INT GetResourceSize( void );

	/**
	 * Callback after any property has changed
	 */
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/**
	 * Called before the package is saved
	 */
	virtual void PreSave( void );

	/**
	 * Manages any error codes that may have occurred
	 */
	FString HandleError( INT Error );

	/**
	 * Convert the language code to Fonix folder
	 */
	FString GetLanguageFolder( void );
};

class USurface : public UObject
{
public:
    //## BEGIN PROPS Surface
    //## END PROPS Surface

    DECLARE_FUNCTION(execGetSurfaceWidth);
    DECLARE_FUNCTION(execGetSurfaceHeight);
    DECLARE_ABSTRACT_CLASS(USurface,UObject,0,Engine)
	virtual FLOAT GetSurfaceWidth() const PURE_VIRTUAL(USurface::GetSurfaceWidth,return 0;);
	virtual FLOAT GetSurfaceHeight() const PURE_VIRTUAL(USurface::GetSurfaceHeight,return 0;);

	/**
	 * @return Width/height this surface was before cooking or other modifications
	 */
	virtual FLOAT GetOriginalSurfaceWidth() const { return GetSurfaceWidth(); }
	virtual FLOAT GetOriginalSurfaceHeight() const { return GetSurfaceHeight(); }
};

class UTranslationContext : public UObject
{
public:
    //## BEGIN PROPS TranslationContext
    TArrayNoInit<class UTranslatorTag*> TranslatorTags;
    //## END PROPS TranslationContext

    virtual UBOOL RegisterTranslatorTag(class UTranslatorTag* InTagHandler);
    DECLARE_FUNCTION(execRegisterTranslatorTag)
    {
        P_GET_OBJECT(UTranslatorTag,InTagHandler);
        P_FINISH;
        *(UBOOL*)Result=this->RegisterTranslatorTag(InTagHandler);
    }
    DECLARE_CLASS(UTranslationContext,UObject,0,Engine)
public:
	/** 
	 * Translator the given string by attempting to pass it to each of the registered translators.
	 *
	 * @param InString       Text to translate.
	 * @param OutTranslated  Translated text.
	 *
	 * @return True if the translation succeeded.
	 */
	UBOOL Translate( const FString& InString, FString *OutTranslated );
private:
	/**
	 * Given a tag, return the appropriate translator if possible.
	 * e.g. Given <MyTag:Option />  get the Appropriate translator for MyTag.
	 */
	UTranslatorTag* TranslatorTagFromName( FName InName ) const;
};

class UTranslatorTag : public UObject
{
public:
    //## BEGIN PROPS TranslatorTag
    FName Tag;
    //## END PROPS TranslatorTag

    virtual FString Translate(const FString& InArgument);
    DECLARE_FUNCTION(execTranslate)
    {
        P_GET_STR(InArgument);
        P_FINISH;
        *(FString*)Result=this->Translate(InArgument);
    }
    DECLARE_CLASS(UTranslatorTag,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UTranslatorTag)
};

class UStringsTag : public UTranslatorTag
{
public:
    //## BEGIN PROPS StringsTag
    //## END PROPS StringsTag

    virtual FString Translate(const FString& InArgument);
    DECLARE_CLASS(UStringsTag,UTranslatorTag,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UStringsTag)
};

struct UIManager_eventPauseGame_Parms
{
    UBOOL bDesiredPauseState;
    INT PlayerIndex;
    UIManager_eventPauseGame_Parms(EEventParm)
    {
    }
};
class UUIManager : public UObject
{
public:
    //## BEGIN PROPS UIManager
    //## END PROPS UIManager

    UBOOL CanUnpauseInternalUI();
    DECLARE_FUNCTION(execGetUIManager);
    DECLARE_FUNCTION(execCanUnpauseInternalUI)
    {
        P_FINISH;
        *(UBOOL*)Result=this->CanUnpauseInternalUI();
    }
    void eventPauseGame(UBOOL bDesiredPauseState,INT PlayerIndex=0)
    {
        UIManager_eventPauseGame_Parms Parms(EC_EventParm);
        Parms.bDesiredPauseState=bDesiredPauseState ? FIRST_BITFIELD : FALSE;
        Parms.PlayerIndex=PlayerIndex;
        ProcessEvent(FindFunctionChecked(ENGINE_PauseGame),&Parms);
    }
    DECLARE_CLASS(UUIManager,UObject,0,Engine)
    DECLARE_WITHIN(UUIInteraction)
	/**
	 * Returns the game's UI Manager.
	 *
	 * @return 	a pointer to the UUIManager instance currently managing the scenes for the UI System.
	 */
	static class UUIManager* GetUIManager();
};

class UWaveFormBase : public UObject
{
public:
    //## BEGIN PROPS WaveFormBase
    class UForceFeedbackWaveform* TheWaveForm;
    //## END PROPS WaveFormBase

    DECLARE_ABSTRACT_CLASS(UWaveFormBase,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UWaveFormBase)
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AActor,-1,execGetActorSpriteComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execGetActorMetrics);
AUTOGENERATE_FUNCTION(AActor,-1,execShouldBeHiddenBySHOW_NavigationNodes);
AUTOGENERATE_FUNCTION(AActor,-1,execWillOverlap);
AUTOGENERATE_FUNCTION(AActor,-1,execGetAvoidanceVector);
AUTOGENERATE_FUNCTION(AActor,-1,execSupportsKismetModification);
AUTOGENERATE_FUNCTION(AActor,-1,execGetAnimTrailParticleSystem);
AUTOGENERATE_FUNCTION(AActor,-1,execIsInPersistentLevel);
AUTOGENERATE_FUNCTION(AActor,-1,execGetPackageGuid);
AUTOGENERATE_FUNCTION(AActor,-1,execNativePostRenderFor);
AUTOGENERATE_FUNCTION(AActor,-1,execSetHUDLocation);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTargetLocation);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(AActor,-1,execIsPlayerOwned);
AUTOGENERATE_FUNCTION(AActor,-1,execPrestreamTextures);
AUTOGENERATE_FUNCTION(AActor,-1,execSetNetUpdateTime);
AUTOGENERATE_FUNCTION(AActor,-1,execGetGravityZ);
AUTOGENERATE_FUNCTION(AActor,-1,execGetALocalPlayerController);
AUTOGENERATE_FUNCTION(AActor,-1,execLocalPlayerControllers);
AUTOGENERATE_FUNCTION(AActor,-1,execAllOwnedComponents);
AUTOGENERATE_FUNCTION(AActor,-1,execComponentList);
AUTOGENERATE_FUNCTION(AActor,-1,execOverlappingActors);
AUTOGENERATE_FUNCTION(AActor,321,execCollidingActors);
AUTOGENERATE_FUNCTION(AActor,312,execVisibleCollidingActors);
AUTOGENERATE_FUNCTION(AActor,311,execVisibleActors);
AUTOGENERATE_FUNCTION(AActor,309,execTraceActors);
AUTOGENERATE_FUNCTION(AActor,307,execTouchingActors);
AUTOGENERATE_FUNCTION(AActor,306,execBasedActors);
AUTOGENERATE_FUNCTION(AActor,305,execChildActors);
AUTOGENERATE_FUNCTION(AActor,313,execDynamicActors);
AUTOGENERATE_FUNCTION(AActor,304,execAllActors);
AUTOGENERATE_FUNCTION(AActor,547,execGetURLMap);
AUTOGENERATE_FUNCTION(AActor,-1,execGetDestination);
AUTOGENERATE_FUNCTION(AActor,-1,execCalculateMinSpeedTrajectory);
AUTOGENERATE_FUNCTION(AActor,-1,execSuggestTossVelocity);
AUTOGENERATE_FUNCTION(AActor,532,execPlayerCanSeeMe);
AUTOGENERATE_FUNCTION(AActor,512,execMakeNoise);
AUTOGENERATE_FUNCTION(AActor,-1,execPlaySound);
AUTOGENERATE_FUNCTION(AActor,-1,execCreateAudioComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execResetTimerTimeDilation);
AUTOGENERATE_FUNCTION(AActor,-1,execModifyTimerTimeDilation);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTimerRate);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTimerCount);
AUTOGENERATE_FUNCTION(AActor,-1,execIsTimerActive);
AUTOGENERATE_FUNCTION(AActor,-1,execPauseTimer);
AUTOGENERATE_FUNCTION(AActor,-1,execClearAllTimers);
AUTOGENERATE_FUNCTION(AActor,-1,execClearTimer);
AUTOGENERATE_FUNCTION(AActor,280,execSetTimer);
AUTOGENERATE_FUNCTION(AActor,279,execDestroy);
AUTOGENERATE_FUNCTION(AActor,-1,execSpawn);
AUTOGENERATE_FUNCTION(AActor,-1,execIsBlockedBy);
AUTOGENERATE_FUNCTION(AActor,-1,execGetBoundingCylinder);
AUTOGENERATE_FUNCTION(AActor,-1,execGetComponentsBoundingBox);
AUTOGENERATE_FUNCTION(AActor,-1,execIsOverlapping);
AUTOGENERATE_FUNCTION(AActor,-1,execContainsPoint);
AUTOGENERATE_FUNCTION(AActor,-1,execFindSpot);
AUTOGENERATE_FUNCTION(AActor,-1,execTraceAllPhysicsAssetInteractions);
AUTOGENERATE_FUNCTION(AActor,548,execFastTrace);
AUTOGENERATE_FUNCTION(AActor,-1,execPointCheckComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execTraceComponent);
AUTOGENERATE_FUNCTION(AActor,277,execTrace);
AUTOGENERATE_FUNCTION(AActor,-1,execClampRotation);
AUTOGENERATE_FUNCTION(AActor,-1,execSetTickIsDisabled);
AUTOGENERATE_FUNCTION(AActor,-1,execSetTickGroup);
AUTOGENERATE_FUNCTION(AActor,-1,execReattachComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execDetachComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execAttachComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execUnClock);
AUTOGENERATE_FUNCTION(AActor,-1,execClock);
AUTOGENERATE_FUNCTION(AActor,3970,execSetPhysics);
AUTOGENERATE_FUNCTION(AActor,-1,execSetOnlyOwnerSee);
AUTOGENERATE_FUNCTION(AActor,-1,execSetHidden);
AUTOGENERATE_FUNCTION(AActor,-1,execChartData);
AUTOGENERATE_FUNCTION(AActor,-1,execFlushDebugStrings);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugFrustrum);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugString);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugCone);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugCylinder);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugSphere);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugCoordinateSystem);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugStar);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugBox);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugPoint);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugLine);
AUTOGENERATE_FUNCTION(AActor,-1,execFlushPersistentDebugLines);
AUTOGENERATE_FUNCTION(AActor,-1,execGetBasedPosition);
AUTOGENERATE_FUNCTION(AActor,-1,execSetBasedPosition);
AUTOGENERATE_FUNCTION(AActor,-1,execBP2Vect);
AUTOGENERATE_FUNCTION(AActor,-1,execVect2BP);
AUTOGENERATE_FUNCTION(AActor,-1,execSetForcedInitialReplicatedProperty);
AUTOGENERATE_FUNCTION(AActor,-1,execGetAggregateBaseVelocity);
AUTOGENERATE_FUNCTION(AActor,-1,execIsOwnedBy);
AUTOGENERATE_FUNCTION(AActor,-1,execGetBaseMost);
AUTOGENERATE_FUNCTION(AActor,-1,execIsBasedOn);
AUTOGENERATE_FUNCTION(AActor,-1,execSearchForBaseBelow);
AUTOGENERATE_FUNCTION(AActor,-1,execFindBase);
AUTOGENERATE_FUNCTION(AActor,272,execSetOwner);
AUTOGENERATE_FUNCTION(AActor,298,execSetBase);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTerminalVelocity);
AUTOGENERATE_FUNCTION(AActor,3971,execAutonomousPhysics);
AUTOGENERATE_FUNCTION(AActor,3969,execMoveSmooth);
AUTOGENERATE_FUNCTION(AActor,-1,execfixedTurn);
AUTOGENERATE_FUNCTION(AActor,-1,execSetShadowParentOnAllAttachedComponents);
AUTOGENERATE_FUNCTION(AActor,-1,execSetHardAttach);
AUTOGENERATE_FUNCTION(AActor,-1,execSetRelativeLocation);
AUTOGENERATE_FUNCTION(AActor,-1,execSetRelativeRotation);
AUTOGENERATE_FUNCTION(AActor,-1,execSetZone);
AUTOGENERATE_FUNCTION(AActor,-1,execMovingWhichWay);
AUTOGENERATE_FUNCTION(AActor,299,execSetRotation);
AUTOGENERATE_FUNCTION(AActor,267,execSetLocation);
AUTOGENERATE_FUNCTION(AActor,266,execMove);
AUTOGENERATE_FUNCTION(AActor,-1,execSetDrawScale3D);
AUTOGENERATE_FUNCTION(AActor,-1,execSetDrawScale);
AUTOGENERATE_FUNCTION(AActor,-1,execSetCollisionType);
AUTOGENERATE_FUNCTION(AActor,283,execSetCollisionSize);
AUTOGENERATE_FUNCTION(AActor,262,execSetCollision);
AUTOGENERATE_FUNCTION(AActor,261,execFinishAnim);
AUTOGENERATE_FUNCTION(AActor,256,execSleep);
AUTOGENERATE_FUNCTION(AActor,-1,execConsoleCommand);
AUTOGENERATE_FUNCTION(AActor,-1,execForceUpdateComponents);
AUTOGENERATE_FUNCTION(AVolume,-1,execEncompassesPoint);
AUTOGENERATE_FUNCTION(AVolume,-1,execEncompasses);
AUTOGENERATE_FUNCTION(APhysicsVolume,-1,execGetZoneVelocityForActor);
AUTOGENERATE_FUNCTION(APhysicsVolume,-1,execGetGravityZ);
AUTOGENERATE_FUNCTION(ADroppedPickup,-1,execRemoveFromNavigation);
AUTOGENERATE_FUNCTION(ADroppedPickup,-1,execAddToNavigation);
AUTOGENERATE_FUNCTION(AEmitter,-1,execSetTemplate);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execSpawnEmitterCustomLifetime);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execSpawnEmitterMeshAttachment);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execSpawnEmitter);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execGetPooledComponent);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execGetFreeMatInstConsts);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execFreeMaterialInstanceConstants);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execGetFreeStaticMeshComponent);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execFreeStaticMeshComponents);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execReturnToPool);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execClearPoolComponents);
AUTOGENERATE_FUNCTION(AEmitterPool,-1,execOnParticleSystemFinished);
AUTOGENERATE_FUNCTION(AHUD,-1,execDrawActorOverlays);
AUTOGENERATE_FUNCTION(AHUD,-1,execDraw2DLine);
AUTOGENERATE_FUNCTION(AHUD,-1,execDraw3DLine);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execDoMemoryTracking);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execDoSentinel_ViewDependentMemoryAtSpecificLocation);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execDoSentinel_PerfAtSpecificLocation);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execDoSentinel_MemoryAtSpecificLocation);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execGetTravelLocations);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execHandlePerLoadedMapAudioStats);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execDoSentinelActionPerLoadedMap);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execEndSentinelRun);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execAddSentinelPerTimePeriodStats);
AUTOGENERATE_FUNCTION(AAutoTestManager,-1,execBeginSentinelRun);
AUTOGENERATE_FUNCTION(ACoverGroup,-1,execToggleGroup);
AUTOGENERATE_FUNCTION(ACoverGroup,-1,execDisableGroup);
AUTOGENERATE_FUNCTION(ACoverGroup,-1,execEnableGroup);
AUTOGENERATE_FUNCTION(AFileWriter,-1,execLogf);
AUTOGENERATE_FUNCTION(AFileWriter,-1,execCloseFile);
AUTOGENERATE_FUNCTION(AFileWriter,-1,execOpenFile);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execEnableStandbyCheatDetection);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execSetBandwidthLimit);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execSwapPlayerControllers);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execGetNextPlayerID);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execRejectLogin);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execResumeLogin);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execPauseLogin);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execForceClearUnpauseDelegates);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execGetNetworkNumber);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execDoNavFearCostFallOff);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execShouldStartInCinematicMode);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execGetMapCommonPackageName);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execGetSupportedGameTypes);
AUTOGENERATE_FUNCTION(ARoute,-1,execMoveOntoRoutePath);
AUTOGENERATE_FUNCTION(ARoute,-1,execResolveRouteIndex);
AUTOGENERATE_FUNCTION(AWeapon,-1,execGetPhysicalFireStartLoc);
AUTOGENERATE_FUNCTION(AInventoryManager,-1,execInventoryActors);
AUTOGENERATE_FUNCTION(AMatineeActor,-1,execAddAIGroupActor);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execIsOnDifferentNetwork);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execGetAllNavInRadius);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execCanTeleport);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execIsUsableAnchorFor);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execGetReachSpecTo);
AUTOGENERATE_FUNCTION(ANavigationPoint,-1,execGetBoundingCylinder);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetLocationDescription);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execAddCoverSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSwatTurnTarget);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsEnabled);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execAutoAdjustSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotActions);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execHasFireLinkTo);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetFireLinkTo);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotIdxToRight);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotIdxToLeft);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsRightEdgeSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsLeftEdgeSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsEdgeSlot);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execFindSlots);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsValidClaimBetween);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsValidClaim);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execIsExposedTo);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotViewPoint);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotRotation);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetSlotLocation);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execUnPackFireLinkInteractionInfo);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execPackFireLinkInteractionInfo);
AUTOGENERATE_FUNCTION(ACoverLink,-1,execGetFireLinkTargetCoverInfo);
AUTOGENERATE_FUNCTION(APortalMarker,-1,execCanTeleport);
AUTOGENERATE_FUNCTION(APylon,-1,execCanReachPylon);
AUTOGENERATE_FUNCTION(APylon,-1,execFlushDynamicEdges);
AUTOGENERATE_FUNCTION(APylon,-1,execUpdateMeshForPreExistingNavMeshObstacles);
AUTOGENERATE_FUNCTION(APylon,-1,execOnPylonStatusChange);
AUTOGENERATE_FUNCTION(ADynamicPylon,-1,execFlushDynamicEdges);
AUTOGENERATE_FUNCTION(ADynamicPylon,-1,execRebuildDynamicEdges);
AUTOGENERATE_FUNCTION(ATeleporter,-1,execCanTeleport);
AUTOGENERATE_FUNCTION(AProjectile,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(AProjectile,-1,execInit);
AUTOGENERATE_FUNCTION(APortalTeleporter,-1,execCreatePortalTexture);
AUTOGENERATE_FUNCTION(APortalTeleporter,-1,execTransformHitLocation);
AUTOGENERATE_FUNCTION(APortalTeleporter,-1,execTransformVectorDir);
AUTOGENERATE_FUNCTION(APortalTeleporter,-1,execTransformActor);
AUTOGENERATE_FUNCTION(UHeightFogComponent,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(USpriteComponent,-1,execSetSpriteAndUV);
AUTOGENERATE_FUNCTION(USpriteComponent,-1,execSetUV);
AUTOGENERATE_FUNCTION(USpriteComponent,-1,execSetSprite);
AUTOGENERATE_FUNCTION(URadialBlurComponent,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(URadialBlurComponent,-1,execSetBlurOpacity);
AUTOGENERATE_FUNCTION(URadialBlurComponent,-1,execSetBlurFalloffExponent);
AUTOGENERATE_FUNCTION(URadialBlurComponent,-1,execSetBlurScale);
AUTOGENERATE_FUNCTION(URadialBlurComponent,-1,execSetMaterial);
AUTOGENERATE_FUNCTION(USceneCaptureComponent,-1,execSetEnabled);
AUTOGENERATE_FUNCTION(USceneCaptureComponent,-1,execSetFrameRate);
AUTOGENERATE_FUNCTION(USceneCapture2DComponent,-1,execSetView);
AUTOGENERATE_FUNCTION(USceneCapture2DComponent,-1,execSetCaptureParameters);
AUTOGENERATE_FUNCTION(USceneCapture2DHitMaskComponent,-1,execSetFadingStartTimeSinceHit);
AUTOGENERATE_FUNCTION(USceneCapture2DHitMaskComponent,-1,execSetCaptureParameters);
AUTOGENERATE_FUNCTION(USceneCapture2DHitMaskComponent,-1,execSetCaptureTargetTexture);
AUTOGENERATE_FUNCTION(USceneCapturePortalComponent,-1,execSetCaptureParameters);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawTextureDoubleLine);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawTextureLine);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDraw2DLine);
AUTOGENERATE_FUNCTION(UCanvas,-1,execSetDrawColor);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawBlendedTile);
AUTOGENERATE_FUNCTION(UCanvas,-1,execPopMaskRegion);
AUTOGENERATE_FUNCTION(UCanvas,-1,execPushMaskRegion);
AUTOGENERATE_FUNCTION(UCanvas,-1,execSetPos);
AUTOGENERATE_FUNCTION(UCanvas,-1,execPopTransform);
AUTOGENERATE_FUNCTION(UCanvas,-1,execPushTranslationMatrix);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDeProject);
AUTOGENERATE_FUNCTION(UCanvas,-1,execProject);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawText);
AUTOGENERATE_FUNCTION(UCanvas,-1,execTextSize);
AUTOGENERATE_FUNCTION(UCanvas,-1,execStrLen);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawTris);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawTileStretched);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawTimer);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawRotatedMaterialTile);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawRotatedTile);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawMaterialTile);
AUTOGENERATE_FUNCTION(UCanvas,-1,execPreOptimizeDrawTiles);
AUTOGENERATE_FUNCTION(UCanvas,-1,execDrawTile);
AUTOGENERATE_FUNCTION(UCheatManager,-1,execGetAnalyticsUserId);
AUTOGENERATE_FUNCTION(UCheatManager,-1,execDumpCoverStats);
AUTOGENERATE_FUNCTION(UCheatManager,-1,execVerifyNavMeshCoverRefs);
AUTOGENERATE_FUNCTION(UCheatManager,-1,execPrintNavMeshObstacles);
AUTOGENERATE_FUNCTION(UCheatManager,-1,execPrintAllPathObjectEdges);
AUTOGENERATE_FUNCTION(UCheatManager,-1,execDrawUnsupportingEdges);
AUTOGENERATE_FUNCTION(UCheatManager,-1,execVerifyNavMeshObjects);
AUTOGENERATE_FUNCTION(UCheatManager,-1,execLogParticleActivateSystemCalls);
AUTOGENERATE_FUNCTION(UCheatManager,-1,execLogPlaySoundCalls);
AUTOGENERATE_FUNCTION(UCloudSaveSystem,-1,execDeserializeObject);
AUTOGENERATE_FUNCTION(UCloudSaveSystem,-1,execSerializeObject);
AUTOGENERATE_FUNCTION(UFaceFXAsset,-1,execUnmountFaceFXAnimSet);
AUTOGENERATE_FUNCTION(UFaceFXAsset,-1,execMountFaceFXAnimSet);
AUTOGENERATE_FUNCTION(UFont,-1,execGetStringHeightAndWidth);
AUTOGENERATE_FUNCTION(UFont,-1,execGetMaxCharHeight);
AUTOGENERATE_FUNCTION(UFont,-1,execGetAuthoredViewportHeight);
AUTOGENERATE_FUNCTION(UFont,-1,execGetScalingFactor);
AUTOGENERATE_FUNCTION(UFont,-1,execGetResolutionPageIndex);
AUTOGENERATE_FUNCTION(UMultiFont,-1,execGetResolutionTestTableIndex);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execGetSessionDuration);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execGetSessionEnd);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execGetSessionStart);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execGetSessionTimestamp);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execGetPlatform);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execGetTitleID);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execGetSessionID);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execProcessStreamEnd);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execProcessStream);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execProcessStreamStart);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execSerializeHeader);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execCloseStatsFile);
AUTOGENERATE_FUNCTION(UGameplayEventsReader,-1,execOpenStatsFile);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogProjectileIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogDamageEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogWeaponIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogPlayerPlayerEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogPlayerKillDeath);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogAllPlayerPositionsEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogPlayerLoginChange);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogPlayerSpawnEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogPlayerStringEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogPlayerFloatEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogPlayerIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogTeamStringEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogTeamFloatEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogTeamIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogGamePositionEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogGameFloatEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogGameStringEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execLogGameIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execEndLogging);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execResetLogging);
AUTOGENERATE_FUNCTION(UGameplayEventsUploadAnalytics,-1,execStartLogging);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execGetGenericParamListEntry);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogSystemPollEvents);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogProjectileIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogDamageEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogWeaponIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogPlayerPlayerEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogPlayerKillDeath);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogAllPlayerPositionsEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogPlayerLoginChange);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogPlayerSpawnEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogPlayerStringEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogPlayerFloatEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogPlayerIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogTeamStringEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogTeamFloatEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogTeamIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogGamePositionEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogGameFloatEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogGameStringEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execLogGameIntEvent);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execEndLogging);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execResetLogging);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execStartLogging);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execSerializeFooter);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execSerializeHeader);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execCloseStatsFile);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execOpenStatsFile);
AUTOGENERATE_FUNCTION(UGameplayEventsWriter,-1,execResolvePlayerIndex);
AUTOGENERATE_FUNCTION(UGameplayEventsHandler,-1,execPreProcessStream);
AUTOGENERATE_FUNCTION(UGenericParamListStatEntry,-1,execCommitToDisk);
AUTOGENERATE_FUNCTION(UGenericParamListStatEntry,-1,execGetString);
AUTOGENERATE_FUNCTION(UGenericParamListStatEntry,-1,execGetVector);
AUTOGENERATE_FUNCTION(UGenericParamListStatEntry,-1,execGetInt);
AUTOGENERATE_FUNCTION(UGenericParamListStatEntry,-1,execGetFloat);
AUTOGENERATE_FUNCTION(UGenericParamListStatEntry,-1,execAddString);
AUTOGENERATE_FUNCTION(UGenericParamListStatEntry,-1,execAddVector);
AUTOGENERATE_FUNCTION(UGenericParamListStatEntry,-1,execAddInt);
AUTOGENERATE_FUNCTION(UGenericParamListStatEntry,-1,execAddFloat);
AUTOGENERATE_FUNCTION(UHttpBaseInterface,-1,execGetContent);
AUTOGENERATE_FUNCTION(UHttpBaseInterface,-1,execGetURL);
AUTOGENERATE_FUNCTION(UHttpBaseInterface,-1,execGetContentLength);
AUTOGENERATE_FUNCTION(UHttpBaseInterface,-1,execGetContentType);
AUTOGENERATE_FUNCTION(UHttpBaseInterface,-1,execGetURLParameter);
AUTOGENERATE_FUNCTION(UHttpBaseInterface,-1,execGetHeaders);
AUTOGENERATE_FUNCTION(UHttpBaseInterface,-1,execGetHeader);
AUTOGENERATE_FUNCTION(UHttpRequestInterface,-1,execProcessRequest);
AUTOGENERATE_FUNCTION(UHttpRequestInterface,-1,execSetHeader);
AUTOGENERATE_FUNCTION(UHttpRequestInterface,-1,execSetContentAsString);
AUTOGENERATE_FUNCTION(UHttpRequestInterface,-1,execSetContent);
AUTOGENERATE_FUNCTION(UHttpRequestInterface,-1,execSetURL);
AUTOGENERATE_FUNCTION(UHttpRequestInterface,-1,execSetVerb);
AUTOGENERATE_FUNCTION(UHttpRequestInterface,-1,execGetVerb);
AUTOGENERATE_FUNCTION(UHttpResponseInterface,-1,execGetContentAsString);
AUTOGENERATE_FUNCTION(UHttpResponseInterface,-1,execGetResponseCode);
AUTOGENERATE_FUNCTION(UIniLocPatcher,-1,execUpdateLocFileName);
AUTOGENERATE_FUNCTION(UIniLocPatcher,-1,execProcessIniLocFile);
AUTOGENERATE_FUNCTION(UJsonObject,-1,execDecodeJson);
AUTOGENERATE_FUNCTION(UJsonObject,-1,execEncodeJson);
AUTOGENERATE_FUNCTION(UJsonObject,-1,execSetStringValue);
AUTOGENERATE_FUNCTION(UJsonObject,-1,execSetObject);
AUTOGENERATE_FUNCTION(UJsonObject,-1,execHasKey);
AUTOGENERATE_FUNCTION(UJsonObject,-1,execGetStringValue);
AUTOGENERATE_FUNCTION(UJsonObject,-1,execGetObject);
AUTOGENERATE_FUNCTION(UOnlineMatchmakingStats,-1,execStopTimer);
AUTOGENERATE_FUNCTION(UOnlineMatchmakingStats,-1,execStartTimer);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execSetDefaultVersionNumber);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetVersionNumber);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execAppendVersionToSettings);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execSetToDefaults);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execAddSettingFloat);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execAddSettingInt);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetRangedProfileSettingValue);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execSetRangedProfileSettingValue);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingRange);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingMappingIds);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingMappingType);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execSetProfileSettingValueFloat);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execSetProfileSettingValueInt);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execSetProfileSettingValueId);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingValueFloat);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingValueInt);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingValueFromListIndex);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingValueId);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execSetProfileSettingValue);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execSetProfileSettingValueByName);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingValueByName);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingValues);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingValueName);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingValue);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execIsProfileSettingIdMapped);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execFindDefaultProfileMappingIndexByName);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execFindProfileMappingIndexByName);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execFindProfileMappingIndex);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execFindProfileSettingIndex);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingColumnHeader);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingName);
AUTOGENERATE_FUNCTION(UOnlinePlayerStorage,-1,execGetProfileSettingId);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execAppendVersionToReadIds);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execSetToDefaults);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingDefaultFloat);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingDefaultInt);
AUTOGENERATE_FUNCTION(UOnlineProfileSettings,-1,execGetProfileSettingDefaultId);
AUTOGENERATE_FUNCTION(UOnlineStats,-1,execGetViewName);
AUTOGENERATE_FUNCTION(UOnlineStats,-1,execGetViewId);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execGetRankForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execAddPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execIsStatZero);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execGetStatValueForPlayerAsString);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execSetFloatStatValueForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execGetFloatStatValueForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execSetIntStatValueForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsRead,-1,execGetIntStatValueForPlayer);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execDecrementIntStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execDecrementFloatStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execIncrementIntStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execIncrementFloatStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execSetIntStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execSetFloatStat);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execGetStatName);
AUTOGENERATE_FUNCTION(UOnlineStatsWrite,-1,execGetStatId);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execGetNumSupportedLogins);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execGetBuildUniqueId);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execStringToUniqueNetId);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execUniqueNetIdToString);
AUTOGENERATE_FUNCTION(UOnlineSubsystem,-1,execInit);
AUTOGENERATE_FUNCTION(UPlayer,-1,execSwitchController);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execFastProject);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execFastDeProject);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execProject);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execDeProject);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execTouchPlayerPostProcessChain);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execGetPostProcessChain);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execRemoveAllPostProcessingChains);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execRemovePostProcessingChain);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execInsertPostProcessingChain);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execGetTranslationContext);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execClearPostProcessSettingsOverride);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execOverridePostProcessSettingsCurve);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execOverridePostProcessSettings);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execGetActorVisibility);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execSendSplitJoin);
AUTOGENERATE_FUNCTION(ULocalPlayer,-1,execSpawnPlayActor);
AUTOGENERATE_FUNCTION(UReachSpec,-1,execGetDirection);
AUTOGENERATE_FUNCTION(UReachSpec,-1,execGetEnd);
AUTOGENERATE_FUNCTION(UReachSpec,-1,execCostFor);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execDebugSetUISystemEnabled);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execIsScaleformEnabled);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execDisableScaleform);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execEnableScaleform);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execFixupOwnerReferences);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execGetPlayerOwner);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execSetMouse);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execForceUpdateMouseCursor);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execNotifySplitscreenLayoutChanged);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execSetCustomInteractionObject);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execGetCustomInteractionClass);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execGetNumCustomInteractions);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execShouldForceFullscreenViewport);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execGetMousePosition);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execIsFullScreenViewport);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execGetViewportSize);
AUTOGENERATE_FUNCTION(UGameViewportClient,-1,execConsoleCommand);
AUTOGENERATE_FUNCTION(USettings,-1,execUpdateFromURL);
AUTOGENERATE_FUNCTION(USettings,-1,execBuildURL);
AUTOGENERATE_FUNCTION(USettings,-1,execAppendContextsToURL);
AUTOGENERATE_FUNCTION(USettings,-1,execAppendPropertiesToURL);
AUTOGENERATE_FUNCTION(USettings,-1,execAppendDataBindingsToURL);
AUTOGENERATE_FUNCTION(USettings,-1,execGetQoSAdvertisedStringSettings);
AUTOGENERATE_FUNCTION(USettings,-1,execGetQoSAdvertisedProperties);
AUTOGENERATE_FUNCTION(USettings,-1,execGetRangedPropertyValue);
AUTOGENERATE_FUNCTION(USettings,-1,execSetRangedPropertyValue);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyRange);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyMappingType);
AUTOGENERATE_FUNCTION(USettings,-1,execHasStringSetting);
AUTOGENERATE_FUNCTION(USettings,-1,execHasProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execUpdateProperties);
AUTOGENERATE_FUNCTION(USettings,-1,execUpdateStringSettings);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyType);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyValueId);
AUTOGENERATE_FUNCTION(USettings,-1,execSetPropertyValueId);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execSetStringProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execGetIntProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execSetIntProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execGetFloatProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execSetFloatProperty);
AUTOGENERATE_FUNCTION(USettings,-1,execSetPropertyFromStringByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyAsStringByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyAsString);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyColumnHeader);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetPropertyId);
AUTOGENERATE_FUNCTION(USettings,-1,execSetStringSettingValueFromStringByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValueNameByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValueName);
AUTOGENERATE_FUNCTION(USettings,-1,execIsWildcardStringSetting);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingColumnHeader);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingId);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValueByName);
AUTOGENERATE_FUNCTION(USettings,-1,execSetStringSettingValueByName);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValueNames);
AUTOGENERATE_FUNCTION(USettings,-1,execIncrementStringSettingValue);
AUTOGENERATE_FUNCTION(USettings,-1,execGetStringSettingValue);
AUTOGENERATE_FUNCTION(USettings,-1,execSetStringSettingValue);
AUTOGENERATE_FUNCTION(USettings,-1,execGetSettingsDataDateTime);
AUTOGENERATE_FUNCTION(USettings,-1,execGetSettingsDataBlob);
AUTOGENERATE_FUNCTION(USettings,-1,execGetSettingsDataInt);
AUTOGENERATE_FUNCTION(USettings,-1,execGetSettingsDataFloat);
AUTOGENERATE_FUNCTION(USettings,-1,execEmptySettingsData);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsData);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsDataBlob);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsDataDateTime);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsDataInt);
AUTOGENERATE_FUNCTION(USettings,-1,execSetSettingsDataFloat);
AUTOGENERATE_FUNCTION(UOnlineGameSearch,-1,execSortSearchResults);
AUTOGENERATE_FUNCTION(USoundCue,-1,execGetCueDuration);
AUTOGENERATE_FUNCTION(USurface,-1,execGetSurfaceHeight);
AUTOGENERATE_FUNCTION(USurface,-1,execGetSurfaceWidth);
AUTOGENERATE_FUNCTION(UTranslationContext,-1,execRegisterTranslatorTag);
AUTOGENERATE_FUNCTION(UTranslatorTag,-1,execTranslate);
AUTOGENERATE_FUNCTION(UStringsTag,-1,execTranslate);
AUTOGENERATE_FUNCTION(UUIManager,-1,execCanUnpauseInternalUI);
AUTOGENERATE_FUNCTION(UUIManager,-1,execGetUIManager);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_NATIVE_DEFS
#define ENGINE_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE \
	AActor::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Actor"), GEngineAActorNatives); \
	ABrush::StaticClass(); \
	ABrushShape::StaticClass(); \
	AVolume::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Volume"), GEngineAVolumeNatives); \
	ABlockingVolume::StaticClass(); \
	ADynamicBlockingVolume::StaticClass(); \
	ACullDistanceVolume::StaticClass(); \
	ALevelGridVolume::StaticClass(); \
	ALevelStreamingVolume::StaticClass(); \
	ALightmassCharacterIndirectDetailVolume::StaticClass(); \
	ALightmassImportanceVolume::StaticClass(); \
	AMassiveLODOverrideVolume::StaticClass(); \
	APathBlockingVolume::StaticClass(); \
	APhysicsVolume::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PhysicsVolume"), GEngineAPhysicsVolumeNatives); \
	ADefaultPhysicsVolume::StaticClass(); \
	AGravityVolume::StaticClass(); \
	ALadderVolume::StaticClass(); \
	APortalVolume::StaticClass(); \
	APostProcessVolume::StaticClass(); \
	APrecomputedVisibilityOverrideVolume::StaticClass(); \
	APrecomputedVisibilityVolume::StaticClass(); \
	AReverbVolume::StaticClass(); \
	ATriggerVolume::StaticClass(); \
	ADroppedPickup::StaticClass(); \
	GNativeLookupFuncs.Set(FName("DroppedPickup"), GEngineADroppedPickupNatives); \
	ADynamicSMActor::StaticClass(); \
	AInterpActor::StaticClass(); \
	AEmitter::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Emitter"), GEngineAEmitterNatives); \
	AEmitterPool::StaticClass(); \
	GNativeLookupFuncs.Set(FName("EmitterPool"), GEngineAEmitterPoolNatives); \
	AHUD::StaticClass(); \
	GNativeLookupFuncs.Set(FName("HUD"), GEngineAHUDNatives); \
	AInfo::StaticClass(); \
	AAutoTestManager::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AutoTestManager"), GEngineAAutoTestManagerNatives); \
	ACoverGroup::StaticClass(); \
	GNativeLookupFuncs.Set(FName("CoverGroup"), GEngineACoverGroupNatives); \
	AFileWriter::StaticClass(); \
	GNativeLookupFuncs.Set(FName("FileWriter"), GEngineAFileWriterNatives); \
	AFileLog::StaticClass(); \
	AGameInfo::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameInfo"), GEngineAGameInfoNatives); \
	AMutator::StaticClass(); \
	APotentialClimbWatcher::StaticClass(); \
	ARoute::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Route"), GEngineARouteNatives); \
	AWindPointSource::StaticClass(); \
	AZoneInfo::StaticClass(); \
	AInventory::StaticClass(); \
	AWeapon::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Weapon"), GEngineAWeaponNatives); \
	AInventoryManager::StaticClass(); \
	GNativeLookupFuncs.Set(FName("InventoryManager"), GEngineAInventoryManagerNatives); \
	AKeypoint::StaticClass(); \
	ATargetPoint::StaticClass(); \
	AMaterialInstanceActor::StaticClass(); \
	AMatineeActor::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MatineeActor"), GEngineAMatineeActorNatives); \
	ANavigationPoint::StaticClass(); \
	GNativeLookupFuncs.Set(FName("NavigationPoint"), GEngineANavigationPointNatives); \
	ACoverLink::StaticClass(); \
	GNativeLookupFuncs.Set(FName("CoverLink"), GEngineACoverLinkNatives); \
	ADoorMarker::StaticClass(); \
	ADynamicAnchor::StaticClass(); \
	ALadder::StaticClass(); \
	AAutoLadder::StaticClass(); \
	ALiftCenter::StaticClass(); \
	ALiftExit::StaticClass(); \
	APathNode::StaticClass(); \
	AVolumePathNode::StaticClass(); \
	APickupFactory::StaticClass(); \
	APlayerStart::StaticClass(); \
	APortalMarker::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PortalMarker"), GEngineAPortalMarkerNatives); \
	APylon::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Pylon"), GEngineAPylonNatives); \
	AAISwitchablePylon::StaticClass(); \
	ADynamicPylon::StaticClass(); \
	GNativeLookupFuncs.Set(FName("DynamicPylon"), GEngineADynamicPylonNatives); \
	ATeleporter::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Teleporter"), GEngineATeleporterNatives); \
	ANote::StaticClass(); \
	AProjectile::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Projectile"), GEngineAProjectileNatives); \
	ARigidBodyBase::StaticClass(); \
	ASceneCaptureActor::StaticClass(); \
	ASceneCapture2DActor::StaticClass(); \
	ASceneCaptureCubeMapActor::StaticClass(); \
	ASceneCaptureReflectActor::StaticClass(); \
	ASceneCapturePortalActor::StaticClass(); \
	APortalTeleporter::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PortalTeleporter"), GEngineAPortalTeleporterNatives); \
	AStaticMeshActorBase::StaticClass(); \
	AStaticMeshActor::StaticClass(); \
	AStaticMeshCollectionActor::StaticClass(); \
	AStaticMeshActorBasedOnExtremeContent::StaticClass(); \
	ATrigger::StaticClass(); \
	ATrigger_PawnsOnly::StaticClass(); \
	UActorComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("ActorComponent"), GEngineUActorComponentNatives); \
	UAudioComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AudioComponent"), GEngineUAudioComponentNatives); \
	USplineAudioComponent::StaticClass(); \
	UMultiCueSplineAudioComponent::StaticClass(); \
	USimpleSplineAudioComponent::StaticClass(); \
	USimpleSplineNonLoopAudioComponent::StaticClass(); \
	UHeightFogComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("HeightFogComponent"), GEngineUHeightFogComponentNatives); \
	UArrowComponent::StaticClass(); \
	UBrushComponent::StaticClass(); \
	UCameraConeComponent::StaticClass(); \
	UCylinderComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("CylinderComponent"), GEngineUCylinderComponentNatives); \
	UDrawBoxComponent::StaticClass(); \
	UDrawCapsuleComponent::StaticClass(); \
	UDrawConeComponent::StaticClass(); \
	UDrawCylinderComponent::StaticClass(); \
	UDrawFrustumComponent::StaticClass(); \
	UDrawQuadComponent::StaticClass(); \
	UDrawSphereComponent::StaticClass(); \
	UDrawPylonRadiusComponent::StaticClass(); \
	UDrawSoundRadiusComponent::StaticClass(); \
	ULevelGridVolumeRenderingComponent::StaticClass(); \
	ULineBatchComponent::StaticClass(); \
	UModelComponent::StaticClass(); \
	USpriteComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SpriteComponent"), GEngineUSpriteComponentNatives); \
	URadialBlurComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("RadialBlurComponent"), GEngineURadialBlurComponentNatives); \
	USceneCaptureComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SceneCaptureComponent"), GEngineUSceneCaptureComponentNatives); \
	USceneCapture2DComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SceneCapture2DComponent"), GEngineUSceneCapture2DComponentNatives); \
	USceneCapture2DHitMaskComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SceneCapture2DHitMaskComponent"), GEngineUSceneCapture2DHitMaskComponentNatives); \
	USceneCaptureCubeMapComponent::StaticClass(); \
	USceneCapturePortalComponent::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SceneCapturePortalComponent"), GEngineUSceneCapturePortalComponentNatives); \
	USceneCaptureReflectComponent::StaticClass(); \
	UWindDirectionalSourceComponent::StaticClass(); \
	UWindPointSourceComponent::StaticClass(); \
	UActorFactory::StaticClass(); \
	UActorFactoryActor::StaticClass(); \
	UActorFactoryAI::StaticClass(); \
	UActorFactoryAmbientSound::StaticClass(); \
	UActorFactoryAmbientSoundMovable::StaticClass(); \
	UActorFactoryAmbientSoundSimple::StaticClass(); \
	UActorFactoryAmbientSoundNonLoop::StaticClass(); \
	UActorFactoryAmbientSoundSimpleToggleable::StaticClass(); \
	UActorFactoryAmbientSoundNonLoopingToggleable::StaticClass(); \
	UActorFactoryApexDestructible::StaticClass(); \
	UActorFactoryArchetype::StaticClass(); \
	UActorFactoryCoverLink::StaticClass(); \
	UActorFactoryDominantDirectionalLight::StaticClass(); \
	UActorFactoryDominantDirectionalLightMovable::StaticClass(); \
	UActorFactoryDynamicSM::StaticClass(); \
	UActorFactoryMover::StaticClass(); \
	UActorFactoryRigidBody::StaticClass(); \
	UActorFactoryEmitter::StaticClass(); \
	UActorFactoryFracturedStaticMesh::StaticClass(); \
	UActorFactoryLensFlare::StaticClass(); \
	UActorFactoryLight::StaticClass(); \
	UActorFactoryPathNode::StaticClass(); \
	UActorFactoryPhysicsAsset::StaticClass(); \
	UActorFactoryPlayerStart::StaticClass(); \
	UActorFactoryPylon::StaticClass(); \
	UActorFactorySkeletalMesh::StaticClass(); \
	UActorFactoryStaticMesh::StaticClass(); \
	UActorFactoryTrigger::StaticClass(); \
	UActorFactoryVehicle::StaticClass(); \
	UBookMark::StaticClass(); \
	UBookMark2D::StaticClass(); \
	UKismetBookMark::StaticClass(); \
	UCanvas::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Canvas"), GEngineUCanvasNatives); \
	UChannel::StaticClass(); \
	UActorChannel::StaticClass(); \
	UControlChannel::StaticClass(); \
	UFileChannel::StaticClass(); \
	UVoiceChannel::StaticClass(); \
	UCheatManager::StaticClass(); \
	GNativeLookupFuncs.Set(FName("CheatManager"), GEngineUCheatManagerNatives); \
	UClient::StaticClass(); \
	UClipPadEntry::StaticClass(); \
	UCloudSaveSystem::StaticClass(); \
	GNativeLookupFuncs.Set(FName("CloudSaveSystem"), GEngineUCloudSaveSystemNatives); \
	UCodecMovie::StaticClass(); \
	UCodecMovieBink::StaticClass(); \
	UCodecMovieFallback::StaticClass(); \
	UCurveEdPresetCurve::StaticClass(); \
	UCustomPropertyItemHandler::StaticClass(); \
	UDamageType::StaticClass(); \
	UKillZDamageType::StaticClass(); \
	UDistributionFloatConstant::StaticClass(); \
	UDistributionFloatParameterBase::StaticClass(); \
	UDistributionFloatConstantCurve::StaticClass(); \
	UDistributionFloatUniform::StaticClass(); \
	UDistributionFloatUniformCurve::StaticClass(); \
	UDistributionFloatUniformRange::StaticClass(); \
	UDistributionVectorConstant::StaticClass(); \
	UDistributionVectorParameterBase::StaticClass(); \
	UDistributionVectorConstantCurve::StaticClass(); \
	UDistributionVectorUniform::StaticClass(); \
	UDistributionVectorUniformCurve::StaticClass(); \
	UDistributionVectorUniformRange::StaticClass(); \
	UDownload::StaticClass(); \
	UChannelDownload::StaticClass(); \
	UEdCoordSystem::StaticClass(); \
	UEditorLinkSelectionInterface::StaticClass(); \
	UEngineTypes::StaticClass(); \
	UFaceFXAnimSet::StaticClass(); \
	UFaceFXAsset::StaticClass(); \
	GNativeLookupFuncs.Set(FName("FaceFXAsset"), GEngineUFaceFXAssetNatives); \
	UFont::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Font"), GEngineUFontNatives); \
	UMultiFont::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MultiFont"), GEngineUMultiFontNatives); \
	UFontImportOptions::StaticClass(); \
	UForceFeedbackManager::StaticClass(); \
	UForceFeedbackWaveform::StaticClass(); \
	UGameplayEvents::StaticClass(); \
	UGameplayEventsReader::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameplayEventsReader"), GEngineUGameplayEventsReaderNatives); \
	UGameplayEventsWriterBase::StaticClass(); \
	UGameplayEventsUploadAnalytics::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameplayEventsUploadAnalytics"), GEngineUGameplayEventsUploadAnalyticsNatives); \
	UGameplayEventsWriter::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameplayEventsWriter"), GEngineUGameplayEventsWriterNatives); \
	UGameplayEventsHandler::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameplayEventsHandler"), GEngineUGameplayEventsHandlerNatives); \
	UGenericParamListStatEntry::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GenericParamListStatEntry"), GEngineUGenericParamListStatEntryNatives); \
	UGuidCache::StaticClass(); \
	UHttpBaseInterface::StaticClass(); \
	GNativeLookupFuncs.Set(FName("HttpBaseInterface"), GEngineUHttpBaseInterfaceNatives); \
	UHttpRequestInterface::StaticClass(); \
	GNativeLookupFuncs.Set(FName("HttpRequestInterface"), GEngineUHttpRequestInterfaceNatives); \
	UHttpResponseInterface::StaticClass(); \
	GNativeLookupFuncs.Set(FName("HttpResponseInterface"), GEngineUHttpResponseInterfaceNatives); \
	UIniLocPatcher::StaticClass(); \
	GNativeLookupFuncs.Set(FName("IniLocPatcher"), GEngineUIniLocPatcherNatives); \
	UInterface_NavigationHandle::StaticClass(); \
	UInterface_Speaker::StaticClass(); \
	UInterpCurveEdSetup::StaticClass(); \
	UInterpTrack::StaticClass(); \
	UJsonObject::StaticClass(); \
	GNativeLookupFuncs.Set(FName("JsonObject"), GEngineUJsonObjectNatives); \
	UKMeshProps::StaticClass(); \
	ULevelBase::StaticClass(); \
	ULevel::StaticClass(); \
	UPendingLevel::StaticClass(); \
	UDemoPlayPendingLevel::StaticClass(); \
	UNetPendingLevel::StaticClass(); \
	ULevelStreaming::StaticClass(); \
	ULevelStreamingAlwaysLoaded::StaticClass(); \
	ULevelStreamingDistance::StaticClass(); \
	ULevelStreamingKismet::StaticClass(); \
	ULevelStreamingPersistent::StaticClass(); \
	ULightmappedSurfaceCollection::StaticClass(); \
	UDEPRECATED_LightmassLevelSettings::StaticClass(); \
	ULightmassPrimitiveSettingsObject::StaticClass(); \
	UMapInfo::StaticClass(); \
	UModel::StaticClass(); \
	UMusicTrackDataStructures::StaticClass(); \
	UNavigationMeshBase::StaticClass(); \
	UNetDriver::StaticClass(); \
	UDemoRecDriver::StaticClass(); \
	UObjectReferencer::StaticClass(); \
	UOnlineAuthInterface::StaticClass(); \
	UOnlineMatchmakingStats::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineMatchmakingStats"), GEngineUOnlineMatchmakingStatsNatives); \
	UOnlinePlayerStorage::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlinePlayerStorage"), GEngineUOnlinePlayerStorageNatives); \
	UOnlineProfileSettings::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineProfileSettings"), GEngineUOnlineProfileSettingsNatives); \
	UOnlineStats::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineStats"), GEngineUOnlineStatsNatives); \
	UOnlineStatsRead::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineStatsRead"), GEngineUOnlineStatsReadNatives); \
	UOnlineStatsWrite::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineStatsWrite"), GEngineUOnlineStatsWriteNatives); \
	UOnlineSubsystem::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineSubsystem"), GEngineUOnlineSubsystemNatives); \
	UPackageMapLevel::StaticClass(); \
	UPackageMapSeekFree::StaticClass(); \
	UPatchScriptCommandlet::StaticClass(); \
	UMicroTransactionProxy::StaticClass(); \
	UPlayer::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Player"), GEngineUPlayerNatives); \
	ULocalPlayer::StaticClass(); \
	GNativeLookupFuncs.Set(FName("LocalPlayer"), GEngineULocalPlayerNatives); \
	UNetConnection::StaticClass(); \
	UChildConnection::StaticClass(); \
	UDemoRecConnection::StaticClass(); \
	UPolys::StaticClass(); \
	UPostProcessChain::StaticClass(); \
	UPostProcessEffect::StaticClass(); \
	UAmbientOcclusionEffect::StaticClass(); \
	UBlurEffect::StaticClass(); \
	UDOFEffect::StaticClass(); \
	UDOFAndBloomEffect::StaticClass(); \
	UDOFBloomMotionBlurEffect::StaticClass(); \
	UUberPostProcessEffect::StaticClass(); \
	UDwTriovizImplEffect::StaticClass(); \
	UMaterialEffect::StaticClass(); \
	UMotionBlurEffect::StaticClass(); \
	UPrimitiveComponentFactory::StaticClass(); \
	UMeshComponentFactory::StaticClass(); \
	UStaticMeshComponentFactory::StaticClass(); \
	UReachSpec::StaticClass(); \
	GNativeLookupFuncs.Set(FName("ReachSpec"), GEngineUReachSpecNatives); \
	UAdvancedReachSpec::StaticClass(); \
	UCeilingReachSpec::StaticClass(); \
	UForcedReachSpec::StaticClass(); \
	UCoverSlipReachSpec::StaticClass(); \
	UFloorToCeilingReachSpec::StaticClass(); \
	UMantleReachSpec::StaticClass(); \
	USlotToSlotReachSpec::StaticClass(); \
	USwatTurnReachSpec::StaticClass(); \
	UWallTransReachSpec::StaticClass(); \
	ULadderReachSpec::StaticClass(); \
	UProscribedReachSpec::StaticClass(); \
	UTeleportReachSpec::StaticClass(); \
	USavedMove::StaticClass(); \
	UDEPRECATED_SaveGameSummary::StaticClass(); \
	UScriptViewportClient::StaticClass(); \
	UGameViewportClient::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameViewportClient"), GEngineUGameViewportClientNatives); \
	USelection::StaticClass(); \
	UServerCommandlet::StaticClass(); \
	USettings::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Settings"), GEngineUSettingsNatives); \
	UOnlineGameSearch::StaticClass(); \
	GNativeLookupFuncs.Set(FName("OnlineGameSearch"), GEngineUOnlineGameSearchNatives); \
	UOnlineGameSettings::StaticClass(); \
	UShaderCache::StaticClass(); \
	UShadowMap1D::StaticClass(); \
	UShadowMap2D::StaticClass(); \
	USmokeTestCommandlet::StaticClass(); \
	USoundCue::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SoundCue"), GEngineUSoundCueNatives); \
	USpeechRecognition::StaticClass(); \
	UStaticMesh::StaticClass(); \
	UFracturedStaticMesh::StaticClass(); \
	USurface::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Surface"), GEngineUSurfaceNatives); \
	ULightMapTexture2D::StaticClass(); \
	UShadowMapTexture2D::StaticClass(); \
	UTranslationContext::StaticClass(); \
	GNativeLookupFuncs.Set(FName("TranslationContext"), GEngineUTranslationContextNatives); \
	UTranslatorTag::StaticClass(); \
	GNativeLookupFuncs.Set(FName("TranslatorTag"), GEngineUTranslatorTagNatives); \
	UStringsTag::StaticClass(); \
	GNativeLookupFuncs.Set(FName("StringsTag"), GEngineUStringsTagNatives); \
	UUIManager::StaticClass(); \
	GNativeLookupFuncs.Set(FName("UIManager"), GEngineUUIManagerNatives); \
	UWaveFormBase::StaticClass(); \
	UWorld::StaticClass(); \

#endif // ENGINE_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineAActorNatives[] = 
{ 
	MAP_NATIVE(AActor, execGetActorSpriteComponent)
	MAP_NATIVE(AActor, execGetActorMetrics)
	MAP_NATIVE(AActor, execShouldBeHiddenBySHOW_NavigationNodes)
	MAP_NATIVE(AActor, execWillOverlap)
	MAP_NATIVE(AActor, execGetAvoidanceVector)
	MAP_NATIVE(AActor, execSupportsKismetModification)
	MAP_NATIVE(AActor, execGetAnimTrailParticleSystem)
	MAP_NATIVE(AActor, execIsInPersistentLevel)
	MAP_NATIVE(AActor, execGetPackageGuid)
	MAP_NATIVE(AActor, execNativePostRenderFor)
	MAP_NATIVE(AActor, execSetHUDLocation)
	MAP_NATIVE(AActor, execGetTargetLocation)
	MAP_NATIVE(AActor, execGetTeamNum)
	MAP_NATIVE(AActor, execIsPlayerOwned)
	MAP_NATIVE(AActor, execPrestreamTextures)
	MAP_NATIVE(AActor, execSetNetUpdateTime)
	MAP_NATIVE(AActor, execGetGravityZ)
	MAP_NATIVE(AActor, execGetALocalPlayerController)
	MAP_NATIVE(AActor, execLocalPlayerControllers)
	MAP_NATIVE(AActor, execAllOwnedComponents)
	MAP_NATIVE(AActor, execComponentList)
	MAP_NATIVE(AActor, execOverlappingActors)
	MAP_NATIVE(AActor, execCollidingActors)
	MAP_NATIVE(AActor, execVisibleCollidingActors)
	MAP_NATIVE(AActor, execVisibleActors)
	MAP_NATIVE(AActor, execTraceActors)
	MAP_NATIVE(AActor, execTouchingActors)
	MAP_NATIVE(AActor, execBasedActors)
	MAP_NATIVE(AActor, execChildActors)
	MAP_NATIVE(AActor, execDynamicActors)
	MAP_NATIVE(AActor, execAllActors)
	MAP_NATIVE(AActor, execGetURLMap)
	MAP_NATIVE(AActor, execGetDestination)
	MAP_NATIVE(AActor, execCalculateMinSpeedTrajectory)
	MAP_NATIVE(AActor, execSuggestTossVelocity)
	MAP_NATIVE(AActor, execPlayerCanSeeMe)
	MAP_NATIVE(AActor, execMakeNoise)
	MAP_NATIVE(AActor, execPlaySound)
	MAP_NATIVE(AActor, execCreateAudioComponent)
	MAP_NATIVE(AActor, execResetTimerTimeDilation)
	MAP_NATIVE(AActor, execModifyTimerTimeDilation)
	MAP_NATIVE(AActor, execGetTimerRate)
	MAP_NATIVE(AActor, execGetTimerCount)
	MAP_NATIVE(AActor, execIsTimerActive)
	MAP_NATIVE(AActor, execPauseTimer)
	MAP_NATIVE(AActor, execClearAllTimers)
	MAP_NATIVE(AActor, execClearTimer)
	MAP_NATIVE(AActor, execSetTimer)
	MAP_NATIVE(AActor, execDestroy)
	MAP_NATIVE(AActor, execSpawn)
	MAP_NATIVE(AActor, execIsBlockedBy)
	MAP_NATIVE(AActor, execGetBoundingCylinder)
	MAP_NATIVE(AActor, execGetComponentsBoundingBox)
	MAP_NATIVE(AActor, execIsOverlapping)
	MAP_NATIVE(AActor, execContainsPoint)
	MAP_NATIVE(AActor, execFindSpot)
	MAP_NATIVE(AActor, execTraceAllPhysicsAssetInteractions)
	MAP_NATIVE(AActor, execFastTrace)
	MAP_NATIVE(AActor, execPointCheckComponent)
	MAP_NATIVE(AActor, execTraceComponent)
	MAP_NATIVE(AActor, execTrace)
	MAP_NATIVE(AActor, execClampRotation)
	MAP_NATIVE(AActor, execSetTickIsDisabled)
	MAP_NATIVE(AActor, execSetTickGroup)
	MAP_NATIVE(AActor, execReattachComponent)
	MAP_NATIVE(AActor, execDetachComponent)
	MAP_NATIVE(AActor, execAttachComponent)
	MAP_NATIVE(AActor, execUnClock)
	MAP_NATIVE(AActor, execClock)
	MAP_NATIVE(AActor, execSetPhysics)
	MAP_NATIVE(AActor, execSetOnlyOwnerSee)
	MAP_NATIVE(AActor, execSetHidden)
	MAP_NATIVE(AActor, execChartData)
	MAP_NATIVE(AActor, execFlushDebugStrings)
	MAP_NATIVE(AActor, execDrawDebugFrustrum)
	MAP_NATIVE(AActor, execDrawDebugString)
	MAP_NATIVE(AActor, execDrawDebugCone)
	MAP_NATIVE(AActor, execDrawDebugCylinder)
	MAP_NATIVE(AActor, execDrawDebugSphere)
	MAP_NATIVE(AActor, execDrawDebugCoordinateSystem)
	MAP_NATIVE(AActor, execDrawDebugStar)
	MAP_NATIVE(AActor, execDrawDebugBox)
	MAP_NATIVE(AActor, execDrawDebugPoint)
	MAP_NATIVE(AActor, execDrawDebugLine)
	MAP_NATIVE(AActor, execFlushPersistentDebugLines)
	MAP_NATIVE(AActor, execGetBasedPosition)
	MAP_NATIVE(AActor, execSetBasedPosition)
	MAP_NATIVE(AActor, execBP2Vect)
	MAP_NATIVE(AActor, execVect2BP)
	MAP_NATIVE(AActor, execSetForcedInitialReplicatedProperty)
	MAP_NATIVE(AActor, execGetAggregateBaseVelocity)
	MAP_NATIVE(AActor, execIsOwnedBy)
	MAP_NATIVE(AActor, execGetBaseMost)
	MAP_NATIVE(AActor, execIsBasedOn)
	MAP_NATIVE(AActor, execSearchForBaseBelow)
	MAP_NATIVE(AActor, execFindBase)
	MAP_NATIVE(AActor, execSetOwner)
	MAP_NATIVE(AActor, execSetBase)
	MAP_NATIVE(AActor, execGetTerminalVelocity)
	MAP_NATIVE(AActor, execAutonomousPhysics)
	MAP_NATIVE(AActor, execMoveSmooth)
	MAP_NATIVE(AActor, execfixedTurn)
	MAP_NATIVE(AActor, execSetShadowParentOnAllAttachedComponents)
	MAP_NATIVE(AActor, execSetHardAttach)
	MAP_NATIVE(AActor, execSetRelativeLocation)
	MAP_NATIVE(AActor, execSetRelativeRotation)
	MAP_NATIVE(AActor, execSetZone)
	MAP_NATIVE(AActor, execMovingWhichWay)
	MAP_NATIVE(AActor, execSetRotation)
	MAP_NATIVE(AActor, execSetLocation)
	MAP_NATIVE(AActor, execMove)
	MAP_NATIVE(AActor, execSetDrawScale3D)
	MAP_NATIVE(AActor, execSetDrawScale)
	MAP_NATIVE(AActor, execSetCollisionType)
	MAP_NATIVE(AActor, execSetCollisionSize)
	MAP_NATIVE(AActor, execSetCollision)
	MAP_NATIVE(AActor, execFinishAnim)
	MAP_NATIVE(AActor, execSleep)
	MAP_NATIVE(AActor, execConsoleCommand)
	MAP_NATIVE(AActor, execForceUpdateComponents)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAVolumeNatives[] = 
{ 
	MAP_NATIVE(AVolume, execEncompassesPoint)
	MAP_NATIVE(AVolume, execEncompasses)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAPhysicsVolumeNatives[] = 
{ 
	MAP_NATIVE(APhysicsVolume, execGetZoneVelocityForActor)
	MAP_NATIVE(APhysicsVolume, execGetGravityZ)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineADroppedPickupNatives[] = 
{ 
	MAP_NATIVE(ADroppedPickup, execRemoveFromNavigation)
	MAP_NATIVE(ADroppedPickup, execAddToNavigation)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAEmitterNatives[] = 
{ 
	MAP_NATIVE(AEmitter, execSetTemplate)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAEmitterPoolNatives[] = 
{ 
	MAP_NATIVE(AEmitterPool, execSpawnEmitterCustomLifetime)
	MAP_NATIVE(AEmitterPool, execSpawnEmitterMeshAttachment)
	MAP_NATIVE(AEmitterPool, execSpawnEmitter)
	MAP_NATIVE(AEmitterPool, execGetPooledComponent)
	MAP_NATIVE(AEmitterPool, execGetFreeMatInstConsts)
	MAP_NATIVE(AEmitterPool, execFreeMaterialInstanceConstants)
	MAP_NATIVE(AEmitterPool, execGetFreeStaticMeshComponent)
	MAP_NATIVE(AEmitterPool, execFreeStaticMeshComponents)
	MAP_NATIVE(AEmitterPool, execReturnToPool)
	MAP_NATIVE(AEmitterPool, execClearPoolComponents)
	MAP_NATIVE(AEmitterPool, execOnParticleSystemFinished)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAHUDNatives[] = 
{ 
	MAP_NATIVE(AHUD, execDrawActorOverlays)
	MAP_NATIVE(AHUD, execDraw2DLine)
	MAP_NATIVE(AHUD, execDraw3DLine)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAAutoTestManagerNatives[] = 
{ 
	MAP_NATIVE(AAutoTestManager, execDoMemoryTracking)
	MAP_NATIVE(AAutoTestManager, execDoSentinel_ViewDependentMemoryAtSpecificLocation)
	MAP_NATIVE(AAutoTestManager, execDoSentinel_PerfAtSpecificLocation)
	MAP_NATIVE(AAutoTestManager, execDoSentinel_MemoryAtSpecificLocation)
	MAP_NATIVE(AAutoTestManager, execGetTravelLocations)
	MAP_NATIVE(AAutoTestManager, execHandlePerLoadedMapAudioStats)
	MAP_NATIVE(AAutoTestManager, execDoSentinelActionPerLoadedMap)
	MAP_NATIVE(AAutoTestManager, execEndSentinelRun)
	MAP_NATIVE(AAutoTestManager, execAddSentinelPerTimePeriodStats)
	MAP_NATIVE(AAutoTestManager, execBeginSentinelRun)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineACoverGroupNatives[] = 
{ 
	MAP_NATIVE(ACoverGroup, execToggleGroup)
	MAP_NATIVE(ACoverGroup, execDisableGroup)
	MAP_NATIVE(ACoverGroup, execEnableGroup)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAFileWriterNatives[] = 
{ 
	MAP_NATIVE(AFileWriter, execLogf)
	MAP_NATIVE(AFileWriter, execCloseFile)
	MAP_NATIVE(AFileWriter, execOpenFile)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAGameInfoNatives[] = 
{ 
	MAP_NATIVE(AGameInfo, execEnableStandbyCheatDetection)
	MAP_NATIVE(AGameInfo, execSetBandwidthLimit)
	MAP_NATIVE(AGameInfo, execSwapPlayerControllers)
	MAP_NATIVE(AGameInfo, execGetNextPlayerID)
	MAP_NATIVE(AGameInfo, execRejectLogin)
	MAP_NATIVE(AGameInfo, execResumeLogin)
	MAP_NATIVE(AGameInfo, execPauseLogin)
	MAP_NATIVE(AGameInfo, execForceClearUnpauseDelegates)
	MAP_NATIVE(AGameInfo, execGetNetworkNumber)
	MAP_NATIVE(AGameInfo, execDoNavFearCostFallOff)
	MAP_NATIVE(AGameInfo, execShouldStartInCinematicMode)
	MAP_NATIVE(AGameInfo, execGetMapCommonPackageName)
	MAP_NATIVE(AGameInfo, execGetSupportedGameTypes)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineARouteNatives[] = 
{ 
	MAP_NATIVE(ARoute, execMoveOntoRoutePath)
	MAP_NATIVE(ARoute, execResolveRouteIndex)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAWeaponNatives[] = 
{ 
	MAP_NATIVE(AWeapon, execGetPhysicalFireStartLoc)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAInventoryManagerNatives[] = 
{ 
	MAP_NATIVE(AInventoryManager, execInventoryActors)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAMatineeActorNatives[] = 
{ 
	MAP_NATIVE(AMatineeActor, execAddAIGroupActor)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineANavigationPointNatives[] = 
{ 
	MAP_NATIVE(ANavigationPoint, execIsOnDifferentNetwork)
	MAP_NATIVE(ANavigationPoint, execGetAllNavInRadius)
	MAP_NATIVE(ANavigationPoint, execCanTeleport)
	MAP_NATIVE(ANavigationPoint, execIsUsableAnchorFor)
	MAP_NATIVE(ANavigationPoint, execGetReachSpecTo)
	MAP_NATIVE(ANavigationPoint, execGetBoundingCylinder)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineACoverLinkNatives[] = 
{ 
	MAP_NATIVE(ACoverLink, execGetLocationDescription)
	MAP_NATIVE(ACoverLink, execAddCoverSlot)
	MAP_NATIVE(ACoverLink, execGetSwatTurnTarget)
	MAP_NATIVE(ACoverLink, execIsEnabled)
	MAP_NATIVE(ACoverLink, execAutoAdjustSlot)
	MAP_NATIVE(ACoverLink, execGetSlotActions)
	MAP_NATIVE(ACoverLink, execHasFireLinkTo)
	MAP_NATIVE(ACoverLink, execGetFireLinkTo)
	MAP_NATIVE(ACoverLink, execGetSlotIdxToRight)
	MAP_NATIVE(ACoverLink, execGetSlotIdxToLeft)
	MAP_NATIVE(ACoverLink, execIsRightEdgeSlot)
	MAP_NATIVE(ACoverLink, execIsLeftEdgeSlot)
	MAP_NATIVE(ACoverLink, execIsEdgeSlot)
	MAP_NATIVE(ACoverLink, execFindSlots)
	MAP_NATIVE(ACoverLink, execIsValidClaimBetween)
	MAP_NATIVE(ACoverLink, execIsValidClaim)
	MAP_NATIVE(ACoverLink, execIsExposedTo)
	MAP_NATIVE(ACoverLink, execGetSlotViewPoint)
	MAP_NATIVE(ACoverLink, execGetSlotRotation)
	MAP_NATIVE(ACoverLink, execGetSlotLocation)
	MAP_NATIVE(ACoverLink, execUnPackFireLinkInteractionInfo)
	MAP_NATIVE(ACoverLink, execPackFireLinkInteractionInfo)
	MAP_NATIVE(ACoverLink, execGetFireLinkTargetCoverInfo)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAPortalMarkerNatives[] = 
{ 
	MAP_NATIVE(APortalMarker, execCanTeleport)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAPylonNatives[] = 
{ 
	MAP_NATIVE(APylon, execCanReachPylon)
	MAP_NATIVE(APylon, execFlushDynamicEdges)
	MAP_NATIVE(APylon, execUpdateMeshForPreExistingNavMeshObstacles)
	MAP_NATIVE(APylon, execOnPylonStatusChange)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineADynamicPylonNatives[] = 
{ 
	MAP_NATIVE(ADynamicPylon, execFlushDynamicEdges)
	MAP_NATIVE(ADynamicPylon, execRebuildDynamicEdges)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineATeleporterNatives[] = 
{ 
	MAP_NATIVE(ATeleporter, execCanTeleport)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAProjectileNatives[] = 
{ 
	MAP_NATIVE(AProjectile, execGetTeamNum)
	MAP_NATIVE(AProjectile, execInit)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAPortalTeleporterNatives[] = 
{ 
	MAP_NATIVE(APortalTeleporter, execCreatePortalTexture)
	MAP_NATIVE(APortalTeleporter, execTransformHitLocation)
	MAP_NATIVE(APortalTeleporter, execTransformVectorDir)
	MAP_NATIVE(APortalTeleporter, execTransformActor)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUActorComponentNatives[] = 
{ 
	MAP_NATIVE(UActorComponent, execDetachFromAny)
	MAP_NATIVE(UActorComponent, execForceUpdate)
	MAP_NATIVE(UActorComponent, execSetComponentRBFixed)
	MAP_NATIVE(UActorComponent, execSetTickGroup)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAudioComponentNatives[] = 
{ 
	MAP_NATIVE(UAudioComponent, execResetToDefaults)
	MAP_NATIVE(UAudioComponent, execSetWaveParameter)
	MAP_NATIVE(UAudioComponent, execSetFloatParameter)
	MAP_NATIVE(UAudioComponent, execAdjustVolume)
	MAP_NATIVE(UAudioComponent, execFadeOut)
	MAP_NATIVE(UAudioComponent, execFadeIn)
	MAP_NATIVE(UAudioComponent, execIsFadingOut)
	MAP_NATIVE(UAudioComponent, execIsFadingIn)
	MAP_NATIVE(UAudioComponent, execIsPlaying)
	MAP_NATIVE(UAudioComponent, execStop)
	MAP_NATIVE(UAudioComponent, execPlay)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUHeightFogComponentNatives[] = 
{ 
	MAP_NATIVE(UHeightFogComponent, execSetEnabled)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUCylinderComponentNatives[] = 
{ 
	MAP_NATIVE(UCylinderComponent, execSetCylinderSize)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSpriteComponentNatives[] = 
{ 
	MAP_NATIVE(USpriteComponent, execSetSpriteAndUV)
	MAP_NATIVE(USpriteComponent, execSetUV)
	MAP_NATIVE(USpriteComponent, execSetSprite)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineURadialBlurComponentNatives[] = 
{ 
	MAP_NATIVE(URadialBlurComponent, execSetEnabled)
	MAP_NATIVE(URadialBlurComponent, execSetBlurOpacity)
	MAP_NATIVE(URadialBlurComponent, execSetBlurFalloffExponent)
	MAP_NATIVE(URadialBlurComponent, execSetBlurScale)
	MAP_NATIVE(URadialBlurComponent, execSetMaterial)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSceneCaptureComponentNatives[] = 
{ 
	MAP_NATIVE(USceneCaptureComponent, execSetEnabled)
	MAP_NATIVE(USceneCaptureComponent, execSetFrameRate)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSceneCapture2DComponentNatives[] = 
{ 
	MAP_NATIVE(USceneCapture2DComponent, execSetView)
	MAP_NATIVE(USceneCapture2DComponent, execSetCaptureParameters)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSceneCapture2DHitMaskComponentNatives[] = 
{ 
	MAP_NATIVE(USceneCapture2DHitMaskComponent, execSetFadingStartTimeSinceHit)
	MAP_NATIVE(USceneCapture2DHitMaskComponent, execSetCaptureParameters)
	MAP_NATIVE(USceneCapture2DHitMaskComponent, execSetCaptureTargetTexture)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSceneCapturePortalComponentNatives[] = 
{ 
	MAP_NATIVE(USceneCapturePortalComponent, execSetCaptureParameters)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUCanvasNatives[] = 
{ 
	MAP_NATIVE(UCanvas, execDrawTextureDoubleLine)
	MAP_NATIVE(UCanvas, execDrawTextureLine)
	MAP_NATIVE(UCanvas, execDraw2DLine)
	MAP_NATIVE(UCanvas, execSetDrawColor)
	MAP_NATIVE(UCanvas, execDrawBlendedTile)
	MAP_NATIVE(UCanvas, execPopMaskRegion)
	MAP_NATIVE(UCanvas, execPushMaskRegion)
	MAP_NATIVE(UCanvas, execSetPos)
	MAP_NATIVE(UCanvas, execPopTransform)
	MAP_NATIVE(UCanvas, execPushTranslationMatrix)
	MAP_NATIVE(UCanvas, execDeProject)
	MAP_NATIVE(UCanvas, execProject)
	MAP_NATIVE(UCanvas, execDrawText)
	MAP_NATIVE(UCanvas, execTextSize)
	MAP_NATIVE(UCanvas, execStrLen)
	MAP_NATIVE(UCanvas, execDrawTris)
	MAP_NATIVE(UCanvas, execDrawTileStretched)
	MAP_NATIVE(UCanvas, execDrawTimer)
	MAP_NATIVE(UCanvas, execDrawRotatedMaterialTile)
	MAP_NATIVE(UCanvas, execDrawRotatedTile)
	MAP_NATIVE(UCanvas, execDrawMaterialTile)
	MAP_NATIVE(UCanvas, execPreOptimizeDrawTiles)
	MAP_NATIVE(UCanvas, execDrawTile)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUCheatManagerNatives[] = 
{ 
	MAP_NATIVE(UCheatManager, execGetAnalyticsUserId)
	MAP_NATIVE(UCheatManager, execDumpCoverStats)
	MAP_NATIVE(UCheatManager, execVerifyNavMeshCoverRefs)
	MAP_NATIVE(UCheatManager, execPrintNavMeshObstacles)
	MAP_NATIVE(UCheatManager, execPrintAllPathObjectEdges)
	MAP_NATIVE(UCheatManager, execDrawUnsupportingEdges)
	MAP_NATIVE(UCheatManager, execVerifyNavMeshObjects)
	MAP_NATIVE(UCheatManager, execLogParticleActivateSystemCalls)
	MAP_NATIVE(UCheatManager, execLogPlaySoundCalls)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUCloudSaveSystemNatives[] = 
{ 
	MAP_NATIVE(UCloudSaveSystem, execDeserializeObject)
	MAP_NATIVE(UCloudSaveSystem, execSerializeObject)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUFaceFXAssetNatives[] = 
{ 
	MAP_NATIVE(UFaceFXAsset, execUnmountFaceFXAnimSet)
	MAP_NATIVE(UFaceFXAsset, execMountFaceFXAnimSet)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUFontNatives[] = 
{ 
	MAP_NATIVE(UFont, execGetStringHeightAndWidth)
	MAP_NATIVE(UFont, execGetMaxCharHeight)
	MAP_NATIVE(UFont, execGetAuthoredViewportHeight)
	MAP_NATIVE(UFont, execGetScalingFactor)
	MAP_NATIVE(UFont, execGetResolutionPageIndex)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMultiFontNatives[] = 
{ 
	MAP_NATIVE(UMultiFont, execGetResolutionTestTableIndex)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUGameplayEventsReaderNatives[] = 
{ 
	MAP_NATIVE(UGameplayEventsReader, execGetSessionDuration)
	MAP_NATIVE(UGameplayEventsReader, execGetSessionEnd)
	MAP_NATIVE(UGameplayEventsReader, execGetSessionStart)
	MAP_NATIVE(UGameplayEventsReader, execGetSessionTimestamp)
	MAP_NATIVE(UGameplayEventsReader, execGetPlatform)
	MAP_NATIVE(UGameplayEventsReader, execGetTitleID)
	MAP_NATIVE(UGameplayEventsReader, execGetSessionID)
	MAP_NATIVE(UGameplayEventsReader, execProcessStreamEnd)
	MAP_NATIVE(UGameplayEventsReader, execProcessStream)
	MAP_NATIVE(UGameplayEventsReader, execProcessStreamStart)
	MAP_NATIVE(UGameplayEventsReader, execSerializeHeader)
	MAP_NATIVE(UGameplayEventsReader, execCloseStatsFile)
	MAP_NATIVE(UGameplayEventsReader, execOpenStatsFile)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUGameplayEventsUploadAnalyticsNatives[] = 
{ 
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogProjectileIntEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogDamageEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogWeaponIntEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogPlayerPlayerEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogPlayerKillDeath)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogAllPlayerPositionsEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogPlayerLoginChange)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogPlayerSpawnEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogPlayerStringEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogPlayerFloatEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogPlayerIntEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogTeamStringEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogTeamFloatEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogTeamIntEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogGamePositionEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogGameFloatEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogGameStringEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execLogGameIntEvent)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execEndLogging)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execResetLogging)
	MAP_NATIVE(UGameplayEventsUploadAnalytics, execStartLogging)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUGameplayEventsWriterNatives[] = 
{ 
	MAP_NATIVE(UGameplayEventsWriter, execGetGenericParamListEntry)
	MAP_NATIVE(UGameplayEventsWriter, execLogSystemPollEvents)
	MAP_NATIVE(UGameplayEventsWriter, execLogProjectileIntEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogDamageEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogWeaponIntEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogPlayerPlayerEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogPlayerKillDeath)
	MAP_NATIVE(UGameplayEventsWriter, execLogAllPlayerPositionsEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogPlayerLoginChange)
	MAP_NATIVE(UGameplayEventsWriter, execLogPlayerSpawnEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogPlayerStringEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogPlayerFloatEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogPlayerIntEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogTeamStringEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogTeamFloatEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogTeamIntEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogGamePositionEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogGameFloatEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogGameStringEvent)
	MAP_NATIVE(UGameplayEventsWriter, execLogGameIntEvent)
	MAP_NATIVE(UGameplayEventsWriter, execEndLogging)
	MAP_NATIVE(UGameplayEventsWriter, execResetLogging)
	MAP_NATIVE(UGameplayEventsWriter, execStartLogging)
	MAP_NATIVE(UGameplayEventsWriter, execSerializeFooter)
	MAP_NATIVE(UGameplayEventsWriter, execSerializeHeader)
	MAP_NATIVE(UGameplayEventsWriter, execCloseStatsFile)
	MAP_NATIVE(UGameplayEventsWriter, execOpenStatsFile)
	MAP_NATIVE(UGameplayEventsWriter, execResolvePlayerIndex)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUGameplayEventsHandlerNatives[] = 
{ 
	MAP_NATIVE(UGameplayEventsHandler, execPreProcessStream)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUGenericParamListStatEntryNatives[] = 
{ 
	MAP_NATIVE(UGenericParamListStatEntry, execCommitToDisk)
	MAP_NATIVE(UGenericParamListStatEntry, execGetString)
	MAP_NATIVE(UGenericParamListStatEntry, execGetVector)
	MAP_NATIVE(UGenericParamListStatEntry, execGetInt)
	MAP_NATIVE(UGenericParamListStatEntry, execGetFloat)
	MAP_NATIVE(UGenericParamListStatEntry, execAddString)
	MAP_NATIVE(UGenericParamListStatEntry, execAddVector)
	MAP_NATIVE(UGenericParamListStatEntry, execAddInt)
	MAP_NATIVE(UGenericParamListStatEntry, execAddFloat)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUHttpBaseInterfaceNatives[] = 
{ 
	MAP_NATIVE(UHttpBaseInterface, execGetContent)
	MAP_NATIVE(UHttpBaseInterface, execGetURL)
	MAP_NATIVE(UHttpBaseInterface, execGetContentLength)
	MAP_NATIVE(UHttpBaseInterface, execGetContentType)
	MAP_NATIVE(UHttpBaseInterface, execGetURLParameter)
	MAP_NATIVE(UHttpBaseInterface, execGetHeaders)
	MAP_NATIVE(UHttpBaseInterface, execGetHeader)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUHttpRequestInterfaceNatives[] = 
{ 
	MAP_NATIVE(UHttpRequestInterface, execProcessRequest)
	MAP_NATIVE(UHttpRequestInterface, execSetHeader)
	MAP_NATIVE(UHttpRequestInterface, execSetContentAsString)
	MAP_NATIVE(UHttpRequestInterface, execSetContent)
	MAP_NATIVE(UHttpRequestInterface, execSetURL)
	MAP_NATIVE(UHttpRequestInterface, execSetVerb)
	MAP_NATIVE(UHttpRequestInterface, execGetVerb)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUHttpResponseInterfaceNatives[] = 
{ 
	MAP_NATIVE(UHttpResponseInterface, execGetContentAsString)
	MAP_NATIVE(UHttpResponseInterface, execGetResponseCode)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUIniLocPatcherNatives[] = 
{ 
	MAP_NATIVE(UIniLocPatcher, execUpdateLocFileName)
	MAP_NATIVE(UIniLocPatcher, execProcessIniLocFile)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUJsonObjectNatives[] = 
{ 
	MAP_NATIVE(UJsonObject, execDecodeJson)
	MAP_NATIVE(UJsonObject, execEncodeJson)
	MAP_NATIVE(UJsonObject, execSetStringValue)
	MAP_NATIVE(UJsonObject, execSetObject)
	MAP_NATIVE(UJsonObject, execHasKey)
	MAP_NATIVE(UJsonObject, execGetStringValue)
	MAP_NATIVE(UJsonObject, execGetObject)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUOnlineMatchmakingStatsNatives[] = 
{ 
	MAP_NATIVE(UOnlineMatchmakingStats, execStopTimer)
	MAP_NATIVE(UOnlineMatchmakingStats, execStartTimer)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUOnlinePlayerStorageNatives[] = 
{ 
	MAP_NATIVE(UOnlinePlayerStorage, execSetDefaultVersionNumber)
	MAP_NATIVE(UOnlinePlayerStorage, execGetVersionNumber)
	MAP_NATIVE(UOnlinePlayerStorage, execAppendVersionToSettings)
	MAP_NATIVE(UOnlinePlayerStorage, execSetToDefaults)
	MAP_NATIVE(UOnlinePlayerStorage, execAddSettingFloat)
	MAP_NATIVE(UOnlinePlayerStorage, execAddSettingInt)
	MAP_NATIVE(UOnlinePlayerStorage, execGetRangedProfileSettingValue)
	MAP_NATIVE(UOnlinePlayerStorage, execSetRangedProfileSettingValue)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingRange)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingMappingIds)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingMappingType)
	MAP_NATIVE(UOnlinePlayerStorage, execSetProfileSettingValueFloat)
	MAP_NATIVE(UOnlinePlayerStorage, execSetProfileSettingValueInt)
	MAP_NATIVE(UOnlinePlayerStorage, execSetProfileSettingValueId)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingValueFloat)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingValueInt)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingValueFromListIndex)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingValueId)
	MAP_NATIVE(UOnlinePlayerStorage, execSetProfileSettingValue)
	MAP_NATIVE(UOnlinePlayerStorage, execSetProfileSettingValueByName)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingValueByName)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingValues)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingValueName)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingValue)
	MAP_NATIVE(UOnlinePlayerStorage, execIsProfileSettingIdMapped)
	MAP_NATIVE(UOnlinePlayerStorage, execFindDefaultProfileMappingIndexByName)
	MAP_NATIVE(UOnlinePlayerStorage, execFindProfileMappingIndexByName)
	MAP_NATIVE(UOnlinePlayerStorage, execFindProfileMappingIndex)
	MAP_NATIVE(UOnlinePlayerStorage, execFindProfileSettingIndex)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingColumnHeader)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingName)
	MAP_NATIVE(UOnlinePlayerStorage, execGetProfileSettingId)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUOnlineProfileSettingsNatives[] = 
{ 
	MAP_NATIVE(UOnlineProfileSettings, execAppendVersionToReadIds)
	MAP_NATIVE(UOnlineProfileSettings, execSetToDefaults)
	MAP_NATIVE(UOnlineProfileSettings, execGetProfileSettingDefaultFloat)
	MAP_NATIVE(UOnlineProfileSettings, execGetProfileSettingDefaultInt)
	MAP_NATIVE(UOnlineProfileSettings, execGetProfileSettingDefaultId)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUOnlineStatsNatives[] = 
{ 
	MAP_NATIVE(UOnlineStats, execGetViewName)
	MAP_NATIVE(UOnlineStats, execGetViewId)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUOnlineStatsReadNatives[] = 
{ 
	MAP_NATIVE(UOnlineStatsRead, execGetRankForPlayer)
	MAP_NATIVE(UOnlineStatsRead, execAddPlayer)
	MAP_NATIVE(UOnlineStatsRead, execIsStatZero)
	MAP_NATIVE(UOnlineStatsRead, execGetStatValueForPlayerAsString)
	MAP_NATIVE(UOnlineStatsRead, execSetFloatStatValueForPlayer)
	MAP_NATIVE(UOnlineStatsRead, execGetFloatStatValueForPlayer)
	MAP_NATIVE(UOnlineStatsRead, execSetIntStatValueForPlayer)
	MAP_NATIVE(UOnlineStatsRead, execGetIntStatValueForPlayer)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUOnlineStatsWriteNatives[] = 
{ 
	MAP_NATIVE(UOnlineStatsWrite, execDecrementIntStat)
	MAP_NATIVE(UOnlineStatsWrite, execDecrementFloatStat)
	MAP_NATIVE(UOnlineStatsWrite, execIncrementIntStat)
	MAP_NATIVE(UOnlineStatsWrite, execIncrementFloatStat)
	MAP_NATIVE(UOnlineStatsWrite, execSetIntStat)
	MAP_NATIVE(UOnlineStatsWrite, execSetFloatStat)
	MAP_NATIVE(UOnlineStatsWrite, execGetStatName)
	MAP_NATIVE(UOnlineStatsWrite, execGetStatId)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUOnlineSubsystemNatives[] = 
{ 
	MAP_NATIVE(UOnlineSubsystem, execGetNumSupportedLogins)
	MAP_NATIVE(UOnlineSubsystem, execGetBuildUniqueId)
	MAP_NATIVE(UOnlineSubsystem, execStringToUniqueNetId)
	MAP_NATIVE(UOnlineSubsystem, execUniqueNetIdToString)
	MAP_NATIVE(UOnlineSubsystem, execInit)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUPlayerNatives[] = 
{ 
	MAP_NATIVE(UPlayer, execSwitchController)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineULocalPlayerNatives[] = 
{ 
	MAP_NATIVE(ULocalPlayer, execFastProject)
	MAP_NATIVE(ULocalPlayer, execFastDeProject)
	MAP_NATIVE(ULocalPlayer, execProject)
	MAP_NATIVE(ULocalPlayer, execDeProject)
	MAP_NATIVE(ULocalPlayer, execTouchPlayerPostProcessChain)
	MAP_NATIVE(ULocalPlayer, execGetPostProcessChain)
	MAP_NATIVE(ULocalPlayer, execRemoveAllPostProcessingChains)
	MAP_NATIVE(ULocalPlayer, execRemovePostProcessingChain)
	MAP_NATIVE(ULocalPlayer, execInsertPostProcessingChain)
	MAP_NATIVE(ULocalPlayer, execGetTranslationContext)
	MAP_NATIVE(ULocalPlayer, execClearPostProcessSettingsOverride)
	MAP_NATIVE(ULocalPlayer, execOverridePostProcessSettingsCurve)
	MAP_NATIVE(ULocalPlayer, execOverridePostProcessSettings)
	MAP_NATIVE(ULocalPlayer, execGetActorVisibility)
	MAP_NATIVE(ULocalPlayer, execSendSplitJoin)
	MAP_NATIVE(ULocalPlayer, execSpawnPlayActor)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUReachSpecNatives[] = 
{ 
	MAP_NATIVE(UReachSpec, execGetDirection)
	MAP_NATIVE(UReachSpec, execGetEnd)
	MAP_NATIVE(UReachSpec, execCostFor)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUGameViewportClientNatives[] = 
{ 
	MAP_NATIVE(UGameViewportClient, execDebugSetUISystemEnabled)
	MAP_NATIVE(UGameViewportClient, execIsScaleformEnabled)
	MAP_NATIVE(UGameViewportClient, execDisableScaleform)
	MAP_NATIVE(UGameViewportClient, execEnableScaleform)
	MAP_NATIVE(UGameViewportClient, execFixupOwnerReferences)
	MAP_NATIVE(UGameViewportClient, execGetPlayerOwner)
	MAP_NATIVE(UGameViewportClient, execSetMouse)
	MAP_NATIVE(UGameViewportClient, execForceUpdateMouseCursor)
	MAP_NATIVE(UGameViewportClient, execNotifySplitscreenLayoutChanged)
	MAP_NATIVE(UGameViewportClient, execSetCustomInteractionObject)
	MAP_NATIVE(UGameViewportClient, execGetCustomInteractionClass)
	MAP_NATIVE(UGameViewportClient, execGetNumCustomInteractions)
	MAP_NATIVE(UGameViewportClient, execShouldForceFullscreenViewport)
	MAP_NATIVE(UGameViewportClient, execGetMousePosition)
	MAP_NATIVE(UGameViewportClient, execIsFullScreenViewport)
	MAP_NATIVE(UGameViewportClient, execGetViewportSize)
	MAP_NATIVE(UGameViewportClient, execConsoleCommand)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSettingsNatives[] = 
{ 
	MAP_NATIVE(USettings, execUpdateFromURL)
	MAP_NATIVE(USettings, execBuildURL)
	MAP_NATIVE(USettings, execAppendContextsToURL)
	MAP_NATIVE(USettings, execAppendPropertiesToURL)
	MAP_NATIVE(USettings, execAppendDataBindingsToURL)
	MAP_NATIVE(USettings, execGetQoSAdvertisedStringSettings)
	MAP_NATIVE(USettings, execGetQoSAdvertisedProperties)
	MAP_NATIVE(USettings, execGetRangedPropertyValue)
	MAP_NATIVE(USettings, execSetRangedPropertyValue)
	MAP_NATIVE(USettings, execGetPropertyRange)
	MAP_NATIVE(USettings, execGetPropertyMappingType)
	MAP_NATIVE(USettings, execHasStringSetting)
	MAP_NATIVE(USettings, execHasProperty)
	MAP_NATIVE(USettings, execUpdateProperties)
	MAP_NATIVE(USettings, execUpdateStringSettings)
	MAP_NATIVE(USettings, execGetPropertyType)
	MAP_NATIVE(USettings, execGetPropertyValueId)
	MAP_NATIVE(USettings, execSetPropertyValueId)
	MAP_NATIVE(USettings, execGetStringProperty)
	MAP_NATIVE(USettings, execSetStringProperty)
	MAP_NATIVE(USettings, execGetIntProperty)
	MAP_NATIVE(USettings, execSetIntProperty)
	MAP_NATIVE(USettings, execGetFloatProperty)
	MAP_NATIVE(USettings, execSetFloatProperty)
	MAP_NATIVE(USettings, execSetPropertyFromStringByName)
	MAP_NATIVE(USettings, execGetPropertyAsStringByName)
	MAP_NATIVE(USettings, execGetPropertyAsString)
	MAP_NATIVE(USettings, execGetPropertyColumnHeader)
	MAP_NATIVE(USettings, execGetPropertyName)
	MAP_NATIVE(USettings, execGetPropertyId)
	MAP_NATIVE(USettings, execSetStringSettingValueFromStringByName)
	MAP_NATIVE(USettings, execGetStringSettingValueNameByName)
	MAP_NATIVE(USettings, execGetStringSettingValueName)
	MAP_NATIVE(USettings, execIsWildcardStringSetting)
	MAP_NATIVE(USettings, execGetStringSettingColumnHeader)
	MAP_NATIVE(USettings, execGetStringSettingName)
	MAP_NATIVE(USettings, execGetStringSettingId)
	MAP_NATIVE(USettings, execGetStringSettingValueByName)
	MAP_NATIVE(USettings, execSetStringSettingValueByName)
	MAP_NATIVE(USettings, execGetStringSettingValueNames)
	MAP_NATIVE(USettings, execIncrementStringSettingValue)
	MAP_NATIVE(USettings, execGetStringSettingValue)
	MAP_NATIVE(USettings, execSetStringSettingValue)
	MAP_NATIVE(USettings, execGetSettingsDataDateTime)
	MAP_NATIVE(USettings, execGetSettingsDataBlob)
	MAP_NATIVE(USettings, execGetSettingsDataInt)
	MAP_NATIVE(USettings, execGetSettingsDataFloat)
	MAP_NATIVE(USettings, execEmptySettingsData)
	MAP_NATIVE(USettings, execSetSettingsData)
	MAP_NATIVE(USettings, execSetSettingsDataBlob)
	MAP_NATIVE(USettings, execSetSettingsDataDateTime)
	MAP_NATIVE(USettings, execSetSettingsDataInt)
	MAP_NATIVE(USettings, execSetSettingsDataFloat)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUOnlineGameSearchNatives[] = 
{ 
	MAP_NATIVE(UOnlineGameSearch, execSortSearchResults)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSoundCueNatives[] = 
{ 
	MAP_NATIVE(USoundCue, execGetCueDuration)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSurfaceNatives[] = 
{ 
	MAP_NATIVE(USurface, execGetSurfaceHeight)
	MAP_NATIVE(USurface, execGetSurfaceWidth)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUTranslationContextNatives[] = 
{ 
	MAP_NATIVE(UTranslationContext, execRegisterTranslatorTag)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUTranslatorTagNatives[] = 
{ 
	MAP_NATIVE(UTranslatorTag, execTranslate)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUStringsTagNatives[] = 
{ 
	MAP_NATIVE(UStringsTag, execTranslate)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUUIManagerNatives[] = 
{ 
	MAP_NATIVE(UUIManager, execCanUnpauseInternalUI)
	MAP_NATIVE(UUIManager, execGetUIManager)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(AActor,Actor,Components)
VERIFY_CLASS_OFFSET_NODIE(AActor,Actor,LatentActions)
VERIFY_CLASS_SIZE_NODIE(AActor)
VERIFY_CLASS_OFFSET_NODIE(ABrush,Brush,CsgOper)
VERIFY_CLASS_OFFSET_NODIE(ABrush,Brush,SavedSelections)
VERIFY_CLASS_SIZE_NODIE(ABrush)
VERIFY_CLASS_SIZE_NODIE(ABrushShape)
VERIFY_CLASS_OFFSET_NODIE(AVolume,Volume,AssociatedActor)
VERIFY_CLASS_SIZE_NODIE(AVolume)
VERIFY_CLASS_SIZE_NODIE(ABlockingVolume)
VERIFY_CLASS_SIZE_NODIE(ADynamicBlockingVolume)
VERIFY_CLASS_OFFSET_NODIE(ACullDistanceVolume,CullDistanceVolume,CullDistances)
VERIFY_CLASS_SIZE_NODIE(ACullDistanceVolume)
VERIFY_CLASS_OFFSET_NODIE(ALevelGridVolume,LevelGridVolume,LevelGridVolumeName)
VERIFY_CLASS_OFFSET_NODIE(ALevelGridVolume,LevelGridVolume,CellConvexElem)
VERIFY_CLASS_SIZE_NODIE(ALevelGridVolume)
VERIFY_CLASS_OFFSET_NODIE(ALevelStreamingVolume,LevelStreamingVolume,StreamingLevels)
VERIFY_CLASS_OFFSET_NODIE(ALevelStreamingVolume,LevelStreamingVolume,TestVolumeDistance)
VERIFY_CLASS_SIZE_NODIE(ALevelStreamingVolume)
VERIFY_CLASS_SIZE_NODIE(ALightmassCharacterIndirectDetailVolume)
VERIFY_CLASS_SIZE_NODIE(ALightmassImportanceVolume)
VERIFY_CLASS_SIZE_NODIE(AMassiveLODOverrideVolume)
VERIFY_CLASS_SIZE_NODIE(APathBlockingVolume)
VERIFY_CLASS_OFFSET_NODIE(APhysicsVolume,PhysicsVolume,ZoneVelocity)
VERIFY_CLASS_OFFSET_NODIE(APhysicsVolume,PhysicsVolume,NextPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(APhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(ADefaultPhysicsVolume)
VERIFY_CLASS_OFFSET_NODIE(AGravityVolume,GravityVolume,GravityZ)
VERIFY_CLASS_SIZE_NODIE(AGravityVolume)
VERIFY_CLASS_OFFSET_NODIE(ALadderVolume,LadderVolume,WallDir)
VERIFY_CLASS_OFFSET_NODIE(ALadderVolume,LadderVolume,WallDirArrow)
VERIFY_CLASS_SIZE_NODIE(ALadderVolume)
VERIFY_CLASS_OFFSET_NODIE(APortalVolume,PortalVolume,Portals)
VERIFY_CLASS_SIZE_NODIE(APortalVolume)
VERIFY_CLASS_OFFSET_NODIE(APostProcessVolume,PostProcessVolume,Priority)
VERIFY_CLASS_OFFSET_NODIE(APostProcessVolume,PostProcessVolume,NextLowerPriorityVolume)
VERIFY_CLASS_SIZE_NODIE(APostProcessVolume)
VERIFY_CLASS_OFFSET_NODIE(APrecomputedVisibilityOverrideVolume,PrecomputedVisibilityOverrideVolume,OverrideVisibleActors)
VERIFY_CLASS_OFFSET_NODIE(APrecomputedVisibilityOverrideVolume,PrecomputedVisibilityOverrideVolume,OverrideInvisibleActors)
VERIFY_CLASS_SIZE_NODIE(APrecomputedVisibilityOverrideVolume)
VERIFY_CLASS_SIZE_NODIE(APrecomputedVisibilityVolume)
VERIFY_CLASS_OFFSET_NODIE(AReverbVolume,ReverbVolume,Priority)
VERIFY_CLASS_OFFSET_NODIE(AReverbVolume,ReverbVolume,NextLowerPriorityVolume)
VERIFY_CLASS_SIZE_NODIE(AReverbVolume)
VERIFY_CLASS_SIZE_NODIE(ATriggerVolume)
VERIFY_CLASS_OFFSET_NODIE(ADroppedPickup,DroppedPickup,Inventory)
VERIFY_CLASS_OFFSET_NODIE(ADroppedPickup,DroppedPickup,PickupCache)
VERIFY_CLASS_SIZE_NODIE(ADroppedPickup)
VERIFY_CLASS_OFFSET_NODIE(ADynamicSMActor,DynamicSMActor,StaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(ADynamicSMActor,DynamicSMActor,ReplicatedMeshScale3D)
VERIFY_CLASS_SIZE_NODIE(ADynamicSMActor)
VERIFY_CLASS_OFFSET_NODIE(AInterpActor,InterpActor,MyMarker)
VERIFY_CLASS_OFFSET_NODIE(AInterpActor,InterpActor,AmbientSoundComponent)
VERIFY_CLASS_SIZE_NODIE(AInterpActor)
VERIFY_CLASS_OFFSET_NODIE(AEmitter,Emitter,ParticleSystemComponent)
VERIFY_CLASS_OFFSET_NODIE(AEmitter,Emitter,LightEnvironment)
VERIFY_CLASS_SIZE_NODIE(AEmitter)
VERIFY_CLASS_OFFSET_NODIE(AEmitterPool,EmitterPool,PSCTemplate)
VERIFY_CLASS_OFFSET_NODIE(AEmitterPool,EmitterPool,FreeMatInstConsts)
VERIFY_CLASS_SIZE_NODIE(AEmitterPool)
VERIFY_CLASS_OFFSET_NODIE(AHUD,HUD,WhiteColor)
VERIFY_CLASS_OFFSET_NODIE(AHUD,HUD,KismetTextInfo)
VERIFY_CLASS_SIZE_NODIE(AHUD)
VERIFY_CLASS_SIZE_NODIE(AInfo)
VERIFY_CLASS_OFFSET_NODIE(AAutoTestManager,AutoTestManager,AutomatedPerfRemainingTime)
VERIFY_CLASS_OFFSET_NODIE(AAutoTestManager,AutoTestManager,CommandStringToExec)
VERIFY_CLASS_SIZE_NODIE(AAutoTestManager)
VERIFY_CLASS_OFFSET_NODIE(ACoverGroup,CoverGroup,CoverLinkRefs)
VERIFY_CLASS_OFFSET_NODIE(ACoverGroup,CoverGroup,AutoSelectHeight)
VERIFY_CLASS_SIZE_NODIE(ACoverGroup)
VERIFY_CLASS_OFFSET_NODIE(AFileWriter,FileWriter,ArchivePtr)
VERIFY_CLASS_OFFSET_NODIE(AFileWriter,FileWriter,FileType)
VERIFY_CLASS_SIZE_NODIE(AFileWriter)
VERIFY_CLASS_SIZE_NODIE(AFileLog)
VERIFY_CLASS_OFFSET_NODIE(AGameInfo,GameInfo,CauseEventCommand)
VERIFY_CLASS_OFFSET_NODIE(AGameInfo,GameInfo,__CanUnpause__Delegate)
VERIFY_CLASS_SIZE_NODIE(AGameInfo)
VERIFY_CLASS_OFFSET_NODIE(AMutator,Mutator,NextMutator)
VERIFY_CLASS_OFFSET_NODIE(AMutator,Mutator,GroupNames)
VERIFY_CLASS_SIZE_NODIE(AMutator)
VERIFY_CLASS_SIZE_NODIE(APotentialClimbWatcher)
VERIFY_CLASS_OFFSET_NODIE(ARoute,Route,RouteType)
VERIFY_CLASS_OFFSET_NODIE(ARoute,Route,RouteIndexOffset)
VERIFY_CLASS_SIZE_NODIE(ARoute)
VERIFY_CLASS_OFFSET_NODIE(AWindPointSource,WindPointSource,Component)
VERIFY_CLASS_SIZE_NODIE(AWindPointSource)
VERIFY_CLASS_OFFSET_NODIE(AZoneInfo,ZoneInfo,KillZ)
VERIFY_CLASS_OFFSET_NODIE(AZoneInfo,ZoneInfo,KillZDamageType)
VERIFY_CLASS_SIZE_NODIE(AZoneInfo)
VERIFY_CLASS_OFFSET_NODIE(AInventory,Inventory,Inventory)
VERIFY_CLASS_OFFSET_NODIE(AInventory,Inventory,DroppedPickupParticles)
VERIFY_CLASS_SIZE_NODIE(AInventory)
VERIFY_CLASS_OFFSET_NODIE(AWeapon,Weapon,CurrentFireMode)
VERIFY_CLASS_OFFSET_NODIE(AWeapon,Weapon,CachedMaxRange)
VERIFY_CLASS_SIZE_NODIE(AWeapon)
VERIFY_CLASS_OFFSET_NODIE(AInventoryManager,InventoryManager,InventoryChain)
VERIFY_CLASS_OFFSET_NODIE(AInventoryManager,InventoryManager,PendingFire)
VERIFY_CLASS_SIZE_NODIE(AInventoryManager)
VERIFY_CLASS_OFFSET_NODIE(AKeypoint,Keypoint,SpriteComp)
VERIFY_CLASS_SIZE_NODIE(AKeypoint)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(ATargetPoint,TargetPoint,SpawnSpriteTexture)
#else
VERIFY_CLASS_OFFSET_NODIE(ATargetPoint,TargetPoint,SpawnRefCount)
#endif
VERIFY_CLASS_OFFSET_NODIE(ATargetPoint,TargetPoint,SpawnRefCount)
VERIFY_CLASS_SIZE_NODIE(ATargetPoint)
VERIFY_CLASS_OFFSET_NODIE(AMaterialInstanceActor,MaterialInstanceActor,MatInst)
VERIFY_CLASS_SIZE_NODIE(AMaterialInstanceActor)
VERIFY_CLASS_OFFSET_NODIE(AMatineeActor,MatineeActor,InterpAction)
VERIFY_CLASS_OFFSET_NODIE(AMatineeActor,MatineeActor,ClientSidePositionErrorTolerance)
VERIFY_CLASS_SIZE_NODIE(AMatineeActor)
VERIFY_CLASS_OFFSET_NODIE(ANavigationPoint,NavigationPoint,NavOctreeObject)
VERIFY_CLASS_OFFSET_NODIE(ANavigationPoint,NavigationPoint,LastAnchoredPawnTime)
VERIFY_CLASS_SIZE_NODIE(ANavigationPoint)
VERIFY_CLASS_OFFSET_NODIE(ACoverLink,CoverLink,LeanTraceDist)
VERIFY_CLASS_OFFSET_NODIE(ACoverLink,CoverLink,LocationDescription)
VERIFY_CLASS_SIZE_NODIE(ACoverLink)
VERIFY_CLASS_OFFSET_NODIE(ADoorMarker,DoorMarker,MyDoor)
VERIFY_CLASS_OFFSET_NODIE(ADoorMarker,DoorMarker,DoorTrigger)
VERIFY_CLASS_SIZE_NODIE(ADoorMarker)
VERIFY_CLASS_OFFSET_NODIE(ADynamicAnchor,DynamicAnchor,CurrentUser)
VERIFY_CLASS_SIZE_NODIE(ADynamicAnchor)
VERIFY_CLASS_OFFSET_NODIE(ALadder,Ladder,MyLadder)
VERIFY_CLASS_OFFSET_NODIE(ALadder,Ladder,LadderList)
VERIFY_CLASS_SIZE_NODIE(ALadder)
VERIFY_CLASS_SIZE_NODIE(AAutoLadder)
VERIFY_CLASS_OFFSET_NODIE(ALiftCenter,LiftCenter,MyLift)
VERIFY_CLASS_OFFSET_NODIE(ALiftCenter,LiftCenter,LiftTrigger)
VERIFY_CLASS_SIZE_NODIE(ALiftCenter)
VERIFY_CLASS_OFFSET_NODIE(ALiftExit,LiftExit,MyLiftCenter)
VERIFY_CLASS_SIZE_NODIE(ALiftExit)
VERIFY_CLASS_SIZE_NODIE(APathNode)
VERIFY_CLASS_OFFSET_NODIE(AVolumePathNode,VolumePathNode,StartingRadius)
VERIFY_CLASS_OFFSET_NODIE(AVolumePathNode,VolumePathNode,StartingHeight)
VERIFY_CLASS_SIZE_NODIE(AVolumePathNode)
VERIFY_CLASS_OFFSET_NODIE(APickupFactory,PickupFactory,InventoryType)
VERIFY_CLASS_OFFSET_NODIE(APickupFactory,PickupFactory,OriginalFactory)
VERIFY_CLASS_SIZE_NODIE(APickupFactory)
VERIFY_CLASS_OFFSET_NODIE(APlayerStart,PlayerStart,TeamIndex)
VERIFY_CLASS_OFFSET_NODIE(APlayerStart,PlayerStart,SelectionIndex)
VERIFY_CLASS_SIZE_NODIE(APlayerStart)
VERIFY_CLASS_OFFSET_NODIE(APortalMarker,PortalMarker,MyPortal)
VERIFY_CLASS_SIZE_NODIE(APortalMarker)
VERIFY_CLASS_OFFSET_NODIE(APylon,Pylon,NavMeshPtr)
VERIFY_CLASS_OFFSET_NODIE(APylon,Pylon,DebugPathStartLocation)
VERIFY_CLASS_SIZE_NODIE(APylon)
VERIFY_CLASS_SIZE_NODIE(AAISwitchablePylon)
VERIFY_CLASS_SIZE_NODIE(ADynamicPylon)
VERIFY_CLASS_OFFSET_NODIE(ATeleporter,Teleporter,URL)
VERIFY_CLASS_OFFSET_NODIE(ATeleporter,Teleporter,LastFired)
VERIFY_CLASS_SIZE_NODIE(ATeleporter)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(ANote,Note,Text)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(ANote,Note,Text)
#endif
VERIFY_CLASS_SIZE_NODIE(ANote)
VERIFY_CLASS_OFFSET_NODIE(AProjectile,Projectile,Speed)
VERIFY_CLASS_OFFSET_NODIE(AProjectile,Projectile,CylinderComponent)
VERIFY_CLASS_SIZE_NODIE(AProjectile)
VERIFY_CLASS_SIZE_NODIE(ARigidBodyBase)
VERIFY_CLASS_OFFSET_NODIE(ASceneCaptureActor,SceneCaptureActor,SceneCapture)
VERIFY_CLASS_SIZE_NODIE(ASceneCaptureActor)
VERIFY_CLASS_OFFSET_NODIE(ASceneCapture2DActor,SceneCapture2DActor,DrawFrustum)
VERIFY_CLASS_SIZE_NODIE(ASceneCapture2DActor)
VERIFY_CLASS_OFFSET_NODIE(ASceneCaptureCubeMapActor,SceneCaptureCubeMapActor,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(ASceneCaptureCubeMapActor,SceneCaptureCubeMapActor,CubeMaterialInst)
VERIFY_CLASS_SIZE_NODIE(ASceneCaptureCubeMapActor)
VERIFY_CLASS_OFFSET_NODIE(ASceneCaptureReflectActor,SceneCaptureReflectActor,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(ASceneCaptureReflectActor,SceneCaptureReflectActor,ReflectMaterialInst)
VERIFY_CLASS_SIZE_NODIE(ASceneCaptureReflectActor)
VERIFY_CLASS_SIZE_NODIE(ASceneCapturePortalActor)
VERIFY_CLASS_OFFSET_NODIE(APortalTeleporter,PortalTeleporter,SisterPortal)
VERIFY_CLASS_OFFSET_NODIE(APortalTeleporter,PortalTeleporter,MyMarker)
VERIFY_CLASS_SIZE_NODIE(APortalTeleporter)
VERIFY_CLASS_SIZE_NODIE(AStaticMeshActorBase)
VERIFY_CLASS_OFFSET_NODIE(AStaticMeshActor,StaticMeshActor,StaticMeshComponent)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AStaticMeshActor,StaticMeshActor,OldCollisionType)
#endif
VERIFY_CLASS_SIZE_NODIE(AStaticMeshActor)
VERIFY_CLASS_OFFSET_NODIE(AStaticMeshCollectionActor,StaticMeshCollectionActor,StaticMeshComponents)
VERIFY_CLASS_OFFSET_NODIE(AStaticMeshCollectionActor,StaticMeshCollectionActor,MaxStaticMeshComponents)
VERIFY_CLASS_SIZE_NODIE(AStaticMeshCollectionActor)
VERIFY_CLASS_OFFSET_NODIE(AStaticMeshActorBasedOnExtremeContent,StaticMeshActorBasedOnExtremeContent,StaticMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(AStaticMeshActorBasedOnExtremeContent,StaticMeshActorBasedOnExtremeContent,NonExtremeContent)
VERIFY_CLASS_SIZE_NODIE(AStaticMeshActorBasedOnExtremeContent)
VERIFY_CLASS_OFFSET_NODIE(ATrigger,Trigger,CylinderComponent)
VERIFY_CLASS_OFFSET_NODIE(ATrigger,Trigger,AITriggerDelay)
VERIFY_CLASS_SIZE_NODIE(ATrigger)
VERIFY_CLASS_SIZE_NODIE(ATrigger_PawnsOnly)
VERIFY_CLASS_OFFSET_NODIE(UActorComponent,ActorComponent,Scene)
VERIFY_CLASS_OFFSET_NODIE(UActorComponent,ActorComponent,Owner)
VERIFY_CLASS_OFFSET_NODIE(UActorComponent,ActorComponent,TickGroup)
VERIFY_CLASS_SIZE_NODIE(UActorComponent)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,SoundCue)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CueFirstNode)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,InstanceParameters)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,StereoBleed)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,LFEBleed)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,WaveInstances)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,SoundNodeData)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,SoundNodeOffsetMap)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,SoundNodeResetWaveMap)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,Listener)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,PlaybackTime)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,PortalVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,Location)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,ComponentLocation)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,LastOwner)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,SubtitlePriority)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,FadeInStartTime)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,FadeInStopTime)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,FadeInTargetVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,FadeOutStartTime)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,FadeOutStopTime)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,FadeOutTargetVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,AdjustVolumeStartTime)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,AdjustVolumeStopTime)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,AdjustVolumeTargetVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrAdjustVolumeTargetVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentNotifyBufferFinishedHook)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentLocation)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentVelocity)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentPitch)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentHighFrequencyGain)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentUseSpatialization)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentNotifyOnLoop)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,OmniRadius)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentVolumeMultiplier)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentPitchMultiplier)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentHighFrequencyGainMultiplier)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentVoiceCenterChannelVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentRadioFilterVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentRadioFilterVolumeThreshold)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,LastUpdateTime)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,SourceInteriorVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,SourceInteriorLPF)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentInteriorVolume)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,CurrentInteriorLPF)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,LastLocation)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,LastInteriorSettings)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,LastReverbVolumeIndex)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,VolumeMultiplier)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,PitchMultiplier)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,HighFrequencyGainMultiplier)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,OcclusionCheckInterval)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,LastOcclusionCheckTime)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,PreviewSoundRadius)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,__OnAudioFinished__Delegate)
VERIFY_CLASS_OFFSET_NODIE(UAudioComponent,AudioComponent,__OnQueueSubtitles__Delegate)
VERIFY_CLASS_SIZE_NODIE(UAudioComponent)
VERIFY_CLASS_OFFSET_NODIE(USplineAudioComponent,SplineAudioComponent,ListenerScopeRadius)
VERIFY_CLASS_OFFSET_NODIE(USplineAudioComponent,SplineAudioComponent,Points)
VERIFY_CLASS_SIZE_NODIE(USplineAudioComponent)
VERIFY_CLASS_OFFSET_NODIE(UMultiCueSplineAudioComponent,MultiCueSplineAudioComponent,SoundSlots)
VERIFY_CLASS_OFFSET_NODIE(UMultiCueSplineAudioComponent,MultiCueSplineAudioComponent,CurrentSlotIndex)
VERIFY_CLASS_SIZE_NODIE(UMultiCueSplineAudioComponent)
VERIFY_CLASS_OFFSET_NODIE(USimpleSplineAudioComponent,SimpleSplineAudioComponent,LPFRadiusMin)
VERIFY_CLASS_OFFSET_NODIE(USimpleSplineAudioComponent,SimpleSplineAudioComponent,NotifyBufferFinishedHook)
VERIFY_CLASS_SIZE_NODIE(USimpleSplineAudioComponent)
VERIFY_CLASS_OFFSET_NODIE(USimpleSplineNonLoopAudioComponent,SimpleSplineNonLoopAudioComponent,DelayMin)
VERIFY_CLASS_OFFSET_NODIE(USimpleSplineNonLoopAudioComponent,SimpleSplineNonLoopAudioComponent,NextSoundTime)
VERIFY_CLASS_SIZE_NODIE(USimpleSplineNonLoopAudioComponent)
VERIFY_CLASS_OFFSET_NODIE(UHeightFogComponent,HeightFogComponent,Height)
VERIFY_CLASS_OFFSET_NODIE(UHeightFogComponent,HeightFogComponent,StartDistance)
VERIFY_CLASS_SIZE_NODIE(UHeightFogComponent)
VERIFY_CLASS_OFFSET_NODIE(UArrowComponent,ArrowComponent,ArrowColor)
VERIFY_CLASS_OFFSET_NODIE(UArrowComponent,ArrowComponent,ArrowSize)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UArrowComponent,ArrowComponent,SpriteCategoryName)
#endif
VERIFY_CLASS_SIZE_NODIE(UArrowComponent)
VERIFY_CLASS_OFFSET_NODIE(UBrushComponent,BrushComponent,Brush)
VERIFY_CLASS_OFFSET_NODIE(UBrushComponent,BrushComponent,BrushAggGeom)
VERIFY_CLASS_OFFSET_NODIE(UBrushComponent,BrushComponent,BrushPhysDesc)
VERIFY_CLASS_OFFSET_NODIE(UBrushComponent,BrushComponent,CachedPhysBrushData)
VERIFY_CLASS_OFFSET_NODIE(UBrushComponent,BrushComponent,CachedPhysBrushDataVersion)
VERIFY_CLASS_SIZE_NODIE(UBrushComponent)
VERIFY_CLASS_SIZE_NODIE(UCameraConeComponent)
VERIFY_CLASS_OFFSET_NODIE(UCylinderComponent,CylinderComponent,CollisionHeight)
VERIFY_CLASS_OFFSET_NODIE(UCylinderComponent,CylinderComponent,CollisionRadius)
VERIFY_CLASS_OFFSET_NODIE(UCylinderComponent,CylinderComponent,CylinderColor)
VERIFY_CLASS_SIZE_NODIE(UCylinderComponent)
VERIFY_CLASS_OFFSET_NODIE(UDrawBoxComponent,DrawBoxComponent,BoxColor)
VERIFY_CLASS_OFFSET_NODIE(UDrawBoxComponent,DrawBoxComponent,BoxMaterial)
VERIFY_CLASS_OFFSET_NODIE(UDrawBoxComponent,DrawBoxComponent,BoxExtent)
VERIFY_CLASS_SIZE_NODIE(UDrawBoxComponent)
VERIFY_CLASS_OFFSET_NODIE(UDrawCapsuleComponent,DrawCapsuleComponent,CapsuleColor)
VERIFY_CLASS_OFFSET_NODIE(UDrawCapsuleComponent,DrawCapsuleComponent,CapsuleMaterial)
VERIFY_CLASS_OFFSET_NODIE(UDrawCapsuleComponent,DrawCapsuleComponent,CapsuleHeight)
VERIFY_CLASS_OFFSET_NODIE(UDrawCapsuleComponent,DrawCapsuleComponent,CapsuleRadius)
VERIFY_CLASS_SIZE_NODIE(UDrawCapsuleComponent)
VERIFY_CLASS_OFFSET_NODIE(UDrawConeComponent,DrawConeComponent,ConeColor)
VERIFY_CLASS_OFFSET_NODIE(UDrawConeComponent,DrawConeComponent,ConeSides)
VERIFY_CLASS_SIZE_NODIE(UDrawConeComponent)
VERIFY_CLASS_OFFSET_NODIE(UDrawCylinderComponent,DrawCylinderComponent,CylinderColor)
VERIFY_CLASS_OFFSET_NODIE(UDrawCylinderComponent,DrawCylinderComponent,CylinderMaterial)
VERIFY_CLASS_OFFSET_NODIE(UDrawCylinderComponent,DrawCylinderComponent,CylinderRadius)
VERIFY_CLASS_OFFSET_NODIE(UDrawCylinderComponent,DrawCylinderComponent,CylinderTopRadius)
VERIFY_CLASS_OFFSET_NODIE(UDrawCylinderComponent,DrawCylinderComponent,CylinderHeight)
VERIFY_CLASS_OFFSET_NODIE(UDrawCylinderComponent,DrawCylinderComponent,CylinderHeightOffset)
VERIFY_CLASS_OFFSET_NODIE(UDrawCylinderComponent,DrawCylinderComponent,CylinderSides)
VERIFY_CLASS_SIZE_NODIE(UDrawCylinderComponent)
VERIFY_CLASS_OFFSET_NODIE(UDrawFrustumComponent,DrawFrustumComponent,FrustumColor)
VERIFY_CLASS_OFFSET_NODIE(UDrawFrustumComponent,DrawFrustumComponent,FrustumAngle)
VERIFY_CLASS_OFFSET_NODIE(UDrawFrustumComponent,DrawFrustumComponent,FrustumAspectRatio)
VERIFY_CLASS_OFFSET_NODIE(UDrawFrustumComponent,DrawFrustumComponent,FrustumStartDist)
VERIFY_CLASS_OFFSET_NODIE(UDrawFrustumComponent,DrawFrustumComponent,FrustumEndDist)
VERIFY_CLASS_OFFSET_NODIE(UDrawFrustumComponent,DrawFrustumComponent,Texture)
VERIFY_CLASS_SIZE_NODIE(UDrawFrustumComponent)
VERIFY_CLASS_OFFSET_NODIE(UDrawQuadComponent,DrawQuadComponent,Texture)
VERIFY_CLASS_OFFSET_NODIE(UDrawQuadComponent,DrawQuadComponent,Width)
VERIFY_CLASS_OFFSET_NODIE(UDrawQuadComponent,DrawQuadComponent,Height)
VERIFY_CLASS_SIZE_NODIE(UDrawQuadComponent)
VERIFY_CLASS_OFFSET_NODIE(UDrawSphereComponent,DrawSphereComponent,SphereColor)
VERIFY_CLASS_OFFSET_NODIE(UDrawSphereComponent,DrawSphereComponent,SphereMaterial)
VERIFY_CLASS_OFFSET_NODIE(UDrawSphereComponent,DrawSphereComponent,SphereRadius)
VERIFY_CLASS_OFFSET_NODIE(UDrawSphereComponent,DrawSphereComponent,SphereSides)
VERIFY_CLASS_SIZE_NODIE(UDrawSphereComponent)
VERIFY_CLASS_SIZE_NODIE(UDrawPylonRadiusComponent)
VERIFY_CLASS_SIZE_NODIE(UDrawSoundRadiusComponent)
VERIFY_CLASS_SIZE_NODIE(ULevelGridVolumeRenderingComponent)
VERIFY_CLASS_OFFSET_NODIE(ULineBatchComponent,LineBatchComponent,BatchedLines)
VERIFY_CLASS_OFFSET_NODIE(ULineBatchComponent,LineBatchComponent,BatchedPoints)
VERIFY_CLASS_OFFSET_NODIE(ULineBatchComponent,LineBatchComponent,DefaultLifeTime)
VERIFY_CLASS_SIZE_NODIE(ULineBatchComponent)
VERIFY_CLASS_SIZE_NODIE(UModelComponent)
VERIFY_CLASS_OFFSET_NODIE(USpriteComponent,SpriteComponent,Sprite)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(USpriteComponent,SpriteComponent,SpriteCategoryName)
#else
VERIFY_CLASS_OFFSET_NODIE(USpriteComponent,SpriteComponent,VL)
#endif
VERIFY_CLASS_SIZE_NODIE(USpriteComponent)
VERIFY_CLASS_OFFSET_NODIE(URadialBlurComponent,RadialBlurComponent,Material)
VERIFY_CLASS_OFFSET_NODIE(URadialBlurComponent,RadialBlurComponent,LocalToWorld)
VERIFY_CLASS_SIZE_NODIE(URadialBlurComponent)
VERIFY_CLASS_OFFSET_NODIE(USceneCaptureComponent,SceneCaptureComponent,ClearColor)
VERIFY_CLASS_OFFSET_NODIE(USceneCaptureComponent,SceneCaptureComponent,PostProcessProxies)
VERIFY_CLASS_SIZE_NODIE(USceneCaptureComponent)
VERIFY_CLASS_OFFSET_NODIE(USceneCapture2DComponent,SceneCapture2DComponent,TextureTarget)
VERIFY_CLASS_OFFSET_NODIE(USceneCapture2DComponent,SceneCapture2DComponent,ProjMatrix)
VERIFY_CLASS_SIZE_NODIE(USceneCapture2DComponent)
VERIFY_CLASS_OFFSET_NODIE(USceneCapture2DHitMaskComponent,SceneCapture2DHitMaskComponent,TextureTarget)
VERIFY_CLASS_OFFSET_NODIE(USceneCapture2DHitMaskComponent,SceneCapture2DHitMaskComponent,FadingIntervalTime)
VERIFY_CLASS_SIZE_NODIE(USceneCapture2DHitMaskComponent)
VERIFY_CLASS_OFFSET_NODIE(USceneCaptureCubeMapComponent,SceneCaptureCubeMapComponent,TextureTarget)
VERIFY_CLASS_OFFSET_NODIE(USceneCaptureCubeMapComponent,SceneCaptureCubeMapComponent,WorldLocation)
VERIFY_CLASS_SIZE_NODIE(USceneCaptureCubeMapComponent)
VERIFY_CLASS_OFFSET_NODIE(USceneCapturePortalComponent,SceneCapturePortalComponent,TextureTarget)
VERIFY_CLASS_OFFSET_NODIE(USceneCapturePortalComponent,SceneCapturePortalComponent,ViewDestination)
VERIFY_CLASS_SIZE_NODIE(USceneCapturePortalComponent)
VERIFY_CLASS_OFFSET_NODIE(USceneCaptureReflectComponent,SceneCaptureReflectComponent,TextureTarget)
VERIFY_CLASS_OFFSET_NODIE(USceneCaptureReflectComponent,SceneCaptureReflectComponent,ScaleFOV)
VERIFY_CLASS_SIZE_NODIE(USceneCaptureReflectComponent)
VERIFY_CLASS_OFFSET_NODIE(UWindDirectionalSourceComponent,WindDirectionalSourceComponent,SceneProxy)
VERIFY_CLASS_OFFSET_NODIE(UWindDirectionalSourceComponent,WindDirectionalSourceComponent,Speed)
VERIFY_CLASS_SIZE_NODIE(UWindDirectionalSourceComponent)
VERIFY_CLASS_OFFSET_NODIE(UWindPointSourceComponent,WindPointSourceComponent,PreviewRadiusComponent)
VERIFY_CLASS_OFFSET_NODIE(UWindPointSourceComponent,WindPointSourceComponent,Radius)
VERIFY_CLASS_SIZE_NODIE(UWindPointSourceComponent)
VERIFY_CLASS_OFFSET_NODIE(UActorFactory,ActorFactory,GameplayActorClass)
VERIFY_CLASS_OFFSET_NODIE(UActorFactory,ActorFactory,NewActorClass)
VERIFY_CLASS_SIZE_NODIE(UActorFactory)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryActor,ActorFactoryActor,ActorClass)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryActor)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryAI,ActorFactoryAI,ControllerClass)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryAI,ActorFactoryAI,TeamIndex)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAI)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryAmbientSound,ActorFactoryAmbientSound,AmbientSoundCue)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAmbientSound)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAmbientSoundMovable)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryAmbientSoundSimple,ActorFactoryAmbientSoundSimple,SoundNodeWave)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAmbientSoundSimple)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAmbientSoundNonLoop)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAmbientSoundSimpleToggleable)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAmbientSoundNonLoopingToggleable)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryApexDestructible,ActorFactoryApexDestructible,RBChannel)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryApexDestructible,ActorFactoryApexDestructible,DestructibleAsset)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryApexDestructible)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryArchetype,ActorFactoryArchetype,ArchetypeActor)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryArchetype)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryCoverLink)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryDominantDirectionalLight)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryDominantDirectionalLightMovable)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryDynamicSM,ActorFactoryDynamicSM,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryDynamicSM,ActorFactoryDynamicSM,CollisionType)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryDynamicSM)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryMover)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryRigidBody,ActorFactoryRigidBody,InitialVelocity)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryRigidBody,ActorFactoryRigidBody,StayUprightMaxTorque)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryRigidBody)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryEmitter,ActorFactoryEmitter,ParticleSystem)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryEmitter)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryFracturedStaticMesh,ActorFactoryFracturedStaticMesh,FracturedStaticMesh)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryFracturedStaticMesh,ActorFactoryFracturedStaticMesh,DrawScale3D)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryFracturedStaticMesh)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryLensFlare,ActorFactoryLensFlare,LensFlareObject)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryLensFlare)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryLight)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPathNode)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryPhysicsAsset,ActorFactoryPhysicsAsset,PhysicsAsset)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryPhysicsAsset,ActorFactoryPhysicsAsset,DrawScale3D)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPhysicsAsset)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPlayerStart)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPylon)
VERIFY_CLASS_OFFSET_NODIE(UActorFactorySkeletalMesh,ActorFactorySkeletalMesh,SkeletalMesh)
VERIFY_CLASS_OFFSET_NODIE(UActorFactorySkeletalMesh,ActorFactorySkeletalMesh,AnimSequenceName)
VERIFY_CLASS_SIZE_NODIE(UActorFactorySkeletalMesh)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryStaticMesh,ActorFactoryStaticMesh,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryStaticMesh,ActorFactoryStaticMesh,DrawScale3D)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryStaticMesh)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryTrigger)
VERIFY_CLASS_OFFSET_NODIE(UActorFactoryVehicle,ActorFactoryVehicle,VehicleClass)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryVehicle)
VERIFY_CLASS_OFFSET_NODIE(UBookMark,BookMark,Location)
VERIFY_CLASS_OFFSET_NODIE(UBookMark,BookMark,HiddenLevels)
VERIFY_CLASS_SIZE_NODIE(UBookMark)
VERIFY_CLASS_OFFSET_NODIE(UBookMark2D,BookMark2D,Zoom2D)
VERIFY_CLASS_OFFSET_NODIE(UBookMark2D,BookMark2D,Location)
VERIFY_CLASS_SIZE_NODIE(UBookMark2D)
VERIFY_CLASS_OFFSET_NODIE(UKismetBookMark,KismetBookMark,BookMarkSequencePathName)
VERIFY_CLASS_SIZE_NODIE(UKismetBookMark)
VERIFY_CLASS_OFFSET_NODIE(UCanvas,Canvas,Font)
VERIFY_CLASS_OFFSET_NODIE(UCanvas,Canvas,DefaultTexture)
VERIFY_CLASS_SIZE_NODIE(UCanvas)
VERIFY_CLASS_OFFSET_NODIE(UCheatManager,CheatManager,ViewingFrom)
VERIFY_CLASS_OFFSET_NODIE(UCheatManager,CheatManager,OwnCamera)
VERIFY_CLASS_SIZE_NODIE(UCheatManager)
VERIFY_CLASS_OFFSET_NODIE(UClipPadEntry,ClipPadEntry,Title)
VERIFY_CLASS_OFFSET_NODIE(UClipPadEntry,ClipPadEntry,Text)
VERIFY_CLASS_SIZE_NODIE(UClipPadEntry)
VERIFY_CLASS_OFFSET_NODIE(UCloudSaveSystem,CloudSaveSystem,KeyValueStore)
VERIFY_CLASS_OFFSET_NODIE(UCloudSaveSystem,CloudSaveSystem,__SaveSystemCallback__Delegate)
VERIFY_CLASS_SIZE_NODIE(UCloudSaveSystem)
VERIFY_CLASS_OFFSET_NODIE(UCodecMovie,CodecMovie,PlaybackDuration)
VERIFY_CLASS_SIZE_NODIE(UCodecMovie)
VERIFY_CLASS_OFFSET_NODIE(UCodecMovieFallback,CodecMovieFallback,CurrentTime)
VERIFY_CLASS_SIZE_NODIE(UCodecMovieFallback)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdPresetCurve,CurveEdPresetCurve,CurveName)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdPresetCurve,CurveEdPresetCurve,Points)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPresetCurve)
VERIFY_CLASS_SIZE_NODIE(UCustomPropertyItemHandler)
VERIFY_CLASS_OFFSET_NODIE(UDamageType,DamageType,KDamageImpulse)
VERIFY_CLASS_OFFSET_NODIE(UDamageType,DamageType,FracturedMeshDamage)
VERIFY_CLASS_SIZE_NODIE(UDamageType)
VERIFY_CLASS_SIZE_NODIE(UKillZDamageType)
VERIFY_CLASS_OFFSET_NODIE(UDistributionFloatConstant,DistributionFloatConstant,Constant)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatConstant)
VERIFY_CLASS_OFFSET_NODIE(UDistributionFloatParameterBase,DistributionFloatParameterBase,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(UDistributionFloatParameterBase,DistributionFloatParameterBase,ParamMode)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatParameterBase)
VERIFY_CLASS_OFFSET_NODIE(UDistributionFloatConstantCurve,DistributionFloatConstantCurve,ConstantCurve)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatConstantCurve)
VERIFY_CLASS_OFFSET_NODIE(UDistributionFloatUniform,DistributionFloatUniform,Min)
VERIFY_CLASS_OFFSET_NODIE(UDistributionFloatUniform,DistributionFloatUniform,Max)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatUniform)
VERIFY_CLASS_OFFSET_NODIE(UDistributionFloatUniformCurve,DistributionFloatUniformCurve,ConstantCurve)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatUniformCurve)
VERIFY_CLASS_OFFSET_NODIE(UDistributionFloatUniformRange,DistributionFloatUniformRange,MaxHigh)
VERIFY_CLASS_OFFSET_NODIE(UDistributionFloatUniformRange,DistributionFloatUniformRange,MinLow)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatUniformRange)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorConstant,DistributionVectorConstant,Constant)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorConstant,DistributionVectorConstant,LockedAxes)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorConstant)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorParameterBase,DistributionVectorParameterBase,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorParameterBase,DistributionVectorParameterBase,ParamModes)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorParameterBase)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorConstantCurve,DistributionVectorConstantCurve,ConstantCurve)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorConstantCurve,DistributionVectorConstantCurve,LockedAxes)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorConstantCurve)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorUniform,DistributionVectorUniform,Max)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorUniform,DistributionVectorUniform,MirrorFlags)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorUniform)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorUniformCurve,DistributionVectorUniformCurve,ConstantCurve)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorUniformCurve,DistributionVectorUniformCurve,MirrorFlags)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorUniformCurve)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorUniformRange,DistributionVectorUniformRange,MaxHigh)
VERIFY_CLASS_OFFSET_NODIE(UDistributionVectorUniformRange,DistributionVectorUniformRange,MinLow)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorUniformRange)
VERIFY_CLASS_OFFSET_NODIE(UEdCoordSystem,EdCoordSystem,M)
VERIFY_CLASS_OFFSET_NODIE(UEdCoordSystem,EdCoordSystem,Desc)
VERIFY_CLASS_SIZE_NODIE(UEdCoordSystem)
VERIFY_CLASS_SIZE_NODIE(UEditorLinkSelectionInterface)
VERIFY_CLASS_SIZE_NODIE(UEngineTypes)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UFaceFXAnimSet,FaceFXAnimSet,DefaultFaceFXAsset)
#else
VERIFY_CLASS_OFFSET_NODIE(UFaceFXAnimSet,FaceFXAnimSet,InternalFaceFXAnimSet)
#endif
VERIFY_CLASS_OFFSET_NODIE(UFaceFXAnimSet,FaceFXAnimSet,NumLoadErrors)
VERIFY_CLASS_SIZE_NODIE(UFaceFXAnimSet)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UFaceFXAsset,FaceFXAsset,DefaultSkelMesh)
#else
VERIFY_CLASS_OFFSET_NODIE(UFaceFXAsset,FaceFXAsset,FaceFXActor)
#endif
VERIFY_CLASS_OFFSET_NODIE(UFaceFXAsset,FaceFXAsset,NumLoadErrors)
VERIFY_CLASS_SIZE_NODIE(UFaceFXAsset)
VERIFY_CLASS_OFFSET_NODIE(UFont,Font,Characters)
VERIFY_CLASS_OFFSET_NODIE(UFont,Font,ScalingFactor)
VERIFY_CLASS_SIZE_NODIE(UFont)
VERIFY_CLASS_OFFSET_NODIE(UMultiFont,MultiFont,ResolutionTestTable)
VERIFY_CLASS_SIZE_NODIE(UMultiFont)
VERIFY_CLASS_OFFSET_NODIE(UFontImportOptions,FontImportOptions,Data)
VERIFY_CLASS_SIZE_NODIE(UFontImportOptions)
VERIFY_CLASS_OFFSET_NODIE(UForceFeedbackManager,ForceFeedbackManager,FFWaveform)
VERIFY_CLASS_OFFSET_NODIE(UForceFeedbackManager,ForceFeedbackManager,WaveformInstigator)
VERIFY_CLASS_SIZE_NODIE(UForceFeedbackManager)
VERIFY_CLASS_OFFSET_NODIE(UForceFeedbackWaveform,ForceFeedbackWaveform,Samples)
VERIFY_CLASS_OFFSET_NODIE(UForceFeedbackWaveform,ForceFeedbackWaveform,MaxWaveformDistance)
VERIFY_CLASS_SIZE_NODIE(UForceFeedbackWaveform)
VERIFY_CLASS_OFFSET_NODIE(UGameplayEvents,GameplayEvents,Archive)
VERIFY_CLASS_OFFSET_NODIE(UGameplayEvents,GameplayEvents,SoundCueArray)
VERIFY_CLASS_SIZE_NODIE(UGameplayEvents)
VERIFY_CLASS_OFFSET_NODIE(UGameplayEventsReader,GameplayEventsReader,RegisteredHandlers)
VERIFY_CLASS_SIZE_NODIE(UGameplayEventsReader)
VERIFY_CLASS_OFFSET_NODIE(UGameplayEventsWriterBase,GameplayEventsWriterBase,Game)
VERIFY_CLASS_SIZE_NODIE(UGameplayEventsWriterBase)
VERIFY_CLASS_SIZE_NODIE(UGameplayEventsUploadAnalytics)
VERIFY_CLASS_SIZE_NODIE(UGameplayEventsWriter)
VERIFY_CLASS_OFFSET_NODIE(UGameplayEventsHandler,GameplayEventsHandler,EventIDFilter)
VERIFY_CLASS_OFFSET_NODIE(UGameplayEventsHandler,GameplayEventsHandler,Reader)
VERIFY_CLASS_SIZE_NODIE(UGameplayEventsHandler)
VERIFY_CLASS_OFFSET_NODIE(UGenericParamListStatEntry,GenericParamListStatEntry,StatEvent)
VERIFY_CLASS_OFFSET_NODIE(UGenericParamListStatEntry,GenericParamListStatEntry,Writer)
VERIFY_CLASS_SIZE_NODIE(UGenericParamListStatEntry)
VERIFY_CLASS_SIZE_NODIE(UHttpBaseInterface)
VERIFY_CLASS_OFFSET_NODIE(UHttpRequestInterface,HttpRequestInterface,__OnProcessRequestComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UHttpRequestInterface)
VERIFY_CLASS_SIZE_NODIE(UHttpResponseInterface)
VERIFY_CLASS_OFFSET_NODIE(UIniLocPatcher,IniLocPatcher,Files)
VERIFY_CLASS_OFFSET_NODIE(UIniLocPatcher,IniLocPatcher,__OnAllTitleFilesCompleted__Delegate)
VERIFY_CLASS_SIZE_NODIE(UIniLocPatcher)
VERIFY_CLASS_SIZE_NODIE(UInterface_NavigationHandle)
VERIFY_CLASS_SIZE_NODIE(UInterface_Speaker)
VERIFY_CLASS_OFFSET_NODIE(UInterpCurveEdSetup,InterpCurveEdSetup,Tabs)
VERIFY_CLASS_OFFSET_NODIE(UInterpCurveEdSetup,InterpCurveEdSetup,ActiveTab)
VERIFY_CLASS_SIZE_NODIE(UInterpCurveEdSetup)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrack,InterpTrack,SubTracks)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInterpTrack,InterpTrack,SubTrackGroups)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInterpTrack,InterpTrack,SupportedSubTracks)
#endif
VERIFY_CLASS_OFFSET_NODIE(UInterpTrack,InterpTrack,TrackInstClass)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrack,InterpTrack,ActiveCondition)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrack,InterpTrack,TrackTitle)
VERIFY_CLASS_SIZE_NODIE(UInterpTrack)
VERIFY_CLASS_OFFSET_NODIE(UJsonObject,JsonObject,ValueMap)
VERIFY_CLASS_OFFSET_NODIE(UJsonObject,JsonObject,ObjectArray)
VERIFY_CLASS_SIZE_NODIE(UJsonObject)
VERIFY_CLASS_OFFSET_NODIE(UKMeshProps,KMeshProps,COMNudge)
VERIFY_CLASS_OFFSET_NODIE(UKMeshProps,KMeshProps,AggGeom)
VERIFY_CLASS_SIZE_NODIE(UKMeshProps)
VERIFY_CLASS_OFFSET_NODIE(ULevelStreaming,LevelStreaming,PackageName)
VERIFY_CLASS_OFFSET_NODIE(ULevelStreaming,LevelStreaming,GridPosition)
VERIFY_CLASS_SIZE_NODIE(ULevelStreaming)
VERIFY_CLASS_SIZE_NODIE(ULevelStreamingAlwaysLoaded)
VERIFY_CLASS_OFFSET_NODIE(ULevelStreamingDistance,LevelStreamingDistance,Origin)
VERIFY_CLASS_OFFSET_NODIE(ULevelStreamingDistance,LevelStreamingDistance,MaxDistance)
VERIFY_CLASS_SIZE_NODIE(ULevelStreamingDistance)
VERIFY_CLASS_SIZE_NODIE(ULevelStreamingKismet)
VERIFY_CLASS_SIZE_NODIE(ULevelStreamingPersistent)
VERIFY_CLASS_OFFSET_NODIE(ULightmappedSurfaceCollection,LightmappedSurfaceCollection,SourceModel)
VERIFY_CLASS_OFFSET_NODIE(ULightmappedSurfaceCollection,LightmappedSurfaceCollection,Surfaces)
VERIFY_CLASS_SIZE_NODIE(ULightmappedSurfaceCollection)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_LightmassLevelSettings,LightmassLevelSettings,NumIndirectLightingBounces)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_LightmassLevelSettings,LightmassLevelSettings,MaxOcclusionDistance)
VERIFY_CLASS_SIZE_NODIE(UDEPRECATED_LightmassLevelSettings)
VERIFY_CLASS_OFFSET_NODIE(ULightmassPrimitiveSettingsObject,LightmassPrimitiveSettingsObject,LightmassSettings)
VERIFY_CLASS_SIZE_NODIE(ULightmassPrimitiveSettingsObject)
VERIFY_CLASS_SIZE_NODIE(UMapInfo)
VERIFY_CLASS_SIZE_NODIE(UMusicTrackDataStructures)
VERIFY_CLASS_OFFSET_NODIE(UObjectReferencer,ObjectReferencer,ReferencedObjects)
VERIFY_CLASS_SIZE_NODIE(UObjectReferencer)
VERIFY_CLASS_SIZE_NODIE(UOnlineAuthInterface)
VERIFY_CLASS_SIZE_NODIE(UOnlineMatchmakingStats)
VERIFY_CLASS_OFFSET_NODIE(UOnlinePlayerStorage,OnlinePlayerStorage,VersionNumber)
VERIFY_CLASS_OFFSET_NODIE(UOnlinePlayerStorage,OnlinePlayerStorage,DeviceID)
VERIFY_CLASS_SIZE_NODIE(UOnlinePlayerStorage)
VERIFY_CLASS_OFFSET_NODIE(UOnlineProfileSettings,OnlineProfileSettings,ProfileSettingIds)
VERIFY_CLASS_OFFSET_NODIE(UOnlineProfileSettings,OnlineProfileSettings,OwnerMappings)
VERIFY_CLASS_SIZE_NODIE(UOnlineProfileSettings)
VERIFY_CLASS_OFFSET_NODIE(UOnlineStats,OnlineStats,ViewIdMappings)
VERIFY_CLASS_SIZE_NODIE(UOnlineStats)
VERIFY_CLASS_OFFSET_NODIE(UOnlineStatsRead,OnlineStatsRead,ViewId)
VERIFY_CLASS_OFFSET_NODIE(UOnlineStatsRead,OnlineStatsRead,TitleId)
VERIFY_CLASS_SIZE_NODIE(UOnlineStatsRead)
VERIFY_CLASS_OFFSET_NODIE(UOnlineStatsWrite,OnlineStatsWrite,StatMappings)
VERIFY_CLASS_OFFSET_NODIE(UOnlineStatsWrite,OnlineStatsWrite,__OnStatsWriteComplete__Delegate)
VERIFY_CLASS_SIZE_NODIE(UOnlineStatsWrite)
VERIFY_CLASS_OFFSET_NODIE(UOnlineSubsystem,OnlineSubsystem,AccountInterface)
VERIFY_CLASS_OFFSET_NODIE(UOnlineSubsystem,OnlineSubsystem,AsyncMinCompletionTime)
VERIFY_CLASS_SIZE_NODIE(UOnlineSubsystem)
VERIFY_CLASS_OFFSET_NODIE(UPlayer,Player,Actor)
VERIFY_CLASS_OFFSET_NODIE(UPlayer,Player,PP_ShadowsMultiplier)
VERIFY_CLASS_SIZE_NODIE(UPlayer)
VERIFY_CLASS_OFFSET_NODIE(ULocalPlayer,LocalPlayer,ControllerId)
VERIFY_CLASS_OFFSET_NODIE(ULocalPlayer,LocalPlayer,ServerAuthUID)
VERIFY_CLASS_SIZE_NODIE(ULocalPlayer)
VERIFY_CLASS_OFFSET_NODIE(UPostProcessChain,PostProcessChain,Effects)
VERIFY_CLASS_SIZE_NODIE(UPostProcessChain)
VERIFY_CLASS_OFFSET_NODIE(UPostProcessEffect,PostProcessEffect,EffectName)
VERIFY_CLASS_OFFSET_NODIE(UPostProcessEffect,PostProcessEffect,SceneDPG)
VERIFY_CLASS_SIZE_NODIE(UPostProcessEffect)
VERIFY_CLASS_OFFSET_NODIE(UAmbientOcclusionEffect,AmbientOcclusionEffect,OcclusionColor)
VERIFY_CLASS_OFFSET_NODIE(UAmbientOcclusionEffect,AmbientOcclusionEffect,HistoryWeightConvergenceTime)
VERIFY_CLASS_SIZE_NODIE(UAmbientOcclusionEffect)
VERIFY_CLASS_OFFSET_NODIE(UBlurEffect,BlurEffect,BlurKernelSize)
VERIFY_CLASS_SIZE_NODIE(UBlurEffect)
VERIFY_CLASS_OFFSET_NODIE(UDOFEffect,DOFEffect,FalloffExponent)
VERIFY_CLASS_OFFSET_NODIE(UDOFEffect,DOFEffect,FocusPosition)
VERIFY_CLASS_SIZE_NODIE(UDOFEffect)
VERIFY_CLASS_OFFSET_NODIE(UDOFAndBloomEffect,DOFAndBloomEffect,BloomScale)
VERIFY_CLASS_OFFSET_NODIE(UDOFAndBloomEffect,DOFAndBloomEffect,BokehTexture)
VERIFY_CLASS_SIZE_NODIE(UDOFAndBloomEffect)
VERIFY_CLASS_OFFSET_NODIE(UDOFBloomMotionBlurEffect,DOFBloomMotionBlurEffect,MaxVelocity)
VERIFY_CLASS_OFFSET_NODIE(UDOFBloomMotionBlurEffect,DOFBloomMotionBlurEffect,CameraTranslationThreshold)
VERIFY_CLASS_SIZE_NODIE(UDOFBloomMotionBlurEffect)
VERIFY_CLASS_OFFSET_NODIE(UUberPostProcessEffect,UberPostProcessEffect,SceneShadows)
VERIFY_CLASS_OFFSET_NODIE(UUberPostProcessEffect,UberPostProcessEffect,SceneHDRTonemapperScale_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(UUberPostProcessEffect)
VERIFY_CLASS_OFFSET_NODIE(UMaterialEffect,MaterialEffect,Material)
VERIFY_CLASS_SIZE_NODIE(UMaterialEffect)
VERIFY_CLASS_OFFSET_NODIE(UMotionBlurEffect,MotionBlurEffect,MaxVelocity)
VERIFY_CLASS_OFFSET_NODIE(UMotionBlurEffect,MotionBlurEffect,CameraTranslationThreshold)
VERIFY_CLASS_SIZE_NODIE(UMotionBlurEffect)
VERIFY_CLASS_SIZE_NODIE(UPrimitiveComponentFactory)
VERIFY_CLASS_OFFSET_NODIE(UMeshComponentFactory,MeshComponentFactory,Materials)
VERIFY_CLASS_SIZE_NODIE(UMeshComponentFactory)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshComponentFactory,StaticMeshComponentFactory,StaticMesh)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshComponentFactory)
VERIFY_CLASS_OFFSET_NODIE(UReachSpec,ReachSpec,NavOctreeObject)
VERIFY_CLASS_OFFSET_NODIE(UReachSpec,ReachSpec,BlockedBy)
VERIFY_CLASS_SIZE_NODIE(UReachSpec)
VERIFY_CLASS_SIZE_NODIE(UAdvancedReachSpec)
VERIFY_CLASS_SIZE_NODIE(UCeilingReachSpec)
VERIFY_CLASS_SIZE_NODIE(UForcedReachSpec)
VERIFY_CLASS_OFFSET_NODIE(UCoverSlipReachSpec,CoverSlipReachSpec,SpecDirection)
VERIFY_CLASS_SIZE_NODIE(UCoverSlipReachSpec)
VERIFY_CLASS_SIZE_NODIE(UFloorToCeilingReachSpec)
VERIFY_CLASS_SIZE_NODIE(UMantleReachSpec)
VERIFY_CLASS_OFFSET_NODIE(USlotToSlotReachSpec,SlotToSlotReachSpec,SpecDirection)
VERIFY_CLASS_SIZE_NODIE(USlotToSlotReachSpec)
VERIFY_CLASS_OFFSET_NODIE(USwatTurnReachSpec,SwatTurnReachSpec,SpecDirection)
VERIFY_CLASS_SIZE_NODIE(USwatTurnReachSpec)
VERIFY_CLASS_SIZE_NODIE(UWallTransReachSpec)
VERIFY_CLASS_SIZE_NODIE(ULadderReachSpec)
VERIFY_CLASS_SIZE_NODIE(UProscribedReachSpec)
VERIFY_CLASS_SIZE_NODIE(UTeleportReachSpec)
VERIFY_CLASS_OFFSET_NODIE(USavedMove,SavedMove,NextMove)
VERIFY_CLASS_OFFSET_NODIE(USavedMove,SavedMove,RootMotionInterpCurveLastValue)
VERIFY_CLASS_SIZE_NODIE(USavedMove)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_SaveGameSummary,SaveGameSummary,BaseLevel)
VERIFY_CLASS_OFFSET_NODIE(UDEPRECATED_SaveGameSummary,SaveGameSummary,Description)
VERIFY_CLASS_SIZE_NODIE(UDEPRECATED_SaveGameSummary)
VERIFY_CLASS_SIZE_NODIE(UScriptViewportClient)
VERIFY_CLASS_OFFSET_NODIE(UGameViewportClient,GameViewportClient,Viewport)
VERIFY_CLASS_OFFSET_NODIE(UGameViewportClient,GameViewportClient,__HandleInputChar__Delegate)
VERIFY_CLASS_SIZE_NODIE(UGameViewportClient)
VERIFY_CLASS_OFFSET_NODIE(USettings,Settings,LocalizedSettings)
VERIFY_CLASS_OFFSET_NODIE(USettings,Settings,PropertyMappings)
VERIFY_CLASS_SIZE_NODIE(USettings)
VERIFY_CLASS_OFFSET_NODIE(UOnlineGameSearch,OnlineGameSearch,MaxSearchResults)
VERIFY_CLASS_OFFSET_NODIE(UOnlineGameSearch,OnlineGameSearch,MaxPingBytes)
VERIFY_CLASS_SIZE_NODIE(UOnlineGameSearch)
VERIFY_CLASS_OFFSET_NODIE(UOnlineGameSettings,OnlineGameSettings,NumPublicConnections)
VERIFY_CLASS_OFFSET_NODIE(UOnlineGameSettings,OnlineGameSettings,BuildUniqueId)
VERIFY_CLASS_SIZE_NODIE(UOnlineGameSettings)
VERIFY_CLASS_OFFSET_NODIE(UShadowMap2D,ShadowMap2D,Texture)
VERIFY_CLASS_OFFSET_NODIE(UShadowMap2D,ShadowMap2D,CoordinateScale)
VERIFY_CLASS_OFFSET_NODIE(UShadowMap2D,ShadowMap2D,CoordinateBias)
VERIFY_CLASS_OFFSET_NODIE(UShadowMap2D,ShadowMap2D,LightGuid)
VERIFY_CLASS_OFFSET_NODIE(UShadowMap2D,ShadowMap2D,Component)
VERIFY_CLASS_OFFSET_NODIE(UShadowMap2D,ShadowMap2D,InstanceIndex)
VERIFY_CLASS_SIZE_NODIE(UShadowMap2D)
VERIFY_CLASS_OFFSET_NODIE(USoundCue,SoundCue,SoundClass)
VERIFY_CLASS_OFFSET_NODIE(USoundCue,SoundCue,SoundGroup_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(USoundCue)
VERIFY_CLASS_OFFSET_NODIE(USpeechRecognition,SpeechRecognition,Language)
VERIFY_CLASS_OFFSET_NODIE(USpeechRecognition,SpeechRecognition,FnxVoiceData)
VERIFY_CLASS_SIZE_NODIE(USpeechRecognition)
VERIFY_CLASS_SIZE_NODIE(USurface)
VERIFY_CLASS_OFFSET_NODIE(UShadowMapTexture2D,ShadowMapTexture2D,ShadowmapFlags)
VERIFY_CLASS_SIZE_NODIE(UShadowMapTexture2D)
VERIFY_CLASS_OFFSET_NODIE(UTranslationContext,TranslationContext,TranslatorTags)
VERIFY_CLASS_SIZE_NODIE(UTranslationContext)
VERIFY_CLASS_OFFSET_NODIE(UTranslatorTag,TranslatorTag,Tag)
VERIFY_CLASS_SIZE_NODIE(UTranslatorTag)
VERIFY_CLASS_SIZE_NODIE(UStringsTag)
VERIFY_CLASS_SIZE_NODIE(UUIManager)
VERIFY_CLASS_OFFSET_NODIE(UWaveFormBase,WaveFormBase,TheWaveForm)
VERIFY_CLASS_SIZE_NODIE(UWaveFormBase)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
