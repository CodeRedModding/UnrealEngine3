/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(Accept)
AUTOGENERATE_NAME(AcceptInventory)
AUTOGENERATE_NAME(ActorEntered)
AUTOGENERATE_NAME(ActorEnteredVolume)
AUTOGENERATE_NAME(ActorLeaving)
AUTOGENERATE_NAME(ActorLeavingVolume)
AUTOGENERATE_NAME(AllowDetourTo)
AUTOGENERATE_NAME(Attach)
AUTOGENERATE_NAME(BaseChange)
AUTOGENERATE_NAME(BecomeViewTarget)
AUTOGENERATE_NAME(BeginPlay)
AUTOGENERATE_NAME(BreathTimer)
AUTOGENERATE_NAME(Broadcast)
AUTOGENERATE_NAME(BroadcastLocalized)
AUTOGENERATE_NAME(BroadcastLocalizedMessage)
AUTOGENERATE_NAME(Bump)
AUTOGENERATE_NAME(ChangeAnimation)
AUTOGENERATE_NAME(ClientMessage)
AUTOGENERATE_NAME(ClientReset)
AUTOGENERATE_NAME(ClientSetViewTarget)
AUTOGENERATE_NAME(ClientTravel)
AUTOGENERATE_NAME(ClientValidate)
AUTOGENERATE_NAME(ConnectFailure)
AUTOGENERATE_NAME(CreateInventory)
AUTOGENERATE_NAME(Destroyed)
AUTOGENERATE_NAME(Detach)
AUTOGENERATE_NAME(DetourWeight)
AUTOGENERATE_NAME(DriverLeave)
AUTOGENERATE_NAME(EncroachedBy)
AUTOGENERATE_NAME(EncroachingOn)
AUTOGENERATE_NAME(EndCrouch)
AUTOGENERATE_NAME(EnemyNotVisible)
AUTOGENERATE_NAME(Falling)
AUTOGENERATE_NAME(FellOutOfWorld)
AUTOGENERATE_NAME(FindInventoryType)
AUTOGENERATE_NAME(GainedChild)
AUTOGENERATE_NAME(GameEnding)
AUTOGENERATE_NAME(GetActorEyesViewPoint)
AUTOGENERATE_NAME(GetBeaconText)
AUTOGENERATE_NAME(GetFOVAngle)
AUTOGENERATE_NAME(GetPlayerViewPoint)
AUTOGENERATE_NAME(HeadVolumeChange)
AUTOGENERATE_NAME(HearNoise)
AUTOGENERATE_NAME(HitWall)
AUTOGENERATE_NAME(InitGame)
AUTOGENERATE_NAME(InitInputSystem)
AUTOGENERATE_NAME(KickIdler)
AUTOGENERATE_NAME(KickWarning)
AUTOGENERATE_NAME(KilledBy)
AUTOGENERATE_NAME(Landed)
AUTOGENERATE_NAME(Login)
AUTOGENERATE_NAME(LongFall)
AUTOGENERATE_NAME(LostChild)
AUTOGENERATE_NAME(MayFall)
AUTOGENERATE_NAME(Message)
AUTOGENERATE_NAME(ModifyVelocity)
AUTOGENERATE_NAME(NotifyBump)
AUTOGENERATE_NAME(NotifyFallingHitWall)
AUTOGENERATE_NAME(NotifyHeadVolumeChange)
AUTOGENERATE_NAME(NotifyHitWall)
AUTOGENERATE_NAME(NotifyJumpApex)
AUTOGENERATE_NAME(NotifyLanded)
AUTOGENERATE_NAME(NotifyMissedJump)
AUTOGENERATE_NAME(NotifyPhysicsVolumeChange)
AUTOGENERATE_NAME(NotifyPostLanded)
AUTOGENERATE_NAME(OnAnimEnd)
AUTOGENERATE_NAME(OnAnimPlay)
AUTOGENERATE_NAME(OverRotated)
AUTOGENERATE_NAME(PawnEnteredVolume)
AUTOGENERATE_NAME(PawnLeavingVolume)
AUTOGENERATE_NAME(PhysicsChangedFor)
AUTOGENERATE_NAME(PhysicsVolumeChange)
AUTOGENERATE_NAME(PlayDying)
AUTOGENERATE_NAME(PlayerInput)
AUTOGENERATE_NAME(PlayerTick)
AUTOGENERATE_NAME(PlayFireEffects)
AUTOGENERATE_NAME(PlayFootStepSound)
AUTOGENERATE_NAME(PlayWeaponSwitch)
AUTOGENERATE_NAME(Possess)
AUTOGENERATE_NAME(PostBeginPlay)
AUTOGENERATE_NAME(PostLogin)
AUTOGENERATE_NAME(PostNetBeginPlay)
AUTOGENERATE_NAME(PostRender)
AUTOGENERATE_NAME(PostTeleport)
AUTOGENERATE_NAME(PostTouch)
AUTOGENERATE_NAME(PreBeginPlay)
AUTOGENERATE_NAME(PreClientTravel)
AUTOGENERATE_NAME(PreLogin)
AUTOGENERATE_NAME(PrepareForMove)
AUTOGENERATE_NAME(PreRender)
AUTOGENERATE_NAME(PreTeleport)
AUTOGENERATE_NAME(RanInto)
AUTOGENERATE_NAME(RatePickup)
AUTOGENERATE_NAME(ReceiveLocalizedMessage)
AUTOGENERATE_NAME(RecoverFromBadStateCode)
AUTOGENERATE_NAME(ReplicatedEvent)
AUTOGENERATE_NAME(ResetCameraMode)
AUTOGENERATE_NAME(SeeMonster)
AUTOGENERATE_NAME(SeePlayer)
AUTOGENERATE_NAME(SendClientAdjustment)
AUTOGENERATE_NAME(ServerTravel)
AUTOGENERATE_NAME(ServerValidationResponse)
AUTOGENERATE_NAME(SetHeadScale)
AUTOGENERATE_NAME(SetInitialState)
AUTOGENERATE_NAME(SetMeshTransformOffset)
AUTOGENERATE_NAME(SetMeshTransformRotation)
AUTOGENERATE_NAME(SetMeshTransformScale)
AUTOGENERATE_NAME(SetMeshTransformScale3D)
AUTOGENERATE_NAME(SetProgressMessage)
AUTOGENERATE_NAME(SetProgressTime)
AUTOGENERATE_NAME(SetupSpecialPathAbilities)
AUTOGENERATE_NAME(SetWalking)
AUTOGENERATE_NAME(SpecialCost)
AUTOGENERATE_NAME(SpecialHandling)
AUTOGENERATE_NAME(StartCrouch)
AUTOGENERATE_NAME(StartDriving)
AUTOGENERATE_NAME(StopDriving)
AUTOGENERATE_NAME(SuggestMovePreparation)
AUTOGENERATE_NAME(TakeDamage)
AUTOGENERATE_NAME(TeamMessage)
AUTOGENERATE_NAME(Tick)
AUTOGENERATE_NAME(Timer)
AUTOGENERATE_NAME(TornOff)
AUTOGENERATE_NAME(Touch)
AUTOGENERATE_NAME(TravelPostAccept)
AUTOGENERATE_NAME(TravelPreAccept)
AUTOGENERATE_NAME(UnPossess)
AUTOGENERATE_NAME(UnTouch)
AUTOGENERATE_NAME(UpdateEyeHeight)
AUTOGENERATE_NAME(UsedBy)
AUTOGENERATE_NAME(ZoneChange)

#ifndef NAMES_ONLY

enum EDoubleClickDir
{
    DCLICK_None             =0,
    DCLICK_Left             =1,
    DCLICK_Right            =2,
    DCLICK_Forward          =3,
    DCLICK_Back             =4,
    DCLICK_Active           =5,
    DCLICK_Done             =6,
    DCLICK_MAX              =7,
};
enum ETravelType
{
    TRAVEL_Absolute         =0,
    TRAVEL_Partial          =1,
    TRAVEL_Relative         =2,
    TRAVEL_MAX              =3,
};
enum ENetRole
{
    ROLE_None               =0,
    ROLE_SimulatedProxy     =1,
    ROLE_AutonomousProxy    =2,
    ROLE_Authority          =3,
    ROLE_MAX                =4,
};
enum EPhysics
{
    PHYS_None               =0,
    PHYS_Walking            =1,
    PHYS_Falling            =2,
    PHYS_Swimming           =3,
    PHYS_Flying             =4,
    PHYS_Rotating           =5,
    PHYS_Projectile         =6,
    PHYS_Interpolating      =7,
    PHYS_Spider             =8,
    PHYS_Ladder             =9,
    PHYS_RigidBody          =10,
    PHYS_Articulated        =11,
    PHYS_MAX                =12,
};
struct FTimerData
{
    BITFIELD bLoop:1 GCC_PACK(PROPERTY_ALIGNMENT);
    FName FuncName GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT Rate;
    FLOAT Count;
};

struct FTraceHitInfo
{
    class UMaterial* Material;
    INT Item;
    FName BoneName;
    class UPrimitiveComponent* HitComponent;
};

#define UCONST_MINFLOORZ 0.7

struct Actor_eventGetActorEyesViewPoint_Parms
{
    FVector out_Location;
    FRotator out_Rotation;
};
struct Actor_eventOnAnimPlay_Parms
{
    class UAnimNodeSequence* SeqNode;
};
struct Actor_eventOnAnimEnd_Parms
{
    class UAnimNodeSequence* SeqNode;
};
struct Actor_eventBecomeViewTarget_Parms
{
    class APlayerController* PC;
};
struct Actor_eventTravelPostAccept_Parms
{
};
struct Actor_eventTravelPreAccept_Parms
{
};
struct Actor_eventTakeDamage_Parms
{
    INT Damage;
    class APawn* EventInstigator;
    FVector HitLocation;
    FVector Momentum;
    class UClass* DamageType;
    FTraceHitInfo HitInfo;
};
struct Actor_eventKilledBy_Parms
{
    class APawn* EventInstigator;
};
struct Actor_eventPostNetBeginPlay_Parms
{
};
struct Actor_eventSetInitialState_Parms
{
};
struct Actor_eventPostBeginPlay_Parms
{
};
struct Actor_eventBroadcastLocalizedMessage_Parms
{
    class UClass* MessageClass;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
};
struct Actor_eventPreBeginPlay_Parms
{
};
struct Actor_eventRecoverFromBadStateCode_Parms
{
};
struct Actor_eventBeginPlay_Parms
{
};
struct Actor_eventPostTeleport_Parms
{
    class ATeleporter* OutTeleporter;
};
struct Actor_eventPreTeleport_Parms
{
    class ATeleporter* InTeleporter;
    BITFIELD ReturnValue;
};
struct Actor_eventTornOff_Parms
{
};
struct Actor_eventFellOutOfWorld_Parms
{
    class UClass* dmgType;
};
struct Actor_eventUsedBy_Parms
{
    class APawn* User;
    BITFIELD ReturnValue;
};
struct Actor_eventOverRotated_Parms
{
    FRotator out_Desired;
    FRotator out_Actual;
    BITFIELD ReturnValue;
};
struct Actor_eventRanInto_Parms
{
    class AActor* Other;
};
struct Actor_eventEncroachedBy_Parms
{
    class AActor* Other;
};
struct Actor_eventEncroachingOn_Parms
{
    class AActor* Other;
    BITFIELD ReturnValue;
};
struct Actor_eventSpecialHandling_Parms
{
    class APawn* Other;
    class AActor* ReturnValue;
};
struct Actor_eventDetach_Parms
{
    class AActor* Other;
};
struct Actor_eventAttach_Parms
{
    class AActor* Other;
};
struct Actor_eventBaseChange_Parms
{
};
struct Actor_eventBump_Parms
{
    class AActor* Other;
    FVector HitNormal;
};
struct Actor_eventUnTouch_Parms
{
    class AActor* Other;
};
struct Actor_eventPostTouch_Parms
{
    class AActor* Other;
};
struct Actor_eventTouch_Parms
{
    class AActor* Other;
    FVector HitLocation;
    FVector HitNormal;
};
struct Actor_eventPhysicsVolumeChange_Parms
{
    class APhysicsVolume* NewVolume;
};
struct Actor_eventZoneChange_Parms
{
    class AZoneInfo* NewZone;
};
struct Actor_eventLanded_Parms
{
    FVector HitNormal;
};
struct Actor_eventFalling_Parms
{
};
struct Actor_eventHitWall_Parms
{
    FVector HitNormal;
    class AActor* HitWall;
};
struct Actor_eventTimer_Parms
{
};
struct Actor_eventTick_Parms
{
    FLOAT DeltaTime;
};
struct Actor_eventLostChild_Parms
{
    class AActor* Other;
};
struct Actor_eventGainedChild_Parms
{
    class AActor* Other;
};
struct Actor_eventDestroyed_Parms
{
};
struct Actor_eventReplicatedEvent_Parms
{
    FString VarName;
};
class AActor : public UObject
{
public:
    TArrayNoInit<class UActorComponent*> Components;
    BYTE Physics;
    BYTE RemoteRole;
    BYTE Role;
    class AActor* Owner GCC_PACK(PROPERTY_ALIGNMENT);
    class AActor* Base;
    TArrayNoInit<FTimerData> Timers;
    BITFIELD bStatic:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bHidden:1;
    BITFIELD bNoDelete:1;
    BITFIELD bDeleteMe:1;
    BITFIELD bOnlyOwnerSee:1;
    BITFIELD bStasis:1;
    BITFIELD bWorldGeometry:1;
    BITFIELD bIgnoreVehicles:1;
    BITFIELD bOrientOnSlope:1;
    BITFIELD bOnlyAffectPawns:1;
    BITFIELD bIgnoreEncroachers:1;
    BITFIELD bNetTemporary:1;
    BITFIELD bOnlyRelevantToOwner:1;
    BITFIELD bAlwaysRelevant:1;
    BITFIELD bReplicateInstigator:1;
    BITFIELD bReplicateMovement:1;
    BITFIELD bSkipActorPropertyReplication:1;
    BITFIELD bUpdateSimulatedPosition:1;
    BITFIELD bTearOff:1;
    BITFIELD bOnlyDirtyReplication:1;
    BITFIELD bNetInitialRotation:1;
    BITFIELD bCompressedPosition:1;
    BITFIELD bClientAuthoritative:1;
    BITFIELD bBadStateCode:1;
    BITFIELD bHardAttach:1;
    BITFIELD bHurtEntry:1;
    BITFIELD bGameRelevant:1;
    BITFIELD bCollideWhenPlacing:1;
    BITFIELD bTravel:1;
    BITFIELD bMovable:1;
    BITFIELD bDestroyInPainVolume:1;
    BITFIELD bCanBeDamaged:1;
    BITFIELD bShouldBaseAtStartup:1;
    BITFIELD bPendingDelete:1;
    BITFIELD bCanTeleport:1;
    BITFIELD bAlwaysTick:1;
    BITFIELD bCollideActors:1;
    BITFIELD bCollideWorld:1;
    BITFIELD bBlockActors:1;
    BITFIELD bProjTarget:1;
    BITFIELD bBlocksTeleport:1;
    BITFIELD bIgnoreOutOfWorld:1;
    BITFIELD bBounce:1;
    BITFIELD bJustTeleported:1;
    BITFIELD bNetInitial:1;
    BITFIELD bNetOwner:1;
    BITFIELD bNetRelevant:1;
    BITFIELD bHiddenEd:1;
    BITFIELD bHiddenEdGroup:1;
    BITFIELD bEdShouldSnap:1;
    BITFIELD bPathColliding:1;
    BITFIELD bScriptInitialized:1;
    BITFIELD bLockLocation:1;
    BITFIELD bTicked:1;
    BITFIELD bNetDirty:1;
    BITFIELD bEdSnap:1;
    BITFIELD bTempEditor:1;
    BITFIELD bPathTemp:1;
    INT NetTag GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT NetUpdateTime;
    FLOAT NetUpdateFrequency;
    FLOAT NetPriority;
    class APawn* Instigator;
    class ALevelInfo* Level;
    class ULevel* XLevel;
    FLOAT LifeSpan;
    FLOAT CreationTime;
    FPointRegion Region;
    FLOAT LastRenderTime;
    FName Tag;
    FName InitialState;
    FName Group;
    TArrayNoInit<class AActor*> Touching;
    class AActor* Deleted;
    FLOAT LatentFloat;
    class UAnimNodeSequence* LatentSeqNode;
    class APhysicsVolume* PhysicsVolume;
    FVector Location;
    FRotator Rotation;
    FVector Velocity;
    FVector Acceleration;
    class USkeletalMeshComponent* BaseSkelComponent;
    FName BaseBoneName;
    FName AttachTag;
    TArrayNoInit<class AActor*> Attached;
    FVector RelativeLocation;
    FRotator RelativeRotation;
    FLOAT DrawScale;
    FVector DrawScale3D;
    FVector PrePivot;
    class UPrimitiveComponent* CollisionComponent;
    INT OverlapTag;
    FLOAT Mass;
    FLOAT Buoyancy;
    FRotator RotationRate;
    FRotator DesiredRotation;
    class AActor* PendingTouch;
    class UEdLayer* Layer;
    class UClass* MessageClass;
    TArrayNoInit<class UClass*> SupportedEvents;
    TArrayNoInit<class USequenceEvent*> GeneratedEvents;
    TArrayNoInit<class USeqAct_Latent*> LatentActions;
    DECLARE_FUNCTION(execActivateEvent);
    DECLARE_FUNCTION(execMultiply_ColorFloat);
    DECLARE_FUNCTION(execAdd_ColorColor);
    DECLARE_FUNCTION(execMultiply_FloatColor);
    DECLARE_FUNCTION(execSubtract_ColorColor);
    DECLARE_FUNCTION(execLocalPlayerControllers);
    DECLARE_FUNCTION(execOverlappingActors);
    DECLARE_FUNCTION(execCollidingActors);
    DECLARE_FUNCTION(execVisibleCollidingActors);
    DECLARE_FUNCTION(execVisibleActors);
    DECLARE_FUNCTION(execTraceActors);
    DECLARE_FUNCTION(execTouchingActors);
    DECLARE_FUNCTION(execBasedActors);
    DECLARE_FUNCTION(execChildActors);
    DECLARE_FUNCTION(execDynamicActors);
    DECLARE_FUNCTION(execAllActors);
    DECLARE_FUNCTION(execMoveCacheEntry);
    DECLARE_FUNCTION(execGetCacheEntry);
    DECLARE_FUNCTION(execGetURLMap);
    DECLARE_FUNCTION(execSuggestFallVelocity);
    DECLARE_FUNCTION(execPlayerCanSeeMe);
    DECLARE_FUNCTION(execMakeNoise);
    DECLARE_FUNCTION(execCreateAudioComponent);
    DECLARE_FUNCTION(execGetTimerCount);
    DECLARE_FUNCTION(execIsTimerActive);
    DECLARE_FUNCTION(execClearTimer);
    DECLARE_FUNCTION(execSetTimer);
    DECLARE_FUNCTION(execDestroy);
    DECLARE_FUNCTION(execSpawn);
    DECLARE_FUNCTION(execGetBoundingCylinder);
    DECLARE_FUNCTION(execGetComponentsBoundingBox);
    DECLARE_FUNCTION(execTouchingActor);
    DECLARE_FUNCTION(execContainsPoint);
    DECLARE_FUNCTION(execFastTrace);
    DECLARE_FUNCTION(execTraceComponent);
    DECLARE_FUNCTION(execTrace);
    DECLARE_FUNCTION(execClampRotation);
    DECLARE_FUNCTION(execAddComponent);
    DECLARE_FUNCTION(execUnClock);
    DECLARE_FUNCTION(execClock);
    DECLARE_FUNCTION(execSetPhysics);
    DECLARE_FUNCTION(execDebugUnclock);
    DECLARE_FUNCTION(execDebugClock);
    DECLARE_FUNCTION(execChartData);
    DECLARE_FUNCTION(execFlushPersistentDebugLines);
    DECLARE_FUNCTION(execDrawPersistentDebugLine);
    DECLARE_FUNCTION(execDrawDebugLine);
    DECLARE_FUNCTION(execSetOwner);
    DECLARE_FUNCTION(execSetBase);
    DECLARE_FUNCTION(execAutonomousPhysics);
    DECLARE_FUNCTION(execMoveSmooth);
    DECLARE_FUNCTION(execSetRelativeLocation);
    DECLARE_FUNCTION(execSetRelativeRotation);
    DECLARE_FUNCTION(execSetRotation);
    DECLARE_FUNCTION(execSetLocation);
    DECLARE_FUNCTION(execMove);
    DECLARE_FUNCTION(execOnlyAffectPawns);
    DECLARE_FUNCTION(execSetPrePivot);
    DECLARE_FUNCTION(execSetDrawScale3D);
    DECLARE_FUNCTION(execSetDrawScale);
    DECLARE_FUNCTION(execSetCollisionSize);
    DECLARE_FUNCTION(execSetCollision);
    DECLARE_FUNCTION(execFinishAnim);
    DECLARE_FUNCTION(execSleep);
    DECLARE_FUNCTION(execError);
    DECLARE_FUNCTION(execConsoleCommand);
    void eventGetActorEyesViewPoint(FVector& out_Location, FRotator& out_Rotation)
    {
        Actor_eventGetActorEyesViewPoint_Parms Parms;
        Parms.out_Location=out_Location;
        Parms.out_Rotation=out_Rotation;
        ProcessEvent(FindFunctionChecked(ENGINE_GetActorEyesViewPoint),&Parms);
        out_Location=Parms.out_Location;
        out_Rotation=Parms.out_Rotation;
    }
    void eventOnAnimPlay(class UAnimNodeSequence* SeqNode)
    {
        Actor_eventOnAnimPlay_Parms Parms;
        Parms.SeqNode=SeqNode;
        ProcessEvent(FindFunctionChecked(ENGINE_OnAnimPlay),&Parms);
    }
    void eventOnAnimEnd(class UAnimNodeSequence* SeqNode)
    {
        Actor_eventOnAnimEnd_Parms Parms;
        Parms.SeqNode=SeqNode;
        ProcessEvent(FindFunctionChecked(ENGINE_OnAnimEnd),&Parms);
    }
    void eventBecomeViewTarget(class APlayerController* PC)
    {
        Actor_eventBecomeViewTarget_Parms Parms;
        Parms.PC=PC;
        ProcessEvent(FindFunctionChecked(ENGINE_BecomeViewTarget),&Parms);
    }
    void eventTravelPostAccept()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_TravelPostAccept),NULL);
    }
    void eventTravelPreAccept()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_TravelPreAccept),NULL);
    }
    void eventTakeDamage(INT Damage, class APawn* EventInstigator, FVector HitLocation, FVector Momentum, class UClass* DamageType, FTraceHitInfo HitInfo)
    {
        Actor_eventTakeDamage_Parms Parms;
        Parms.Damage=Damage;
        Parms.EventInstigator=EventInstigator;
        Parms.HitLocation=HitLocation;
        Parms.Momentum=Momentum;
        Parms.DamageType=DamageType;
        Parms.HitInfo=HitInfo;
        ProcessEvent(FindFunctionChecked(ENGINE_TakeDamage),&Parms);
    }
    void eventKilledBy(class APawn* EventInstigator)
    {
        Actor_eventKilledBy_Parms Parms;
        Parms.EventInstigator=EventInstigator;
        ProcessEvent(FindFunctionChecked(ENGINE_KilledBy),&Parms);
    }
    void eventPostNetBeginPlay()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostNetBeginPlay),NULL);
    }
    void eventSetInitialState()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SetInitialState),NULL);
    }
    void eventPostBeginPlay()
    {
        if(IsProbing(NAME_PostBeginPlay)) {
        ProcessEvent(FindFunctionChecked(ENGINE_PostBeginPlay),NULL);
        }
    }
    void eventBroadcastLocalizedMessage(class UClass* MessageClass, INT Switch, class APlayerReplicationInfo* RelatedPRI_1, class APlayerReplicationInfo* RelatedPRI_2, class UObject* OptionalObject)
    {
        Actor_eventBroadcastLocalizedMessage_Parms Parms;
        Parms.MessageClass=MessageClass;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalizedMessage),&Parms);
    }
    void eventPreBeginPlay()
    {
        if(IsProbing(NAME_PreBeginPlay)) {
        ProcessEvent(FindFunctionChecked(ENGINE_PreBeginPlay),NULL);
        }
    }
    void eventRecoverFromBadStateCode()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_RecoverFromBadStateCode),NULL);
    }
    void eventBeginPlay()
    {
        if(IsProbing(NAME_BeginPlay)) {
        ProcessEvent(FindFunctionChecked(ENGINE_BeginPlay),NULL);
        }
    }
    void eventPostTeleport(class ATeleporter* OutTeleporter)
    {
        Actor_eventPostTeleport_Parms Parms;
        Parms.OutTeleporter=OutTeleporter;
        ProcessEvent(FindFunctionChecked(ENGINE_PostTeleport),&Parms);
    }
    BITFIELD eventPreTeleport(class ATeleporter* InTeleporter)
    {
        Actor_eventPreTeleport_Parms Parms;
        Parms.ReturnValue=0;
        Parms.InTeleporter=InTeleporter;
        ProcessEvent(FindFunctionChecked(ENGINE_PreTeleport),&Parms);
        return Parms.ReturnValue;
    }
    void eventTornOff()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_TornOff),NULL);
    }
    void eventFellOutOfWorld(class UClass* dmgType)
    {
        Actor_eventFellOutOfWorld_Parms Parms;
        Parms.dmgType=dmgType;
        ProcessEvent(FindFunctionChecked(ENGINE_FellOutOfWorld),&Parms);
    }
    BITFIELD eventUsedBy(class APawn* User)
    {
        Actor_eventUsedBy_Parms Parms;
        Parms.ReturnValue=0;
        Parms.User=User;
        ProcessEvent(FindFunctionChecked(ENGINE_UsedBy),&Parms);
        return Parms.ReturnValue;
    }
    BITFIELD eventOverRotated(FRotator& out_Desired, FRotator& out_Actual)
    {
        Actor_eventOverRotated_Parms Parms;
        Parms.ReturnValue=0;
        Parms.out_Desired=out_Desired;
        Parms.out_Actual=out_Actual;
        ProcessEvent(FindFunctionChecked(ENGINE_OverRotated),&Parms);
        out_Desired=Parms.out_Desired;
        out_Actual=Parms.out_Actual;
        return Parms.ReturnValue;
    }
    void eventRanInto(class AActor* Other)
    {
        Actor_eventRanInto_Parms Parms;
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_RanInto),&Parms);
    }
    void eventEncroachedBy(class AActor* Other)
    {
        Actor_eventEncroachedBy_Parms Parms;
        if(IsProbing(NAME_EncroachedBy)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_EncroachedBy),&Parms);
        }
    }
    BITFIELD eventEncroachingOn(class AActor* Other)
    {
        Actor_eventEncroachingOn_Parms Parms;
        Parms.ReturnValue=0;
        if(IsProbing(NAME_EncroachingOn)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_EncroachingOn),&Parms);
        }
        return Parms.ReturnValue;
    }
    class AActor* eventSpecialHandling(class APawn* Other)
    {
        Actor_eventSpecialHandling_Parms Parms;
        Parms.ReturnValue=0;
        if(IsProbing(NAME_SpecialHandling)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_SpecialHandling),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventDetach(class AActor* Other)
    {
        Actor_eventDetach_Parms Parms;
        if(IsProbing(NAME_Detach)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_Detach),&Parms);
        }
    }
    void eventAttach(class AActor* Other)
    {
        Actor_eventAttach_Parms Parms;
        if(IsProbing(NAME_Attach)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_Attach),&Parms);
        }
    }
    void eventBaseChange()
    {
        if(IsProbing(NAME_BaseChange)) {
        ProcessEvent(FindFunctionChecked(ENGINE_BaseChange),NULL);
        }
    }
    void eventBump(class AActor* Other, FVector HitNormal)
    {
        Actor_eventBump_Parms Parms;
        if(IsProbing(NAME_Bump)) {
        Parms.Other=Other;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_Bump),&Parms);
        }
    }
    void eventUnTouch(class AActor* Other)
    {
        Actor_eventUnTouch_Parms Parms;
        if(IsProbing(NAME_UnTouch)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_UnTouch),&Parms);
        }
    }
    void eventPostTouch(class AActor* Other)
    {
        Actor_eventPostTouch_Parms Parms;
        if(IsProbing(NAME_PostTouch)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PostTouch),&Parms);
        }
    }
    void eventTouch(class AActor* Other, FVector HitLocation, FVector HitNormal)
    {
        Actor_eventTouch_Parms Parms;
        if(IsProbing(NAME_Touch)) {
        Parms.Other=Other;
        Parms.HitLocation=HitLocation;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_Touch),&Parms);
        }
    }
    void eventPhysicsVolumeChange(class APhysicsVolume* NewVolume)
    {
        Actor_eventPhysicsVolumeChange_Parms Parms;
        if(IsProbing(NAME_PhysicsVolumeChange)) {
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_PhysicsVolumeChange),&Parms);
        }
    }
    void eventZoneChange(class AZoneInfo* NewZone)
    {
        Actor_eventZoneChange_Parms Parms;
        if(IsProbing(NAME_ZoneChange)) {
        Parms.NewZone=NewZone;
        ProcessEvent(FindFunctionChecked(ENGINE_ZoneChange),&Parms);
        }
    }
    void eventLanded(FVector HitNormal)
    {
        Actor_eventLanded_Parms Parms;
        if(IsProbing(NAME_Landed)) {
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_Landed),&Parms);
        }
    }
    void eventFalling()
    {
        if(IsProbing(NAME_Falling)) {
        ProcessEvent(FindFunctionChecked(ENGINE_Falling),NULL);
        }
    }
    void eventHitWall(FVector HitNormal, class AActor* HitWall)
    {
        Actor_eventHitWall_Parms Parms;
        if(IsProbing(NAME_HitWall)) {
        Parms.HitNormal=HitNormal;
        Parms.HitWall=HitWall;
        ProcessEvent(FindFunctionChecked(ENGINE_HitWall),&Parms);
        }
    }
    void eventTimer()
    {
        if(IsProbing(NAME_Timer)) {
        ProcessEvent(FindFunctionChecked(ENGINE_Timer),NULL);
        }
    }
    void eventTick(FLOAT DeltaTime)
    {
        Actor_eventTick_Parms Parms;
        if(IsProbing(NAME_Tick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_Tick),&Parms);
        }
    }
    void eventLostChild(class AActor* Other)
    {
        Actor_eventLostChild_Parms Parms;
        if(IsProbing(NAME_LostChild)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_LostChild),&Parms);
        }
    }
    void eventGainedChild(class AActor* Other)
    {
        Actor_eventGainedChild_Parms Parms;
        if(IsProbing(NAME_GainedChild)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_GainedChild),&Parms);
        }
    }
    void eventDestroyed()
    {
        if(IsProbing(NAME_Destroyed)) {
        ProcessEvent(FindFunctionChecked(ENGINE_Destroyed),NULL);
        }
    }
    void eventReplicatedEvent(const FString& VarName)
    {
        Actor_eventReplicatedEvent_Parms Parms;
        Parms.VarName=VarName;
        ProcessEvent(FindFunctionChecked(ENGINE_ReplicatedEvent),&Parms);
    }
    DECLARE_CLASS(AActor,UObject,0|CLASS_NativeReplication,Engine)
    #include "AActor.h"
};

enum ECsgOper
{
    CSG_Active              =0,
    CSG_Add                 =1,
    CSG_Subtract            =2,
    CSG_Intersect           =3,
    CSG_Deintersect         =4,
    CSG_MAX                 =5,
};
struct FGeomSelection
{
    INT Type;
    INT Index;
    INT SelectionIndex;
    FLOAT SelStrength;
    friend FArchive& operator<<(FArchive& Ar,FGeomSelection& MyGeomSelection)
    {
        return Ar << MyGeomSelection.Type << MyGeomSelection.Index << MyGeomSelection.SelectionIndex << MyGeomSelection.SelStrength;
    }
};


class ABrush : public AActor
{
public:
    BYTE CsgOper;
    FColor BrushColor GCC_PACK(PROPERTY_ALIGNMENT);
    INT PolyFlags;
    BITFIELD bColored:1 GCC_PACK(PROPERTY_ALIGNMENT);
    class UModel* Brush GCC_PACK(PROPERTY_ALIGNMENT);
    class UBrushComponent* BrushComponent;
    TArrayNoInit<FGeomSelection> SavedSelections;
    DECLARE_CLASS(ABrush,AActor,0,Engine)
    #include "ABrush.h"
};


class AVolume : public ABrush
{
public:
    class AActor* AssociatedActor;
    FName AssociatedActorTag;
    INT LocationPriority;
    FStringNoInit LocationName;
    DECLARE_FUNCTION(execEncompasses);
    DECLARE_CLASS(AVolume,ABrush,0,Engine)
	INT Encompasses(FVector point);
	void SetVolumes();
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual UBOOL IsAVolume() {return true;}
};


class ABlockingVolume : public AVolume
{
public:
    BITFIELD bClampFluid:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(ABlockingVolume,AVolume,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ABlockingVolume)
};


struct PhysicsVolume_eventPawnLeavingVolume_Parms
{
    class APawn* Other;
};
struct PhysicsVolume_eventPawnEnteredVolume_Parms
{
    class APawn* Other;
};
struct PhysicsVolume_eventActorLeavingVolume_Parms
{
    class AActor* Other;
};
struct PhysicsVolume_eventActorEnteredVolume_Parms
{
    class AActor* Other;
};
struct PhysicsVolume_eventPhysicsChangedFor_Parms
{
    class AActor* Other;
};
class APhysicsVolume : public AVolume
{
public:
    FVector ZoneVelocity;
    FVector Gravity;
    FVector BACKUP_Gravity;
    FLOAT GroundFriction;
    FLOAT TerminalVelocity;
    FLOAT DamagePerSec;
    class UClass* DamageType;
    INT Priority;
    FLOAT FluidFriction;
    BITFIELD bPainCausing:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD BACKUP_bPainCausing:1;
    BITFIELD bDestructive:1;
    BITFIELD bNoInventory:1;
    BITFIELD bMoveProjectiles:1;
    BITFIELD bBounceVelocity:1;
    BITFIELD bNeutralZone:1;
    BITFIELD bPhysicsOnContact:1;
    BITFIELD bWaterVolume:1;
    class AInfo* PainTimer GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT KExtraLinearDamping;
    FLOAT KExtraAngularDamping;
    FLOAT KBuoyancy;
    class APhysicsVolume* NextPhysicsVolume;
    void eventPawnLeavingVolume(class APawn* Other)
    {
        PhysicsVolume_eventPawnLeavingVolume_Parms Parms;
        if(IsProbing(NAME_PawnLeavingVolume)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PawnLeavingVolume),&Parms);
        }
    }
    void eventPawnEnteredVolume(class APawn* Other)
    {
        PhysicsVolume_eventPawnEnteredVolume_Parms Parms;
        if(IsProbing(NAME_PawnEnteredVolume)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PawnEnteredVolume),&Parms);
        }
    }
    void eventActorLeavingVolume(class AActor* Other)
    {
        PhysicsVolume_eventActorLeavingVolume_Parms Parms;
        if(IsProbing(NAME_ActorLeavingVolume)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ActorLeavingVolume),&Parms);
        }
    }
    void eventActorEnteredVolume(class AActor* Other)
    {
        PhysicsVolume_eventActorEnteredVolume_Parms Parms;
        if(IsProbing(NAME_ActorEnteredVolume)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ActorEnteredVolume),&Parms);
        }
    }
    void eventPhysicsChangedFor(class AActor* Other)
    {
        PhysicsVolume_eventPhysicsChangedFor_Parms Parms;
        if(IsProbing(NAME_PhysicsChangedFor)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_PhysicsChangedFor),&Parms);
        }
    }
    DECLARE_CLASS(APhysicsVolume,AVolume,0|CLASS_NativeReplication,Engine)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	void SetZone( UBOOL bTest, UBOOL bForceRefresh );
void CheckForErrors();
};


class ADefaultPhysicsVolume : public APhysicsVolume
{
public:
    DECLARE_CLASS(ADefaultPhysicsVolume,APhysicsVolume,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ADefaultPhysicsVolume)
};


class ALadderVolume : public APhysicsVolume
{
public:
    FName ClimbingAnimation;
    FName TopAnimation;
    FRotator WallDir;
    FVector LookDir;
    FVector ClimbDir;
    class ALadder* LadderList;
    BITFIELD bNoPhysicalLadder:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bAutoPath:1;
    BITFIELD bAllowLadderStrafing:1;
    class APawn* PendingClimber GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(ALadderVolume,APhysicsVolume,0,Engine)
	virtual INT AddMyMarker(AActor *S);
	FVector FindTop(FVector V);
	FVector FindCenter();
};

struct FsViewTarget
{
    class AActor* Target;
    class AController* TargetController;
    FVector LastLocation;
    FRotator LastRotation;
};

struct FsCameraCache
{
    FLOAT LastTimeStamp;
    FVector LastLocation;
    FRotator LastRotation;
};


class ACamera : public AActor
{
public:
    class APlayerController* PCOwner;
    FLOAT fBlendTime;
    FName CameraStyle;
    FLOAT CamFOV;
    BITFIELD bLockedFOV:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bConstrainAspectRatio:1;
    BITFIELD bEnableFading:1;
    FLOAT LockedFOV GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT ConstrainedAspectRatio;
    FColor FadeColor;
    FLOAT FadeAmount;
    FsViewTarget primaryVT;
    FsCameraCache CameraCache;
    TArrayNoInit<class UCameraModifier*> ModifierList;
    DECLARE_FUNCTION(execSetViewTarget);
    DECLARE_FUNCTION(execFillCameraCache);
    DECLARE_CLASS(ACamera,AActor,0,Engine)
	void CheckViewTarget( FsViewTarget* VT );
	void SetViewTarget( AActor* NewViewTarget );
	AActor* GetViewTarget();
};


class ACameraActor : public AActor
{
public:
    BITFIELD bConstrainAspectRatio:1 GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT AspectRatio GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT FOVAngle;
    class UDrawFrustumComponent* DrawFrustum;
    class UStaticMeshComponent* MeshComp;
    DECLARE_CLASS(ACameraActor,AActor,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// AActor interface
	virtual void Spawned();

	// ACameraActor interface
	void UpdateDrawFrustum();
};


class ACarriedObject : public AActor
{
public:
    BITFIELD bHome:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bHeld:1;
    class APlayerReplicationInfo* HolderPRI GCC_PACK(PROPERTY_ALIGNMENT);
    class APawn* Holder;
    class ANavigationPoint* LastAnchor;
    FLOAT LastValidAnchorTime;
    DECLARE_CLASS(ACarriedObject,AActor,0|CLASS_NativeReplication,Engine)
	INT* GetOptimizedRepList( BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

#define UCONST_LATENT_MOVETOWARD 503

struct Controller_eventNotifyMissedJump_Parms
{
};
struct Controller_eventNotifyJumpApex_Parms
{
};
struct Controller_eventNotifyBump_Parms
{
    class AActor* Other;
    FVector HitNormal;
    BITFIELD ReturnValue;
};
struct Controller_eventNotifyFallingHitWall_Parms
{
    FVector HitNormal;
    class AActor* Wall;
};
struct Controller_eventNotifyHitWall_Parms
{
    FVector HitNormal;
    class AActor* Wall;
    BITFIELD ReturnValue;
};
struct Controller_eventNotifyLanded_Parms
{
    FVector HitNormal;
    BITFIELD ReturnValue;
};
struct Controller_eventNotifyHeadVolumeChange_Parms
{
    class APhysicsVolume* NewVolume;
    BITFIELD ReturnValue;
};
struct Controller_eventNotifyPhysicsVolumeChange_Parms
{
    class APhysicsVolume* NewVolume;
};
struct Controller_eventGetPlayerViewPoint_Parms
{
    FVector out_Location;
    FRotator out_Rotation;
};
struct Controller_eventGetFOVAngle_Parms
{
    FLOAT ReturnValue;
};
struct Controller_eventAllowDetourTo_Parms
{
    class ANavigationPoint* N;
    BITFIELD ReturnValue;
};
struct Controller_eventMayFall_Parms
{
};
struct Controller_eventLongFall_Parms
{
};
struct Controller_eventSetupSpecialPathAbilities_Parms
{
};
struct Controller_eventPrepareForMove_Parms
{
    class ANavigationPoint* Goal;
    class UReachSpec* Path;
};
struct Controller_eventEnemyNotVisible_Parms
{
};
struct Controller_eventSeeMonster_Parms
{
    class APawn* Seen;
};
struct Controller_eventSeePlayer_Parms
{
    class APawn* Seen;
};
struct Controller_eventHearNoise_Parms
{
    FLOAT Loudness;
    class AActor* NoiseMaker;
};
struct Controller_eventRatePickup_Parms
{
    class APickupFactory* inPickup;
    FLOAT ReturnValue;
};
struct Controller_eventNotifyPostLanded_Parms
{
};
struct Controller_eventUnPossess_Parms
{
};
struct Controller_eventPossess_Parms
{
    class APawn* inPawn;
};
class AController : public AActor
{
public:
    class APawn* Pawn;
    class APlayerReplicationInfo* PlayerReplicationInfo;
    INT PlayerNum;
    class AController* NextController;
    FLOAT FOVAngle;
    BITFIELD bIsPlayer:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bGodMode:1;
    BITFIELD bSoaking:1;
    BITFIELD bSlowerZAcquire:1;
    BITFIELD bForceStrafe:1;
    BITFIELD bNotifyPostLanded:1;
    BITFIELD bNotifyApex:1;
    BITFIELD bAdvancedTactics:1;
    BITFIELD bCanOpenDoors:1;
    BITFIELD bCanDoSpecial:1;
    BITFIELD bAdjusting:1;
    BITFIELD bPreparingMove:1;
    BITFIELD bLOSflag:1;
    BITFIELD bUsePlayerHearing:1;
    BITFIELD bJumpOverWall:1;
    BITFIELD bEnemyAcquired:1;
    BITFIELD bNotifyFallingHitWall:1;
    BYTE bFire GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT MinHitWall GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT MoveTimer;
    class AActor* MoveTarget;
    FVector Destination;
    FVector FocalPoint;
    class AActor* Focus;
    FLOAT FocusLead;
    class AActor* GoalList[4];
    INT AcquisitionYawRate;
    FVector AdjustLoc;
    class ANavigationPoint* StartSpot;
    TArrayNoInit<class AActor*> RouteCache;
    class UReachSpec* CurrentPath;
    class UReachSpec* NextRoutePath;
    FVector CurrentPathDir;
    class AActor* RouteGoal;
    FLOAT RouteDist;
    FLOAT LastRouteFind;
    FLOAT GroundPitchTime;
    FVector ViewX;
    FVector ViewY;
    FVector ViewZ;
    class APawn* ShotTarget;
    class AActor* LastFailedReach;
    FLOAT FailedReachTime;
    FVector FailedReachLocation;
    FLOAT SightCounter;
    class APawn* Enemy;
    class AActor* Target;
    BITFIELD bForceDesiredRotation:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bPreciseDestination:1;
    DECLARE_FUNCTION(execStopLatentExecution);
    DECLARE_FUNCTION(execInLatentExecution);
    DECLARE_FUNCTION(execEndClimbLadder);
    DECLARE_FUNCTION(execWaitForLanding);
    DECLARE_FUNCTION(execPickWallAdjust);
    DECLARE_FUNCTION(execActorReachable);
    DECLARE_FUNCTION(execPointReachable);
    DECLARE_FUNCTION(execFindPathToIntercept);
    DECLARE_FUNCTION(execFindRandomDest);
    DECLARE_FUNCTION(execFindPathTowardNearest);
    DECLARE_FUNCTION(execFindPathToward);
    DECLARE_FUNCTION(execFindPathTo);
    DECLARE_FUNCTION(execFinishRotation);
    DECLARE_FUNCTION(execMoveToward);
    DECLARE_FUNCTION(execMoveTo);
    DECLARE_FUNCTION(execPickAnyTarget);
    DECLARE_FUNCTION(execPickTarget);
    DECLARE_FUNCTION(execCanSee);
    DECLARE_FUNCTION(execLineOfSightTo);
    void eventNotifyMissedJump()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyMissedJump),NULL);
    }
    void eventNotifyJumpApex()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyJumpApex),NULL);
    }
    BITFIELD eventNotifyBump(class AActor* Other, FVector HitNormal)
    {
        Controller_eventNotifyBump_Parms Parms;
        Parms.ReturnValue=0;
        if(IsProbing(NAME_NotifyBump)) {
        Parms.Other=Other;
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyBump),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventNotifyFallingHitWall(FVector HitNormal, class AActor* Wall)
    {
        Controller_eventNotifyFallingHitWall_Parms Parms;
        Parms.HitNormal=HitNormal;
        Parms.Wall=Wall;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyFallingHitWall),&Parms);
    }
    BITFIELD eventNotifyHitWall(FVector HitNormal, class AActor* Wall)
    {
        Controller_eventNotifyHitWall_Parms Parms;
        Parms.ReturnValue=0;
        if(IsProbing(NAME_NotifyHitWall)) {
        Parms.HitNormal=HitNormal;
        Parms.Wall=Wall;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyHitWall),&Parms);
        }
        return Parms.ReturnValue;
    }
    BITFIELD eventNotifyLanded(FVector HitNormal)
    {
        Controller_eventNotifyLanded_Parms Parms;
        Parms.ReturnValue=0;
        if(IsProbing(NAME_NotifyLanded)) {
        Parms.HitNormal=HitNormal;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyLanded),&Parms);
        }
        return Parms.ReturnValue;
    }
    BITFIELD eventNotifyHeadVolumeChange(class APhysicsVolume* NewVolume)
    {
        Controller_eventNotifyHeadVolumeChange_Parms Parms;
        Parms.ReturnValue=0;
        if(IsProbing(NAME_NotifyHeadVolumeChange)) {
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyHeadVolumeChange),&Parms);
        }
        return Parms.ReturnValue;
    }
    void eventNotifyPhysicsVolumeChange(class APhysicsVolume* NewVolume)
    {
        Controller_eventNotifyPhysicsVolumeChange_Parms Parms;
        if(IsProbing(NAME_NotifyPhysicsVolumeChange)) {
        Parms.NewVolume=NewVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPhysicsVolumeChange),&Parms);
        }
    }
    void eventGetPlayerViewPoint(FVector& out_Location, FRotator& out_Rotation)
    {
        Controller_eventGetPlayerViewPoint_Parms Parms;
        Parms.out_Location=out_Location;
        Parms.out_Rotation=out_Rotation;
        ProcessEvent(FindFunctionChecked(ENGINE_GetPlayerViewPoint),&Parms);
        out_Location=Parms.out_Location;
        out_Rotation=Parms.out_Rotation;
    }
    FLOAT eventGetFOVAngle()
    {
        Controller_eventGetFOVAngle_Parms Parms;
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_GetFOVAngle),&Parms);
        return Parms.ReturnValue;
    }
    BITFIELD eventAllowDetourTo(class ANavigationPoint* N)
    {
        Controller_eventAllowDetourTo_Parms Parms;
        Parms.ReturnValue=0;
        Parms.N=N;
        ProcessEvent(FindFunctionChecked(ENGINE_AllowDetourTo),&Parms);
        return Parms.ReturnValue;
    }
    void eventMayFall()
    {
        if(IsProbing(NAME_MayFall)) {
        ProcessEvent(FindFunctionChecked(ENGINE_MayFall),NULL);
        }
    }
    void eventLongFall()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_LongFall),NULL);
    }
    void eventSetupSpecialPathAbilities()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SetupSpecialPathAbilities),NULL);
    }
    void eventPrepareForMove(class ANavigationPoint* Goal, class UReachSpec* Path)
    {
        Controller_eventPrepareForMove_Parms Parms;
        if(IsProbing(NAME_PrepareForMove)) {
        Parms.Goal=Goal;
        Parms.Path=Path;
        ProcessEvent(FindFunctionChecked(ENGINE_PrepareForMove),&Parms);
        }
    }
    void eventEnemyNotVisible()
    {
        if(IsProbing(NAME_EnemyNotVisible)) {
        ProcessEvent(FindFunctionChecked(ENGINE_EnemyNotVisible),NULL);
        }
    }
    void eventSeeMonster(class APawn* Seen)
    {
        Controller_eventSeeMonster_Parms Parms;
        if(IsProbing(NAME_SeeMonster)) {
        Parms.Seen=Seen;
        ProcessEvent(FindFunctionChecked(ENGINE_SeeMonster),&Parms);
        }
    }
    void eventSeePlayer(class APawn* Seen)
    {
        Controller_eventSeePlayer_Parms Parms;
        if(IsProbing(NAME_SeePlayer)) {
        Parms.Seen=Seen;
        ProcessEvent(FindFunctionChecked(ENGINE_SeePlayer),&Parms);
        }
    }
    void eventHearNoise(FLOAT Loudness, class AActor* NoiseMaker)
    {
        Controller_eventHearNoise_Parms Parms;
        if(IsProbing(NAME_HearNoise)) {
        Parms.Loudness=Loudness;
        Parms.NoiseMaker=NoiseMaker;
        ProcessEvent(FindFunctionChecked(ENGINE_HearNoise),&Parms);
        }
    }
    FLOAT eventRatePickup(class APickupFactory* inPickup)
    {
        Controller_eventRatePickup_Parms Parms;
        Parms.ReturnValue=0;
        Parms.inPickup=inPickup;
        ProcessEvent(FindFunctionChecked(ENGINE_RatePickup),&Parms);
        return Parms.ReturnValue;
    }
    void eventNotifyPostLanded()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPostLanded),NULL);
    }
    void eventUnPossess()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_UnPossess),NULL);
    }
    void eventPossess(class APawn* inPawn)
    {
        Controller_eventPossess_Parms Parms;
        Parms.inPawn=inPawn;
        ProcessEvent(FindFunctionChecked(ENGINE_Possess),&Parms);
    }
    DECLARE_CLASS(AController,AActor,0|CLASS_NativeReplication,Engine)
    #include "AController.h"
};

enum EInputMatchAction
{
    IMA_GreaterThan         =0,
    IMA_LessThan            =1,
    IMA_MAX                 =2,
};
enum EInputTypes
{
    IT_XAxis                =0,
    IT_YAxis                =1,
    IT_MAX                  =2,
};
struct FClientAdjustment
{
    FLOAT TimeStamp;
    FName NewState;
    BYTE newPhysics;
    FVector NewLoc GCC_PACK(PROPERTY_ALIGNMENT);
    FVector NewVel;
    class AActor* NewBase;
    FVector NewFloor;
    BYTE bAckGoodMove;
};

struct FInputEntry
{
    BYTE Type;
    FLOAT Value GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT TimeDelta;
    BYTE Action;
};

struct FInputMatchRequest
{
    TArrayNoInit<FInputEntry> Inputs;
    class AActor* MatchActor;
    FName MatchFuncName;
    FName FailedFuncName;
    FName RequestName;
    INT MatchIdx;
    FLOAT LastMatchTime;
};


struct PlayerController_eventClientSetViewTarget_Parms
{
    class AActor* A;
};
struct PlayerController_eventPlayerTick_Parms
{
    FLOAT DeltaTime;
};
struct PlayerController_eventSetProgressTime_Parms
{
    FLOAT T;
};
struct PlayerController_eventSetProgressMessage_Parms
{
    INT Index;
    FString S;
    FColor C;
};
struct PlayerController_eventSendClientAdjustment_Parms
{
};
struct PlayerController_eventResetCameraMode_Parms
{
};
struct PlayerController_eventPreClientTravel_Parms
{
};
struct PlayerController_eventTeamMessage_Parms
{
    class APlayerReplicationInfo* PRI;
    FString S;
    FName Type;
};
struct PlayerController_eventClientMessage_Parms
{
    FString S;
    FName Type;
};
struct PlayerController_eventReceiveLocalizedMessage_Parms
{
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
};
struct PlayerController_eventInitInputSystem_Parms
{
};
struct PlayerController_eventClientReset_Parms
{
};
struct PlayerController_eventKickWarning_Parms
{
};
struct PlayerController_eventPreRender_Parms
{
    class UCanvas* Canvas;
};
struct PlayerController_eventServerValidationResponse_Parms
{
    FString R;
};
struct PlayerController_eventClientValidate_Parms
{
    FString C;
};
struct PlayerController_eventClientTravel_Parms
{
    FString URL;
    BYTE TravelType;
    BITFIELD bItems;
};
class APlayerController : public AController
{
public:
    class UPlayer* Player;
    class ACamera* PlayerCamera;
    class UClass* CameraClass;
    BITFIELD bFrozen:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bPressedJump:1;
    BITFIELD bDoubleJump:1;
    BITFIELD bUpdatePosition:1;
    BITFIELD bIsTyping:1;
    BITFIELD bFixedCamera:1;
    BITFIELD bJumpStatus:1;
    BITFIELD bUpdating:1;
    BITFIELD bNeverSwitchOnPickup:1;
    BITFIELD bZooming:1;
    BITFIELD bSetTurnRot:1;
    BITFIELD bCheatFlying:1;
    BITFIELD bZeroRoll:1;
    BITFIELD bCameraPositionLocked:1;
    BITFIELD bShortConnectTimeOut:1;
    BITFIELD bPendingDestroy:1;
    BITFIELD bWasSpeedHack:1;
    BITFIELD bWasSaturated:1;
    BITFIELD bDynamicNetSpeed:1;
    BITFIELD bAimingHelp:1;
    BITFIELD bLandingShake:1;
    BITFIELD bMovementInputEnabled:1;
    BITFIELD bTurningInputEnabled:1;
    FLOAT MaxResponseTime GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT WaitDelay;
    class APawn* AcknowledgedPawn;
    BYTE DoubleClickDir;
    BYTE bRun;
    BYTE bDuck;
    class AActor* ViewTarget GCC_PACK(PROPERTY_ALIGNMENT);
    class AController* RealViewTarget;
    FLOAT DesiredFOV;
    FLOAT DefaultFOV;
    FLOAT ZoomLevel;
    FRotator TargetViewRotation;
    FLOAT TargetEyeHeight;
    FVector TargetWeaponViewOffset;
    class AHUD* myHUD;
    class UClass* SavedMoveClass;
    class ASavedMove* SavedMoves;
    class ASavedMove* FreeMoves;
    class ASavedMove* PendingMove;
    FVector LastAckedAccel;
    FLOAT CurrentTimeStamp;
    FLOAT LastUpdateTime;
    FLOAT ServerTimeStamp;
    FLOAT TimeMargin;
    FLOAT ClientUpdateTime;
    FLOAT MaxTimeMargin;
    FLOAT LastActiveTime;
    FLOAT DynamicPingThreshold;
    INT ClientCap;
    FLOAT LastPingUpdate;
    FLOAT ExactPing;
    FLOAT OldPing;
    FLOAT LastSpeedHackLog;
    FClientAdjustment PendingAdjustment;
    FStringNoInit ProgressMessage[4];
    FColor ProgressColor[4];
    FLOAT ProgressTimeOut;
    FStringNoInit QuickSaveString;
    FStringNoInit NoPauseMessage;
    FStringNoInit ViewingFrom;
    FStringNoInit OwnCamera;
    FStringNoInit StatsUsername;
    FStringNoInit StatsPassword;
    class UClass* LocalMessageClass;
    FLOAT MaxShakeRoll;
    FVector MaxShakeOffset;
    FLOAT ShakeRollRate;
    FVector ShakeOffsetRate;
    FVector ShakeOffset;
    FLOAT ShakeRollTime;
    FVector ShakeOffsetTime;
    class APawn* TurnTarget;
    INT EnemyTurnSpeed;
    INT GroundPitch;
    FRotator TurnRot180;
    FVector OldFloor;
    class UCheatManager* CheatManager;
    class UClass* CheatClass;
    class UPlayerInput* PlayerInput;
    class UClass* InputClass;
    class UClass* ConsoleClass;
    FVector FailedPathStart;
    class UCylinderComponent* CylinderComponent;
    class UClass* ForceFeedbackManagerClass;
    class UForceFeedbackManager* ForceFeedbackManager;
    TArrayNoInit<class UInteraction*> Interactions;
    class UConsole* Console;
    FLOAT InteractDistance;
    TArrayNoInit<FInputMatchRequest> InputRequests;
    FLOAT LastBroadcastTime;
    FStringNoInit LastBroadcastString[4];
    DECLARE_FUNCTION(execFindStairRotation);
    DECLARE_FUNCTION(execCheckSpeedHack);
    DECLARE_FUNCTION(execServerValidationResponse);
    DECLARE_FUNCTION(execClientValidate);
    DECLARE_FUNCTION(execSetViewTarget);
    DECLARE_FUNCTION(execPasteFromClipboard);
    DECLARE_FUNCTION(execCopyToClipboard);
    DECLARE_FUNCTION(execGetDefaultURL);
    DECLARE_FUNCTION(execUpdateURL);
    DECLARE_FUNCTION(execClientTravel);
    DECLARE_FUNCTION(execGetEntryLevel);
    DECLARE_FUNCTION(execConsoleCommand);
    DECLARE_FUNCTION(execGetServerNetworkAddress);
    DECLARE_FUNCTION(execGetPlayerNetworkAddress);
    DECLARE_FUNCTION(execSetNetSpeed);
    void eventClientSetViewTarget(class AActor* A)
    {
        PlayerController_eventClientSetViewTarget_Parms Parms;
        Parms.A=A;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientSetViewTarget),&Parms);
    }
    void eventPlayerTick(FLOAT DeltaTime)
    {
        PlayerController_eventPlayerTick_Parms Parms;
        if(IsProbing(NAME_PlayerTick)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayerTick),&Parms);
        }
    }
    void eventSetProgressTime(FLOAT T)
    {
        PlayerController_eventSetProgressTime_Parms Parms;
        Parms.T=T;
        ProcessEvent(FindFunctionChecked(ENGINE_SetProgressTime),&Parms);
    }
    void eventSetProgressMessage(INT Index, const FString& S, FColor C)
    {
        PlayerController_eventSetProgressMessage_Parms Parms;
        Parms.Index=Index;
        Parms.S=S;
        Parms.C=C;
        ProcessEvent(FindFunctionChecked(ENGINE_SetProgressMessage),&Parms);
    }
    void eventSendClientAdjustment()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SendClientAdjustment),NULL);
    }
    void eventResetCameraMode()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ResetCameraMode),NULL);
    }
    void eventPreClientTravel()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PreClientTravel),NULL);
    }
    void eventTeamMessage(class APlayerReplicationInfo* PRI, const FString& S, FName Type)
    {
        PlayerController_eventTeamMessage_Parms Parms;
        Parms.PRI=PRI;
        Parms.S=S;
        Parms.Type=Type;
        ProcessEvent(FindFunctionChecked(ENGINE_TeamMessage),&Parms);
    }
    void eventClientMessage(const FString& S, FName Type)
    {
        PlayerController_eventClientMessage_Parms Parms;
        Parms.S=S;
        Parms.Type=Type;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientMessage),&Parms);
    }
    void eventReceiveLocalizedMessage(class UClass* Message, INT Switch, class APlayerReplicationInfo* RelatedPRI_1, class APlayerReplicationInfo* RelatedPRI_2, class UObject* OptionalObject)
    {
        PlayerController_eventReceiveLocalizedMessage_Parms Parms;
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_ReceiveLocalizedMessage),&Parms);
    }
    void eventInitInputSystem()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_InitInputSystem),NULL);
    }
    void eventClientReset()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ClientReset),NULL);
    }
    void eventKickWarning()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_KickWarning),NULL);
    }
    void eventPreRender(class UCanvas* Canvas)
    {
        PlayerController_eventPreRender_Parms Parms;
        Parms.Canvas=Canvas;
        ProcessEvent(FindFunctionChecked(ENGINE_PreRender),&Parms);
    }
    void eventServerValidationResponse(const FString& R)
    {
        PlayerController_eventServerValidationResponse_Parms Parms;
        Parms.R=R;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerValidationResponse),&Parms);
    }
    void eventClientValidate(const FString& C)
    {
        PlayerController_eventClientValidate_Parms Parms;
        Parms.C=C;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientValidate),&Parms);
    }
    void eventClientTravel(const FString& URL, BYTE TravelType, BITFIELD bItems)
    {
        PlayerController_eventClientTravel_Parms Parms;
        Parms.URL=URL;
        Parms.TravelType=TravelType;
        Parms.bItems=bItems;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientTravel),&Parms);
    }
    DECLARE_CLASS(APlayerController,AController,0|CLASS_Config|CLASS_NativeReplication,Engine)
	//  Player Pawn interface.
	void SetPlayer( UPlayer* Player );

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	UBOOL IsNetRelevantFor( APlayerController* RealViewer, AActor* Viewer, FVector SrcLocation );
	virtual UBOOL LocalPlayerController();
	virtual UBOOL WantsLedgeCheck();
	virtual UBOOL StopAtLedge();
	virtual AActor* GetViewTarget();
	virtual APlayerController* GetAPlayerController() { return this; }
	void SetViewTarget(AActor* NewViewTarget);

    virtual UBOOL IsAPlayerController() { return true; }
	virtual void PostScriptDestroyed();
};


class ADroppedPickup : public AActor
{
public:
    class AInventory* Inventory;
    class ANavigationPoint* PickupCache;
    DECLARE_FUNCTION(execRemoveFromNavigation);
    DECLARE_FUNCTION(execAddToNavigation);
    DECLARE_CLASS(ADroppedPickup,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ADroppedPickup)
};

struct FConsoleMessage
{
    FStringNoInit Text;
    FColor TextColor;
    FLOAT MessageLife;
    class APlayerReplicationInfo* PRI;
};

struct FHudLocalizedMessage
{
    class UClass* Message;
    FStringNoInit StringMessage;
    INT Switch;
    FLOAT EndOfLife;
    FLOAT Lifetime;
    FLOAT PosY;
    FColor DrawColor;
    INT FontSize;
    class UFont* StringFont;
    FLOAT DX;
    FLOAT DY;
    BITFIELD Drawn:1 GCC_PACK(PROPERTY_ALIGNMENT);
};


struct HUD_eventConnectFailure_Parms
{
    FString FailCode;
    FString URL;
};
struct HUD_eventPostRender_Parms
{
};
class AHUD : public AActor
{
public:
    FColor WhiteColor;
    FColor GreenColor;
    FColor RedColor;
    class APlayerController* PlayerOwner;
    class AHUD* HudOwner;
    class APlayerReplicationInfo* ViewedInfo;
    FLOAT ProgressFadeTime;
    FColor MOTDColor;
    class AActor* AnimDebugThis;
    class AScoreBoard* ScoreBoard;
    BITFIELD bShowHUD:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bShowScores:1;
    BITFIELD bShowDebugInfo:1;
    BITFIELD bShowAIDebug:1;
    BITFIELD bShowPhysicsDebug:1;
    BITFIELD bShowWeaponDebug:1;
    BITFIELD bShowNetworkDebug:1;
    BITFIELD bShowCollisionDebug:1;
    BITFIELD bShowAnimDebug:1;
    BITFIELD bHideCenterMessages:1;
    BITFIELD bShowBadConnectionAlert:1;
    BITFIELD bMessageBeep:1;
    FLOAT HudCanvasScale GCC_PACK(PROPERTY_ALIGNMENT);
    FStringNoInit LoadingMessage;
    FStringNoInit SavingMessage;
    FStringNoInit ConnectingMessage;
    FStringNoInit PausedMessage;
    FStringNoInit PrecachingMessage;
    FConsoleMessage ConsoleMessages[8];
    FColor ConsoleColor;
    INT ConsoleMessageCount;
    INT ConsoleFontSize;
    INT MessageFontOffset;
    FHudLocalizedMessage LocalMessages[8];
    FLOAT ConsoleMessagePosX;
    FLOAT ConsoleMessagePosY;
    class UCanvas* Canvas;
    FLOAT LastRenderTime;
    FLOAT RenderDelta;
    FLOAT SizeX;
    FLOAT SizeY;
    FLOAT CenterX;
    FLOAT CenterY;
    FLOAT RatioX;
    FLOAT RatioY;
    DECLARE_FUNCTION(execDraw3DLine);
    void eventConnectFailure(const FString& FailCode, const FString& URL)
    {
        HUD_eventConnectFailure_Parms Parms;
        Parms.FailCode=FailCode;
        Parms.URL=URL;
        ProcessEvent(FindFunctionChecked(ENGINE_ConnectFailure),&Parms);
    }
    void eventPostRender()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_PostRender),NULL);
    }
    DECLARE_CLASS(AHUD,AActor,0|CLASS_Transient|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(AHUD)
};

struct FKeyValuePair
{
    FString Key;
    FString Value;
    friend FArchive& operator<<(FArchive& Ar,FKeyValuePair& MyKeyValuePair)
    {
        return Ar << MyKeyValuePair.Key << MyKeyValuePair.Value;
    }
};

struct FPlayerResponseLine
{
    INT PlayerNum;
    INT PlayerID;
    FString PlayerName;
    INT Ping;
    INT Score;
    INT StatsID;
    TArray<FKeyValuePair> PlayerInfo;
    friend FArchive& operator<<(FArchive& Ar,FPlayerResponseLine& MyPlayerResponseLine)
    {
        return Ar << MyPlayerResponseLine.PlayerNum << MyPlayerResponseLine.PlayerID << MyPlayerResponseLine.PlayerName << MyPlayerResponseLine.Ping << MyPlayerResponseLine.Score << MyPlayerResponseLine.StatsID << MyPlayerResponseLine.PlayerInfo;
    }
};

struct FServerResponseLine
{
    INT ServerID;
    FString IP;
    INT Port;
    INT QueryPort;
    FString ServerName;
    FString MapName;
    FString GameType;
    INT CurrentPlayers;
    INT MaxPlayers;
    INT Ping;
    TArray<FKeyValuePair> ServerInfo;
    TArray<FPlayerResponseLine> PlayerInfo;
    friend FArchive& operator<<(FArchive& Ar,FServerResponseLine& MyServerResponseLine)
    {
        return Ar << MyServerResponseLine.ServerID << MyServerResponseLine.IP << MyServerResponseLine.Port << MyServerResponseLine.QueryPort << MyServerResponseLine.ServerName << MyServerResponseLine.MapName << MyServerResponseLine.GameType << MyServerResponseLine.CurrentPlayers << MyServerResponseLine.MaxPlayers << MyServerResponseLine.Ping << MyServerResponseLine.ServerInfo << MyServerResponseLine.PlayerInfo;
    }
};


class AInfo : public AActor
{
public:
    DECLARE_CLASS(AInfo,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AInfo)
};


class AFileLog : public AInfo
{
public:
    Fpointer LogAr;
    FStringNoInit LogFileName;
    DECLARE_FUNCTION(execLogf);
    DECLARE_FUNCTION(execCloseLog);
    DECLARE_FUNCTION(execOpenLog);
    DECLARE_CLASS(AFileLog,AInfo,0,Engine)
	void OpenLog(FString &fileName,FString &extension);
	void Logf(FString &logString);
};


struct GameInfo_eventBroadcastLocalized_Parms
{
    class AActor* Sender;
    class UClass* Message;
    INT Switch;
    class APlayerReplicationInfo* RelatedPRI_1;
    class APlayerReplicationInfo* RelatedPRI_2;
    class UObject* OptionalObject;
};
struct GameInfo_eventBroadcast_Parms
{
    class AActor* Sender;
    FString Msg;
    FName Type;
};
struct GameInfo_eventAcceptInventory_Parms
{
    class APawn* PlayerPawn;
};
struct GameInfo_eventPostLogin_Parms
{
    class APlayerController* NewPlayer;
};
struct GameInfo_eventLogin_Parms
{
    FString Portal;
    FString Options;
    FString Error;
    class APlayerController* ReturnValue;
};
struct GameInfo_eventPreLogin_Parms
{
    FString Options;
    FString Address;
    FString Error;
    FString FailCode;
};
struct GameInfo_eventGetBeaconText_Parms
{
    FString ReturnValue;
};
struct GameInfo_eventInitGame_Parms
{
    FString Options;
    FString Error;
};
struct GameInfo_eventKickIdler_Parms
{
    class APlayerController* PC;
};
struct GameInfo_eventGameEnding_Parms
{
};
class AGameInfo : public AInfo
{
public:
    BITFIELD bRestartLevel:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bPauseable:1;
    BITFIELD bTeamGame:1;
    BITFIELD bGameEnded:1;
    BITFIELD bOverTime:1;
    BITFIELD bDelayedStart:1;
    BITFIELD bWaitingToStartMatch:1;
    BITFIELD bChangeLevels:1;
    BITFIELD bAlreadyChanged:1;
    BITFIELD bLoggingGame:1;
    BITFIELD bEnableStatLogging:1;
    BITFIELD bAdminCanPause:1;
    BITFIELD bGameRestarted:1;
    BITFIELD bAllowVehicles:1;
    BITFIELD bIsSaveGame:1;
    FLOAT GameDifficulty GCC_PACK(PROPERTY_ALIGNMENT);
    INT GoreLevel;
    FLOAT GameSpeed;
    FStringNoInit DefaultPawnClassName;
    FStringNoInit ScoreBoardType;
    FStringNoInit HUDType;
    FStringNoInit MapListType;
    FStringNoInit MapPrefix;
    INT MaxSpectators;
    INT NumSpectators;
    INT MaxPlayers;
    INT NumPlayers;
    INT NumBots;
    INT CurrentID;
    FStringNoInit DefaultPlayerName;
    FStringNoInit GameName;
    FLOAT FearCostFallOff;
    INT GoalScore;
    INT MaxLives;
    INT TimeLimit;
    class UClass* DeathMessageClass;
    class UClass* GameMessageClass;
    FStringNoInit MutatorClass;
    class AMutator* BaseMutator;
    FStringNoInit AccessControlClass;
    class AAccessControl* AccessControl;
    class AGameRules* GameRulesModifiers;
    FStringNoInit BroadcastHandlerClass;
    class ABroadcastHandler* BroadcastHandler;
    class UClass* PlayerControllerClass;
    FStringNoInit PlayerControllerClassName;
    class UClass* PlayerReplicationInfoClass;
    class UClass* GameReplicationInfoClass;
    class AGameReplicationInfo* GameReplicationInfo;
    class AGameStats* GameStats;
    FStringNoInit GameStatsClass;
    FLOAT MaxIdleTime;
    DECLARE_FUNCTION(execParseKillMessage);
    DECLARE_FUNCTION(execGetNetworkNumber);
    void eventBroadcastLocalized(class AActor* Sender, class UClass* Message, INT Switch, class APlayerReplicationInfo* RelatedPRI_1, class APlayerReplicationInfo* RelatedPRI_2, class UObject* OptionalObject)
    {
        GameInfo_eventBroadcastLocalized_Parms Parms;
        Parms.Sender=Sender;
        Parms.Message=Message;
        Parms.Switch=Switch;
        Parms.RelatedPRI_1=RelatedPRI_1;
        Parms.RelatedPRI_2=RelatedPRI_2;
        Parms.OptionalObject=OptionalObject;
        ProcessEvent(FindFunctionChecked(ENGINE_BroadcastLocalized),&Parms);
    }
    void eventBroadcast(class AActor* Sender, const FString& Msg, FName Type)
    {
        GameInfo_eventBroadcast_Parms Parms;
        Parms.Sender=Sender;
        Parms.Msg=Msg;
        Parms.Type=Type;
        ProcessEvent(FindFunctionChecked(ENGINE_Broadcast),&Parms);
    }
    void eventAcceptInventory(class APawn* PlayerPawn)
    {
        GameInfo_eventAcceptInventory_Parms Parms;
        Parms.PlayerPawn=PlayerPawn;
        ProcessEvent(FindFunctionChecked(ENGINE_AcceptInventory),&Parms);
    }
    void eventPostLogin(class APlayerController* NewPlayer)
    {
        GameInfo_eventPostLogin_Parms Parms;
        Parms.NewPlayer=NewPlayer;
        ProcessEvent(FindFunctionChecked(ENGINE_PostLogin),&Parms);
    }
    class APlayerController* eventLogin(const FString& Portal, const FString& Options, FString& Error)
    {
        GameInfo_eventLogin_Parms Parms;
        Parms.ReturnValue=0;
        Parms.Portal=Portal;
        Parms.Options=Options;
        Parms.Error=Error;
        ProcessEvent(FindFunctionChecked(ENGINE_Login),&Parms);
        Error=Parms.Error;
        return Parms.ReturnValue;
    }
    void eventPreLogin(const FString& Options, const FString& Address, FString& Error, FString& FailCode)
    {
        GameInfo_eventPreLogin_Parms Parms;
        Parms.Options=Options;
        Parms.Address=Address;
        Parms.Error=Error;
        Parms.FailCode=FailCode;
        ProcessEvent(FindFunctionChecked(ENGINE_PreLogin),&Parms);
        Error=Parms.Error;
        FailCode=Parms.FailCode;
    }
    FString eventGetBeaconText()
    {
        GameInfo_eventGetBeaconText_Parms Parms;
        ProcessEvent(FindFunctionChecked(ENGINE_GetBeaconText),&Parms);
        return Parms.ReturnValue;
    }
    void eventInitGame(const FString& Options, FString& Error)
    {
        GameInfo_eventInitGame_Parms Parms;
        Parms.Options=Options;
        Parms.Error=Error;
        ProcessEvent(FindFunctionChecked(ENGINE_InitGame),&Parms);
        Error=Parms.Error;
    }
    void eventKickIdler(class APlayerController* PC)
    {
        GameInfo_eventKickIdler_Parms Parms;
        Parms.PC=PC;
        ProcessEvent(FindFunctionChecked(ENGINE_KickIdler),&Parms);
    }
    void eventGameEnding()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_GameEnding),NULL);
    }
    DECLARE_CLASS(AGameInfo,AInfo,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(AGameInfo)
};


class AGameStats : public AInfo
{
public:
    class AFileLog* TempLog;
    class AGameReplicationInfo* GRI;
    BITFIELD bShowBots:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_FUNCTION(execGetMapFileName);
    DECLARE_FUNCTION(execGetStatsIdentifier);
    DECLARE_CLASS(AGameStats,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AGameStats)
};


class AInternetInfo : public AInfo
{
public:
    DECLARE_CLASS(AInternetInfo,AInfo,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(AInternetInfo)
};


class AMutator : public AInfo
{
public:
    class AMutator* NextMutator;
    class UClass* DefaultWeapon;
    FStringNoInit DefaultWeaponName;
    FStringNoInit GroupName;
    FStringNoInit FriendlyName;
    FStringNoInit Description;
    BITFIELD bUserAdded:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(AMutator,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AMutator)
};


class APotentialClimbWatcher : public AInfo
{
public:
    DECLARE_CLASS(APotentialClimbWatcher,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(APotentialClimbWatcher)
};


class AReplicationInfo : public AInfo
{
public:
    DECLARE_CLASS(AReplicationInfo,AInfo,0,Engine)
	INT* GetOptimizedRepList( BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};

enum ECarriedObjectState
{
    COS_Home                =0,
    COS_HeldFriendly        =1,
    COS_HeldEnemy           =2,
    COS_Down                =3,
    COS_MAX                 =4,
};

class AGameReplicationInfo : public AReplicationInfo
{
public:
    FStringNoInit GameName;
    FStringNoInit GameClass;
    BITFIELD bTeamGame:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bStopCountDown:1;
    BITFIELD bMatchHasBegun:1;
    INT RemainingTime GCC_PACK(PROPERTY_ALIGNMENT);
    INT ElapsedTime;
    INT RemainingMinute;
    FLOAT SecondCount;
    INT GoalScore;
    INT TimeLimit;
    INT MaxLives;
    class ATeamInfo* Teams[2];
    FStringNoInit ServerName;
    FStringNoInit ShortName;
    FStringNoInit AdminName;
    FStringNoInit AdminEmail;
    INT ServerRegion;
    FStringNoInit MessageOfTheDay;
    class AActor* Winner;
    TArrayNoInit<class APlayerReplicationInfo*> PRIArray;
    BYTE CarriedObjectState[2];
    INT MatchID GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(AGameReplicationInfo,AReplicationInfo,0|CLASS_Config|CLASS_NativeReplication,Engine)
	// Constructors.
	AGameReplicationInfo() {}

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};


class APlayerReplicationInfo : public AReplicationInfo
{
public:
    FLOAT Score;
    FLOAT Deaths;
    class ACarriedObject* HasFlag;
    BYTE Ping;
    BYTE PacketLoss;
    class AActor* PlayerLocationHint GCC_PACK(PROPERTY_ALIGNMENT);
    INT NumLives;
    FStringNoInit PlayerName;
    FStringNoInit OldName;
    FStringNoInit PreviousName;
    INT PlayerID;
    class ATeamInfo* Team;
    INT TeamID;
    BITFIELD bAdmin:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bIsFemale:1;
    BITFIELD bIsSpectator:1;
    BITFIELD bOnlySpectator:1;
    BITFIELD bWaitingPlayer:1;
    BITFIELD bReadyToPlay:1;
    BITFIELD bOutOfLives:1;
    BITFIELD bBot:1;
    BITFIELD bReceivedPing:1;
    BITFIELD bHasFlag:1;
    BITFIELD bHasBeenWelcomed:1;
    INT StartTime GCC_PACK(PROPERTY_ALIGNMENT);
    FStringNoInit StringDead;
    FStringNoInit StringSpectating;
    FStringNoInit StringUnknown;
    INT GoalsScored;
    INT Kills;
    class UClass* GameMessageClass;
    DECLARE_CLASS(APlayerReplicationInfo,AReplicationInfo,0|CLASS_NativeReplication,Engine)
	// Constructors.
	APlayerReplicationInfo() {}

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};


class ATeamInfo : public AReplicationInfo
{
public:
    FStringNoInit TeamName;
    INT Size;
    FLOAT Score;
    INT TeamIndex;
    DECLARE_CLASS(ATeamInfo,AReplicationInfo,0|CLASS_NativeReplication,Engine)
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};


class ASavedMove : public AInfo
{
public:
    class ASavedMove* NextMove;
    FLOAT TimeStamp;
    FLOAT Delta;
    BITFIELD bRun:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bDuck:1;
    BITFIELD bPressedJump:1;
    BITFIELD bDoubleJump:1;
    BYTE DoubleClickMove GCC_PACK(PROPERTY_ALIGNMENT);
    BYTE SavedPhysics;
    FVector StartLocation GCC_PACK(PROPERTY_ALIGNMENT);
    FVector StartRelativeLocation;
    FVector StartVelocity;
    FVector StartFloor;
    FVector SavedLocation;
    FVector SavedVelocity;
    FVector SavedRelativeLocation;
    class AActor* StartBase;
    class AActor* EndBase;
    FLOAT AccelDotThreshold;
    DECLARE_CLASS(ASavedMove,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ASavedMove)
};


struct ZoneInfo_eventActorLeaving_Parms
{
    class AActor* Other;
};
struct ZoneInfo_eventActorEntered_Parms
{
    class AActor* Other;
};
class AZoneInfo : public AInfo
{
public:
    FName ZoneTag;
    FStringNoInit LocationName;
    FLOAT KillZ;
    FLOAT SoftKill;
    class UClass* KillZDamageType;
    BITFIELD bSoftKillZ:1 GCC_PACK(PROPERTY_ALIGNMENT);
    TArrayNoInit<FName> ForceCullZones GCC_PACK(PROPERTY_ALIGNMENT);
    FName CullTag;
    DECLARE_FUNCTION(execZoneActors);
    void eventActorLeaving(class AActor* Other)
    {
        ZoneInfo_eventActorLeaving_Parms Parms;
        if(IsProbing(NAME_ActorLeaving)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ActorLeaving),&Parms);
        }
    }
    void eventActorEntered(class AActor* Other)
    {
        ZoneInfo_eventActorEntered_Parms Parms;
        if(IsProbing(NAME_ActorEntered)) {
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_ActorEntered),&Parms);
        }
    }
    DECLARE_CLASS(AZoneInfo,AInfo,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AZoneInfo)
};

enum ENetMode
{
    NM_Standalone           =0,
    NM_DedicatedServer      =1,
    NM_ListenServer         =2,
    NM_Client               =3,
    NM_MAX                  =4,
};
enum ELevelAction
{
    LEVACT_None             =0,
    LEVACT_Loading          =1,
    LEVACT_Saving           =2,
    LEVACT_Connecting       =3,
    LEVACT_Precaching       =4,
    LEVACT_MAX              =5,
};

struct LevelInfo_eventServerTravel_Parms
{
    FString URL;
    BITFIELD bItems;
};
class ALevelInfo : public AZoneInfo
{
public:
    TArrayNoInit<class UEdLayer*> Layers;
    class UBookMark* BookMarks[10];
    FLOAT TimeDilation;
    FLOAT TimeSeconds;
    INT Year;
    INT Month;
    INT Day;
    INT DayOfWeek;
    INT Hour;
    INT Minute;
    INT Second;
    INT Millisecond;
    FLOAT PauseDelay;
    BITFIELD bRBPhysNoInit:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD HideFromMenus:1;
    BITFIELD bLonePlayer:1;
    BITFIELD bBegunPlay:1;
    BITFIELD bPlayersOnly:1;
    BITFIELD bDropDetail:1;
    BITFIELD bAggressiveLOD:1;
    BITFIELD bStartup:1;
    BITFIELD bPathsRebuilt:1;
    BITFIELD bHasPathNodes:1;
    BITFIELD bKickLiveIdlers:1;
    BITFIELD bNextItems:1;
    FStringNoInit Title GCC_PACK(PROPERTY_ALIGNMENT);
    FStringNoInit Author;
    FStringNoInit Description;
    class UTexture2D* Screenshot;
    FStringNoInit DecoTextName;
    class APlayerReplicationInfo* Pauser;
    class ULevelSummary* Summary;
    FStringNoInit VisibleGroups;
    FStringNoInit SelectedGroups;
    class UTexture2D* DefaultTexture;
    class UTexture2D* WireframeTexture;
    class UTexture2D* WhiteSquareTexture;
    class UTexture2D* LargeVertex;
    class UTexture2D* BSPVertex;
    BYTE LevelAction;
    class AGameReplicationInfo* GRI GCC_PACK(PROPERTY_ALIGNMENT);
    BYTE NetMode;
    FStringNoInit ComputerName GCC_PACK(PROPERTY_ALIGNMENT);
    FStringNoInit EngineVersion;
    FStringNoInit MinNetVersion;
    FStringNoInit DefaultGameType;
    class AGameInfo* Game;
    FLOAT DefaultGravity;
    FLOAT StallZ;
    class ANavigationPoint* NavigationPointList;
    class AController* ControllerList;
    class AObjective* ObjectiveList;
    FLOAT MoveRepSize;
    FLOAT MaxClientFrameRate;
    FLOAT MaxTimeMargin;
    FLOAT TimeMarginSlack;
    FLOAT MinTimeMargin;
    class APlayerController* ReplicationViewer;
    class AActor* ReplicationViewTarget;
    FStringNoInit NextURL;
    FLOAT NextSwitchCountdown;
    DECLARE_FUNCTION(execSetLevelRBGravity);
    DECLARE_FUNCTION(execGetLevelSequence);
    DECLARE_FUNCTION(execGetAddressURL);
    DECLARE_FUNCTION(execIsConsoleBuild);
    DECLARE_FUNCTION(execIsDemoBuild);
    DECLARE_FUNCTION(execGetLocalURL);
    DECLARE_FUNCTION(execIsEntry);
    void eventServerTravel(const FString& URL, BITFIELD bItems)
    {
        LevelInfo_eventServerTravel_Parms Parms;
        Parms.URL=URL;
        Parms.bItems=bItems;
        ProcessEvent(FindFunctionChecked(ENGINE_ServerTravel),&Parms);
    }
    DECLARE_CLASS(ALevelInfo,AZoneInfo,0|CLASS_Config|CLASS_NativeReplication,Engine)
	// Constructors.
	ALevelInfo() {}

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	void CheckForErrors();
	void PreNetReceive();
	void PostNetReceive();

	// Level functions
	void SetZone( UBOOL bTest, UBOOL bForceRefresh );
	void SetVolumes();
	virtual void SetVolumes(const TArray<class AVolume*>& Volumes);
	APhysicsVolume* GetDefaultPhysicsVolume();
	APhysicsVolume* GetPhysicsVolume(FVector Loc, AActor *A, UBOOL bUseTouch);
};


class AInventory : public AActor
{
public:
    BITFIELD bRenderOverlays:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bReceiveOwnerEvents:1;
    BITFIELD bDelayedSpawn:1;
    BITFIELD bPredictRespawns:1;
    class AInventory* Inventory GCC_PACK(PROPERTY_ALIGNMENT);
    class AInventoryManager* InvManager;
    FStringNoInit ItemName;
    FLOAT RespawnTime;
    FLOAT MaxDesireability;
    FStringNoInit PickupMessage;
    class USoundCue* PickupSound;
    FStringNoInit PickupForce;
    class UClass* DroppedPickupClass;
    class UTransformComponent* DroppedPickupMesh;
    class UTransformComponent* PickupFactoryMesh;
    DECLARE_CLASS(AInventory,AActor,0|CLASS_NativeReplication,Engine)
	// Constructors.
	AInventory() {}

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};


struct Weapon_eventPlayFireEffects_Parms
{
    BYTE FireModeNum;
};
class AWeapon : public AInventory
{
public:
    TArrayNoInit<FName> FiringStatesArray;
    BYTE ShotCount;
    BYTE CurrentFireMode;
    BYTE ForceFireMode;
    BITFIELD bForceFire:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bWeaponPutDown:1;
    BITFIELD bCanThrow:1;
    FLOAT WeaponRange GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT WarnTargetPct;
    void eventPlayFireEffects(BYTE FireModeNum)
    {
        Weapon_eventPlayFireEffects_Parms Parms;
        Parms.FireModeNum=FireModeNum;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayFireEffects),&Parms);
    }
    DECLARE_CLASS(AWeapon,AInventory,0|CLASS_NativeReplication,Engine)
	// Constructors.
	AWeapon() {}

	// AActor interface.
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	void PreNetReceive();
	void PostNetReceive();
	UBOOL IsNetRelevantFor( APlayerController* RealViewer, AActor* Viewer, FVector SrcLocation );
};


struct InventoryManager_eventFindInventoryType_Parms
{
    class UClass* DesiredClass;
    class AInventory* ReturnValue;
};
class AInventoryManager : public AActor
{
public:
    class AInventory* InventoryChain;
    class AWeapon* PendingWeapon;
    DECLARE_FUNCTION(execInventoryActors);
    class AInventory* eventFindInventoryType(class UClass* DesiredClass)
    {
        InventoryManager_eventFindInventoryType_Parms Parms;
        Parms.ReturnValue=0;
        Parms.DesiredClass=DesiredClass;
        ProcessEvent(FindFunctionChecked(ENGINE_FindInventoryType),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AInventoryManager,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AInventoryManager)
};


class AKeypoint : public AActor
{
public:
    DECLARE_CLASS(AKeypoint,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AKeypoint)
};


class AClipMarker : public AKeypoint
{
public:
    DECLARE_CLASS(AClipMarker,AKeypoint,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AClipMarker)
};


class APolyMarker : public AKeypoint
{
public:
    DECLARE_CLASS(APolyMarker,AKeypoint,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(APolyMarker)
};


class ALight : public AActor
{
public:
    class ULightComponent* LightComponent;
    DECLARE_CLASS(ALight,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ALight)
};


struct NavigationPoint_eventSuggestMovePreparation_Parms
{
    class APawn* Other;
    BITFIELD ReturnValue;
};
struct NavigationPoint_eventDetourWeight_Parms
{
    class APawn* Other;
    FLOAT PathWeight;
    FLOAT ReturnValue;
};
struct NavigationPoint_eventAccept_Parms
{
    class AActor* Incoming;
    class AActor* Source;
    BITFIELD ReturnValue;
};
struct NavigationPoint_eventSpecialCost_Parms
{
    class APawn* Seeker;
    class UReachSpec* Path;
    INT ReturnValue;
};
class ANavigationPoint : public AActor
{
public:
    BITFIELD bEndPoint:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bTransientEndPoint:1;
    BITFIELD bHideEditorPaths:1;
    BITFIELD bCanReach:1;
    BITFIELD taken:1;
    BITFIELD bBlocked:1;
    BITFIELD bPropagatesSound:1;
    BITFIELD bOneWayPath:1;
    BITFIELD bNeverUseStrafing:1;
    BITFIELD bAlwaysUseStrafing:1;
    BITFIELD bForceNoStrafing:1;
    BITFIELD bAutoBuilt:1;
    BITFIELD bSpecialMove:1;
    BITFIELD bNoAutoConnect:1;
    BITFIELD bNotBased:1;
    BITFIELD bPathsChanged:1;
    BITFIELD bDestinationOnly:1;
    BITFIELD bSourceOnly:1;
    BITFIELD bSpecialForced:1;
    BITFIELD bMustBeReachable:1;
    BITFIELD bBlockable:1;
    BITFIELD bFlyingPreferred:1;
    BITFIELD bMayCausePain:1;
    BITFIELD bReceivePlayerToucherDiedNotify:1;
    BITFIELD bAlreadyVisited:1;
    BITFIELD bVehicleDestination:1;
    BITFIELD bMakeSourceOnly:1;
    TArrayNoInit<class UReachSpec*> PathList GCC_PACK(PROPERTY_ALIGNMENT);
    TArrayNoInit<class ANavigationPoint*> ProscribedPaths;
    TArrayNoInit<class ANavigationPoint*> ForcedPaths;
    INT visitedWeight;
    INT bestPathWeight;
    class ANavigationPoint* nextNavigationPoint;
    class ANavigationPoint* nextOrdered;
    class ANavigationPoint* prevOrdered;
    class ANavigationPoint* previousPath;
    INT cost;
    INT ExtraCost;
    INT TransientCost;
    INT FearCost;
    class ADroppedPickup* InventoryCache;
    FLOAT InventoryDist;
    FLOAT LastDetourWeight;
    class UCylinderComponent* CylinderComponent;
    class AObjective* NearestObjective;
    FLOAT ObjectiveDistance;
    FVector MaxPathSize;
    BITFIELD eventSuggestMovePreparation(class APawn* Other)
    {
        NavigationPoint_eventSuggestMovePreparation_Parms Parms;
        Parms.ReturnValue=0;
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_SuggestMovePreparation),&Parms);
        return Parms.ReturnValue;
    }
    FLOAT eventDetourWeight(class APawn* Other, FLOAT PathWeight)
    {
        NavigationPoint_eventDetourWeight_Parms Parms;
        Parms.ReturnValue=0;
        Parms.Other=Other;
        Parms.PathWeight=PathWeight;
        ProcessEvent(FindFunctionChecked(ENGINE_DetourWeight),&Parms);
        return Parms.ReturnValue;
    }
    BITFIELD eventAccept(class AActor* Incoming, class AActor* Source)
    {
        NavigationPoint_eventAccept_Parms Parms;
        Parms.ReturnValue=0;
        Parms.Incoming=Incoming;
        Parms.Source=Source;
        ProcessEvent(FindFunctionChecked(ENGINE_Accept),&Parms);
        return Parms.ReturnValue;
    }
    INT eventSpecialCost(class APawn* Seeker, class UReachSpec* Path)
    {
        NavigationPoint_eventSpecialCost_Parms Parms;
        Parms.ReturnValue=0;
        Parms.Seeker=Seeker;
        Parms.Path=Path;
        ProcessEvent(FindFunctionChecked(ENGINE_SpecialCost),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(ANavigationPoint,AActor,0,Engine)
    #include "ANavigationPoint.h"
};


class AJumpPad : public ANavigationPoint
{
public:
    FVector JumpVelocity;
    FVector BACKUP_JumpVelocity;
    class AActor* JumpTarget;
    FLOAT JumpZModifier;
    class USoundCue* JumpSound;
    DECLARE_CLASS(AJumpPad,ANavigationPoint,0,Engine)
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
};


class ALadder : public ANavigationPoint
{
public:
    class ALadderVolume* MyLadder;
    class ALadder* LadderList;
    DECLARE_CLASS(ALadder,ANavigationPoint,0,Engine)
	INT ProscribedPathTo(ANavigationPoint *Dest);
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
	void InitForPathFinding();
	void ClearPaths();
};


class AAutoLadder : public ALadder
{
public:
    DECLARE_CLASS(AAutoLadder,ALadder,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AAutoLadder)
};


class AObjective : public ANavigationPoint
{
public:
    BITFIELD bDisabled:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bFirstObjective:1;
    BITFIELD bOptionalObjective:1;
    BYTE DefenderTeamIndex GCC_PACK(PROPERTY_ALIGNMENT);
    BYTE StartTeam;
    BYTE DefensePriority;
    INT Score GCC_PACK(PROPERTY_ALIGNMENT);
    class AObjective* NextObjective;
    class UClass* ConstraintPawnClass;
    FStringNoInit ObjectiveName;
    FStringNoInit ObjectiveStringPrefix;
    FStringNoInit ObjectiveStringSuffix;
    FStringNoInit ColorNames[4];
    DECLARE_CLASS(AObjective,ANavigationPoint,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AObjective)
};


class APathNode : public ANavigationPoint
{
public:
    DECLARE_CLASS(APathNode,ANavigationPoint,0,Engine)
	virtual UBOOL ReviewPath(APawn* Scout);
	virtual void CheckSymmetry(ANavigationPoint* Other);
	virtual INT AddMyMarker(AActor *S);
};

enum ECoverAction
{
    CA_Default              =0,
    CA_BlindLeft            =1,
    CA_BlindRight           =2,
    CA_LeanLeft             =3,
    CA_LeanRight            =4,
    CA_StepLeft             =5,
    CA_StepRight            =6,
    CA_PopUp                =7,
    CA_MAX                  =8,
};
enum ECoverType
{
    CT_None                 =0,
    CT_Standing             =1,
    CT_MidLevel             =2,
    CT_Crouching            =3,
    CT_MAX                  =4,
};

class ACoverNode : public APathNode
{
public:
    BITFIELD bAutoSetup:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bLeanLeft:1;
    BITFIELD bLeanRight:1;
    BITFIELD bEnabled:1;
    BITFIELD bCircular:1;
    BYTE AIRating GCC_PACK(PROPERTY_ALIGNMENT);
    BYTE CoverType;
    FLOAT AlignDist GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT EdgeAlignDist;
    FLOAT CornerAlignDist;
    FLOAT TransitionDist;
    FLOAT StandHeight;
    FLOAT MidHeight;
    FLOAT CrouchHeight;
    class ACoverNode* LeftNode;
    class ACoverNode* RightNode;
    class ACoverNode* TransitionNode;
    class AController* CoverClaim;
    DECLARE_CLASS(ACoverNode,APathNode,0,Engine)
	void InitialPass();
	void LinkPass();
	void FinalPass();
	void UpdateSprite();
	virtual void PostEditChange(UProperty *PropertyThatChanged)
	{
		UpdateSprite();
		Super::PostEditChange(PropertyThatChanged);
	}
	void FindBase();
};


class APickupFactory : public ANavigationPoint
{
public:
    BITFIELD bOnlyReplicateHidden:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bPickupHidden:1;
    BITFIELD bPredictRespawns:1;
    class UClass* InventoryType GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT RespawnEffectTime;
    class UTransformComponent* PickupMesh;
    DECLARE_CLASS(APickupFactory,ANavigationPoint,0|CLASS_NativeReplication,Engine)
    virtual APickupFactory* GetAPickupFactory() { return this; }
	INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
};


class APlayerStart : public ANavigationPoint
{
public:
    BYTE TeamNumber;
    BITFIELD bSinglePlayerStart:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bCoopStart:1;
    BITFIELD bEnabled:1;
    BITFIELD bPrimaryStart:1;
    FLOAT LastSpawnCampTime GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(APlayerStart,ANavigationPoint,0,Engine)
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
};


class ATeleporter : public ANavigationPoint
{
public:
    FStringNoInit URL;
    FName ProductRequired;
    BITFIELD bChangesVelocity:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bChangesYaw:1;
    BITFIELD bReversesX:1;
    BITFIELD bReversesY:1;
    BITFIELD bReversesZ:1;
    BITFIELD bEnabled:1;
    FVector TargetVelocity GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT LastFired;
    DECLARE_CLASS(ATeleporter,ANavigationPoint,0,Engine)
	void addReachSpecs(AScout *Scout, UBOOL bOnlyChanged=0);
};


class ANote : public AActor
{
public:
    FStringNoInit Text;
    DECLARE_CLASS(ANote,AActor,0,Engine)
	void CheckForErrors();
};


struct Pawn_eventPlayWeaponSwitch_Parms
{
    class AWeapon* OldWeapon;
    class AWeapon* NewWeapon;
};
struct Pawn_eventCreateInventory_Parms
{
    class UClass* NewInvClass;
    class AInventory* ReturnValue;
};
struct Pawn_eventStopDriving_Parms
{
    class AVehicle* V;
};
struct Pawn_eventStartDriving_Parms
{
    class AVehicle* V;
};
struct Pawn_eventSetMeshTransformScale3D_Parms
{
    FVector NewScale;
};
struct Pawn_eventSetMeshTransformScale_Parms
{
    FLOAT NewScale;
};
struct Pawn_eventSetMeshTransformRotation_Parms
{
    FRotator NewRotation;
};
struct Pawn_eventSetMeshTransformOffset_Parms
{
    FVector NewOffset;
};
struct Pawn_eventChangeAnimation_Parms
{
    class UAnimNode* Node;
};
struct Pawn_eventPlayFootStepSound_Parms
{
    INT FootDown;
};
struct Pawn_eventPlayDying_Parms
{
    class UClass* DamageType;
    FVector HitLoc;
};
struct Pawn_eventBreathTimer_Parms
{
};
struct Pawn_eventHeadVolumeChange_Parms
{
    class APhysicsVolume* newHeadVolume;
};
struct Pawn_eventStartCrouch_Parms
{
    FLOAT HeightAdjust;
};
struct Pawn_eventEndCrouch_Parms
{
    FLOAT HeightAdjust;
};
struct Pawn_eventModifyVelocity_Parms
{
    FLOAT DeltaTime;
    FVector OldVelocity;
};
struct Pawn_eventClientMessage_Parms
{
    FString S;
    FName Type;
};
struct Pawn_eventUpdateEyeHeight_Parms
{
    FLOAT DeltaTime;
};
struct Pawn_eventSetWalking_Parms
{
    BITFIELD bNewIsWalking;
};
struct Pawn_eventSetHeadScale_Parms
{
    FLOAT NewScale;
};
class APawn : public AActor
{
public:
    FLOAT MaxStepHeight;
    FLOAT MaxJumpHeight;
    class AController* Controller;
    FLOAT NetRelevancyTime;
    class APlayerController* LastRealViewer;
    class AActor* LastViewer;
    BITFIELD bJustLanded:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bLandRecovery:1;
    BITFIELD bUpAndOut:1;
    BITFIELD bIsWalking:1;
    BITFIELD bWantsToCrouch:1;
    BITFIELD bIsCrouched:1;
    BITFIELD bTryToUncrouch:1;
    BITFIELD bCanCrouch:1;
    BITFIELD bCrawler:1;
    BITFIELD bReducedSpeed:1;
    BITFIELD bJumpCapable:1;
    BITFIELD bCanJump:1;
    BITFIELD bCanWalk:1;
    BITFIELD bCanSwim:1;
    BITFIELD bCanFly:1;
    BITFIELD bCanClimbLadders:1;
    BITFIELD bCanStrafe:1;
    BITFIELD bAvoidLedges:1;
    BITFIELD bStopAtLedges:1;
    BITFIELD bNoJumpAdjust:1;
    BITFIELD bCountJumps:1;
    BITFIELD bSimulateGravity:1;
    BITFIELD bUpdateEyeheight:1;
    BITFIELD bIgnoreForces:1;
    BITFIELD bNoVelocityUpdate:1;
    BITFIELD bCanWalkOffLedges:1;
    BITFIELD bCanBeBaseForPawns:1;
    BITFIELD bClientCollision:1;
    BITFIELD bSimGravityDisabled:1;
    BITFIELD bDirectHitWall:1;
    BITFIELD bPushesRigidBodies:1;
    BITFIELD bFlyingRigidBody:1;
    BITFIELD bInvulnerableBody:1;
    BITFIELD bIsFemale:1;
    BITFIELD bCanPickupInventory:1;
    BITFIELD bAmbientCreature:1;
    BITFIELD bLOSHearing:1;
    BITFIELD bSameZoneHearing:1;
    BITFIELD bAdjacentZoneHearing:1;
    BITFIELD bMuffledHearing:1;
    BITFIELD bAroundCornerHearing:1;
    BITFIELD bDontPossess:1;
    BITFIELD bAutoFire:1;
    BITFIELD bRollToDesired:1;
    BITFIELD bCachedRelevant:1;
    BITFIELD bUseCompressedPosition:1;
    BITFIELD bWeaponBob:1;
    BITFIELD bSpecialHUD:1;
    BITFIELD bIsTyping:1;
    BITFIELD bPlayedDeath:1;
    BITFIELD bReplicateWeapon:1;
    FLOAT UncrouchTime GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT CrouchHeight;
    FLOAT CrouchRadius;
    BYTE FlashCount;
    BYTE Visibility;
    BYTE RemoteViewPitch;
    FLOAT DesiredSpeed GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT MaxDesiredSpeed;
    FLOAT HearingThreshold;
    FLOAT Alertness;
    FLOAT SightRadius;
    FLOAT PeripheralVision;
    FLOAT AvgPhysicsTime;
    FLOAT MeleeRange;
    class ANavigationPoint* Anchor;
    class ANavigationPoint* LastAnchor;
    FLOAT FindAnchorFailedTime;
    FLOAT LastValidAnchorTime;
    FLOAT DestinationOffset;
    FLOAT NextPathRadius;
    FVector SerpentineDir;
    FLOAT SerpentineDist;
    FLOAT SerpentineTime;
    FLOAT SpawnTime;
    FLOAT GroundSpeed;
    FLOAT WaterSpeed;
    FLOAT AirSpeed;
    FLOAT LadderSpeed;
    FLOAT AccelRate;
    FLOAT JumpZ;
    FLOAT AirControl;
    FLOAT WalkingPct;
    FLOAT CrouchedPct;
    FLOAT MaxFallSpeed;
    FLOAT MoveThresholdScale;
    FLOAT BaseEyeHeight;
    FLOAT EyeHeight;
    FVector Floor;
    FLOAT SplashTime;
    FLOAT OldZ;
    class APhysicsVolume* HeadVolume;
    INT HealthMax;
    INT Health;
    FLOAT BreathTime;
    FLOAT UnderWaterTime;
    FLOAT LastPainTime;
    class UClass* ReducedDamageType;
    FLOAT HeadScale;
    FVector noise1spot;
    FLOAT noise1time;
    class APawn* noise1other;
    FLOAT noise1loudness;
    FVector noise2spot;
    FLOAT noise2time;
    class APawn* noise2other;
    FLOAT noise2loudness;
    FLOAT LastPainSound;
    FLOAT Bob;
    FLOAT LandBob;
    FLOAT AppliedBob;
    FLOAT bobtime;
    FVector WalkBob;
    FLOAT SoundDampening;
    FLOAT DamageScaling;
    FStringNoInit MenuName;
    class UClass* ControllerClass;
    class APlayerReplicationInfo* PlayerReplicationInfo;
    class ALadderVolume* OnLadder;
    FName LandMovementState;
    FName WaterMovementState;
    class APlayerStart* LastStartSpot;
    FLOAT LastStartTime;
    FVector TakeHitLocation;
    class UClass* HitDamageType;
    FVector TearOffMomentum;
    FCompressedPosition PawnPosition;
    class USkeletalMeshComponent* Mesh;
    class UTransformComponent* MeshTransform;
    class UCylinderComponent* CylinderComponent;
    FLOAT RBPushRadius;
    FLOAT RBPushStrength;
    class AVehicle* DrivenVehicle;
    FLOAT ViewPitchMin;
    FLOAT ViewPitchMax;
    class UClass* InventoryManagerClass;
    class AInventoryManager* InvManager;
    class AWeapon* Weapon;
    DECLARE_FUNCTION(execInitRagdoll);
    DECLARE_FUNCTION(execSetPushesRigidBodies);
    DECLARE_FUNCTION(execForceCrouch);
    DECLARE_FUNCTION(execReachedDestination);
    DECLARE_FUNCTION(execSetRemoteViewPitch);
    void eventPlayWeaponSwitch(class AWeapon* OldWeapon, class AWeapon* NewWeapon)
    {
        Pawn_eventPlayWeaponSwitch_Parms Parms;
        Parms.OldWeapon=OldWeapon;
        Parms.NewWeapon=NewWeapon;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayWeaponSwitch),&Parms);
    }
    class AInventory* eventCreateInventory(class UClass* NewInvClass)
    {
        Pawn_eventCreateInventory_Parms Parms;
        Parms.ReturnValue=0;
        Parms.NewInvClass=NewInvClass;
        ProcessEvent(FindFunctionChecked(ENGINE_CreateInventory),&Parms);
        return Parms.ReturnValue;
    }
    void eventStopDriving(class AVehicle* V)
    {
        Pawn_eventStopDriving_Parms Parms;
        Parms.V=V;
        ProcessEvent(FindFunctionChecked(ENGINE_StopDriving),&Parms);
    }
    void eventStartDriving(class AVehicle* V)
    {
        Pawn_eventStartDriving_Parms Parms;
        Parms.V=V;
        ProcessEvent(FindFunctionChecked(ENGINE_StartDriving),&Parms);
    }
    void eventSetMeshTransformScale3D(FVector NewScale)
    {
        Pawn_eventSetMeshTransformScale3D_Parms Parms;
        Parms.NewScale=NewScale;
        ProcessEvent(FindFunctionChecked(ENGINE_SetMeshTransformScale3D),&Parms);
    }
    void eventSetMeshTransformScale(FLOAT NewScale)
    {
        Pawn_eventSetMeshTransformScale_Parms Parms;
        Parms.NewScale=NewScale;
        ProcessEvent(FindFunctionChecked(ENGINE_SetMeshTransformScale),&Parms);
    }
    void eventSetMeshTransformRotation(FRotator NewRotation)
    {
        Pawn_eventSetMeshTransformRotation_Parms Parms;
        Parms.NewRotation=NewRotation;
        ProcessEvent(FindFunctionChecked(ENGINE_SetMeshTransformRotation),&Parms);
    }
    void eventSetMeshTransformOffset(FVector NewOffset)
    {
        Pawn_eventSetMeshTransformOffset_Parms Parms;
        Parms.NewOffset=NewOffset;
        ProcessEvent(FindFunctionChecked(ENGINE_SetMeshTransformOffset),&Parms);
    }
    void eventChangeAnimation(class UAnimNode* Node)
    {
        Pawn_eventChangeAnimation_Parms Parms;
        Parms.Node=Node;
        ProcessEvent(FindFunctionChecked(ENGINE_ChangeAnimation),&Parms);
    }
    void eventPlayFootStepSound(INT FootDown)
    {
        Pawn_eventPlayFootStepSound_Parms Parms;
        Parms.FootDown=FootDown;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayFootStepSound),&Parms);
    }
    void eventPlayDying(class UClass* DamageType, FVector HitLoc)
    {
        Pawn_eventPlayDying_Parms Parms;
        Parms.DamageType=DamageType;
        Parms.HitLoc=HitLoc;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayDying),&Parms);
    }
    void eventBreathTimer()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_BreathTimer),NULL);
    }
    void eventHeadVolumeChange(class APhysicsVolume* newHeadVolume)
    {
        Pawn_eventHeadVolumeChange_Parms Parms;
        if(IsProbing(NAME_HeadVolumeChange)) {
        Parms.newHeadVolume=newHeadVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_HeadVolumeChange),&Parms);
        }
    }
    void eventStartCrouch(FLOAT HeightAdjust)
    {
        Pawn_eventStartCrouch_Parms Parms;
        Parms.HeightAdjust=HeightAdjust;
        ProcessEvent(FindFunctionChecked(ENGINE_StartCrouch),&Parms);
    }
    void eventEndCrouch(FLOAT HeightAdjust)
    {
        Pawn_eventEndCrouch_Parms Parms;
        Parms.HeightAdjust=HeightAdjust;
        ProcessEvent(FindFunctionChecked(ENGINE_EndCrouch),&Parms);
    }
    void eventModifyVelocity(FLOAT DeltaTime, FVector OldVelocity)
    {
        Pawn_eventModifyVelocity_Parms Parms;
        if(IsProbing(NAME_ModifyVelocity)) {
        Parms.DeltaTime=DeltaTime;
        Parms.OldVelocity=OldVelocity;
        ProcessEvent(FindFunctionChecked(ENGINE_ModifyVelocity),&Parms);
        }
    }
    void eventClientMessage(const FString& S, FName Type)
    {
        Pawn_eventClientMessage_Parms Parms;
        Parms.S=S;
        Parms.Type=Type;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientMessage),&Parms);
    }
    void eventUpdateEyeHeight(FLOAT DeltaTime)
    {
        Pawn_eventUpdateEyeHeight_Parms Parms;
        if(IsProbing(NAME_UpdateEyeHeight)) {
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_UpdateEyeHeight),&Parms);
        }
    }
    void eventSetWalking(BITFIELD bNewIsWalking)
    {
        Pawn_eventSetWalking_Parms Parms;
        Parms.bNewIsWalking=bNewIsWalking;
        ProcessEvent(FindFunctionChecked(ENGINE_SetWalking),&Parms);
    }
    void eventSetHeadScale(FLOAT NewScale)
    {
        Pawn_eventSetHeadScale_Parms Parms;
        Parms.NewScale=NewScale;
        ProcessEvent(FindFunctionChecked(ENGINE_SetHeadScale),&Parms);
    }
    DECLARE_CLASS(APawn,AActor,0|CLASS_Config|CLASS_NativeReplication,Engine)
    #include "APawn.h"
};

struct FPathSizeInfo
{
    FName Desc;
    FLOAT Radius;
    FLOAT Height;
    FLOAT CrouchHeight;
};


class AScout : public APawn
{
public:
    TArrayNoInit<FPathSizeInfo> PathSizes;
    FLOAT TestJumpZ;
    FLOAT TestGroundSpeed;
    FLOAT TestMaxFallSpeed;
    FLOAT TestFallSpeed;
    FLOAT MaxLandingVelocity;
    DECLARE_CLASS(AScout,APawn,0|CLASS_Config,Engine)
	NO_DEFAULT_CONSTRUCTOR(AScout)
	INT findStart(FVector start);

	UBOOL HurtByVolume(AActor *A)
	{
		// scouts are never hurt by volumes
		return 0;
	}

	virtual void InitForPathing()
	{
		Physics = PHYS_Walking;
		JumpZ = TestJumpZ; 
		bCanWalk = 1;
		bJumpCapable = 1;
		bCanJump = 1;
		bCanSwim = 1;
		bCanClimbLadders = 1;
		bCanFly = 0;
		GroundSpeed = TestGroundSpeed;
		MaxFallSpeed = TestMaxFallSpeed;
	}

	FVector GetSize(FName desc)
	{
		for (INT idx = 0; idx < PathSizes.Num(); idx++)
		{
			if (PathSizes(idx).Desc == desc)
			{
				return FVector(PathSizes(idx).Radius,PathSizes(idx).Height,0.f);
			}
		}
		return FVector(PathSizes(0).Radius,PathSizes(0).Height,0.f);
	}
};


struct Vehicle_eventDriverLeave_Parms
{
    BITFIELD bForceLeave;
    BITFIELD ReturnValue;
};
class AVehicle : public APawn
{
public:
    class APawn* Driver;
    BITFIELD bDriving:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bTeamLocked:1;
    BITFIELD bRelativeExitPos:1;
    BITFIELD bAttachDriver:1;
    TArrayNoInit<FVector> ExitPositions GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT Steering;
    FLOAT Throttle;
    FLOAT Rise;
    class AVehicle* NextVehicle;
    BITFIELD eventDriverLeave(BITFIELD bForceLeave)
    {
        Vehicle_eventDriverLeave_Parms Parms;
        Parms.ReturnValue=0;
        Parms.bForceLeave=bForceLeave;
        ProcessEvent(FindFunctionChecked(ENGINE_DriverLeave),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(AVehicle,APawn,0|CLASS_Config,Engine)
	virtual UBOOL IgnoreBlockingBy( const AActor *Other ) const;
	virtual UBOOL moveToward(const FVector &Dest, AActor *GoalActor);
	virtual void rotateToward(AActor *Focus, FVector FocalPoint);
	virtual int pointReachable(FVector aPoint, int bKnowVisible=0);
	virtual int actorReachable(AActor *Other, UBOOL bKnowVisible=0, UBOOL bNoAnchorCheck=0);
	UBOOL IsNetRelevantFor( APlayerController* RealViewer, AActor* Viewer, FVector SrcLocation );
	virtual FVector GetDestination();
};


class AProjectile : public AActor
{
public:
    FLOAT Speed;
    FLOAT MaxSpeed;
    FLOAT TossZ;
    BITFIELD bSwitchToZeroCollision:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bBegunPlay:1;
    class AActor* ZeroCollider GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT Damage;
    FLOAT DamageRadius;
    FLOAT MomentumTransfer;
    class UClass* MyDamageType;
    class USoundCue* SpawnSound;
    class USoundCue* ImpactSound;
    FLOAT ExploWallOut;
    class AController* InstigatorController;
    DECLARE_CLASS(AProjectile,AActor,0,Engine)
	void BoundProjectileVelocity();
	virtual UBOOL ShrinkCollision(AActor *HitActor, const FVector &StartLocation);
    virtual UBOOL IsAProjectile() { return true; }
    virtual AProjectile* GetAProjectile() { return this; } 
};

enum ERouteType
{
    ERT_Linear              =0,
    ERT_Loop                =1,
    ERT_Circle              =2,
    ERT_MAX                 =3,
};

class ARoute : public AActor
{
public:
    BYTE RouteType;
    TArrayNoInit<class ANavigationPoint*> MoveList GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(ARoute,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ARoute)
};


class ASkeletalMeshActor : public AActor
{
public:
    class USkeletalMeshComponent* SkeletalMeshComponent;
    DECLARE_CLASS(ASkeletalMeshActor,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ASkeletalMeshActor)
};


class AStaticMeshActor : public AActor
{
public:
    class UStaticMeshComponent* StaticMeshComponent;
    BITFIELD bExactProjectileCollision:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(AStaticMeshActor,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AStaticMeshActor)
};


class AInterpActor : public AStaticMeshActor
{
public:
    DECLARE_CLASS(AInterpActor,AStaticMeshActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AInterpActor)
};


class ATrigger : public AActor
{
public:
    class UCylinderComponent* CylinderComponent;
    DECLARE_CLASS(ATrigger,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ATrigger)
};


class UActorFactory : public UObject
{
public:
    FStringNoInit MenuName;
    INT MenuPriority;
    class UClass* NewActorClass;
    BITFIELD bPlaceable:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(UActorFactory,UObject,0|CLASS_Config,Engine)
	/** Called to actual create an actor at the supplied location/rotation, using the properties in the ActorFactory */
	virtual AActor* CreateActor(ULevel* Level, const FVector* const Location, const FRotator* const Rotation);

	/**
	 * If the ActorFactory thinks it could create an Actor with the current settings. 
	 * Used to determine if we should add to context menu for example.
	 */
	virtual UBOOL CanCreateActor() { return true; }

	/** Fill in parameters automatically, using GSelectionTools etc. */
	virtual void AutoFillFields() {}

	/** Name to put on context menu. */
	virtual FString GetMenuName() { return MenuName; }
};


class UActorFactoryAI : public UActorFactory
{
public:
    class UClass* ControllerClass;
    class UClass* PawnClass;
    TArrayNoInit<class UClass*> InventoryList;
    INT TeamIndex;
    DECLARE_CLASS(UActorFactoryAI,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor(ULevel* Level, const FVector* const Location, const FRotator* const Rotation);
};


class UActorFactoryEmitter : public UActorFactory
{
public:
    class UParticleSystem* ParticleSystem;
    DECLARE_CLASS(UActorFactoryEmitter,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor(ULevel* Level, const FVector* const Location, const FRotator* const Rotation);
	virtual UBOOL CanCreateActor();
	virtual void AutoFillFields();
	virtual FString GetMenuName();
};


class UActorFactoryLight : public UActorFactory
{
public:
    DECLARE_CLASS(UActorFactoryLight,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryLight)
};


class UActorFactoryPhysicsAsset : public UActorFactory
{
public:
    class UPhysicsAsset* PhysicsAsset;
    class USkeletalMesh* SkeletalMesh;
    BITFIELD bStartAwake:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bDamageAppliesImpulse:1;
    FVector InitialVelocity GCC_PACK(PROPERTY_ALIGNMENT);
    FVector DrawScale3D;
    DECLARE_CLASS(UActorFactoryPhysicsAsset,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor(ULevel* Level, const FVector* const Location, const FRotator* const Rotation);
	virtual UBOOL CanCreateActor();
	virtual void AutoFillFields();
	virtual FString GetMenuName();
};


class UActorFactoryPlayerStart : public UActorFactory
{
public:
    DECLARE_CLASS(UActorFactoryPlayerStart,UActorFactory,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryPlayerStart)
};


class UActorFactoryRoute : public UActorFactory
{
public:
    DECLARE_CLASS(UActorFactoryRoute,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor(ULevel* Level, const FVector* const Location, const FRotator* const Rotation);
	virtual UBOOL CanCreateActor();
};


class UActorFactorySkeletalMesh : public UActorFactory
{
public:
    class USkeletalMesh* SkeletalMesh;
    class UAnimSet* AnimSet;
    FName AnimSequenceName;
    DECLARE_CLASS(UActorFactorySkeletalMesh,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor(ULevel* Level, const FVector* const Location, const FRotator* const Rotation);
	virtual UBOOL CanCreateActor();
	virtual void AutoFillFields();
	virtual FString GetMenuName();
};


class UActorFactoryStaticMesh : public UActorFactory
{
public:
    class UStaticMesh* StaticMesh;
    FVector DrawScale3D;
    DECLARE_CLASS(UActorFactoryStaticMesh,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor(ULevel* Level, const FVector* const Location, const FRotator* const Rotation);
	virtual UBOOL CanCreateActor();
	virtual void AutoFillFields();
	virtual FString GetMenuName();
};


class UActorFactoryMover : public UActorFactoryStaticMesh
{
public:
    DECLARE_CLASS(UActorFactoryMover,UActorFactoryStaticMesh,0|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UActorFactoryMover)
};


class UActorFactoryRigidBody : public UActorFactoryStaticMesh
{
public:
    BITFIELD bStartAwake:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bDamageAppliesImpulse:1;
    FVector InitialVelocity GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(UActorFactoryRigidBody,UActorFactoryStaticMesh,0|CLASS_Config,Engine)
	virtual UBOOL CanCreateActor();
	virtual AActor* CreateActor(ULevel* Level, const FVector* const Location, const FRotator* const Rotation);
};


class UActorFactoryVehicle : public UActorFactory
{
public:
    class UClass* VehicleClass;
    DECLARE_CLASS(UActorFactoryVehicle,UActorFactory,0|CLASS_Config,Engine)
	virtual AActor* CreateActor(ULevel* Level, const FVector* const Location, const FRotator* const Rotation);
};


class UBookMark : public UObject
{
public:
    FVector Location;
    FRotator Rotation;
    DECLARE_CLASS(UBookMark,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UBookMark)
};


class UCheatManager : public UObject
{
public:
    DECLARE_CLASS(UCheatManager,UObject,0,Engine)
    DECLARE_WITHIN(APlayerController)
    NO_DEFAULT_CONSTRUCTOR(UCheatManager)
};


class UCodecMovie : public UObject
{
public:
    FLOAT PlaybackDuration;
    DECLARE_CLASS(UCodecMovie,UObject,0,Engine)
	// Can't have pure virtual functions in classes declared in *Classes.h due to DECLARE_CLASS macro being used.

	/**
	 * Returns the movie width.
	 *
	 * @return width of movie.
	 */
	virtual UINT GetSizeX() { return 0; }
	/**
	 * Returns the movie height.
	 *
	 * @return height of movie.
	 */
	virtual UINT GetSizeY()	{ return 0; }
	/** 
	 * Returns the movie format.
	 *
	 * @return format of movie.
	 */
	virtual EPixelFormat GetFormat() { return PF_Unknown; }
	/**
	 * Returns the framerate the movie was encoded at.
	 *
	 * @return framerate the movie was encoded at.
	 */
	virtual FLOAT GetFrameRate() { return 0; }
	
	/**
	 * Initializes the decoder to stream from disk.
	 *
	 * @param	Filename	Filename of compressed media.
	 * @param	Offset		Offset into file to look for the beginning of the compressed data.
	 * @param	Size		Size of compressed data.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( const FString& Filename, DWORD Offset, DWORD Size ) { return FALSE; }
	/**
	 * Initializes the decoder to stream from memory.
	 *
	 * @param	Source		Beginning of memory block holding compressed data.
	 * @param	Size		Size of memory block.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( void* Source, DWORD Size ) { return FALSE; }
	/**
	 * Tears down stream.
	 */	
	virtual void Close() {}

	/**
	 * Resets the stream to its initial state so it can be played again from the beginning.
	 */
	virtual void ResetStream() {}
	/**
	 * Blocks until the decoder has finished the pending decompression request.
	 *
	 * @return	Time into movie playback as seen from the decoder side.
	 */
	virtual FLOAT BlockUntilIdle() { return 0.f; }	
	/**
	 * Queues the request to retrieve the next frame.
	 *
 	 * @param	Destination		Memory block to uncompress data into.
	 * @return	FALSE if the end of the frame has been reached and the frame couldn't be completed, TRUE otherwise
	 */
	virtual UBOOL GetFrame( void* Destination ) { return FALSE; }

	/**
	 * Returns the playback time of the movie.
	 *
	 * @return playback duration of movie.
	 */
	virtual FLOAT GetDuration() { return PlaybackDuration; }
};


class UCodecMovieFallback : public UCodecMovie
{
public:
    FLOAT CurrentTime;
    DECLARE_CLASS(UCodecMovieFallback,UCodecMovie,0,Engine)
	/**
	 * Returns the movie width.
	 *
	 * @return width of movie.
	 */
	virtual UINT GetSizeX();
	/**
	 * Returns the movie height.
	 *
	 * @return height of movie.
	 */
	virtual UINT GetSizeY();
	/** 
	 * Returns the movie format.
	 *
	 * @return format of movie.
	 */
	virtual EPixelFormat GetFormat();
	/**
	 * Returns the framerate the movie was encoded at.
	 *
	 * @return framerate the movie was encoded at.
	 */
	virtual FLOAT GetFrameRate();
	
	/**
	 * Initializes the decoder to stream from disk.
	 *
	 * @param	Filename	Filename of compressed media.
	 * @param	Offset		Offset into file to look for the beginning of the compressed data.
	 * @param	Size		Size of compressed data.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( const FString& Filename, DWORD Offset, DWORD Size );
	/**
	 * Initializes the decoder to stream from memory.
	 *
	 * @param	Source		Beginning of memory block holding compressed data.
	 * @param	Size		Size of memory block.
	 *
	 * @return	TRUE if initialization was successful, FALSE otherwise.
	 */
	virtual UBOOL Open( void* Source, DWORD Size );
	/**
	 * Tears down stream.
	 */	
	virtual void Close();

	/**
	 * Resets the stream to its initial state so it can be played again from the beginning.
	 */
	virtual void ResetStream();
	/**
	 * Blocks until the decoder has finished the pending decompression request.
	 *
	 * @return	Time into movie playback as seen from the decoder side.
	 */
	virtual FLOAT BlockUntilIdle();
	/**
	 * Queues the request to retrieve the next frame.
	 *
 	 * @param	Destination		Memory block to uncompress data into.
	 * @return	FALSE if the end of the frame has been reached and the frame couldn't be completed, TRUE otherwise
	 */
	virtual UBOOL GetFrame( void* Destination );
};


class UHeightFogComponent : public UActorComponent
{
public:
    FLOAT Height;
    FLOAT Density;
    FLOAT LightBrightness;
    FColor LightColor;
    DECLARE_CLASS(UHeightFogComponent,UActorComponent,0,Engine)
	// UActorComponent interface.

	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Created();
	virtual void Destroyed();
};


class UDirectionalLightComponent : public ULightComponent
{
public:
    DECLARE_CLASS(UDirectionalLightComponent,ULightComponent,0,Engine)
	virtual FPlane GetPosition() const;
};


class UPointLightComponent : public ULightComponent
{
public:
    FLOAT Radius;
    DECLARE_CLASS(UPointLightComponent,ULightComponent,0,Engine)
	virtual UBOOL AffectsSphere(const FSphere& Sphere);
	virtual FPlane GetPosition() const;
	virtual FBox GetBoundingBox() const;
};


class USpotLightComponent : public UPointLightComponent
{
public:
    FLOAT InnerConeAngle;
    FLOAT OuterConeAngle;
    DECLARE_CLASS(USpotLightComponent,UPointLightComponent,0,Engine)
	virtual UBOOL AffectsSphere(const FSphere& Sphere);
};


class USkyLightComponent : public ULightComponent
{
public:
    DECLARE_CLASS(USkyLightComponent,ULightComponent,0,Engine)
	virtual FPlane GetPosition() const;
};


class UTransformComponent : public UActorComponent
{
public:
    FMatrix CachedParentToWorld;
    class UActorComponent* TransformedComponent;
    FVector Translation;
    FRotator Rotation;
    FLOAT Scale;
    FVector Scale3D;
    BITFIELD AbsoluteTranslation:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD AbsoluteRotation:1;
    BITFIELD AbsoluteScale:1;
    DECLARE_FUNCTION(execSetAbsolute);
    DECLARE_FUNCTION(execSetScale3D);
    DECLARE_FUNCTION(execSetScale);
    DECLARE_FUNCTION(execSetRotation);
    DECLARE_FUNCTION(execSetTranslation);
    DECLARE_FUNCTION(execSetTransformedComponent);
    DECLARE_CLASS(UTransformComponent,UActorComponent,0,Engine)
	/**
	 * Calls SetParentToWorld on TransformedComponent.
	 */
	void SetTransformedToWorld();

	// UActorComponent interface.

	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Created();
	virtual void Update();
	virtual void Destroyed();
	virtual void Tick(FLOAT DeltaTime);
	virtual UBOOL IsValidComponent() const { return TransformedComponent && TransformedComponent->IsValidComponent(); }
};


class UWindDirectionalSourceComponent : public UActorComponent
{
public:
    FVector Direction;
    FLOAT Strength;
    FLOAT Phase;
    FLOAT Frequency;
    DECLARE_CLASS(UWindDirectionalSourceComponent,UActorComponent,0,Engine)
	// UActorComponent interface.

	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Created();
	virtual void Destroyed();

	// GetRenderData

	FWindDirectionSource GetRenderData() const;
};


class UWindPointSourceComponent : public UActorComponent
{
public:
    FVector Position;
    FLOAT Strength;
    FLOAT Phase;
    FLOAT Frequency;
    FLOAT Radius;
    FLOAT Duration;
    DECLARE_CLASS(UWindPointSourceComponent,UActorComponent,0,Engine)
	// UActorComponent interface.

	virtual void SetParentToWorld(const FMatrix& ParentToWorld);
	virtual void Created();
	virtual void Destroyed();

	// GetRenderData

	FWindPointSource GetRenderData() const;
};


class UDistributionFloatConstant : public UDistributionFloat
{
public:
    FLOAT Constant;
    DECLARE_CLASS(UDistributionFloatConstant,UDistributionFloat,0,Engine)
	virtual FLOAT GetValue( FLOAT F = 0.f );

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};


class UDistributionFloatConstantCurve : public UDistributionFloat
{
public:
    FInterpCurveFloat ConstantCurve;
    DECLARE_CLASS(UDistributionFloatConstantCurve,UDistributionFloat,0,Engine)
	virtual FLOAT GetValue( FLOAT F = 0.f );

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};


class UDistributionFloatUniform : public UDistributionFloat
{
public:
    FLOAT Min;
    FLOAT Max;
    DECLARE_CLASS(UDistributionFloatUniform,UDistributionFloat,0,Engine)
	virtual FLOAT GetValue( FLOAT F = 0.f );

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};


class UDistributionVectorConstant : public UDistributionVector
{
public:
    FVector Constant;
    BITFIELD bLockAxes:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BYTE LockedAxes GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(UDistributionVectorConstant,UDistributionVector,0,Engine)
	virtual FVector GetValue( FLOAT F = 0.f );

	// UObject interface
	virtual void Serialize(FArchive& Ar);
	
	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};


class UDistributionVectorConstantCurve : public UDistributionVector
{
public:
    FInterpCurveVector ConstantCurve;
    BITFIELD bLockAxes:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BYTE LockedAxes GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(UDistributionVectorConstantCurve,UDistributionVector,0,Engine)
	virtual FVector GetValue( FLOAT F = 0.f );

	// UObject interface
	virtual void Serialize(FArchive& Ar);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};


class UDistributionVectorUniform : public UDistributionVector
{
public:
    FVector Max;
    FVector Min;
    BITFIELD bLockAxes:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BYTE LockedAxes GCC_PACK(PROPERTY_ALIGNMENT);
    BYTE MirrorFlags[3];
    DECLARE_CLASS(UDistributionVectorUniform,UDistributionVector,0,Engine)
	virtual FVector GetValue( FLOAT F = 0.f );
	
	/** These two functions will retrieve the Min/Max values respecting the Locked and Mirror flags. */
	virtual FVector GetMinValue();
	virtual FVector GetMaxValue();

	// UObject interface
	virtual void Serialize(FArchive& Ar);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};


class UDamageType : public UObject
{
public:
    FStringNoInit DeathString;
    FStringNoInit FemaleSuicide;
    FStringNoInit MaleSuicide;
    FStringNoInit DamageWeaponName;
    BITFIELD bArmorStops:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bAlwaysGibs:1;
    BITFIELD bLocationalHit:1;
    BITFIELD bSkeletize:1;
    BITFIELD bCausesBlood:1;
    BITFIELD bKUseOwnDeathVel:1;
    FLOAT GibModifier GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT KDamageImpulse;
    FLOAT KDeathVel;
    FLOAT KDeathUpKick;
    FLOAT VehicleDamageScaling;
    FLOAT VehicleMomentumScaling;
    class UForceFeedbackWaveform* DamagedFFWaveform;
    class UForceFeedbackWaveform* KilledFFWaveform;
    DECLARE_CLASS(UDamageType,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDamageType)
};


class UKillZDamageType : public UDamageType
{
public:
    DECLARE_CLASS(UKillZDamageType,UDamageType,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UKillZDamageType)
};


class UDmgType_Suicided : public UKillZDamageType
{
public:
    DECLARE_CLASS(UDmgType_Suicided,UKillZDamageType,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDmgType_Suicided)
};


class UDebugManager : public UObject
{
public:
    INT FirstColoredMip;
    DECLARE_CLASS(UDebugManager,UObject,0|CLASS_Transient,Engine)
    NO_DEFAULT_CONSTRUCTOR(UDebugManager)
};


class UEdCoordSystem : public UObject
{
public:
    FMatrix M;
    FStringNoInit Desc;
    DECLARE_CLASS(UEdCoordSystem,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UEdCoordSystem)
};


class UEdLayer : public UObject
{
public:
    FStringNoInit Desc;
    BITFIELD bVisible:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bUseColor:1;
    FColor Color GCC_PACK(PROPERTY_ALIGNMENT);
    class UEdCoordSystem* CoordSystem;
    DECLARE_CLASS(UEdLayer,UObject,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};


class UForceFeedbackManager : public UObject
{
public:
    BITFIELD bAllowsForceFeedback:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bIsPaused:1;
    class UForceFeedbackWaveform* FFWaveform GCC_PACK(PROPERTY_ALIGNMENT);
    INT CurrentSample;
    FLOAT ElapsedTime;
    FLOAT ScaleAllWaveformsBy;
    DECLARE_CLASS(UForceFeedbackManager,UObject,0|CLASS_Transient,Engine)
    DECLARE_WITHIN(APlayerController)
protected:
	/**
	 * Update the currently playing waveform sample
	 *
	 * @param DeltaTime The amount of elapsed time since the last update
	 */
	virtual void UpdateWaveformData(FLOAT DeltaTime);

public:
	/**
	 * Applies the current waveform data to the gamepad/mouse/etc
	 * This function is platform specific
	 *
	 * @param DeltaTime The amount of elapsed time since the last update
	 * @param DeviceID The device that needs updating
	 */
	virtual void ApplyForceFeedback(FLOAT DeltaTime,INT DeviceID) {}
};

#define UCONST_MaxHistory 16

struct Console_eventPostRender_Parms
{
    class UCanvas* Canvas;
};
struct Console_eventMessage_Parms
{
    FString Msg;
    FLOAT MsgLife;
};
class UConsole : public UInput
{
public:
    FName ConsoleKey;
    INT HistoryTop;
    INT HistoryBot;
    INT HistoryCur;
    FStringNoInit TypedStr;
    FStringNoInit History[16];
    INT TypedStrPos;
    BITFIELD bTyping:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bIgnoreKeys:1;
    void eventPostRender(class UCanvas* Canvas)
    {
        Console_eventPostRender_Parms Parms;
        Parms.Canvas=Canvas;
        ProcessEvent(FindFunctionChecked(ENGINE_PostRender),&Parms);
    }
    void eventMessage(const FString& Msg, FLOAT MsgLife)
    {
        Console_eventMessage_Parms Parms;
        Parms.Msg=Msg;
        Parms.MsgLife=MsgLife;
        ProcessEvent(FindFunctionChecked(ENGINE_Message),&Parms);
    }
    DECLARE_CLASS(UConsole,UInput,0|CLASS_Transient|CLASS_Config,Engine)
    NO_DEFAULT_CONSTRUCTOR(UConsole)
};


struct PlayerInput_eventPlayerInput_Parms
{
    FLOAT DeltaTime;
};
class UPlayerInput : public UInput
{
public:
    BITFIELD bInvertMouse:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bWasForward:1;
    BITFIELD bWasBack:1;
    BITFIELD bWasLeft:1;
    BITFIELD bWasRight:1;
    BITFIELD bEdgeForward:1;
    BITFIELD bEdgeBack:1;
    BITFIELD bEdgeLeft:1;
    BITFIELD bEdgeRight:1;
    BITFIELD bAdjustSampling:1;
    FLOAT MouseSensitivity GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT DoubleClickTimer;
    FLOAT DoubleClickTime;
    FLOAT aBaseX;
    FLOAT aBaseY;
    FLOAT aBaseZ;
    FLOAT aMouseX;
    FLOAT aMouseY;
    FLOAT aForward;
    FLOAT aTurn;
    FLOAT aStrafe;
    FLOAT aUp;
    FLOAT aLookUp;
    BYTE bStrafe;
    BYTE bTurn180;
    BYTE bTurnToNearest;
    BYTE bXAxis;
    BYTE bYAxis;
    FLOAT LastStrafe GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT LastBaseY;
    void eventPlayerInput(FLOAT DeltaTime)
    {
        PlayerInput_eventPlayerInput_Parms Parms;
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayerInput),&Parms);
    }
    DECLARE_CLASS(UPlayerInput,UInput,0|CLASS_Transient|CLASS_Config,Engine)
    DECLARE_WITHIN(APlayerController)
    NO_DEFAULT_CONSTRUCTOR(UPlayerInput)
};

struct FCurveEdEntry
{
    class UObject* CurveObject;
    FColor CurveColor;
    FStringNoInit CurveName;
    INT bHideCurve;
    INT bColorCurve;
};

struct FCurveEdTab
{
    FStringNoInit TabName;
    TArrayNoInit<FCurveEdEntry> Curves;
    FLOAT ViewStartInput;
    FLOAT ViewEndInput;
    FLOAT ViewStartOutput;
    FLOAT ViewEndOutput;
};


class UInterpCurveEdSetup : public UObject
{
public:
    TArrayNoInit<FCurveEdTab> Tabs;
    INT ActiveTab;
    DECLARE_CLASS(UInterpCurveEdSetup,UObject,0,Engine)
	// UObject interface
	void PostLoad();

	// InterpCurveEdSetup interface
	static FCurveEdInterface* GetCurveEdInterfacePointer(const FCurveEdEntry& Entry);
	void AddCurveToCurrentTab(UObject* InCurve, const FString& CurveName, const FColor& CurveColor, UBOOL bColorCurve=false);
	void RemoveCurve(UObject* InCurve);
	void ReplaceCurve(UObject* RemoveCurve, UObject* AddCurve);
	void CreateNewTab(const FString& InTabName);
	UBOOL ShowingCurve(UObject* InCurve);
	
	void ResetTabs();
};


class ULevelSummary : public UObject
{
public:
    FStringNoInit Title;
    FStringNoInit Author;
    INT IdealPlayerCount;
    DECLARE_CLASS(ULevelSummary,UObject,0,Engine)
	// Constructors.
	ULevelSummary()
	{}

	// UObject interface.
	void PostLoad()
	{
		Super::PostLoad();
		FString Text = Localize( TEXT("LevelInfo0"), TEXT("Title"), GetOuter()->GetName(), NULL, 1 );
		if( Text.Len() )
			Title = Text;
	}
};


class ULightFunction : public UObject
{
public:
    class UMaterialInstance* SourceMaterial;
    FVector Scale;
    DECLARE_CLASS(ULightFunction,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ULightFunction)
};


class UMaterialExpression : public UObject
{
public:
    INT EditorX;
    INT EditorY;
    BITFIELD Compiling:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD PendingKill:1;
    TArrayNoInit<FString> Errors GCC_PACK(PROPERTY_ALIGNMENT);
    FStringNoInit Desc;
    DECLARE_CLASS(UMaterialExpression,UObject,0,Engine)
    DECLARE_WITHIN(UMaterial)
	// UObject interface.

	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual UBOOL IsPendingKill() {return PendingKill;}

	// UMaterialExpression interface.

	virtual INT Compile(FMaterialCompiler* Compiler) { return INDEX_NONE; }
	virtual void GetOutputs(TArray<FExpressionOutput>& Outputs) const;
	virtual INT GetWidth() const;
	virtual INT GetHeight() const;
	virtual UBOOL UsesLeftGutter() const;
	virtual UBOOL UsesRightGutter() const;
	virtual FString GetCaption() const;
	virtual INT GetLabelPadding() { return 0; }
};


class UMaterialInstance : public UObject
{
public:
    DECLARE_FUNCTION(execGetMaterial);
    DECLARE_CLASS(UMaterialInstance,UObject,0,Engine)
	// GetMaterial - Get the material which this is an instance of.

	virtual class UMaterial* GetMaterial() { check(0); return 0; }

	// GetLayerMask - Returns the layers this material needs to be rendered on.

	virtual DWORD GetLayerMask() { check(0); return 0; }

	// GetMaterialInterface - Returns a pointer to the FMaterial used for rendering.

	virtual FMaterial* GetMaterialInterface(UBOOL Selected) { check(0); return NULL; }

	// GetInstanceInterface - Returns a pointer to the FMaterialInstance used for rendering.

	virtual FMaterialInstance* GetInstanceInterface() { check(0); return NULL; }

	// UObject interface.

	virtual void DrawThumbnail( EThumbnailPrimType InPrimType, INT InX, INT InY, INT InPitch, INT InYaw, FChildViewport* InViewport, FRenderInterface* InRI, FLOAT InZoom, UBOOL InShowBackground, FLOAT InZoomPct, INT InFixedSz );
	virtual void DrawThumbnail( EThumbnailPrimType InPrimType, INT InX, INT InY, struct FChildViewport* InViewport, struct FRenderInterface* InRI, FLOAT InZoom, UBOOL InShowBackground, FLOAT InZoomPct, INT InFixedSz ) { DrawThumbnail(InPrimType,InX,InY,0,0,InViewport,InRI,InZoom,InShowBackground,InZoomPct,InFixedSz); }
	virtual FThumbnailDesc GetThumbnailDesc( FRenderInterface* InRI, FLOAT InZoom, INT InFixedSz );
	virtual INT GetThumbnailLabels( TArray<FString>* InLabels );
	INT GetWidth() const;
	INT GetHeight() const;
};

enum EBlendMode
{
    BLEND_Opaque            =0,
    BLEND_Masked            =1,
    BLEND_Translucent       =2,
    BLEND_Additive          =3,
    BLEND_MAX               =4,
};

class UMaterial : public UMaterialInstance
{
public:
    class UClass* PhysicalMaterial;
    FColorMaterialInput DiffuseColor;
    FColorMaterialInput SpecularColor;
    FScalarMaterialInput SpecularPower;
    FVectorMaterialInput Normal;
    class USphericalHarmonicMap* SHM;
    FColorMaterialInput EmissiveColor;
    FScalarMaterialInput Opacity;
    FScalarMaterialInput OpacityMask;
    FLOAT OpacityMaskClipValue;
    FVector2MaterialInput Distortion;
    BYTE BlendMode;
    BITFIELD Unlit:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD TwoSided:1;
    BITFIELD NonDirectionalLighting:1;
    FScalarMaterialInput TwoSidedLightingMask GCC_PACK(PROPERTY_ALIGNMENT);
    FColorMaterialInput TwoSidedLightingColor;
    FMaterialPointer MaterialResources[2];
    FMaterialInstancePointer DefaultMaterialInstance;
    TArrayNoInit<FTextureBasePointer> StreamingTextures;
    FGuid PersistentIds[2];
    INT EditorX;
    INT EditorY;
    INT EditorPitch;
    INT EditorYaw;
    DECLARE_CLASS(UMaterial,UMaterialInstance,0,Engine)
	// Constructor.

	UMaterial();

	// UMaterial interface.

	/** Fills in the StreamingTextures array with streamable textures used by this matieral. */
	virtual void CollectStreamingTextures();

	// UMaterialInstance interface.

	virtual UMaterial* GetMaterial() { return this; }
	virtual DWORD GetLayerMask();
	virtual FMaterial* GetMaterialInterface(UBOOL Selected) { return MaterialResources[Selected]; }
	virtual FMaterialInstance* GetInstanceInterface() { return DefaultMaterialInstance; }
	
	// UObject interface.

	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void Destroy();
};


class UPrimitiveComponentFactory : public UObject
{
public:
    BITFIELD CollideActors:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD BlockActors:1;
    BITFIELD BlockZeroExtent:1;
    BITFIELD BlockNonZeroExtent:1;
    BITFIELD BlockRigidBody:1;
    BITFIELD HiddenGame:1;
    BITFIELD HiddenEditor:1;
    BITFIELD CastShadow:1;
    DECLARE_CLASS(UPrimitiveComponentFactory,UObject,0,Engine)
	virtual UBOOL FactoryIsValid() { return 1; }
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter) { return NULL; }
};


class UMeshComponentFactory : public UPrimitiveComponentFactory
{
public:
    TArrayNoInit<class UMaterialInstance*> Materials;
    DECLARE_CLASS(UMeshComponentFactory,UPrimitiveComponentFactory,0,Engine)
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter) { return NULL; }
};


class UStaticMeshComponentFactory : public UMeshComponentFactory
{
public:
    class UStaticMesh* StaticMesh;
    DECLARE_CLASS(UStaticMeshComponentFactory,UMeshComponentFactory,0,Engine)
	virtual UBOOL FactoryIsValid() { return StaticMesh != NULL && Super::FactoryIsValid(); }
	virtual UPrimitiveComponent* CreatePrimitiveComponent(UObject* InOuter);
};


class UReachSpec : public UObject
{
public:
    INT Distance;
    class ANavigationPoint* Start;
    class ANavigationPoint* End;
    INT CollisionRadius;
    INT CollisionHeight;
    INT reachFlags;
    INT MaxLandingVelocity;
    BYTE bPruned;
    BITFIELD bForced:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(UReachSpec,UObject,0,Engine)
	/*
	supports() -
	returns true if it supports the requirements of aPawn.  Distance is not considered.
	*/
	inline UBOOL supports (INT iRadius, INT iHeight, INT moveFlags, INT iMaxFallVelocity)
	{
		return ( (CollisionRadius >= iRadius) 
			&& (CollisionHeight >= iHeight)
			&& ((reachFlags & moveFlags) == reachFlags)
			&& ((MaxLandingVelocity <= iMaxFallVelocity) || bForced) );
	}

	int defineFor (class ANavigationPoint *begin, class ANavigationPoint * dest, class APawn * Scout);
	int operator<= (const UReachSpec &Spec);
	FPlane PathColor();
	void Init();
	int findBestReachable(class AScout *Scout);
	UBOOL PlaceScout(class AScout *Scout); 
};


class USoundNode : public UObject
{
public:
    TArrayNoInit<class USoundNode*> ChildNodes;
    DECLARE_CLASS(USoundNode,UObject,0,Engine)
	// USoundNode interface.
	
	virtual UBOOL Finished( class UAudioComponent* AudioComponent ) { return TRUE; }
	/**
	 * Returns whether this sound node will potentially loop leaf nodes.
	 *
	 * @return FALSE
	 */
	virtual UBOOL IsPotentiallyLooping() { return FALSE; }

	virtual void ParseNodes( class UAudioComponent* AudioComponent, TArray<FWaveInstance*>& WaveInstances );
	virtual void GetNodes( class UAudioComponent* AudioComponent, TArray<USoundNode*>& SoundNodes );
	virtual void GetAllNodes( TArray<USoundNode*>& SoundNodes ); // Like above but returns ALL (not just active) nodes.

	virtual INT GetMaxChildNodes() { return 1; }

	// Tool drawing
	virtual void DrawSoundNode(FRenderInterface* RI, const struct FSoundNodeEditorData& EdData, UBOOL bSelected);
	virtual FIntPoint GetConnectionLocation(FRenderInterface* RI, INT ConnType, INT ConnIndex, const struct FSoundNodeEditorData& EdData);

	// Editor interface.
	virtual void InsertChildNode( INT Index );
	virtual void RemoveChildNode( INT Index );
};

#endif

AUTOGENERATE_FUNCTION(AActor,-1,execActivateEvent);
AUTOGENERATE_FUNCTION(AActor,552,execMultiply_ColorFloat);
AUTOGENERATE_FUNCTION(AActor,551,execAdd_ColorColor);
AUTOGENERATE_FUNCTION(AActor,550,execMultiply_FloatColor);
AUTOGENERATE_FUNCTION(AActor,549,execSubtract_ColorColor);
AUTOGENERATE_FUNCTION(AActor,-1,execLocalPlayerControllers);
AUTOGENERATE_FUNCTION(AActor,-1,execOverlappingActors);
AUTOGENERATE_FUNCTION(AActor,321,execCollidingActors);
AUTOGENERATE_FUNCTION(AActor,312,execVisibleCollidingActors);
AUTOGENERATE_FUNCTION(AActor,311,execVisibleActors);
AUTOGENERATE_FUNCTION(AActor,309,execTraceActors);
AUTOGENERATE_FUNCTION(AActor,307,execTouchingActors);
AUTOGENERATE_FUNCTION(AActor,306,execBasedActors);
AUTOGENERATE_FUNCTION(AActor,305,execChildActors);
AUTOGENERATE_FUNCTION(AActor,313,execDynamicActors);
AUTOGENERATE_FUNCTION(AActor,304,execAllActors);
AUTOGENERATE_FUNCTION(AActor,-1,execMoveCacheEntry);
AUTOGENERATE_FUNCTION(AActor,-1,execGetCacheEntry);
AUTOGENERATE_FUNCTION(AActor,547,execGetURLMap);
AUTOGENERATE_FUNCTION(AActor,-1,execSuggestFallVelocity);
AUTOGENERATE_FUNCTION(AActor,532,execPlayerCanSeeMe);
AUTOGENERATE_FUNCTION(AActor,512,execMakeNoise);
AUTOGENERATE_FUNCTION(AActor,-1,execCreateAudioComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execGetTimerCount);
AUTOGENERATE_FUNCTION(AActor,-1,execIsTimerActive);
AUTOGENERATE_FUNCTION(AActor,-1,execClearTimer);
AUTOGENERATE_FUNCTION(AActor,280,execSetTimer);
AUTOGENERATE_FUNCTION(AActor,279,execDestroy);
AUTOGENERATE_FUNCTION(AActor,278,execSpawn);
AUTOGENERATE_FUNCTION(AActor,-1,execGetBoundingCylinder);
AUTOGENERATE_FUNCTION(AActor,-1,execGetComponentsBoundingBox);
AUTOGENERATE_FUNCTION(AActor,-1,execTouchingActor);
AUTOGENERATE_FUNCTION(AActor,-1,execContainsPoint);
AUTOGENERATE_FUNCTION(AActor,548,execFastTrace);
AUTOGENERATE_FUNCTION(AActor,-1,execTraceComponent);
AUTOGENERATE_FUNCTION(AActor,277,execTrace);
AUTOGENERATE_FUNCTION(AActor,-1,execClampRotation);
AUTOGENERATE_FUNCTION(AActor,-1,execAddComponent);
AUTOGENERATE_FUNCTION(AActor,-1,execUnClock);
AUTOGENERATE_FUNCTION(AActor,-1,execClock);
AUTOGENERATE_FUNCTION(AActor,3970,execSetPhysics);
AUTOGENERATE_FUNCTION(AActor,-1,execDebugUnclock);
AUTOGENERATE_FUNCTION(AActor,-1,execDebugClock);
AUTOGENERATE_FUNCTION(AActor,-1,execChartData);
AUTOGENERATE_FUNCTION(AActor,-1,execFlushPersistentDebugLines);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawPersistentDebugLine);
AUTOGENERATE_FUNCTION(AActor,-1,execDrawDebugLine);
AUTOGENERATE_FUNCTION(AActor,272,execSetOwner);
AUTOGENERATE_FUNCTION(AActor,298,execSetBase);
AUTOGENERATE_FUNCTION(AActor,3971,execAutonomousPhysics);
AUTOGENERATE_FUNCTION(AActor,3969,execMoveSmooth);
AUTOGENERATE_FUNCTION(AActor,-1,execSetRelativeLocation);
AUTOGENERATE_FUNCTION(AActor,-1,execSetRelativeRotation);
AUTOGENERATE_FUNCTION(AActor,299,execSetRotation);
AUTOGENERATE_FUNCTION(AActor,267,execSetLocation);
AUTOGENERATE_FUNCTION(AActor,266,execMove);
AUTOGENERATE_FUNCTION(AActor,-1,execOnlyAffectPawns);
AUTOGENERATE_FUNCTION(AActor,-1,execSetPrePivot);
AUTOGENERATE_FUNCTION(AActor,-1,execSetDrawScale3D);
AUTOGENERATE_FUNCTION(AActor,-1,execSetDrawScale);
AUTOGENERATE_FUNCTION(AActor,283,execSetCollisionSize);
AUTOGENERATE_FUNCTION(AActor,262,execSetCollision);
AUTOGENERATE_FUNCTION(AActor,261,execFinishAnim);
AUTOGENERATE_FUNCTION(AActor,256,execSleep);
AUTOGENERATE_FUNCTION(AActor,233,execError);
AUTOGENERATE_FUNCTION(AActor,-1,execConsoleCommand);
AUTOGENERATE_FUNCTION(ACamera,-1,execSetViewTarget);
AUTOGENERATE_FUNCTION(ACamera,-1,execFillCameraCache);
AUTOGENERATE_FUNCTION(AController,-1,execStopLatentExecution);
AUTOGENERATE_FUNCTION(AController,-1,execInLatentExecution);
AUTOGENERATE_FUNCTION(AController,-1,execEndClimbLadder);
AUTOGENERATE_FUNCTION(AController,527,execWaitForLanding);
AUTOGENERATE_FUNCTION(AController,526,execPickWallAdjust);
AUTOGENERATE_FUNCTION(AController,520,execActorReachable);
AUTOGENERATE_FUNCTION(AController,521,execPointReachable);
AUTOGENERATE_FUNCTION(AController,-1,execFindPathToIntercept);
AUTOGENERATE_FUNCTION(AController,525,execFindRandomDest);
AUTOGENERATE_FUNCTION(AController,-1,execFindPathTowardNearest);
AUTOGENERATE_FUNCTION(AController,517,execFindPathToward);
AUTOGENERATE_FUNCTION(AController,518,execFindPathTo);
AUTOGENERATE_FUNCTION(AController,508,execFinishRotation);
AUTOGENERATE_FUNCTION(AController,502,execMoveToward);
AUTOGENERATE_FUNCTION(AController,500,execMoveTo);
AUTOGENERATE_FUNCTION(AController,534,execPickAnyTarget);
AUTOGENERATE_FUNCTION(AController,531,execPickTarget);
AUTOGENERATE_FUNCTION(AController,533,execCanSee);
AUTOGENERATE_FUNCTION(AController,514,execLineOfSightTo);
AUTOGENERATE_FUNCTION(ADroppedPickup,-1,execRemoveFromNavigation);
AUTOGENERATE_FUNCTION(ADroppedPickup,-1,execAddToNavigation);
AUTOGENERATE_FUNCTION(AFileLog,-1,execLogf);
AUTOGENERATE_FUNCTION(AFileLog,-1,execCloseLog);
AUTOGENERATE_FUNCTION(AFileLog,-1,execOpenLog);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execParseKillMessage);
AUTOGENERATE_FUNCTION(AGameInfo,-1,execGetNetworkNumber);
AUTOGENERATE_FUNCTION(AGameStats,-1,execGetMapFileName);
AUTOGENERATE_FUNCTION(AGameStats,-1,execGetStatsIdentifier);
AUTOGENERATE_FUNCTION(AHUD,-1,execDraw3DLine);
AUTOGENERATE_FUNCTION(AInventoryManager,-1,execInventoryActors);
AUTOGENERATE_FUNCTION(ALevelInfo,-1,execSetLevelRBGravity);
AUTOGENERATE_FUNCTION(ALevelInfo,-1,execGetLevelSequence);
AUTOGENERATE_FUNCTION(ALevelInfo,-1,execGetAddressURL);
AUTOGENERATE_FUNCTION(ALevelInfo,-1,execIsConsoleBuild);
AUTOGENERATE_FUNCTION(ALevelInfo,-1,execIsDemoBuild);
AUTOGENERATE_FUNCTION(ALevelInfo,-1,execGetLocalURL);
AUTOGENERATE_FUNCTION(ALevelInfo,-1,execIsEntry);
AUTOGENERATE_FUNCTION(UMaterialInstance,-1,execGetMaterial);
AUTOGENERATE_FUNCTION(APawn,-1,execInitRagdoll);
AUTOGENERATE_FUNCTION(APawn,-1,execSetPushesRigidBodies);
AUTOGENERATE_FUNCTION(APawn,-1,execForceCrouch);
AUTOGENERATE_FUNCTION(APawn,-1,execReachedDestination);
AUTOGENERATE_FUNCTION(APawn,-1,execSetRemoteViewPitch);
AUTOGENERATE_FUNCTION(APlayerController,524,execFindStairRotation);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCheckSpeedHack);
AUTOGENERATE_FUNCTION(APlayerController,-1,execServerValidationResponse);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientValidate);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetViewTarget);
AUTOGENERATE_FUNCTION(APlayerController,-1,execPasteFromClipboard);
AUTOGENERATE_FUNCTION(APlayerController,-1,execCopyToClipboard);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetDefaultURL);
AUTOGENERATE_FUNCTION(APlayerController,546,execUpdateURL);
AUTOGENERATE_FUNCTION(APlayerController,-1,execClientTravel);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetEntryLevel);
AUTOGENERATE_FUNCTION(APlayerController,-1,execConsoleCommand);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetServerNetworkAddress);
AUTOGENERATE_FUNCTION(APlayerController,-1,execGetPlayerNetworkAddress);
AUTOGENERATE_FUNCTION(APlayerController,-1,execSetNetSpeed);
AUTOGENERATE_FUNCTION(UTransformComponent,-1,execSetAbsolute);
AUTOGENERATE_FUNCTION(UTransformComponent,-1,execSetScale3D);
AUTOGENERATE_FUNCTION(UTransformComponent,-1,execSetScale);
AUTOGENERATE_FUNCTION(UTransformComponent,-1,execSetRotation);
AUTOGENERATE_FUNCTION(UTransformComponent,-1,execSetTranslation);
AUTOGENERATE_FUNCTION(UTransformComponent,-1,execSetTransformedComponent);
AUTOGENERATE_FUNCTION(AVolume,-1,execEncompasses);
AUTOGENERATE_FUNCTION(AZoneInfo,308,execZoneActors);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_NATIVE_DEFS
#define ENGINE_NATIVE_DEFS

DECLARE_NATIVE_TYPE(Engine,AActor);
DECLARE_NATIVE_TYPE(Engine,UActorFactory);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryAI);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryEmitter);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryLight);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryMover);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryPhysicsAsset);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryPlayerStart);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryRigidBody);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryRoute);
DECLARE_NATIVE_TYPE(Engine,UActorFactorySkeletalMesh);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryStaticMesh);
DECLARE_NATIVE_TYPE(Engine,UActorFactoryVehicle);
DECLARE_NATIVE_TYPE(Engine,UAnimNode);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlend);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendList);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeBlendPerBone);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeCrossfader);
DECLARE_NATIVE_TYPE(Engine,UAnimNodeSequence);
DECLARE_NATIVE_TYPE(Engine,UAudioComponent);
DECLARE_NATIVE_TYPE(Engine,AAutoLadder);
DECLARE_NATIVE_TYPE(Engine,ABlockingVolume);
DECLARE_NATIVE_TYPE(Engine,UBookMark);
DECLARE_NATIVE_TYPE(Engine,ABrush);
DECLARE_NATIVE_TYPE(Engine,ACamera);
DECLARE_NATIVE_TYPE(Engine,ACameraActor);
DECLARE_NATIVE_TYPE(Engine,UCanvas);
DECLARE_NATIVE_TYPE(Engine,ACarriedObject);
DECLARE_NATIVE_TYPE(Engine,UCheatManager);
DECLARE_NATIVE_TYPE(Engine,AClipMarker);
DECLARE_NATIVE_TYPE(Engine,UCodecMovie);
DECLARE_NATIVE_TYPE(Engine,UCodecMovieFallback);
DECLARE_NATIVE_TYPE(Engine,UConsole);
DECLARE_NATIVE_TYPE(Engine,AController);
DECLARE_NATIVE_TYPE(Engine,ACoverNode);
DECLARE_NATIVE_TYPE(Engine,UCylinderComponent);
DECLARE_NATIVE_TYPE(Engine,UDamageType);
DECLARE_NATIVE_TYPE(Engine,UDebugManager);
DECLARE_NATIVE_TYPE(Engine,ADefaultPhysicsVolume);
DECLARE_NATIVE_TYPE(Engine,UDirectionalLightComponent);
DECLARE_NATIVE_TYPE(Engine,UDistributionFloatConstant);
DECLARE_NATIVE_TYPE(Engine,UDistributionFloatConstantCurve);
DECLARE_NATIVE_TYPE(Engine,UDistributionFloatUniform);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorConstant);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorConstantCurve);
DECLARE_NATIVE_TYPE(Engine,UDistributionVectorUniform);
DECLARE_NATIVE_TYPE(Engine,UDmgType_Suicided);
DECLARE_NATIVE_TYPE(Engine,ADroppedPickup);
DECLARE_NATIVE_TYPE(Engine,UEdCoordSystem);
DECLARE_NATIVE_TYPE(Engine,UEdLayer);
DECLARE_NATIVE_TYPE(Engine,AEmitter);
DECLARE_NATIVE_TYPE(Engine,AFileLog);
DECLARE_NATIVE_TYPE(Engine,UForceFeedbackManager);
DECLARE_NATIVE_TYPE(Engine,AGameInfo);
DECLARE_NATIVE_TYPE(Engine,AGameReplicationInfo);
DECLARE_NATIVE_TYPE(Engine,AGameStats);
DECLARE_NATIVE_TYPE(Engine,UHeightFogComponent);
DECLARE_NATIVE_TYPE(Engine,AHUD);
DECLARE_NATIVE_TYPE(Engine,AInfo);
DECLARE_NATIVE_TYPE(Engine,AInternetInfo);
DECLARE_NATIVE_TYPE(Engine,AInterpActor);
DECLARE_NATIVE_TYPE(Engine,UInterpCurveEdSetup);
DECLARE_NATIVE_TYPE(Engine,AInventory);
DECLARE_NATIVE_TYPE(Engine,AInventoryManager);
DECLARE_NATIVE_TYPE(Engine,AJumpPad);
DECLARE_NATIVE_TYPE(Engine,AKeypoint);
DECLARE_NATIVE_TYPE(Engine,UKillZDamageType);
DECLARE_NATIVE_TYPE(Engine,ALadder);
DECLARE_NATIVE_TYPE(Engine,ALadderVolume);
DECLARE_NATIVE_TYPE(Engine,ALevelInfo);
DECLARE_NATIVE_TYPE(Engine,ULevelSummary);
DECLARE_NATIVE_TYPE(Engine,ALight);
DECLARE_NATIVE_TYPE(Engine,ULightFunction);
DECLARE_NATIVE_TYPE(Engine,UMaterial);
DECLARE_NATIVE_TYPE(Engine,UMaterialExpression);
DECLARE_NATIVE_TYPE(Engine,UMaterialInstance);
DECLARE_NATIVE_TYPE(Engine,UMaterialInstanceConstant);
DECLARE_NATIVE_TYPE(Engine,UMeshComponent);
DECLARE_NATIVE_TYPE(Engine,UMeshComponentFactory);
DECLARE_NATIVE_TYPE(Engine,AMutator);
DECLARE_NATIVE_TYPE(Engine,ANavigationPoint);
DECLARE_NATIVE_TYPE(Engine,ANote);
DECLARE_NATIVE_TYPE(Engine,AObjective);
DECLARE_NATIVE_TYPE(Engine,UParticleSystemComponent);
DECLARE_NATIVE_TYPE(Engine,APathNode);
DECLARE_NATIVE_TYPE(Engine,APawn);
DECLARE_NATIVE_TYPE(Engine,APhysicsVolume);
DECLARE_NATIVE_TYPE(Engine,APickupFactory);
DECLARE_NATIVE_TYPE(Engine,APlayerController);
DECLARE_NATIVE_TYPE(Engine,UPlayerInput);
DECLARE_NATIVE_TYPE(Engine,APlayerReplicationInfo);
DECLARE_NATIVE_TYPE(Engine,APlayerStart);
DECLARE_NATIVE_TYPE(Engine,UPointLightComponent);
DECLARE_NATIVE_TYPE(Engine,APolyMarker);
DECLARE_NATIVE_TYPE(Engine,APotentialClimbWatcher);
DECLARE_NATIVE_TYPE(Engine,UPrimitiveComponent);
DECLARE_NATIVE_TYPE(Engine,UPrimitiveComponentFactory);
DECLARE_NATIVE_TYPE(Engine,AProjectile);
DECLARE_NATIVE_TYPE(Engine,ARB_ConstraintActor);
DECLARE_NATIVE_TYPE(Engine,URB_Handle);
DECLARE_NATIVE_TYPE(Engine,ARB_LineImpulseActor);
DECLARE_NATIVE_TYPE(Engine,URB_RadialImpulseComponent);
DECLARE_NATIVE_TYPE(Engine,URB_Spring);
DECLARE_NATIVE_TYPE(Engine,UReachSpec);
DECLARE_NATIVE_TYPE(Engine,AReplicationInfo);
DECLARE_NATIVE_TYPE(Engine,ARoute);
DECLARE_NATIVE_TYPE(Engine,ASavedMove);
DECLARE_NATIVE_TYPE(Engine,AScout);
DECLARE_NATIVE_TYPE(Engine,USeqAct_Latent);
DECLARE_NATIVE_TYPE(Engine,USequence);
DECLARE_NATIVE_TYPE(Engine,USequenceEvent);
DECLARE_NATIVE_TYPE(Engine,USequenceObject);
DECLARE_NATIVE_TYPE(Engine,USequenceOp);
DECLARE_NATIVE_TYPE(Engine,ASkeletalMeshActor);
DECLARE_NATIVE_TYPE(Engine,USkeletalMeshComponent);
DECLARE_NATIVE_TYPE(Engine,USkyLightComponent);
DECLARE_NATIVE_TYPE(Engine,USoundNode);
DECLARE_NATIVE_TYPE(Engine,USpotLightComponent);
DECLARE_NATIVE_TYPE(Engine,AStaticMeshActor);
DECLARE_NATIVE_TYPE(Engine,UStaticMeshComponentFactory);
DECLARE_NATIVE_TYPE(Engine,ATeamInfo);
DECLARE_NATIVE_TYPE(Engine,ATeleporter);
DECLARE_NATIVE_TYPE(Engine,UTextureMovie);
DECLARE_NATIVE_TYPE(Engine,UTransformComponent);
DECLARE_NATIVE_TYPE(Engine,ATrigger);
DECLARE_NATIVE_TYPE(Engine,AVehicle);
DECLARE_NATIVE_TYPE(Engine,AVolume);
DECLARE_NATIVE_TYPE(Engine,AWeapon);
DECLARE_NATIVE_TYPE(Engine,UWindDirectionalSourceComponent);
DECLARE_NATIVE_TYPE(Engine,UWindPointSourceComponent);
DECLARE_NATIVE_TYPE(Engine,AZoneInfo);

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE \
	AActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAActorNative; \
	UActorChannel::StaticClass(); \
	UActorComponent::StaticClass(); \
	UActorFactory::StaticClass(); \
	UActorFactoryAI::StaticClass(); \
	UActorFactoryEmitter::StaticClass(); \
	UActorFactoryLight::StaticClass(); \
	UActorFactoryMover::StaticClass(); \
	UActorFactoryPhysicsAsset::StaticClass(); \
	UActorFactoryPlayerStart::StaticClass(); \
	UActorFactoryRigidBody::StaticClass(); \
	UActorFactoryRoute::StaticClass(); \
	UActorFactorySkeletalMesh::StaticClass(); \
	UActorFactoryStaticMesh::StaticClass(); \
	UActorFactoryVehicle::StaticClass(); \
	AAIController::StaticClass(); \
	UAnimNode::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeNative; \
	UAnimNodeBlend::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeBlendNative; \
	UAnimNodeBlendBase::StaticClass(); \
	UAnimNodeBlendByPosture::StaticClass(); \
	UAnimNodeBlendBySpeed::StaticClass(); \
	UAnimNodeBlendDirectional::StaticClass(); \
	UAnimNodeBlendList::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeBlendListNative; \
	UAnimNodeBlendPerBone::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeBlendPerBoneNative; \
	UAnimNodeCrossfader::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeCrossfaderNative; \
	UAnimNodeSequence::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAnimNodeSequenceNative; \
	UAnimNotify::StaticClass(); \
	UAnimNotify_DestroyEffect::StaticClass(); \
	UAnimNotify_Effect::StaticClass(); \
	UAnimNotify_Footstep::StaticClass(); \
	UAnimNotify_Script::StaticClass(); \
	UAnimNotify_Scripted::StaticClass(); \
	UAnimNotify_Sound::StaticClass(); \
	UAnimSequence::StaticClass(); \
	UAnimSet::StaticClass(); \
	UAnimTree::StaticClass(); \
	UArrowComponent::StaticClass(); \
	UAudioComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUAudioComponentNative; \
	UAudioDevice::StaticClass(); \
	AAutoLadder::StaticClass(); \
	ABlockingVolume::StaticClass(); \
	UBookMark::StaticClass(); \
	ABrush::StaticClass(); \
	UBrushComponent::StaticClass(); \
	ACamera::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineACameraNative; \
	ACameraActor::StaticClass(); \
	UCameraConeComponent::StaticClass(); \
	UCanvas::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUCanvasNative; \
	ACar::StaticClass(); \
	ACarriedObject::StaticClass(); \
	UChannel::StaticClass(); \
	UChannelDownload::StaticClass(); \
	UCheatManager::StaticClass(); \
	UClient::StaticClass(); \
	AClipMarker::StaticClass(); \
	UCodecMovie::StaticClass(); \
	UCodecMovieFallback::StaticClass(); \
	UCodecMovieTheora::StaticClass(); \
	UConsole::StaticClass(); \
	UControlChannel::StaticClass(); \
	AController::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAControllerNative; \
	ACoverNode::StaticClass(); \
	UCylinderComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUCylinderComponentNative; \
	UDamageType::StaticClass(); \
	UDebugManager::StaticClass(); \
	ADefaultPhysicsVolume::StaticClass(); \
	UDirectionalLightComponent::StaticClass(); \
	UDistributionFloat::StaticClass(); \
	UDistributionFloatConstant::StaticClass(); \
	UDistributionFloatConstantCurve::StaticClass(); \
	UDistributionFloatUniform::StaticClass(); \
	UDistributionVector::StaticClass(); \
	UDistributionVectorConstant::StaticClass(); \
	UDistributionVectorConstantCurve::StaticClass(); \
	UDistributionVectorUniform::StaticClass(); \
	UDmgType_Suicided::StaticClass(); \
	UDownload::StaticClass(); \
	UDrawFrustumComponent::StaticClass(); \
	UDrawSphereComponent::StaticClass(); \
	ADroppedPickup::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineADroppedPickupNative; \
	UEdCoordSystem::StaticClass(); \
	UEdLayer::StaticClass(); \
	AEmitter::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAEmitterNative; \
	UEngine::StaticClass(); \
	UFileChannel::StaticClass(); \
	AFileLog::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAFileLogNative; \
	UFont::StaticClass(); \
	UForceFeedbackManager::StaticClass(); \
	UForceFeedbackWaveform::StaticClass(); \
	UGameEngine::StaticClass(); \
	AGameInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAGameInfoNative; \
	AGameReplicationInfo::StaticClass(); \
	AGameStats::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAGameStatsNative; \
	UHeightFogComponent::StaticClass(); \
	AHUD::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAHUDNative; \
	AInfo::StaticClass(); \
	UInput::StaticClass(); \
	UInteraction::StaticClass(); \
	AInternetInfo::StaticClass(); \
	AInterpActor::StaticClass(); \
	UInterpCurveEdSetup::StaticClass(); \
	UInterpData::StaticClass(); \
	UInterpGroup::StaticClass(); \
	UInterpGroupDirector::StaticClass(); \
	UInterpGroupInst::StaticClass(); \
	UInterpGroupInstDirector::StaticClass(); \
	UInterpTrack::StaticClass(); \
	UInterpTrackDirector::StaticClass(); \
	UInterpTrackEvent::StaticClass(); \
	UInterpTrackFade::StaticClass(); \
	UInterpTrackFloatBase::StaticClass(); \
	UInterpTrackFloatProp::StaticClass(); \
	UInterpTrackInst::StaticClass(); \
	UInterpTrackInstDirector::StaticClass(); \
	UInterpTrackInstEvent::StaticClass(); \
	UInterpTrackInstFade::StaticClass(); \
	UInterpTrackInstFloatProp::StaticClass(); \
	UInterpTrackInstMove::StaticClass(); \
	UInterpTrackInstSlomo::StaticClass(); \
	UInterpTrackMove::StaticClass(); \
	UInterpTrackSlomo::StaticClass(); \
	AInventory::StaticClass(); \
	AInventoryManager::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAInventoryManagerNative; \
	AJumpPad::StaticClass(); \
	AKActor::StaticClass(); \
	AKAsset::StaticClass(); \
	AKeypoint::StaticClass(); \
	UKillZDamageType::StaticClass(); \
	UKMeshProps::StaticClass(); \
	ALadder::StaticClass(); \
	ALadderVolume::StaticClass(); \
	ULevel::StaticClass(); \
	ULevelBase::StaticClass(); \
	ALevelInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineALevelInfoNative; \
	ULevelSummary::StaticClass(); \
	ALight::StaticClass(); \
	ULightComponent::StaticClass(); \
	ULightFunction::StaticClass(); \
	ULineBatchComponent::StaticClass(); \
	ULocalPlayer::StaticClass(); \
	UMaterial::StaticClass(); \
	UMaterialExpression::StaticClass(); \
	UMaterialExpressionAdd::StaticClass(); \
	UMaterialExpressionAppendVector::StaticClass(); \
	UMaterialExpressionBumpOffset::StaticClass(); \
	UMaterialExpressionCameraVector::StaticClass(); \
	UMaterialExpressionCeil::StaticClass(); \
	UMaterialExpressionClamp::StaticClass(); \
	UMaterialExpressionComponentMask::StaticClass(); \
	UMaterialExpressionConstant::StaticClass(); \
	UMaterialExpressionConstant2Vector::StaticClass(); \
	UMaterialExpressionConstant3Vector::StaticClass(); \
	UMaterialExpressionConstant4Vector::StaticClass(); \
	UMaterialExpressionCosine::StaticClass(); \
	UMaterialExpressionCrossProduct::StaticClass(); \
	UMaterialExpressionDesaturation::StaticClass(); \
	UMaterialExpressionDivide::StaticClass(); \
	UMaterialExpressionDotProduct::StaticClass(); \
	UMaterialExpressionFloor::StaticClass(); \
	UMaterialExpressionFrac::StaticClass(); \
	UMaterialExpressionLinearInterpolate::StaticClass(); \
	UMaterialExpressionMultiply::StaticClass(); \
	UMaterialExpressionNormalize::StaticClass(); \
	UMaterialExpressionPanner::StaticClass(); \
	UMaterialExpressionParticleSubUV::StaticClass(); \
	UMaterialExpressionReflectionVector::StaticClass(); \
	UMaterialExpressionRotator::StaticClass(); \
	UMaterialExpressionScalarParameter::StaticClass(); \
	UMaterialExpressionSine::StaticClass(); \
	UMaterialExpressionSubtract::StaticClass(); \
	UMaterialExpressionTextureCoordinate::StaticClass(); \
	UMaterialExpressionTextureSample::StaticClass(); \
	UMaterialExpressionTime::StaticClass(); \
	UMaterialExpressionVectorParameter::StaticClass(); \
	UMaterialExpressionVertexColor::StaticClass(); \
	UMaterialInstance::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMaterialInstanceNative; \
	UMaterialInstanceConstant::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMaterialInstanceConstantNative; \
	UMeshComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUMeshComponentNative; \
	UMeshComponentFactory::StaticClass(); \
	UModel::StaticClass(); \
	UModelComponent::StaticClass(); \
	AMutator::StaticClass(); \
	ANavigationPoint::StaticClass(); \
	UNetConnection::StaticClass(); \
	UNetDriver::StaticClass(); \
	UNetPendingLevel::StaticClass(); \
	ANote::StaticClass(); \
	AObjective::StaticClass(); \
	UPackageMapLevel::StaticClass(); \
	UParticleEmitter::StaticClass(); \
	UParticleMeshEmitter::StaticClass(); \
	UParticleModule::StaticClass(); \
	UParticleModuleAcceleration::StaticClass(); \
	UParticleModuleAccelerationBase::StaticClass(); \
	UParticleModuleAccelerationOverLifetime::StaticClass(); \
	UParticleModuleAttractorBase::StaticClass(); \
	UParticleModuleAttractorLine::StaticClass(); \
	UParticleModuleAttractorPoint::StaticClass(); \
	UParticleModuleCollision::StaticClass(); \
	UParticleModuleCollisionBase::StaticClass(); \
	UParticleModuleColor::StaticClass(); \
	UParticleModuleColorBase::StaticClass(); \
	UParticleModuleColorByParameter::StaticClass(); \
	UParticleModuleColorOverLife::StaticClass(); \
	UParticleModuleLifetime::StaticClass(); \
	UParticleModuleLifetimeBase::StaticClass(); \
	UParticleModuleLocation::StaticClass(); \
	UParticleModuleLocationBase::StaticClass(); \
	UParticleModuleMeshRotation::StaticClass(); \
	UParticleModuleMeshRotationRate::StaticClass(); \
	UParticleModuleRotation::StaticClass(); \
	UParticleModuleRotationBase::StaticClass(); \
	UParticleModuleRotationOverLifetime::StaticClass(); \
	UParticleModuleRotationRate::StaticClass(); \
	UParticleModuleRotationRateBase::StaticClass(); \
	UParticleModuleRotationRateMultiplyLife::StaticClass(); \
	UParticleModuleSize::StaticClass(); \
	UParticleModuleSizeBase::StaticClass(); \
	UParticleModuleSizeMultiplyLife::StaticClass(); \
	UParticleModuleSizeMultiplyVelocity::StaticClass(); \
	UParticleModuleSizeScale::StaticClass(); \
	UParticleModuleSubUV::StaticClass(); \
	UParticleModuleSubUVBase::StaticClass(); \
	UParticleModuleTypeDataBase::StaticClass(); \
	UParticleModuleTypeDataMesh::StaticClass(); \
	UParticleModuleTypeDataSubUV::StaticClass(); \
	UParticleModuleTypeDataTrail::StaticClass(); \
	UParticleModuleVelocity::StaticClass(); \
	UParticleModuleVelocityBase::StaticClass(); \
	UParticleModuleVelocityInheritParent::StaticClass(); \
	UParticleModuleVelocityOverLifetime::StaticClass(); \
	UParticleSpriteEmitter::StaticClass(); \
	UParticleSpriteSubUVEmitter::StaticClass(); \
	UParticleSystem::StaticClass(); \
	UParticleSystemComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUParticleSystemComponentNative; \
	APathNode::StaticClass(); \
	UPathRenderingComponent::StaticClass(); \
	APawn::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPawnNative; \
	UPendingLevel::StaticClass(); \
	UPhysicalMaterial::StaticClass(); \
	UPhysicsAsset::StaticClass(); \
	UPhysicsAssetInstance::StaticClass(); \
	APhysicsVolume::StaticClass(); \
	APickupFactory::StaticClass(); \
	UPlayer::StaticClass(); \
	APlayerController::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAPlayerControllerNative; \
	UPlayerInput::StaticClass(); \
	APlayerReplicationInfo::StaticClass(); \
	APlayerStart::StaticClass(); \
	UPointLightComponent::StaticClass(); \
	APolyMarker::StaticClass(); \
	UPolys::StaticClass(); \
	APotentialClimbWatcher::StaticClass(); \
	UPrimitiveComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUPrimitiveComponentNative; \
	UPrimitiveComponentFactory::StaticClass(); \
	AProjectile::StaticClass(); \
	URB_BodyInstance::StaticClass(); \
	URB_BodySetup::StaticClass(); \
	URB_BSJointSetup::StaticClass(); \
	ARB_ConstraintActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineARB_ConstraintActorNative; \
	URB_ConstraintDrawComponent::StaticClass(); \
	URB_ConstraintInstance::StaticClass(); \
	URB_ConstraintSetup::StaticClass(); \
	URB_Handle::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_HandleNative; \
	URB_HingeSetup::StaticClass(); \
	ARB_LineImpulseActor::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineARB_LineImpulseActorNative; \
	URB_PrismaticSetup::StaticClass(); \
	URB_RadialImpulseComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_RadialImpulseComponentNative; \
	URB_SkelJointSetup::StaticClass(); \
	URB_Spring::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineURB_SpringNative; \
	ARB_Thruster::StaticClass(); \
	UReachSpec::StaticClass(); \
	AReplicationInfo::StaticClass(); \
	ARoute::StaticClass(); \
	ASavedMove::StaticClass(); \
	AScout::StaticClass(); \
	USeqAct_ActorFactory::StaticClass(); \
	USeqAct_AIMoveToActor::StaticClass(); \
	USeqAct_AttachToEvent::StaticClass(); \
	USeqAct_CauseDamage::StaticClass(); \
	USeqAct_Delay::StaticClass(); \
	USeqAct_DelaySwitch::StaticClass(); \
	USeqAct_FinishSequence::StaticClass(); \
	USeqAct_GetDistance::StaticClass(); \
	USeqAct_GetVelocity::StaticClass(); \
	USeqAct_Interp::StaticClass(); \
	USeqAct_Latent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSeqAct_LatentNative; \
	USeqAct_Log::StaticClass(); \
	USeqAct_ModifyProperty::StaticClass(); \
	USeqAct_PlaySound::StaticClass(); \
	USeqAct_Possess::StaticClass(); \
	USeqAct_RandomSwitch::StaticClass(); \
	USeqAct_RangeSwitch::StaticClass(); \
	USeqAct_SetBlockRigidBody::StaticClass(); \
	USeqAct_SetBool::StaticClass(); \
	USeqAct_SetCameraTarget::StaticClass(); \
	USeqAct_SetFloat::StaticClass(); \
	USeqAct_SetInt::StaticClass(); \
	USeqAct_SetObject::StaticClass(); \
	USeqAct_SetPhysics::StaticClass(); \
	USeqAct_Switch::StaticClass(); \
	USeqAct_Toggle::StaticClass(); \
	USeqCond_CompareBool::StaticClass(); \
	USeqCond_CompareFloat::StaticClass(); \
	USeqCond_CompareInt::StaticClass(); \
	USeqCond_Increment::StaticClass(); \
	USeqEvent_AISeeEnemy::StaticClass(); \
	USeqEvent_ConstraintBroken::StaticClass(); \
	USeqEvent_Destroyed::StaticClass(); \
	USeqEvent_LevelStartup::StaticClass(); \
	USeqEvent_SequenceActivated::StaticClass(); \
	USeqEvent_Touch::StaticClass(); \
	USeqEvent_UnTouch::StaticClass(); \
	USeqEvent_Used::StaticClass(); \
	USequence::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceNative; \
	USequenceAction::StaticClass(); \
	USequenceCondition::StaticClass(); \
	USequenceEvent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceEventNative; \
	USequenceFrame::StaticClass(); \
	USequenceObject::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceObjectNative; \
	USequenceOp::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSequenceOpNative; \
	USequenceVariable::StaticClass(); \
	USeqVar_Bool::StaticClass(); \
	USeqVar_External::StaticClass(); \
	USeqVar_Float::StaticClass(); \
	USeqVar_Int::StaticClass(); \
	USeqVar_Named::StaticClass(); \
	USeqVar_Object::StaticClass(); \
	USeqVar_Player::StaticClass(); \
	USeqVar_RandomFloat::StaticClass(); \
	USeqVar_RandomInt::StaticClass(); \
	USeqVar_String::StaticClass(); \
	UServerCommandlet::StaticClass(); \
	UShadowMap::StaticClass(); \
	USkeletalMesh::StaticClass(); \
	ASkeletalMeshActor::StaticClass(); \
	USkeletalMeshComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUSkeletalMeshComponentNative; \
	USkyLightComponent::StaticClass(); \
	USoundCue::StaticClass(); \
	USoundNode::StaticClass(); \
	USoundNodeAttenuation::StaticClass(); \
	USoundNodeLooping::StaticClass(); \
	USoundNodeMixer::StaticClass(); \
	USoundNodeModulator::StaticClass(); \
	USoundNodeOscillator::StaticClass(); \
	USoundNodeRandom::StaticClass(); \
	USoundNodeWave::StaticClass(); \
	USphericalHarmonicMap::StaticClass(); \
	USpotLightComponent::StaticClass(); \
	USpriteComponent::StaticClass(); \
	UStaticMesh::StaticClass(); \
	AStaticMeshActor::StaticClass(); \
	UStaticMeshComponent::StaticClass(); \
	UStaticMeshComponentFactory::StaticClass(); \
	ASVehicle::StaticClass(); \
	USVehicleWheel::StaticClass(); \
	ATeamInfo::StaticClass(); \
	ATeleporter::StaticClass(); \
	ATerrain::StaticClass(); \
	UTerrainComponent::StaticClass(); \
	UTerrainLayerSetup::StaticClass(); \
	UTerrainMaterial::StaticClass(); \
	UTexture::StaticClass(); \
	UTexture2D::StaticClass(); \
	UTexture3D::StaticClass(); \
	UTextureCube::StaticClass(); \
	UTextureMovie::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUTextureMovieNative; \
	UTransformComponent::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineUTransformComponentNative; \
	ATrigger::StaticClass(); \
	AVehicle::StaticClass(); \
	AVolume::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAVolumeNative; \
	AWeapon::StaticClass(); \
	UWindDirectionalSourceComponent::StaticClass(); \
	UWindPointSourceComponent::StaticClass(); \
	AZoneInfo::StaticClass(); \
	GNativeLookupFuncs[Lookup++] = &FindEngineAZoneInfoNative; \

#endif // ENGINE_NATIVE_DEFS

#ifdef NATIVES_ONLY
NATIVE_INFO(AActor) GEngineAActorNatives[] = 
{ 
	MAP_NATIVE(AActor,execActivateEvent)
	MAP_NATIVE(AActor,execMultiply_ColorFloat)
	MAP_NATIVE(AActor,execAdd_ColorColor)
	MAP_NATIVE(AActor,execMultiply_FloatColor)
	MAP_NATIVE(AActor,execSubtract_ColorColor)
	MAP_NATIVE(AActor,execLocalPlayerControllers)
	MAP_NATIVE(AActor,execOverlappingActors)
	MAP_NATIVE(AActor,execCollidingActors)
	MAP_NATIVE(AActor,execVisibleCollidingActors)
	MAP_NATIVE(AActor,execVisibleActors)
	MAP_NATIVE(AActor,execTraceActors)
	MAP_NATIVE(AActor,execTouchingActors)
	MAP_NATIVE(AActor,execBasedActors)
	MAP_NATIVE(AActor,execChildActors)
	MAP_NATIVE(AActor,execDynamicActors)
	MAP_NATIVE(AActor,execAllActors)
	MAP_NATIVE(AActor,execMoveCacheEntry)
	MAP_NATIVE(AActor,execGetCacheEntry)
	MAP_NATIVE(AActor,execGetURLMap)
	MAP_NATIVE(AActor,execSuggestFallVelocity)
	MAP_NATIVE(AActor,execPlayerCanSeeMe)
	MAP_NATIVE(AActor,execMakeNoise)
	MAP_NATIVE(AActor,execCreateAudioComponent)
	MAP_NATIVE(AActor,execGetTimerCount)
	MAP_NATIVE(AActor,execIsTimerActive)
	MAP_NATIVE(AActor,execClearTimer)
	MAP_NATIVE(AActor,execSetTimer)
	MAP_NATIVE(AActor,execDestroy)
	MAP_NATIVE(AActor,execSpawn)
	MAP_NATIVE(AActor,execGetBoundingCylinder)
	MAP_NATIVE(AActor,execGetComponentsBoundingBox)
	MAP_NATIVE(AActor,execTouchingActor)
	MAP_NATIVE(AActor,execContainsPoint)
	MAP_NATIVE(AActor,execFastTrace)
	MAP_NATIVE(AActor,execTraceComponent)
	MAP_NATIVE(AActor,execTrace)
	MAP_NATIVE(AActor,execClampRotation)
	MAP_NATIVE(AActor,execAddComponent)
	MAP_NATIVE(AActor,execUnClock)
	MAP_NATIVE(AActor,execClock)
	MAP_NATIVE(AActor,execSetPhysics)
	MAP_NATIVE(AActor,execDebugUnclock)
	MAP_NATIVE(AActor,execDebugClock)
	MAP_NATIVE(AActor,execChartData)
	MAP_NATIVE(AActor,execFlushPersistentDebugLines)
	MAP_NATIVE(AActor,execDrawPersistentDebugLine)
	MAP_NATIVE(AActor,execDrawDebugLine)
	MAP_NATIVE(AActor,execSetOwner)
	MAP_NATIVE(AActor,execSetBase)
	MAP_NATIVE(AActor,execAutonomousPhysics)
	MAP_NATIVE(AActor,execMoveSmooth)
	MAP_NATIVE(AActor,execSetRelativeLocation)
	MAP_NATIVE(AActor,execSetRelativeRotation)
	MAP_NATIVE(AActor,execSetRotation)
	MAP_NATIVE(AActor,execSetLocation)
	MAP_NATIVE(AActor,execMove)
	MAP_NATIVE(AActor,execOnlyAffectPawns)
	MAP_NATIVE(AActor,execSetPrePivot)
	MAP_NATIVE(AActor,execSetDrawScale3D)
	MAP_NATIVE(AActor,execSetDrawScale)
	MAP_NATIVE(AActor,execSetCollisionSize)
	MAP_NATIVE(AActor,execSetCollision)
	MAP_NATIVE(AActor,execFinishAnim)
	MAP_NATIVE(AActor,execSleep)
	MAP_NATIVE(AActor,execError)
	MAP_NATIVE(AActor,execConsoleCommand)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AActor);

NATIVE_INFO(UAnimNode) GEngineUAnimNodeNatives[] = 
{ 
	MAP_NATIVE(UAnimNode,execFindAnimNode)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNode);

NATIVE_INFO(UAnimNodeBlend) GEngineUAnimNodeBlendNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlend,execSetBlendTarget)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeBlend);

NATIVE_INFO(UAnimNodeBlendList) GEngineUAnimNodeBlendListNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlendList,execSetActiveChild)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeBlendList);

NATIVE_INFO(UAnimNodeBlendPerBone) GEngineUAnimNodeBlendPerBoneNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlendPerBone,execSetChild2StartBone)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeBlendPerBone);

NATIVE_INFO(UAnimNodeCrossfader) GEngineUAnimNodeCrossfaderNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeCrossfader,execGetActiveChild)
	MAP_NATIVE(UAnimNodeCrossfader,execGetActiveAnimSeq)
	MAP_NATIVE(UAnimNodeCrossfader,execBlendToLoopingAnim)
	MAP_NATIVE(UAnimNodeCrossfader,execPlayOneShotAnim)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeCrossfader);

NATIVE_INFO(UAnimNodeSequence) GEngineUAnimNodeSequenceNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeSequence,execGetAnimLength)
	MAP_NATIVE(UAnimNodeSequence,execSetPosition)
	MAP_NATIVE(UAnimNodeSequence,execStopAnim)
	MAP_NATIVE(UAnimNodeSequence,execPlayAnim)
	MAP_NATIVE(UAnimNodeSequence,execSetAnim)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAnimNodeSequence);

NATIVE_INFO(UAudioComponent) GEngineUAudioComponentNatives[] = 
{ 
	MAP_NATIVE(UAudioComponent,execStop)
	MAP_NATIVE(UAudioComponent,execPause)
	MAP_NATIVE(UAudioComponent,execPlay)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UAudioComponent);

NATIVE_INFO(ACamera) GEngineACameraNatives[] = 
{ 
	MAP_NATIVE(ACamera,execSetViewTarget)
	MAP_NATIVE(ACamera,execFillCameraCache)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ACamera);

NATIVE_INFO(UCanvas) GEngineUCanvasNatives[] = 
{ 
	MAP_NATIVE(UCanvas,execDeProject)
	MAP_NATIVE(UCanvas,execProject)
	MAP_NATIVE(UCanvas,execDrawTextJustified)
	MAP_NATIVE(UCanvas,execDrawTileScaled)
	MAP_NATIVE(UCanvas,execDrawTileJustified)
	MAP_NATIVE(UCanvas,execDrawTileStretched)
	MAP_NATIVE(UCanvas,execDrawMaterialTile)
	MAP_NATIVE(UCanvas,execWrapStringToArray)
	MAP_NATIVE(UCanvas,execTextSize)
	MAP_NATIVE(UCanvas,execDrawTextClipped)
	MAP_NATIVE(UCanvas,execDrawTileClipped)
	MAP_NATIVE(UCanvas,execDrawTile)
	MAP_NATIVE(UCanvas,execDrawText)
	MAP_NATIVE(UCanvas,execStrLen)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UCanvas);

NATIVE_INFO(AController) GEngineAControllerNatives[] = 
{ 
	MAP_NATIVE(AController,execStopLatentExecution)
	MAP_NATIVE(AController,execInLatentExecution)
	MAP_NATIVE(AController,execEndClimbLadder)
	MAP_NATIVE(AController,execWaitForLanding)
	MAP_NATIVE(AController,execPickWallAdjust)
	MAP_NATIVE(AController,execActorReachable)
	MAP_NATIVE(AController,execPointReachable)
	MAP_NATIVE(AController,execFindPathToIntercept)
	MAP_NATIVE(AController,execFindRandomDest)
	MAP_NATIVE(AController,execFindPathTowardNearest)
	MAP_NATIVE(AController,execFindPathToward)
	MAP_NATIVE(AController,execFindPathTo)
	MAP_NATIVE(AController,execFinishRotation)
	MAP_NATIVE(AController,execMoveToward)
	MAP_NATIVE(AController,execMoveTo)
	MAP_NATIVE(AController,execPickAnyTarget)
	MAP_NATIVE(AController,execPickTarget)
	MAP_NATIVE(AController,execCanSee)
	MAP_NATIVE(AController,execLineOfSightTo)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AController);

NATIVE_INFO(UCylinderComponent) GEngineUCylinderComponentNatives[] = 
{ 
	MAP_NATIVE(UCylinderComponent,execSetSize)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UCylinderComponent);

NATIVE_INFO(ADroppedPickup) GEngineADroppedPickupNatives[] = 
{ 
	MAP_NATIVE(ADroppedPickup,execRemoveFromNavigation)
	MAP_NATIVE(ADroppedPickup,execAddToNavigation)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ADroppedPickup);

NATIVE_INFO(AEmitter) GEngineAEmitterNatives[] = 
{ 
	MAP_NATIVE(AEmitter,execSetTemplate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AEmitter);

NATIVE_INFO(AFileLog) GEngineAFileLogNatives[] = 
{ 
	MAP_NATIVE(AFileLog,execLogf)
	MAP_NATIVE(AFileLog,execCloseLog)
	MAP_NATIVE(AFileLog,execOpenLog)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AFileLog);

NATIVE_INFO(AGameInfo) GEngineAGameInfoNatives[] = 
{ 
	MAP_NATIVE(AGameInfo,execParseKillMessage)
	MAP_NATIVE(AGameInfo,execGetNetworkNumber)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AGameInfo);

NATIVE_INFO(AGameStats) GEngineAGameStatsNatives[] = 
{ 
	MAP_NATIVE(AGameStats,execGetMapFileName)
	MAP_NATIVE(AGameStats,execGetStatsIdentifier)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AGameStats);

NATIVE_INFO(AHUD) GEngineAHUDNatives[] = 
{ 
	MAP_NATIVE(AHUD,execDraw3DLine)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AHUD);

NATIVE_INFO(AInventoryManager) GEngineAInventoryManagerNatives[] = 
{ 
	MAP_NATIVE(AInventoryManager,execInventoryActors)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AInventoryManager);

NATIVE_INFO(ALevelInfo) GEngineALevelInfoNatives[] = 
{ 
	MAP_NATIVE(ALevelInfo,execSetLevelRBGravity)
	MAP_NATIVE(ALevelInfo,execGetLevelSequence)
	MAP_NATIVE(ALevelInfo,execGetAddressURL)
	MAP_NATIVE(ALevelInfo,execIsConsoleBuild)
	MAP_NATIVE(ALevelInfo,execIsDemoBuild)
	MAP_NATIVE(ALevelInfo,execGetLocalURL)
	MAP_NATIVE(ALevelInfo,execIsEntry)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ALevelInfo);

NATIVE_INFO(UMaterialInstance) GEngineUMaterialInstanceNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstance,execGetMaterial)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMaterialInstance);

NATIVE_INFO(UMaterialInstanceConstant) GEngineUMaterialInstanceConstantNatives[] = 
{ 
	MAP_NATIVE(UMaterialInstanceConstant,execSetScalarParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant,execSetVectorParameterValue)
	MAP_NATIVE(UMaterialInstanceConstant,execSetParent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMaterialInstanceConstant);

NATIVE_INFO(UMeshComponent) GEngineUMeshComponentNatives[] = 
{ 
	MAP_NATIVE(UMeshComponent,execSetMaterial)
	MAP_NATIVE(UMeshComponent,execGetMaterial)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UMeshComponent);

NATIVE_INFO(UParticleSystemComponent) GEngineUParticleSystemComponentNatives[] = 
{ 
	MAP_NATIVE(UParticleSystemComponent,execSetActorParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetColorParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetVectorParameter)
	MAP_NATIVE(UParticleSystemComponent,execSetFloatParameter)
	MAP_NATIVE(UParticleSystemComponent,execDeactivateSystem)
	MAP_NATIVE(UParticleSystemComponent,execActivateSystem)
	MAP_NATIVE(UParticleSystemComponent,execSetTemplate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UParticleSystemComponent);

NATIVE_INFO(APawn) GEngineAPawnNatives[] = 
{ 
	MAP_NATIVE(APawn,execInitRagdoll)
	MAP_NATIVE(APawn,execSetPushesRigidBodies)
	MAP_NATIVE(APawn,execForceCrouch)
	MAP_NATIVE(APawn,execReachedDestination)
	MAP_NATIVE(APawn,execSetRemoteViewPitch)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APawn);

NATIVE_INFO(APlayerController) GEngineAPlayerControllerNatives[] = 
{ 
	MAP_NATIVE(APlayerController,execFindStairRotation)
	MAP_NATIVE(APlayerController,execCheckSpeedHack)
	MAP_NATIVE(APlayerController,execServerValidationResponse)
	MAP_NATIVE(APlayerController,execClientValidate)
	MAP_NATIVE(APlayerController,execSetViewTarget)
	MAP_NATIVE(APlayerController,execPasteFromClipboard)
	MAP_NATIVE(APlayerController,execCopyToClipboard)
	MAP_NATIVE(APlayerController,execGetDefaultURL)
	MAP_NATIVE(APlayerController,execUpdateURL)
	MAP_NATIVE(APlayerController,execClientTravel)
	MAP_NATIVE(APlayerController,execGetEntryLevel)
	MAP_NATIVE(APlayerController,execConsoleCommand)
	MAP_NATIVE(APlayerController,execGetServerNetworkAddress)
	MAP_NATIVE(APlayerController,execGetPlayerNetworkAddress)
	MAP_NATIVE(APlayerController,execSetNetSpeed)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,APlayerController);

NATIVE_INFO(UPrimitiveComponent) GEngineUPrimitiveComponentNatives[] = 
{ 
	MAP_NATIVE(UPrimitiveComponent,execSetHidden)
	MAP_NATIVE(UPrimitiveComponent,execSetBlockRigidBody)
	MAP_NATIVE(UPrimitiveComponent,execRigidBodyIsAwake)
	MAP_NATIVE(UPrimitiveComponent,execUpdateWindForces)
	MAP_NATIVE(UPrimitiveComponent,execWakeRigidBody)
	MAP_NATIVE(UPrimitiveComponent,execSetRBPosition)
	MAP_NATIVE(UPrimitiveComponent,execSetRBLinearVelocity)
	MAP_NATIVE(UPrimitiveComponent,execAddForce)
	MAP_NATIVE(UPrimitiveComponent,execAddRadialImpulse)
	MAP_NATIVE(UPrimitiveComponent,execAddImpulse)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UPrimitiveComponent);

NATIVE_INFO(ARB_ConstraintActor) GEngineARB_ConstraintActorNatives[] = 
{ 
	MAP_NATIVE(ARB_ConstraintActor,execSetDisableCollision)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ARB_ConstraintActor);

NATIVE_INFO(URB_Handle) GEngineURB_HandleNatives[] = 
{ 
	MAP_NATIVE(URB_Handle,execSetOrientation)
	MAP_NATIVE(URB_Handle,execSetLocation)
	MAP_NATIVE(URB_Handle,execReleaseComponent)
	MAP_NATIVE(URB_Handle,execGrabComponent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_Handle);

NATIVE_INFO(ARB_LineImpulseActor) GEngineARB_LineImpulseActorNatives[] = 
{ 
	MAP_NATIVE(ARB_LineImpulseActor,execFireLineImpulse)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,ARB_LineImpulseActor);

NATIVE_INFO(URB_RadialImpulseComponent) GEngineURB_RadialImpulseComponentNatives[] = 
{ 
	MAP_NATIVE(URB_RadialImpulseComponent,execFireImpulse)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_RadialImpulseComponent);

NATIVE_INFO(URB_Spring) GEngineURB_SpringNatives[] = 
{ 
	MAP_NATIVE(URB_Spring,execClear)
	MAP_NATIVE(URB_Spring,execSetComponents)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,URB_Spring);

NATIVE_INFO(USeqAct_Latent) GEngineUSeqAct_LatentNatives[] = 
{ 
	MAP_NATIVE(USeqAct_Latent,execAbortFor)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USeqAct_Latent);

NATIVE_INFO(USequence) GEngineUSequenceNatives[] = 
{ 
	MAP_NATIVE(USequence,execFindSeqObjectsByClass)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequence);

NATIVE_INFO(USequenceEvent) GEngineUSequenceEventNatives[] = 
{ 
	MAP_NATIVE(USequenceEvent,execCheckActivate)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequenceEvent);

NATIVE_INFO(USequenceObject) GEngineUSequenceObjectNatives[] = 
{ 
	MAP_NATIVE(USequenceObject,execScriptLog)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequenceObject);

NATIVE_INFO(USequenceOp) GEngineUSequenceOpNatives[] = 
{ 
	MAP_NATIVE(USequenceOp,execGetObjectVars)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USequenceOp);

NATIVE_INFO(USkeletalMeshComponent) GEngineUSkeletalMeshComponentNatives[] = 
{ 
	MAP_NATIVE(USkeletalMeshComponent,execSetAnimTreeTemplate)
	MAP_NATIVE(USkeletalMeshComponent,execGetBoneLocation)
	MAP_NATIVE(USkeletalMeshComponent,execGetBoneQuaternion)
	MAP_NATIVE(USkeletalMeshComponent,execDrawAnimDebug)
	MAP_NATIVE(USkeletalMeshComponent,execClearBoneRotations)
	MAP_NATIVE(USkeletalMeshComponent,execSetBoneRotation)
	MAP_NATIVE(USkeletalMeshComponent,execFindAnimSequence)
	MAP_NATIVE(USkeletalMeshComponent,execSetSkeletalMesh)
	MAP_NATIVE(USkeletalMeshComponent,execDetachComponent)
	MAP_NATIVE(USkeletalMeshComponent,execAttachComponent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,USkeletalMeshComponent);

NATIVE_INFO(UTextureMovie) GEngineUTextureMovieNatives[] = 
{ 
	MAP_NATIVE(UTextureMovie,execStop)
	MAP_NATIVE(UTextureMovie,execPause)
	MAP_NATIVE(UTextureMovie,execPlay)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UTextureMovie);

NATIVE_INFO(UTransformComponent) GEngineUTransformComponentNatives[] = 
{ 
	MAP_NATIVE(UTransformComponent,execSetAbsolute)
	MAP_NATIVE(UTransformComponent,execSetScale3D)
	MAP_NATIVE(UTransformComponent,execSetScale)
	MAP_NATIVE(UTransformComponent,execSetRotation)
	MAP_NATIVE(UTransformComponent,execSetTranslation)
	MAP_NATIVE(UTransformComponent,execSetTransformedComponent)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,UTransformComponent);

NATIVE_INFO(AVolume) GEngineAVolumeNatives[] = 
{ 
	MAP_NATIVE(AVolume,execEncompasses)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AVolume);

NATIVE_INFO(AZoneInfo) GEngineAZoneInfoNatives[] = 
{ 
	MAP_NATIVE(AZoneInfo,execZoneActors)
	{NULL,NULL}
};
IMPLEMENT_NATIVE_HANDLER(Engine,AZoneInfo);

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(AActor)
VERIFY_CLASS_SIZE_NODIE(UActorChannel)
VERIFY_CLASS_OFFSET_NODIE(U,ActorComponent,Scene)
VERIFY_CLASS_OFFSET_NODIE(U,ActorComponent,Owner)
VERIFY_CLASS_SIZE_NODIE(UActorComponent)
VERIFY_CLASS_SIZE_NODIE(UActorFactory)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryAI)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryEmitter)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryLight)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryMover)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPhysicsAsset)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryPlayerStart)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryRigidBody)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryRoute)
VERIFY_CLASS_SIZE_NODIE(UActorFactorySkeletalMesh)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryStaticMesh)
VERIFY_CLASS_SIZE_NODIE(UActorFactoryVehicle)
VERIFY_CLASS_SIZE_NODIE(AAIController)
VERIFY_CLASS_SIZE_NODIE(UAnimNode)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlend)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendBase)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendByPosture)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendBySpeed)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendDirectional)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendList)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendPerBone)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeCrossfader)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSequence)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_DestroyEffect)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Effect)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Footstep)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Script)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Scripted)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Sound)
VERIFY_CLASS_SIZE_NODIE(UAnimSequence)
VERIFY_CLASS_SIZE_NODIE(UAnimSet)
VERIFY_CLASS_SIZE_NODIE(UAnimTree)
VERIFY_CLASS_OFFSET_NODIE(U,ArrowComponent,ArrowColor)
VERIFY_CLASS_OFFSET_NODIE(U,ArrowComponent,ArrowSize)
VERIFY_CLASS_SIZE_NODIE(UArrowComponent)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SoundCue)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CueFirstNode)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,WaveInstances)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SoundNodeData)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SoundNodeOffsetMap)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SoundNodeWaveMap)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,SoundNodeResetWaveMap)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,Listener)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,PlaybackTime)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,Location)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,ComponentLocation)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentNotifyFinished)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentLocation)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentDelay)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentVolume)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentPitch)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentUseSpatialization)
VERIFY_CLASS_OFFSET_NODIE(U,AudioComponent,CurrentNodeIndex)
VERIFY_CLASS_SIZE_NODIE(UAudioComponent)
VERIFY_CLASS_SIZE_NODIE(UAudioDevice)
VERIFY_CLASS_SIZE_NODIE(AAutoLadder)
VERIFY_CLASS_SIZE_NODIE(ABlockingVolume)
VERIFY_CLASS_SIZE_NODIE(UBookMark)
VERIFY_CLASS_SIZE_NODIE(ABrush)
VERIFY_CLASS_OFFSET_NODIE(U,BrushComponent,Brush)
VERIFY_CLASS_OFFSET_NODIE(U,BrushComponent,WireObject)
VERIFY_CLASS_SIZE_NODIE(UBrushComponent)
VERIFY_CLASS_SIZE_NODIE(ACamera)
VERIFY_CLASS_SIZE_NODIE(ACameraActor)
VERIFY_CLASS_SIZE_NODIE(UCameraConeComponent)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,Font)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,SpaceX)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,SpaceY)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,OrgX)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,OrgY)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,ClipX)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,ClipY)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,CurX)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,CurY)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,CurYL)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,DrawColor)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,SizeY)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,RenderInterface)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,SceneView)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,ColorModulate)
VERIFY_CLASS_OFFSET_NODIE(U,Canvas,DefaultTexture)
VERIFY_CLASS_SIZE_NODIE(UCanvas)
VERIFY_CLASS_SIZE_NODIE(ACar)
VERIFY_CLASS_SIZE_NODIE(ACarriedObject)
VERIFY_CLASS_SIZE_NODIE(UChannel)
VERIFY_CLASS_SIZE_NODIE(UChannelDownload)
VERIFY_CLASS_SIZE_NODIE(UCheatManager)
VERIFY_CLASS_SIZE_NODIE(UClient)
VERIFY_CLASS_SIZE_NODIE(AClipMarker)
VERIFY_CLASS_SIZE_NODIE(UCodecMovie)
VERIFY_CLASS_SIZE_NODIE(UCodecMovieFallback)
VERIFY_CLASS_SIZE_NODIE(UCodecMovieTheora)
VERIFY_CLASS_SIZE_NODIE(UConsole)
VERIFY_CLASS_SIZE_NODIE(UControlChannel)
VERIFY_CLASS_SIZE_NODIE(AController)
VERIFY_CLASS_SIZE_NODIE(ACoverNode)
VERIFY_CLASS_OFFSET_NODIE(U,CylinderComponent,CollisionHeight)
VERIFY_CLASS_OFFSET_NODIE(U,CylinderComponent,CollisionRadius)
VERIFY_CLASS_SIZE_NODIE(UCylinderComponent)
VERIFY_CLASS_SIZE_NODIE(UDamageType)
VERIFY_CLASS_SIZE_NODIE(UDebugManager)
VERIFY_CLASS_SIZE_NODIE(ADefaultPhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(UDirectionalLightComponent)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloat)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatConstant)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatConstantCurve)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatUniform)
VERIFY_CLASS_SIZE_NODIE(UDistributionVector)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorConstant)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorConstantCurve)
VERIFY_CLASS_SIZE_NODIE(UDistributionVectorUniform)
VERIFY_CLASS_SIZE_NODIE(UDmgType_Suicided)
VERIFY_CLASS_SIZE_NODIE(UDownload)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumColor)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumAngle)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumAspectRatio)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumStartDist)
VERIFY_CLASS_OFFSET_NODIE(U,DrawFrustumComponent,FrustumEndDist)
VERIFY_CLASS_SIZE_NODIE(UDrawFrustumComponent)
VERIFY_CLASS_OFFSET_NODIE(U,DrawSphereComponent,SphereColor)
VERIFY_CLASS_OFFSET_NODIE(U,DrawSphereComponent,SphereMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,DrawSphereComponent,SphereRadius)
VERIFY_CLASS_OFFSET_NODIE(U,DrawSphereComponent,SphereSides)
VERIFY_CLASS_SIZE_NODIE(UDrawSphereComponent)
VERIFY_CLASS_SIZE_NODIE(ADroppedPickup)
VERIFY_CLASS_SIZE_NODIE(UEdCoordSystem)
VERIFY_CLASS_SIZE_NODIE(UEdLayer)
VERIFY_CLASS_SIZE_NODIE(AEmitter)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,TinyFont)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,SmallFont)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,MediumFont)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,LargeFont)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,NetworkDriverClass)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,DefaultMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,LightingOnlyMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,SolidColorMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,ColoredNodeMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,GeomMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,TickMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,CrossMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,LightComplexityColors)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,EditorBrushMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,Client)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,Players)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,TickCycles)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,GameCycles)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,ClientCycles)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,MaxStreamedInMips)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,MinStreamedInMips)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,DebugManager)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_WorldBox)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_GroundPlane)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_GroundHighlight)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_BrushWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_Pivot)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_Select)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_Current)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_AddWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_SubtractWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_GreyWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_BrushVertex)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_BrushSnap)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_Invalid)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_ActorWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_ActorHiWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_Black)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_White)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_Mask)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_SemiSolidWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_NonSolidWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_WireBackground)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_WireGridAxis)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_ActorArrow)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_ScaleBox)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_ScaleBoxHi)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_ZoneWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_OrthoBackground)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_Volume)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_ConstraintLine)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_AnimMesh)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,C_TerrainWire)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,StreamingDistanceFactor)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,MaterialMap)
VERIFY_CLASS_OFFSET_NODIE(U,Engine,ScoutClassName)
VERIFY_CLASS_SIZE_NODIE(UEngine)
VERIFY_CLASS_SIZE_NODIE(UFileChannel)
VERIFY_CLASS_SIZE_NODIE(AFileLog)
VERIFY_CLASS_SIZE_NODIE(UFont)
VERIFY_CLASS_SIZE_NODIE(UForceFeedbackManager)
VERIFY_CLASS_OFFSET_NODIE(U,ForceFeedbackWaveform,Samples)
VERIFY_CLASS_SIZE_NODIE(UForceFeedbackWaveform)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,GLevel)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,GEntry)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,GPendingLevel)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,LastURL)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,ServerActors)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,ServerPackages)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,TravelURL)
VERIFY_CLASS_OFFSET_NODIE(U,GameEngine,TravelType)
VERIFY_CLASS_SIZE_NODIE(UGameEngine)
VERIFY_CLASS_SIZE_NODIE(AGameInfo)
VERIFY_CLASS_SIZE_NODIE(AGameReplicationInfo)
VERIFY_CLASS_SIZE_NODIE(AGameStats)
VERIFY_CLASS_SIZE_NODIE(UHeightFogComponent)
VERIFY_CLASS_SIZE_NODIE(AHUD)
VERIFY_CLASS_SIZE_NODIE(AInfo)
VERIFY_CLASS_OFFSET_NODIE(U,Input,Bindings)
VERIFY_CLASS_OFFSET_NODIE(U,Input,PressedKeys)
VERIFY_CLASS_OFFSET_NODIE(U,Input,CurrentEvent)
VERIFY_CLASS_OFFSET_NODIE(U,Input,CurrentDelta)
VERIFY_CLASS_OFFSET_NODIE(U,Input,CurrentDeltaTime)
VERIFY_CLASS_OFFSET_NODIE(U,Input,NameToPtr)
VERIFY_CLASS_OFFSET_NODIE(U,Input,AxisArray)
VERIFY_CLASS_SIZE_NODIE(UInput)
VERIFY_CLASS_OFFSET_NODIE(U,Interaction,Player)
VERIFY_CLASS_SIZE_NODIE(UInteraction)
VERIFY_CLASS_SIZE_NODIE(AInternetInfo)
VERIFY_CLASS_SIZE_NODIE(AInterpActor)
VERIFY_CLASS_SIZE_NODIE(UInterpCurveEdSetup)
VERIFY_CLASS_SIZE_NODIE(UInterpData)
VERIFY_CLASS_SIZE_NODIE(UInterpGroup)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupDirector)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupInst)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupInstDirector)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrack,TrackInstClass)
VERIFY_CLASS_OFFSET_NODIE(U,InterpTrack,TrackTitle)
VERIFY_CLASS_SIZE_NODIE(UInterpTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackDirector)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackEvent)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFade)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatBase)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatProp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInst)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstDirector)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstEvent)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFade)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFloatProp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstMove)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstSlomo)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackMove)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSlomo)
VERIFY_CLASS_SIZE_NODIE(AInventory)
VERIFY_CLASS_SIZE_NODIE(AInventoryManager)
VERIFY_CLASS_SIZE_NODIE(AJumpPad)
VERIFY_CLASS_SIZE_NODIE(AKActor)
VERIFY_CLASS_SIZE_NODIE(AKAsset)
VERIFY_CLASS_SIZE_NODIE(AKeypoint)
VERIFY_CLASS_SIZE_NODIE(UKillZDamageType)
VERIFY_CLASS_OFFSET_NODIE(U,KMeshProps,COMNudge)
VERIFY_CLASS_OFFSET_NODIE(U,KMeshProps,AggGeom)
VERIFY_CLASS_SIZE_NODIE(UKMeshProps)
VERIFY_CLASS_SIZE_NODIE(ALadder)
VERIFY_CLASS_SIZE_NODIE(ALadderVolume)
VERIFY_CLASS_SIZE_NODIE(ULevel)
VERIFY_CLASS_SIZE_NODIE(ULevelBase)
VERIFY_CLASS_SIZE_NODIE(ALevelInfo)
VERIFY_CLASS_SIZE_NODIE(ULevelSummary)
VERIFY_CLASS_SIZE_NODIE(ALight)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,FirstDynamicPrimitiveLink)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,FirstStaticPrimitiveLink)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,WorldToLight)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,LightToWorld)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,Brightness)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,Color)
VERIFY_CLASS_OFFSET_NODIE(U,LightComponent,Function)
VERIFY_CLASS_SIZE_NODIE(ULightComponent)
VERIFY_CLASS_SIZE_NODIE(ULightFunction)
VERIFY_CLASS_SIZE_NODIE(ULineBatchComponent)
VERIFY_CLASS_OFFSET_NODIE(U,LocalPlayer,Viewport)
VERIFY_CLASS_OFFSET_NODIE(U,LocalPlayer,MasterViewport)
VERIFY_CLASS_OFFSET_NODIE(U,LocalPlayer,EnabledStats)
VERIFY_CLASS_OFFSET_NODIE(U,LocalPlayer,ViewMode)
VERIFY_CLASS_OFFSET_NODIE(U,LocalPlayer,ShowFlags)
VERIFY_CLASS_OFFSET_NODIE(U,LocalPlayer,UseAutomaticBrightness)
VERIFY_CLASS_OFFSET_NODIE(U,LocalPlayer,ViewState)
VERIFY_CLASS_SIZE_NODIE(ULocalPlayer)
VERIFY_CLASS_SIZE_NODIE(UMaterial)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpression)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAdd)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionAppendVector)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionBumpOffset)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCameraVector)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCeil)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionClamp)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionComponentMask)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant2Vector)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant3Vector)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionConstant4Vector)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCosine)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionCrossProduct)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDesaturation)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDivide)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionDotProduct)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFloor)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionFrac)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionLinearInterpolate)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionMultiply)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionNormalize)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionPanner)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionParticleSubUV)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionReflectionVector)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionRotator)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionScalarParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSine)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionSubtract)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureCoordinate)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTextureSample)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionTime)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionVectorParameter)
VERIFY_CLASS_SIZE_NODIE(UMaterialExpressionVertexColor)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstance)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceConstant)
VERIFY_CLASS_OFFSET_NODIE(U,MeshComponent,Materials)
VERIFY_CLASS_SIZE_NODIE(UMeshComponent)
VERIFY_CLASS_SIZE_NODIE(UMeshComponentFactory)
VERIFY_CLASS_SIZE_NODIE(UModel)
VERIFY_CLASS_OFFSET_NODIE(U,ModelComponent,Level)
VERIFY_CLASS_OFFSET_NODIE(U,ModelComponent,ZoneIndex)
VERIFY_CLASS_OFFSET_NODIE(U,ModelComponent,Model)
VERIFY_CLASS_OFFSET_NODIE(U,ModelComponent,MeshObject)
VERIFY_CLASS_OFFSET_NODIE(U,ModelComponent,StaticLights)
VERIFY_CLASS_OFFSET_NODIE(U,ModelComponent,IgnoreLights)
VERIFY_CLASS_SIZE_NODIE(UModelComponent)
VERIFY_CLASS_SIZE_NODIE(AMutator)
VERIFY_CLASS_SIZE_NODIE(ANavigationPoint)
VERIFY_CLASS_SIZE_NODIE(UNetConnection)
VERIFY_CLASS_SIZE_NODIE(UNetDriver)
VERIFY_CLASS_SIZE_NODIE(UNetPendingLevel)
VERIFY_CLASS_SIZE_NODIE(ANote)
VERIFY_CLASS_SIZE_NODIE(AObjective)
VERIFY_CLASS_SIZE_NODIE(UPackageMapLevel)
VERIFY_CLASS_SIZE_NODIE(UParticleEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleMeshEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleModule)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAcceleration)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAccelerationBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAccelerationOverLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorLine)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleAttractorPoint)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCollision)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleCollisionBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColor)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorByParameter)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleColorOverLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLifetimeBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleLocationBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleMeshRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotation)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationOverLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRate)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRateBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleRotationRateMultiplyLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSize)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeMultiplyLife)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeMultiplyVelocity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSizeScale)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUV)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleSubUVBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataMesh)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataSubUV)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleTypeDataTrail)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocity)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityBase)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityInheritParent)
VERIFY_CLASS_SIZE_NODIE(UParticleModuleVelocityOverLifetime)
VERIFY_CLASS_SIZE_NODIE(UParticleSpriteEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleSpriteSubUVEmitter)
VERIFY_CLASS_SIZE_NODIE(UParticleSystem)
VERIFY_CLASS_SIZE_NODIE(UParticleSystemComponent)
VERIFY_CLASS_SIZE_NODIE(APathNode)
VERIFY_CLASS_SIZE_NODIE(UPathRenderingComponent)
VERIFY_CLASS_SIZE_NODIE(APawn)
VERIFY_CLASS_SIZE_NODIE(UPendingLevel)
VERIFY_CLASS_SIZE_NODIE(UPhysicalMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAsset,DefaultSkelMesh)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAsset,BodySetup)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAsset,ConstraintSetup)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAsset,DefaultInstance)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAsset)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAssetInstance,Owner)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAssetInstance,RootBodyIndex)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAssetInstance,Bodies)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAssetInstance,Constraints)
VERIFY_CLASS_OFFSET_NODIE(U,PhysicsAssetInstance,CollisionDisableTable)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAssetInstance)
VERIFY_CLASS_SIZE_NODIE(APhysicsVolume)
VERIFY_CLASS_SIZE_NODIE(APickupFactory)
VERIFY_CLASS_OFFSET_NODIE(U,Player,Actor)
VERIFY_CLASS_OFFSET_NODIE(U,Player,CurrentNetSpeed)
VERIFY_CLASS_OFFSET_NODIE(U,Player,ConfiguredInternetSpeed)
VERIFY_CLASS_OFFSET_NODIE(U,Player,ConfiguredLanSpeed)
VERIFY_CLASS_SIZE_NODIE(UPlayer)
VERIFY_CLASS_SIZE_NODIE(APlayerController)
VERIFY_CLASS_SIZE_NODIE(UPlayerInput)
VERIFY_CLASS_SIZE_NODIE(APlayerReplicationInfo)
VERIFY_CLASS_SIZE_NODIE(APlayerStart)
VERIFY_CLASS_SIZE_NODIE(UPointLightComponent)
VERIFY_CLASS_SIZE_NODIE(APolyMarker)
VERIFY_CLASS_SIZE_NODIE(UPolys)
VERIFY_CLASS_SIZE_NODIE(APotentialClimbWatcher)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,LocalToWorldDeterminant)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,LocalToWorld)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,Lights)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,CachedShadowVolumes)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,ShadowParent)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,FirstShadowChild)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,NextShadowChild)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,Bounds)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,CullDistance)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,OctreeNodes)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,OctreeTag)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,ZoneMask)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,PhysicalMaterialOverride)
VERIFY_CLASS_OFFSET_NODIE(U,PrimitiveComponent,BodyInstance)
VERIFY_CLASS_SIZE_NODIE(UPrimitiveComponent)
VERIFY_CLASS_SIZE_NODIE(UPrimitiveComponentFactory)
VERIFY_CLASS_SIZE_NODIE(AProjectile)
VERIFY_CLASS_SIZE_NODIE(URB_BodyInstance)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,BoneName)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,PhysicalMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,MassScale)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,ApparentVelocity)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,CollisionGeom)
VERIFY_CLASS_OFFSET_NODIE(U,RB_BodySetup,CollisionGeomScale3D)
VERIFY_CLASS_SIZE_NODIE(URB_BodySetup)
VERIFY_CLASS_SIZE_NODIE(URB_BSJointSetup)
VERIFY_CLASS_SIZE_NODIE(ARB_ConstraintActor)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintDrawComponent)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintInstance)
VERIFY_CLASS_SIZE_NODIE(URB_ConstraintSetup)
VERIFY_CLASS_SIZE_NODIE(URB_Handle)
VERIFY_CLASS_SIZE_NODIE(URB_HingeSetup)
VERIFY_CLASS_SIZE_NODIE(ARB_LineImpulseActor)
VERIFY_CLASS_SIZE_NODIE(URB_PrismaticSetup)
VERIFY_CLASS_SIZE_NODIE(URB_RadialImpulseComponent)
VERIFY_CLASS_SIZE_NODIE(URB_SkelJointSetup)
VERIFY_CLASS_SIZE_NODIE(URB_Spring)
VERIFY_CLASS_SIZE_NODIE(ARB_Thruster)
VERIFY_CLASS_SIZE_NODIE(UReachSpec)
VERIFY_CLASS_SIZE_NODIE(AReplicationInfo)
VERIFY_CLASS_SIZE_NODIE(ARoute)
VERIFY_CLASS_SIZE_NODIE(ASavedMove)
VERIFY_CLASS_SIZE_NODIE(AScout)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ActorFactory)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AIMoveToActor)
VERIFY_CLASS_SIZE_NODIE(USeqAct_AttachToEvent)
VERIFY_CLASS_SIZE_NODIE(USeqAct_CauseDamage)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Delay)
VERIFY_CLASS_SIZE_NODIE(USeqAct_DelaySwitch)
VERIFY_CLASS_SIZE_NODIE(USeqAct_FinishSequence)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetDistance)
VERIFY_CLASS_SIZE_NODIE(USeqAct_GetVelocity)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Interp)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Latent)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Log)
VERIFY_CLASS_SIZE_NODIE(USeqAct_ModifyProperty)
VERIFY_CLASS_SIZE_NODIE(USeqAct_PlaySound)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Possess)
VERIFY_CLASS_SIZE_NODIE(USeqAct_RandomSwitch)
VERIFY_CLASS_SIZE_NODIE(USeqAct_RangeSwitch)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetBlockRigidBody)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetBool)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetCameraTarget)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetFloat)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetInt)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetObject)
VERIFY_CLASS_SIZE_NODIE(USeqAct_SetPhysics)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Switch)
VERIFY_CLASS_SIZE_NODIE(USeqAct_Toggle)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareBool)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareFloat)
VERIFY_CLASS_SIZE_NODIE(USeqCond_CompareInt)
VERIFY_CLASS_SIZE_NODIE(USeqCond_Increment)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_AISeeEnemy)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_ConstraintBroken)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Destroyed)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_LevelStartup)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_SequenceActivated)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Touch)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_UnTouch)
VERIFY_CLASS_SIZE_NODIE(USeqEvent_Used)
VERIFY_CLASS_SIZE_NODIE(USequence)
VERIFY_CLASS_SIZE_NODIE(USequenceAction)
VERIFY_CLASS_SIZE_NODIE(USequenceCondition)
VERIFY_CLASS_SIZE_NODIE(USequenceEvent)
VERIFY_CLASS_SIZE_NODIE(USequenceFrame)
VERIFY_CLASS_SIZE_NODIE(USequenceObject)
VERIFY_CLASS_SIZE_NODIE(USequenceOp)
VERIFY_CLASS_SIZE_NODIE(USequenceVariable)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Bool)
VERIFY_CLASS_SIZE_NODIE(USeqVar_External)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Float)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Int)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Named)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Object)
VERIFY_CLASS_SIZE_NODIE(USeqVar_Player)
VERIFY_CLASS_SIZE_NODIE(USeqVar_RandomFloat)
VERIFY_CLASS_SIZE_NODIE(USeqVar_RandomInt)
VERIFY_CLASS_SIZE_NODIE(USeqVar_String)
VERIFY_CLASS_SIZE_NODIE(UServerCommandlet)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,ResourceIndex)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,Dynamic)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,SizeY)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,Format)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,SizeZ)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,NumMips)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,CurrentMips)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,Mips)
VERIFY_CLASS_OFFSET_NODIE(U,ShadowMap,Light)
VERIFY_CLASS_SIZE_NODIE(UShadowMap)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,Bounds)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,Materials)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,Origin)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,RotOrigin)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,RefSkeleton)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,SkeletalDepth)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,LODModels)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMesh,RefBasesInvMatrix)
VERIFY_CLASS_SIZE_NODIE(USkeletalMesh)
VERIFY_CLASS_SIZE_NODIE(ASkeletalMeshActor)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SkeletalMesh)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,AnimTreeTemplate)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,Animations)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PhysicsAsset)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PhysicsAssetInstance)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,PhysicsWeight)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,MeshObject)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,SpaceBases)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,AnimSets)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,Attachments)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,BoneRotationControls)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,BoneTranslationControls)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,ForcedLodModel)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bForceRefpose)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bDisplayBones)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bHideSkin)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bForceRawOffset)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bIgnoreControllers)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,LimitMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bDiscardRootRotation)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,RootBoneOption)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,bOldRootInitialized)
VERIFY_CLASS_OFFSET_NODIE(U,SkeletalMeshComponent,OldRootLocation)
VERIFY_CLASS_SIZE_NODIE(USkeletalMeshComponent)
VERIFY_CLASS_SIZE_NODIE(USkyLightComponent)
VERIFY_CLASS_OFFSET_NODIE(U,SoundCue,FirstNode)
VERIFY_CLASS_OFFSET_NODIE(U,SoundCue,EditorData)
VERIFY_CLASS_SIZE_NODIE(USoundCue)
VERIFY_CLASS_SIZE_NODIE(USoundNode)
VERIFY_CLASS_SIZE_NODIE(USoundNodeAttenuation)
VERIFY_CLASS_SIZE_NODIE(USoundNodeLooping)
VERIFY_CLASS_SIZE_NODIE(USoundNodeMixer)
VERIFY_CLASS_SIZE_NODIE(USoundNodeModulator)
VERIFY_CLASS_SIZE_NODIE(USoundNodeOscillator)
VERIFY_CLASS_SIZE_NODIE(USoundNodeRandom)
VERIFY_CLASS_OFFSET_NODIE(U,SoundNodeWave,Volume)
VERIFY_CLASS_OFFSET_NODIE(U,SoundNodeWave,Pitch)
VERIFY_CLASS_OFFSET_NODIE(U,SoundNodeWave,Duration)
VERIFY_CLASS_OFFSET_NODIE(U,SoundNodeWave,FileType)
VERIFY_CLASS_OFFSET_NODIE(U,SoundNodeWave,RawData)
VERIFY_CLASS_OFFSET_NODIE(U,SoundNodeWave,ResourceID)
VERIFY_CLASS_SIZE_NODIE(USoundNodeWave)
VERIFY_CLASS_SIZE_NODIE(USphericalHarmonicMap)
VERIFY_CLASS_SIZE_NODIE(USpotLightComponent)
VERIFY_CLASS_OFFSET_NODIE(U,SpriteComponent,Sprite)
VERIFY_CLASS_SIZE_NODIE(USpriteComponent)
VERIFY_CLASS_SIZE_NODIE(UStaticMesh)
VERIFY_CLASS_SIZE_NODIE(AStaticMeshActor)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,StaticMesh)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,MeshObject)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,WireframeColor)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,StaticLights)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,StaticLightMaps)
VERIFY_CLASS_OFFSET_NODIE(U,StaticMeshComponent,IgnoreLights)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshComponent)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshComponentFactory)
VERIFY_CLASS_SIZE_NODIE(ASVehicle)
VERIFY_CLASS_SIZE_NODIE(USVehicleWheel)
VERIFY_CLASS_SIZE_NODIE(ATeamInfo)
VERIFY_CLASS_SIZE_NODIE(ATeleporter)
VERIFY_CLASS_SIZE_NODIE(ATerrain)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,StaticLights)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,IgnoreLights)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,TerrainObject)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,SectionBaseX)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,SectionBaseY)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,SectionSizeX)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,SectionSizeY)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,PatchBounds)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,PatchBatches)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,BatchMaterials)
VERIFY_CLASS_OFFSET_NODIE(U,TerrainComponent,FullBatch)
VERIFY_CLASS_SIZE_NODIE(UTerrainComponent)
VERIFY_CLASS_SIZE_NODIE(UTerrainLayerSetup)
VERIFY_CLASS_SIZE_NODIE(UTerrainMaterial)
VERIFY_CLASS_OFFSET_NODIE(U,Texture,UnpackMin)
VERIFY_CLASS_OFFSET_NODIE(U,Texture,UnpackMax)
VERIFY_CLASS_OFFSET_NODIE(U,Texture,SourceArt)
VERIFY_CLASS_OFFSET_NODIE(U,Texture,CompressionSettings)
VERIFY_CLASS_SIZE_NODIE(UTexture)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,ResourceIndex)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,Dynamic)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,SizeY)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,Format)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,SizeZ)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,NumMips)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,CurrentMips)
VERIFY_CLASS_OFFSET_NODIE(U,Texture2D,Mips)
VERIFY_CLASS_SIZE_NODIE(UTexture2D)
VERIFY_CLASS_OFFSET_NODIE(U,Texture3D,ResourceIndex)
VERIFY_CLASS_OFFSET_NODIE(U,Texture3D,Dynamic)
VERIFY_CLASS_OFFSET_NODIE(U,Texture3D,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,Texture3D,SizeY)
VERIFY_CLASS_OFFSET_NODIE(U,Texture3D,Format)
VERIFY_CLASS_OFFSET_NODIE(U,Texture3D,SizeZ)
VERIFY_CLASS_OFFSET_NODIE(U,Texture3D,NumMips)
VERIFY_CLASS_OFFSET_NODIE(U,Texture3D,CurrentMips)
VERIFY_CLASS_OFFSET_NODIE(U,Texture3D,Mips)
VERIFY_CLASS_SIZE_NODIE(UTexture3D)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,ResourceIndex)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,Dynamic)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,SizeY)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,Format)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,SizeZ)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,NumMips)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,CurrentMips)
VERIFY_CLASS_OFFSET_NODIE(U,TextureCube,Valid)
VERIFY_CLASS_SIZE_NODIE(UTextureCube)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,ResourceIndex)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,Dynamic)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,SizeX)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,SizeY)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,Format)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,SizeZ)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,NumMips)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,CurrentMips)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,DecoderClass)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,Decoder)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,TimeIntoMovie)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,TimeSinceLastFrame)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,CurrentFrame)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,RawData)
VERIFY_CLASS_OFFSET_NODIE(U,TextureMovie,RawSize)
VERIFY_CLASS_SIZE_NODIE(UTextureMovie)
VERIFY_CLASS_SIZE_NODIE(UTransformComponent)
VERIFY_CLASS_SIZE_NODIE(ATrigger)
VERIFY_CLASS_SIZE_NODIE(AVehicle)
VERIFY_CLASS_SIZE_NODIE(AVolume)
VERIFY_CLASS_SIZE_NODIE(AWeapon)
VERIFY_CLASS_SIZE_NODIE(UWindDirectionalSourceComponent)
VERIFY_CLASS_SIZE_NODIE(UWindPointSourceComponent)
VERIFY_CLASS_SIZE_NODIE(AZoneInfo)
#endif // VERIFY_CLASS_SIZES
