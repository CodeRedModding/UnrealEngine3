/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_ANIM_ENUMS
#define INCLUDED_ENGINE_ANIM_ENUMS 1

enum AnimationKeyFormat
{
    AKF_ConstantKeyLerp     =0,
    AKF_VariableKeyLerp     =1,
    AKF_PerTrackCompression =2,
    AKF_MAX                 =3,
};
#define FOREACH_ENUM_ANIMATIONKEYFORMAT(op) \
    op(AKF_ConstantKeyLerp) \
    op(AKF_VariableKeyLerp) \
    op(AKF_PerTrackCompression) 
enum AnimationCompressionFormat
{
    ACF_None                =0,
    ACF_Float96NoW          =1,
    ACF_Fixed48NoW          =2,
    ACF_IntervalFixed32NoW  =3,
    ACF_Fixed32NoW          =4,
    ACF_Float32NoW          =5,
    ACF_Identity            =6,
    ACF_MAX                 =7,
};
#define FOREACH_ENUM_ANIMATIONCOMPRESSIONFORMAT(op) \
    op(ACF_None) \
    op(ACF_Float96NoW) \
    op(ACF_Fixed48NoW) \
    op(ACF_IntervalFixed32NoW) \
    op(ACF_Fixed32NoW) \
    op(ACF_Float32NoW) \
    op(ACF_Identity) 
enum ESliderType
{
    ST_1D                   =0,
    ST_2D                   =1,
    ST_MAX                  =2,
};
#define FOREACH_ENUM_ESLIDERTYPE(op) \
    op(ST_1D) \
    op(ST_2D) 
enum EBlendType
{
    EBT_ParentBoneSpace     =0,
    EBT_MeshSpace           =1,
    EBT_MAX                 =2,
};
#define FOREACH_ENUM_EBLENDTYPE(op) \
    op(EBT_ParentBoneSpace) \
    op(EBT_MeshSpace) 
enum EWeightCheck
{
    EWC_AnimNodeSlotNotPlaying=0,
    EWC_MAX                 =1,
};
#define FOREACH_ENUM_EWEIGHTCHECK(op) \
    op(EWC_AnimNodeSlotNotPlaying) 
enum EAimID
{
    EAID_LeftUp             =0,
    EAID_LeftDown           =1,
    EAID_RightUp            =2,
    EAID_RightDown          =3,
    EAID_ZeroUp             =4,
    EAID_ZeroDown           =5,
    EAID_ZeroLeft           =6,
    EAID_ZeroRight          =7,
    EAID_CellLU             =8,
    EAID_CellCU             =9,
    EAID_CellRU             =10,
    EAID_CellLC             =11,
    EAID_CellCC             =12,
    EAID_CellRC             =13,
    EAID_CellLD             =14,
    EAID_CellCD             =15,
    EAID_CellRD             =16,
    EAID_MAX                =17,
};
#define FOREACH_ENUM_EAIMID(op) \
    op(EAID_LeftUp) \
    op(EAID_LeftDown) \
    op(EAID_RightUp) \
    op(EAID_RightDown) \
    op(EAID_ZeroUp) \
    op(EAID_ZeroDown) \
    op(EAID_ZeroLeft) \
    op(EAID_ZeroRight) \
    op(EAID_CellLU) \
    op(EAID_CellCU) \
    op(EAID_CellRU) \
    op(EAID_CellLC) \
    op(EAID_CellCC) \
    op(EAID_CellRC) \
    op(EAID_CellLD) \
    op(EAID_CellCD) \
    op(EAID_CellRD) 
enum EAnimAimDir
{
    ANIMAIM_LEFTUP          =0,
    ANIMAIM_CENTERUP        =1,
    ANIMAIM_RIGHTUP         =2,
    ANIMAIM_LEFTCENTER      =3,
    ANIMAIM_CENTERCENTER    =4,
    ANIMAIM_RIGHTCENTER     =5,
    ANIMAIM_LEFTDOWN        =6,
    ANIMAIM_CENTERDOWN      =7,
    ANIMAIM_RIGHTDOWN       =8,
    ANIMAIM_MAX             =9,
};
#define FOREACH_ENUM_EANIMAIMDIR(op) \
    op(ANIMAIM_LEFTUP) \
    op(ANIMAIM_CENTERUP) \
    op(ANIMAIM_RIGHTUP) \
    op(ANIMAIM_LEFTCENTER) \
    op(ANIMAIM_CENTERCENTER) \
    op(ANIMAIM_RIGHTCENTER) \
    op(ANIMAIM_LEFTDOWN) \
    op(ANIMAIM_CENTERDOWN) \
    op(ANIMAIM_RIGHTDOWN) 
enum ERootRotationOption
{
    RRO_Default             =0,
    RRO_Discard             =1,
    RRO_Extract             =2,
    RRO_MAX                 =3,
};
#define FOREACH_ENUM_EROOTROTATIONOPTION(op) \
    op(RRO_Default) \
    op(RRO_Discard) \
    op(RRO_Extract) 
enum ERootBoneAxis
{
    RBA_Default             =0,
    RBA_Discard             =1,
    RBA_Translate           =2,
    RBA_MAX                 =3,
};
#define FOREACH_ENUM_EROOTBONEAXIS(op) \
    op(RBA_Default) \
    op(RBA_Discard) \
    op(RBA_Translate) 
enum EBaseBlendType
{
    BBT_ByActorTag          =0,
    BBT_ByActorClass        =1,
    BBT_MAX                 =2,
};
#define FOREACH_ENUM_EBASEBLENDTYPE(op) \
    op(BBT_ByActorTag) \
    op(BBT_ByActorClass) 
enum EBoneControlSpace
{
    BCS_WorldSpace          =0,
    BCS_ActorSpace          =1,
    BCS_ComponentSpace      =2,
    BCS_ParentBoneSpace     =3,
    BCS_BoneSpace           =4,
    BCS_OtherBoneSpace      =5,
    BCS_BaseMeshSpace       =6,
    BCS_MAX                 =7,
};
#define FOREACH_ENUM_EBONECONTROLSPACE(op) \
    op(BCS_WorldSpace) \
    op(BCS_ActorSpace) \
    op(BCS_ComponentSpace) \
    op(BCS_ParentBoneSpace) \
    op(BCS_BoneSpace) \
    op(BCS_OtherBoneSpace) \
    op(BCS_BaseMeshSpace) 
enum ESplineControlRotMode
{
    SCR_NoChange            =0,
    SCR_AlongSpline         =1,
    SCR_Interpolate         =2,
    SCR_MAX                 =3,
};
#define FOREACH_ENUM_ESPLINECONTROLROTMODE(op) \
    op(SCR_NoChange) \
    op(SCR_AlongSpline) \
    op(SCR_Interpolate) 

#endif // !INCLUDED_ENGINE_ANIM_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_ANIM_CLASSES
#define INCLUDED_ENGINE_ANIM_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct FSkelMeshActorControlTarget
{
    FName ControlName;
    class AActor* TargetActor;

    /** Constructors */
    FSkelMeshActorControlTarget() {}
    FSkelMeshActorControlTarget(EEventParm)
    {
        appMemzero(this, sizeof(FSkelMeshActorControlTarget));
    }
};

struct SkeletalMeshActor_eventOnSetSkelControlTarget_Parms
{
    class USeqAct_SetSkelControlTarget* Action;
    SkeletalMeshActor_eventOnSetSkelControlTarget_Parms(EEventParm)
    {
    }
};
struct SkeletalMeshActor_eventOnUpdatePhysBonesFromAnim_Parms
{
    class USeqAct_UpdatePhysBonesFromAnim* Action;
    SkeletalMeshActor_eventOnUpdatePhysBonesFromAnim_Parms(EEventParm)
    {
    }
};
struct SkeletalMeshActor_eventOnSetMesh_Parms
{
    class USeqAct_SetMesh* Action;
    SkeletalMeshActor_eventOnSetMesh_Parms(EEventParm)
    {
    }
};
class ASkeletalMeshActor : public AActor
{
public:
    //## BEGIN PROPS SkeletalMeshActor
    BITFIELD bDamageAppliesImpulse:1;
    BITFIELD bShouldDoAnimNotifies:1;
    BITFIELD bForceSaveInCheckpoint:1;
    BITFIELD bCollideActors_OldValue_DEPRECATED:1;
    BITFIELD bShouldShadowParentAllAttachedActors:1;
    class USkeletalMeshComponent* SkeletalMeshComponent;
    class ULightEnvironmentComponent* LightEnvironment;
    class UAudioComponent* FacialAudioComp;
    class USkeletalMesh* ReplicatedMesh;
    class UMaterialInterface* ReplicatedMaterial0;
    class UMaterialInterface* ReplicatedMaterial1;
    TArrayNoInit<struct FSkelMeshActorControlTarget> ControlTargets;
    TArrayNoInit<class UInterpGroup*> InterpGroupList;
    FName SavedAnimSeqName;
    FLOAT SavedCurrentTime;
    //## END PROPS SkeletalMeshActor

    virtual void UpdateAnimSetList();
    virtual void MAT_BeginAnimControl(class UInterpGroup* InInterpGroup);
    virtual void MAT_FinishAnimControl(class UInterpGroup* InInterpGroup);
    DECLARE_FUNCTION(execUpdateAnimSetList)
    {
        P_FINISH;
        this->UpdateAnimSetList();
    }
    DECLARE_FUNCTION(execMAT_BeginAnimControl)
    {
        P_GET_OBJECT(UInterpGroup,InInterpGroup);
        P_FINISH;
        this->MAT_BeginAnimControl(InInterpGroup);
    }
    DECLARE_FUNCTION(execMAT_FinishAnimControl)
    {
        P_GET_OBJECT(UInterpGroup,InInterpGroup);
        P_FINISH;
        this->MAT_FinishAnimControl(InInterpGroup);
    }
    void eventOnSetSkelControlTarget(class USeqAct_SetSkelControlTarget* Action)
    {
        SkeletalMeshActor_eventOnSetSkelControlTarget_Parms Parms(EC_EventParm);
        Parms.Action=Action;
        ProcessEvent(FindFunctionChecked(ENGINE_OnSetSkelControlTarget),&Parms);
    }
    void eventOnUpdatePhysBonesFromAnim(class USeqAct_UpdatePhysBonesFromAnim* Action)
    {
        SkeletalMeshActor_eventOnUpdatePhysBonesFromAnim_Parms Parms(EC_EventParm);
        Parms.Action=Action;
        ProcessEvent(FindFunctionChecked(ENGINE_OnUpdatePhysBonesFromAnim),&Parms);
    }
    void eventOnSetMesh(class USeqAct_SetMesh* Action)
    {
        SkeletalMeshActor_eventOnSetMesh_Parms Parms(EC_EventParm);
        Parms.Action=Action;
        ProcessEvent(FindFunctionChecked(ENGINE_OnSetMesh),&Parms);
    }
    DECLARE_CLASS(ASkeletalMeshActor,AActor,0,Engine)
	// UObject interface
#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
	//@compatibility
	virtual void PostLoad();

	// AActor interface
	virtual void TickSpecial(FLOAT DeltaSeconds);
	virtual void ForceUpdateComponents(UBOOL bCollisionUpdate,UBOOL bTransformOnly);
	virtual void PreviewBeginAnimControl(class UInterpGroup* InInterpGroup);
	virtual void PreviewSetAnimPosition(FName SlotName, INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bLooping, UBOOL bFireNotifies, UBOOL bEnableRootMotion, FLOAT DeltaTime);
	virtual void PreviewSetAnimWeights(TArray<FAnimSlotInfo>& SlotInfos);
	virtual void PreviewFinishAnimControl(class UInterpGroup* InInterpGroup);
	virtual void PreviewUpdateFaceFX(UBOOL bForceAnim, const FString& GroupName, const FString& SeqName, FLOAT InPosition);
	virtual void PreviewActorPlayFaceFX(const FString& GroupName, const FString& SeqName, USoundCue* InSoundCue);
	virtual void PreviewActorStopFaceFX();
	virtual UAudioComponent* PreviewGetFaceFXAudioComponent();
	virtual class UFaceFXAsset* PreviewGetActorFaceFXAsset();

	/** Called each from while the Matinee action is running, to set the animation weights for the actor. */
	virtual void SetAnimWeights( const TArray<struct FAnimSlotInfo>& SlotInfos );

	/** Build AnimSet list, called by UpdateAnimSetList() */
	void BuildAnimSetList();
	/** Add a given list of anim sets on the top of the list (so they override the other ones */
	void AddAnimSets(const TArray<class UAnimSet*>& CustomAnimSets);
	/** Restore Mesh's AnimSets to defaults, as defined in the default properties */
	void RestoreAnimSetsToDefault();
	/** Save Mesh's defaults to AnimSets, back up*/
	void SaveDefaultsToAnimSets();

protected:
#if USE_GAMEPLAY_PROFILER
    /** 
     * This function actually does the work for the GetProfilerAssetObject and is virtual.  
     * It should only be called from GetProfilerAssetObject as GetProfilerAssetObject is safe to call on NULL object pointers
     */
	virtual UObject* GetProfilerAssetObjectInternal() const;
#endif
	/**
     * This function actually does the work for the GetDetailInfo and is virtual.
     * It should only be called from GetDetailedInfo as GetDetailedInfo is safe to call on NULL object pointers
     */
	virtual FString GetDetailedInfoInternal() const;
};

struct FSkelMaterialSetterDatum
{
    INT MaterialIndex;
    class UMaterialInterface* TheMaterial;

    /** Constructors */
    FSkelMaterialSetterDatum() {}
    FSkelMaterialSetterDatum(EEventParm)
    {
        appMemzero(this, sizeof(FSkelMaterialSetterDatum));
    }
};

class ASkeletalMeshActorBasedOnExtremeContent : public ASkeletalMeshActor
{
public:
    //## BEGIN PROPS SkeletalMeshActorBasedOnExtremeContent
    TArrayNoInit<struct FSkelMaterialSetterDatum> ExtremeContent;
    TArrayNoInit<struct FSkelMaterialSetterDatum> NonExtremeContent;
    //## END PROPS SkeletalMeshActorBasedOnExtremeContent

    DECLARE_CLASS(ASkeletalMeshActorBasedOnExtremeContent,ASkeletalMeshActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ASkeletalMeshActorBasedOnExtremeContent)
};

class ASkeletalMeshActorSpawnable : public ASkeletalMeshActor
{
public:
    //## BEGIN PROPS SkeletalMeshActorSpawnable
    //## END PROPS SkeletalMeshActorSpawnable

    DECLARE_CLASS(ASkeletalMeshActorSpawnable,ASkeletalMeshActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ASkeletalMeshActorSpawnable)
};

class ASkeletalMeshCinematicActor : public ASkeletalMeshActor
{
public:
    //## BEGIN PROPS SkeletalMeshCinematicActor
    //## END PROPS SkeletalMeshCinematicActor

    DECLARE_CLASS(ASkeletalMeshCinematicActor,ASkeletalMeshActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ASkeletalMeshCinematicActor)
};

class ASkeletalMeshActorMAT : public ASkeletalMeshCinematicActor
{
public:
    //## BEGIN PROPS SkeletalMeshActorMAT
    TArrayNoInit<class UAnimNodeSlot*> SlotNodes;
    //## END PROPS SkeletalMeshActorMAT

    virtual void MAT_SetAnimWeights(const TArray<struct FAnimSlotInfo>& SlotInfos);
    virtual void MAT_SetMorphWeight(FName MorphNodeName,FLOAT MorphWeight);
    virtual void MAT_SetSkelControlScale(FName SkelControlName,FLOAT Scale);
    virtual void MAT_SetSkelControlStrength(FName SkelControlName,FLOAT ControlStrength);
    virtual void MAT_SetAnimPosition(FName SlotName,INT ChannelIndex,FName InAnimSeqName,FLOAT InPosition,UBOOL bFireNotifies,UBOOL bLooping,UBOOL bEnableRootMotion);
    DECLARE_FUNCTION(execMAT_SetAnimWeights)
    {
        P_GET_TARRAY(struct FAnimSlotInfo,SlotInfos);
        P_FINISH;
        this->MAT_SetAnimWeights(SlotInfos);
    }
    DECLARE_FUNCTION(execMAT_SetMorphWeight)
    {
        P_GET_NAME(MorphNodeName);
        P_GET_FLOAT(MorphWeight);
        P_FINISH;
        this->MAT_SetMorphWeight(MorphNodeName,MorphWeight);
    }
    DECLARE_FUNCTION(execMAT_SetSkelControlScale)
    {
        P_GET_NAME(SkelControlName);
        P_GET_FLOAT(Scale);
        P_FINISH;
        this->MAT_SetSkelControlScale(SkelControlName,Scale);
    }
    DECLARE_FUNCTION(execMAT_SetSkelControlStrength)
    {
        P_GET_NAME(SkelControlName);
        P_GET_FLOAT(ControlStrength);
        P_FINISH;
        this->MAT_SetSkelControlStrength(SkelControlName,ControlStrength);
    }
    DECLARE_FUNCTION(execMAT_SetAnimPosition)
    {
        P_GET_NAME(SlotName);
        P_GET_INT(ChannelIndex);
        P_GET_NAME(InAnimSeqName);
        P_GET_FLOAT(InPosition);
        P_GET_UBOOL(bFireNotifies);
        P_GET_UBOOL(bLooping);
        P_GET_UBOOL(bEnableRootMotion);
        P_FINISH;
        this->MAT_SetAnimPosition(SlotName,ChannelIndex,InAnimSeqName,InPosition,bFireNotifies,bLooping,bEnableRootMotion);
    }
    DECLARE_CLASS(ASkeletalMeshActorMAT,ASkeletalMeshCinematicActor,0,Engine)

#if WITH_EDITOR
	virtual void CheckForErrors();
#endif

	virtual void GetAnimControlSlotDesc(TArray<struct FAnimSlotDesc>& OutSlotDescs);
	virtual void PreviewBeginAnimControl(class UInterpGroup* InInterpGroup);
	virtual void PreviewSetAnimPosition(FName SlotName, INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bLooping, UBOOL bFireNotifies, UBOOL bEnableRootMotion, FLOAT DeltaTime);
	virtual void PreviewSetAnimWeights(TArray<FAnimSlotInfo>& SlotInfos);
	virtual void PreviewFinishAnimControl(class UInterpGroup* InInterpGroup);
	virtual void PreviewSetMorphWeight(FName MorphNodeName, FLOAT MorphWeight);
	virtual void PreviewSetSkelControlScale(FName SkelControlName, FLOAT Scale);
	virtual void SetSkelControlStrength(FName SkelControlName, FLOAT ControlStrength);

	/** Called each from while the Matinee action is running, to set the animation weights for the actor. */
	virtual void SetAnimWeights( const TArray<struct FAnimSlotInfo>& SlotInfos );
};

struct FActorToLookAt
{
    class AActor* Actor;
    FLOAT Rating;
    FLOAT EnteredTime;
    FLOAT LastKnownDistance;
    FLOAT StartTimeBeingLookedAt;
    BITFIELD CurrentlyBeingLookedAt:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FActorToLookAt() {}
    FActorToLookAt(EEventParm)
    {
        appMemzero(this, sizeof(FActorToLookAt));
    }
};

class UHeadTrackingComponent : public UActorComponent
{
public:
    //## BEGIN PROPS HeadTrackingComponent
    TArrayNoInit<FName> TrackControllerName;
    FLOAT LookAtActorRadius;
    BITFIELD bDisableBeyondLimit:1;
    FLOAT MaxLookAtTime;
    FLOAT MinLookAtTime;
    FLOAT MaxInterestTime;
    TArrayNoInit<class UClass*> ActorClassesToLookAt;
    TArrayNoInit<FName> TargetBoneNames;
    TMap< class AActor*,struct FActorToLookAt* > CurrentActorMap;
    class USkeletalMeshComponent* SkeletalMeshComp;
    TArrayNoInit<class USkelControlLookAt*> TrackControls;
    FVector RootMeshLocation;
    FRotator RootMeshRotation;
    //## END PROPS HeadTrackingComponent

    DECLARE_CLASS(UHeadTrackingComponent,UActorComponent,0,Engine)
public:
	/** Enable/Disable HeadTracking **/
	void EnableHeadTracking(UBOOL bEnable);

	/**
	 * Attaches the component to a ParentToWorld transform, owner and scene.
	 * Requires IsValidComponent() == true.
	 */
	virtual void Attach();

	/**
	 * Detaches the component from the scene it is in.
	 * Requires bAttached == true
	 *
	 * @param bWillReattach TRUE is passed if Attach will be called immediately afterwards.  This can be used to
	 *                      preserve state between reattachments.
	 */
	virtual void Detach( UBOOL bWillReattach = FALSE );

	/**
	 * Updates time dependent state for this component.
	 * Requires bAttached == true.
	 * @param DeltaTime - The time since the last tick.
	 */
	virtual void Tick(FLOAT DeltaTime);

	/** Clear list **/
	virtual void BeginDestroy();

	/** Make sure CurrentActorMap is referenced */
	void AddReferencedObjects( TArray<UObject*>& ObjectArray );

private:
	/** 
	 * Update Acotr Map
	 * returns # of actors in the map
	 */
	INT UpdateActorMap(FLOAT CurrentTime);
	/**
	 * Find Best Candidate from the current listing
	*/
	FActorToLookAt * FindBestCandidate(FLOAT CurrentTime);
	/**
	 *  Update Head Tracking
	 */
	void UpdateHeadTracking(FLOAT DeltaTime);

	/** 
	 * Refresh Head Tracking Skel Control List
	 */
	void RefreshTrackControls();
};

struct FAnimNotifyEvent
{
    FLOAT Time;
    class UAnimNotify* Notify;
#if WITH_EDITORONLY_DATA
    FName Comment;
#endif // WITH_EDITORONLY_DATA
    FLOAT Duration;

    /** Constructors */
    FAnimNotifyEvent() {}
    FAnimNotifyEvent(EEventParm)
    {
        appMemzero(this, sizeof(FAnimNotifyEvent));
    }
};

struct FTimeModifier
{
    FLOAT Time;
    FLOAT TargetStrength;

    /** Constructors */
    FTimeModifier() {}
    FTimeModifier(EEventParm)
    {
        appMemzero(this, sizeof(FTimeModifier));
    }
};

struct FSkelControlModifier
{
    FName SkelControlName;
    TArrayNoInit<struct FTimeModifier> Modifiers;

    /** Constructors */
    FSkelControlModifier() {}
    FSkelControlModifier(EEventParm)
    {
        appMemzero(this, sizeof(FSkelControlModifier));
    }
};

struct FTranslationTrack
{
    TArrayNoInit<FVector> PosKeys;
    TArrayNoInit<FLOAT> Times;

    /** Constructors */
    FTranslationTrack() {}
    FTranslationTrack(EEventParm)
    {
        appMemzero(this, sizeof(FTranslationTrack));
    }
};

struct FRotationTrack
{
    TArrayNoInit<FQuat> RotKeys;
    TArrayNoInit<FLOAT> Times;

    /** Constructors */
    FRotationTrack() {}
    FRotationTrack(EEventParm)
    {
        appMemzero(this, sizeof(FRotationTrack));
    }
};

struct FCurveTrack
{
    FName CurveName;
    TArrayNoInit<FLOAT> CurveWeights;

	/** Returns TRUE if valid curve weight exists in the array*/
	UBOOL IsValidCurveTrack();
	/** This is very simple cut to 1 key method if all is same since I see so many redundant same value in every frame 
	 *  Eventually this can get more complicated 
	 *  Will return TRUE if compressed to 1. Return FALSE otherwise **/
	UBOOL CompressCurveWeights();
	
};

struct FCompressedTrack
{
    TArrayNoInit<BYTE> ByteStream;
    TArrayNoInit<FLOAT> Times;
    FLOAT Mins[3];
    FLOAT Ranges[3];

    /** Constructors */
    FCompressedTrack() {}
    FCompressedTrack(EEventParm)
    {
        appMemzero(this, sizeof(FCompressedTrack));
    }
};

class UAnimSequence : public UObject
{
public:
    //## BEGIN PROPS AnimSequence
    FName SequenceName;
    TArrayNoInit<struct FAnimNotifyEvent> Notifies;
    TArrayNoInit<class UAnimMetaData*> MetaData;
    TArrayNoInit<struct FSkelControlModifier> BoneControlModifiers_DEPRECATED;
    FLOAT SequenceLength;
    INT NumFrames;
    FLOAT RateScale;
    BITFIELD bNoLoopingInterpolation:1;
    BITFIELD bIsAdditive:1;
    BITFIELD bAdditiveBuiltLooping:1;
    BITFIELD bDoNotOverrideCompression:1;
    BITFIELD bHasBeenUsed:1;
    BITFIELD bWasCompressedWithoutTranslations:1;
    TArrayNoInit<FRawAnimSequenceTrack> RawAnimData_DEPRECATED;
    TArrayNoInit<FRawAnimSequenceTrack> RawAnimationData;
    TArrayNoInit<struct FTranslationTrack> TranslationData;
    TArrayNoInit<struct FRotationTrack> RotationData;
    TArrayNoInit<struct FCurveTrack> CurveData;
#if WITH_EDITORONLY_DATA
    class UAnimationCompressionAlgorithm* CompressionScheme;
#endif // WITH_EDITORONLY_DATA
    BYTE TranslationCompressionFormat;
    BYTE RotationCompressionFormat;
    BYTE KeyEncodingFormat;
    TArrayNoInit<INT> CompressedTrackOffsets;
    TArrayNoInit<BYTE> CompressedByteStream;
    FPointer TranslationCodec;
    FPointer RotationCodec;
    TArrayNoInit<FBoneAtom> AdditiveRefPose_DEPRECATED;
    TArrayNoInit<FRawAnimSequenceTrack> AdditiveBasePose;
#if WITH_EDITORONLY_DATA
    FName AdditiveRefName;
    TArrayNoInit<class UAnimSequence*> AdditiveBasePoseAnimSeq;
    TArrayNoInit<class UAnimSequence*> AdditiveTargetPoseAnimSeq;
    TArrayNoInit<class UAnimSequence*> RelatedAdditiveAnimSeqs;
#endif // WITH_EDITORONLY_DATA
    INT EncodingPkgVersion;
#if WITH_EDITORONLY_DATA
    INT CompressCommandletVersion;
#endif // WITH_EDITORONLY_DATA
    FLOAT UseScore;
    //## END PROPS AnimSequence

    virtual FLOAT GetNotifyTimeByClass(class UClass* NotifyClass,FLOAT PlayRate=1.000000,FLOAT StartPosition=-1.000000,class UAnimNotify** out_Notify=NULL,FLOAT* out_Duration=NULL);
    DECLARE_FUNCTION(execGetNotifyTimeByClass)
    {
        P_GET_OBJECT(UClass,NotifyClass);
        P_GET_FLOAT_OPTX(PlayRate,1.000000);
        P_GET_FLOAT_OPTX(StartPosition,-1.000000);
        P_GET_OBJECT_OPTX_REF(UAnimNotify,out_Notify,NULL);
        P_GET_FLOAT_OPTX_REF(out_Duration,0);
        P_FINISH;
        *(FLOAT*)Result=this->GetNotifyTimeByClass(NotifyClass,PlayRate,StartPosition,pout_Notify ? &out_Notify : NULL,pout_Duration ? &out_Duration : NULL);
    }
    DECLARE_CLASS(UAnimSequence,UObject,0,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Engine");}

	// UObject interface

	virtual void Serialize(FArchive& Ar);
	virtual void PreSave();
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void BeginDestroy();

	/**
	 * Used by various commandlets to purge editor only and platform-specific data from various objects
	 * 
	 * @param PlatformsToKeep Platforms for which to keep platform-specific data
	 * @param bStripLargeEditorData If TRUE, data used in the editor, but large enough to bloat download sizes, will be removed
	 */
	virtual void StripData(UE3::EPlatformType PlatformsToKeep, UBOOL bStripLargeEditorData);

	// AnimSequence interface

	/**
	 * Reconstructs a bone atom from key-reduced tracks.
	 */
	static void ReconstructBoneAtom(FBoneAtom& OutAtom,
									const FTranslationTrack& TranslationTrack,
									const FRotationTrack& RotationTrack,
									FLOAT SequenceLength,
									FLOAT Time,
									UBOOL bLooping);

	/**
	 * Reconstructs a bone atom from compressed tracks.
	 */
	static void ReconstructBoneAtom(FBoneAtom& OutAtom,
									const FCompressedTrack& TranslationTrack,
									const FCompressedTrack& RotationTrack,
									AnimationCompressionFormat TranslationCompressionFormat,
									AnimationCompressionFormat RotationCompressionFormat,
									FLOAT SequenceLength,
									FLOAT Time,
									UBOOL bLooping);

	/**
	 * Reconstructs a bone atom from compressed tracks.
	 */
	static void ReconstructBoneAtom(FBoneAtom& OutAtom,
									const BYTE* TransStream,
									INT NumTransKeys,
									const BYTE* RotStream,
									INT NumRotKeys,
									AnimationCompressionFormat TranslationCompressionFormat,
									AnimationCompressionFormat RotationCompressionFormat,
									FLOAT SequenceLength,
									FLOAT Time,
									UBOOL bLooping);

	/**
	 * Decompresses a translation key from the specified compressed translation track.
	 */
	static void ReconstructTranslation(class FVector& Out, const BYTE* Stream, INT KeyIndex, AnimationCompressionFormat TranslationCompressionFormat);

	/**
	 * Decompresses a rotation key from the specified compressed rotation track.
	 */
	static void ReconstructRotation(class FQuat& Out, const BYTE* Stream, INT KeyIndex, AnimationCompressionFormat RotationCompressionFormat, const FLOAT *Mins, const FLOAT *Ranges);

	/**
	 * Decompresses a translation key from the specified compressed translation track.
	 */
	static void ReconstructTranslation(class FVector& Out, const BYTE* Stream, INT KeyIndex);

	/**
	 * Decompresses a rotation key from the specified compressed rotation track.
	 */
	static void ReconstructRotation(class FQuat& Out, const BYTE* Stream, INT KeyIndex, UBOOL bTrackHasCompressionInfo, AnimationCompressionFormat RotationCompressionFormat);

	/**
	 * Populates the key reduced arrays from raw animation data.
	 */
	static void SeparateRawDataToTracks(const TArray<FRawAnimSequenceTrack>& RawAnimData,
										FLOAT SequenceLength,
										TArray<FTranslationTrack>& OutTranslationData,
										TArray<FRotationTrack>& OutRotationData);

	/**
	 * Interpolate keyframes in this sequence to find the bone transform (relative to parent).
	 *
	 * @param	OutAtom			[out] Output bone transform.
	 * @param	TrackIndex		Index of track to interpolate.
	 * @param	Time			Time on track to interpolate to.
	 * @param	bLooping		TRUE if the animation is looping.
	 * @param	bUseRawData		If TRUE, use raw animation data instead of compressed data.
	 * @param	CurveKeys		List of Curve Keys if exists
	 */
	void GetBoneAtom(FBoneAtom& OutAtom, INT TrackIndex, FLOAT Time, UBOOL bLooping, UBOOL bUseRawData, FCurveKeyArray* CurveKeys = NULL) const;
	
	/**
	 * Interpolate keyframes in this sequence to find the bone transform (relative to parent).
	 * This returns the base pose used to create the additive animation.
	 *
	 * @param	OutAtom			[out] Output bone transform.
	 * @param	TrackIndex		Index of track to interpolate.
	 * @param	Time			Time on track to interpolate to.
	 * @param	bLooping		TRUE if the animation is looping.
	 */
	void GetAdditiveBasePoseBoneAtom(FBoneAtom& OutAtom, INT TrackIndex, FLOAT Time, UBOOL bLooping) const;

	/**
	 * Interpolate curve weights of the Time in this sequence if curve data exists
	 *
	 * @param	Time			Time on track to interpolate to.
	 * @param	bLooping		TRUE if the animation is looping.
	 * @param	CurveKeys		Add the curve keys if exists
	 */
	void GetCurveData(FLOAT Time, UBOOL bLooping, FCurveKeyArray& CurveKeys) const;

	/** Sort the Notifies array by time, earliest first. */
	void SortNotifies();

	/**
	 * @return		A reference to the AnimSet this sequence belongs to.
	 */
	UAnimSet* GetAnimSet() const;

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	virtual INT GetResourceSize();

	/**
	 * @return		The approximate size of raw animation data.
	 */
	INT GetApproxRawSize() const;

	/**
	 * @return		The approximate size of key-reduced animation data.
	 */
	INT GetApproxReducedSize() const;

	/**
	 * @return		The approximate size of compressed animation data.
	 */
	INT GetApproxCompressedSize() const;

	/**
	 * Crops the raw anim data either from Start to CurrentTime or CurrentTime to End depending on
	 * value of bFromStart.  Can't be called against cooked data.
	 *
	 * @param	CurrentTime		marker for cropping (either beginning or end)
	 * @param	bFromStart		whether marker is begin or end marker
	 * @return					TRUE if the operation was successful.
	 */
	UBOOL CropRawAnimData( FLOAT CurrentTime, UBOOL bFromStart );
	/** 
	 *  Utility function for lossless compression of a FRawAnimSequenceTrack 
	 *  @return TRUE if keys were removed.
	 **/
	UBOOL CompressRawAnimSequenceTrack(FRawAnimSequenceTrack& RawTrack, float MaxPosDiff, float MaxAngleDiff);
	/**
	 * Removes trivial frames -- frames of tracks when position or orientation is constant
	 * over the entire animation -- from the raw animation data.  If both position and rotation
	 * go down to a single frame, the time is stripped out as well.
	 * @return TRUE if keys were removed.
	 */
	UBOOL CompressRawAnimData(float MaxPosDiff, float MaxAngleDiff);
	/**
	 * Removes trivial frames -- frames of tracks when position or orientation is constant
	 * over the entire animation -- from the raw animation data.  If both position and rotation
	 * go down to a single frame, the time is stripped out as well.
	 * @return TRUE if keys were removed.
	 */
	UBOOL CompressRawAnimData();

	/** Clears any data in the AnimSequence, so it can be recycled when importing a new animation with same name over it. */
	void RecycleAnimSequence();

	/** 
	 * Clear references to additive animations.
	 * This is the following arrays: AdditiveBasePoseAnimSeq, AdditiveTargetPoseAnimSeq and RelatedAdditiveAnimSeqs.
	 * Handles dependencies, and removes us properly.
	 */
	void ClearAdditiveAnimReferences();
	void FixUpBadAnimNotifiers();

	static UBOOL CopyAnimSequenceProperties(UAnimSequence* SourceAnimSeq, UAnimSequence* DestAnimSeq, UBOOL bSkipCopyingNotifies=FALSE);
	static void CopyMetadata(UAnimSequence* SourceAnimSeq, UAnimSequence* DestAnimSeq);
	static UBOOL CopyNotifies(UAnimSequence* SourceAnimSeq, UAnimSequence* DestAnimSeq);
};

class UAnimationCompressionAlgorithm : public UObject
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm
    FStringNoInit Description;
    BITFIELD bNeedsSkeleton:1;
    SCRIPT_ALIGN;
    BYTE TranslationCompressionFormat;
    BYTE RotationCompressionFormat;
    SCRIPT_ALIGN;
    //## END PROPS AnimationCompressionAlgorithm

    DECLARE_ABSTRACT_CLASS(UAnimationCompressionAlgorithm,UObject,0,Engine)
public:
	/**
	 * Reduce the number of keyframes and bitwise compress the specified sequence.
	 *
	 * @param	AnimSeq		The animation sequence to compress.
	 * @param	SkelMesh	The skeletal mesh against which to compress the animation.  Not needed by all compression schemes.
	 * @param	bOutput		If FALSE don't generate output or compute memory savings.
	 * @return				FALSE if a skeleton was needed by the algorithm but not provided.
	 */
	UBOOL Reduce(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, UBOOL bOutput);

	/**
	 * Reduce the number of keyframes and bitwise compress all sequences in the specified animation set.
	 *
	 * @param	AnimSet		The animation set to compress.
	 * @param	SkelMesh	The skeletal mesh against which to compress the animation.  Not needed by all compression schemes.
	 * @param	bOutput		If FALSE don't generate output or compute memory savings.
	 * @return				FALSE if a skeleton was needed by the algorithm but not provided.
	 */
	UBOOL Reduce(class UAnimSet* AnimSet, class USkeletalMesh* SkelMesh, UBOOL bOutput);

protected:
	/**
	 * Implemented by child classes, this function reduces the number of keyframes in
	 * the specified sequence, given the specified skeleton (if needed).
	 *
	 * @return		TRUE if the keyframe reduction was successful.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData) PURE_VIRTUAL(UAnimationCompressionAlgorithm::DoReduction,);

	/**
	 * Common compression utility to remove 'redundant' position keys in a set of tracks based on the provided delta threshold
	 *
	 * @param	InputTracks		Array of position track elements to reduce
	 * @param	MaxPosDelta		Maximum local-space threshold for stationary motion
	 */
	static void FilterTrivialPositionKeys(
		TArray<struct FTranslationTrack>& Track,
		FLOAT MaxPosDelta);

	/**
	 * Common compression utility to remove 'redundant' position keys in a single track based on the provided delta threshold
	 *
	 * @param	Track			Track to reduce
	 * @param	MaxPosDelta		Maximum local-space threshold for stationary motion
	 */
	static void FilterTrivialPositionKeys(
		struct FTranslationTrack& Track,
		FLOAT MaxPosDelta);

	/**
	 * Common compression utility to remove 'redundant' rotation keys in a set of tracks based on the provided delta threshold
	 *
	 * @param	InputTracks		Array of rotation track elements to reduce
	 * @param	MaxRotDelta		Maximum angle threshold to consider stationary motion
	 */
	static void FilterTrivialRotationKeys(
		TArray<struct FRotationTrack>& InputTracks,
		FLOAT MaxRotDelta);

	/**
	 * Common compression utility to remove 'redundant' rotation keys in a set of tracks based on the provided delta threshold
	 *
	 * @param	Track			Track to reduce
	 * @param	MaxRotDelta		Maximum angle threshold to consider stationary motion
	 */
	static void FilterTrivialRotationKeys(
		struct FRotationTrack& Track,
		FLOAT MaxRotDelta);

	/**
	 * Common compression utility to remove 'redundant' keys based on the provided delta thresholds
	 *
	 * @param	PositionTracks	Array of position track elements to reduce
	 * @param	RotationTracks	Array of rotation track elements to reduce
	 * @param	MaxPosDelta		Maximum local-space threshold for stationary motion
	 * @param	MaxRotDelta		Maximum angle threshold to consider stationary motion
	 */
	static void FilterTrivialKeys(
		TArray<struct FTranslationTrack>& PositionTracks,
		TArray<struct FRotationTrack>& RotationTracks,
		FLOAT MaxPosDelta,
		FLOAT MaxRotDelta);

	/** 
	 * Remove translation keys from tracks marked bAnimRotationOnly.
	 *
	 * @param PositionTracks	Array of position track elements to reduce
	 * @param AnimSeq			AnimSequence the track is from.
	 * @param SkelMesh			SkeletalMesh associated with the AnimSerquence 
	 */
	static void FilterAnimRotationOnlyKeys(TArray<FTranslationTrack>& PositionTracks, UAnimSequence* AnimSeq, USkeletalMesh* SkelMesh);

	/**
	 * Common compression utility to retain only intermittent position keys. For example,
	 * calling with an Interval of 3 would keep every third key in the set and discard the rest
	 *
	 * @param	PositionTracks	Array of position track elements to reduce
	 * @param	StartIndex		Index at which to begin reduction
	 * @param	Interval		Interval of keys to retain
	 */
	static void FilterIntermittentPositionKeys(
		TArray<struct FTranslationTrack>& PositionTracks,
		INT StartIndex,
		INT Interval);

	/**
	 * Common compression utility to retain only intermittent position keys. For example,
	 * calling with an Interval of 3 would keep every third key in the set and discard the rest
	 *
	 * @param	Track			Track to reduce
	 * @param	StartIndex		Index at which to begin reduction
	 * @param	Interval		Interval of keys to retain
	 */
	static void FilterIntermittentPositionKeys(
		struct FTranslationTrack& Track,
		INT StartIndex,
		INT Interval);

	/**
	 * Common compression utility to retain only intermittent rotation keys. For example,
	 * calling with an Interval of 3 would keep every third key in the set and discard the rest
	 *
	 * @param	RotationTracks	Array of rotation track elements to reduce
	 * @param	StartIndex		Index at which to begin reduction
	 * @param	Interval		Interval of keys to retain
	 */
	static void FilterIntermittentRotationKeys(
		TArray<struct FRotationTrack>& RotationTracks,
		INT StartIndex,
		INT Interval);

	/**
	 * Common compression utility to retain only intermittent rotation keys. For example,
	 * calling with an Interval of 3 would keep every third key in the set and discard the rest
	 *
	 * @param	Track			Track to reduce
	 * @param	StartIndex		Index at which to begin reduction
	 * @param	Interval		Interval of keys to retain
	 */
	static void FilterIntermittentRotationKeys(
		struct FRotationTrack& Track,
		INT StartIndex,
		INT Interval);

	/**
	 * Common compression utility to retain only intermittent animation keys. For example,
	 * calling with an Interval of 3 would keep every third key in the set and discard the rest
	 *
	 * @param	PositionTracks	Array of position track elements to reduce
	 * @param	RotationTracks	Array of rotation track elements to reduce
	 * @param	StartIndex		Index at which to begin reduction
	 * @param	Interval		Interval of keys to retain
	 */
	static void FilterIntermittentKeys(
		TArray<struct FTranslationTrack>& PositionTracks,
		TArray<struct FRotationTrack>& RotationTracks,
		INT StartIndex,
		INT Interval);

	/**
	 * Common compression utility to populate individual rotation and translation track
	 * arrays from a set of raw animation tracks. Used as a precurser to animation compression.
	 *
	 * @param	RawAnimData			Array of raw animation tracks
	 * @param	SequenceLength		The duration of the animation in seconds
	 * @param	OutTranslationData	Translation tracks to fill
	 * @param	OutRotationData		Rotation tracks to fill
	 */
	static void SeparateRawDataIntoTracks(
		const TArray<struct FRawAnimSequenceTrack>& RawAnimData,
		FLOAT SequenceLength,
		TArray<struct FTranslationTrack>& OutTranslationData,
		TArray<struct FRotationTrack>& OutRotationData);

	/**
	 * Common compression utility to walk an array of rotation tracks and enforce
	 * that all adjacent rotation keys are represented by shortest-arc quaternion pairs.
	 *
	 * @param	RotationData	Array of rotation track elements to reduce.
	 */
	static void PrecalculateShortestQuaternionRoutes(TArray<struct FRotationTrack>& RotationData);

public:

	/**
	 * Encodes individual key arrays into an AnimSequence using the desired bit packing formats.
	 *
	 * @param	Seq							Pointer to an Animation Sequence which will contain the bit-packed data .
	 * @param	TargetTranslationFormat		The format to use when encoding translation keys.
	 * @param	TargetRotationFormat		The format to use when encoding rotation keys.
	 * @param	TranslationData				Translation Tracks to bit-pack into the Animation Sequence.
	 * @param	RotationData				Rotation Tracks to bit-pack into the Animation Sequence.
	 * @param	IncludeKeyTable				TRUE if the compressed data should also contain a table of frame indices for each key. (required by some codecs)
	 */
	static void BitwiseCompressAnimationTracks(
		class UAnimSequence* Seq,
		AnimationCompressionFormat TargetTranslationFormat,
		AnimationCompressionFormat TargetRotationFormat,
		const TArray<struct FTranslationTrack>& TranslationData,
		const TArray<struct FRotationTrack>& RotationData,
		UBOOL IncludeKeyTable = FALSE);
};

class UAnimationCompressionAlgorithm_Automatic : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_Automatic
    FLOAT MaxEndEffectorError;
    BITFIELD bTryFixedBitwiseCompression:1;
    BITFIELD bTryPerTrackBitwiseCompression:1;
    BITFIELD bTryLinearKeyRemovalCompression:1;
    BITFIELD bTryIntervalKeyRemoval:1;
    BITFIELD bRunCurrentDefaultCompressor:1;
    BITFIELD bAutoReplaceIfExistingErrorTooGreat:1;
    BITFIELD bRaiseMaxErrorToExisting:1;
    SCRIPT_ALIGN;
    //## END PROPS AnimationCompressionAlgorithm_Automatic

    DECLARE_CLASS(UAnimationCompressionAlgorithm_Automatic,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Animation compression algorithm that optionally:
	 *   1) Forcefully removes a portion of keys (every other key, 2 out of every 3, etc...)
	 *   2) Removes any keys which can be linearly approximated by neighboring keys
	 * but always packs each track using per-track compression settings.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

class UAnimationCompressionAlgorithm_BitwiseCompressOnly : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_BitwiseCompressOnly
    //## END PROPS AnimationCompressionAlgorithm_BitwiseCompressOnly

    DECLARE_CLASS(UAnimationCompressionAlgorithm_BitwiseCompressOnly,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Bitwise animation compression only; performs no key reduction.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

class UAnimationCompressionAlgorithm_LeastDestructive : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_LeastDestructive
    //## END PROPS AnimationCompressionAlgorithm_LeastDestructive

    DECLARE_CLASS(UAnimationCompressionAlgorithm_LeastDestructive,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Uses the Bitwise compressor, with really light settings, so it acts pretty close to "no compression at all"
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

class UAnimationCompressionAlgorithm_RemoveEverySecondKey : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_RemoveEverySecondKey
    INT MinKeys;
    BITFIELD bStartAtSecondKey:1;
    SCRIPT_ALIGN;
    //## END PROPS AnimationCompressionAlgorithm_RemoveEverySecondKey

    DECLARE_CLASS(UAnimationCompressionAlgorithm_RemoveEverySecondKey,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Keyframe reduction algorithm that simply removes every second key.
	 *
	 * @return		TRUE if the keyframe reduction was successful.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

class UAnimationCompressionAlgorithm_RemoveLinearKeys : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_RemoveLinearKeys
    FLOAT MaxPosDiff;
    FLOAT MaxAngleDiff;
    FLOAT MaxEffectorDiff;
    FLOAT MinEffectorDiff;
    FLOAT EffectorDiffSocket;
    FLOAT ParentKeyScale;
    BITFIELD bRetarget:1;
    BITFIELD bActuallyFilterLinearKeys:1;
    SCRIPT_ALIGN;
    //## END PROPS AnimationCompressionAlgorithm_RemoveLinearKeys

    DECLARE_CLASS(UAnimationCompressionAlgorithm_RemoveLinearKeys,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Keyframe reduction algorithm that removes any keys which can be linearly approximated by neighboring keys.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);

	/**
	 * Pre-filters the tracks before running the main key removal algorithm
	 */
	virtual void FilterBeforeMainKeyRemoval(
		UAnimSequence* AnimSeq, 
		USkeletalMesh* SkelMesh, 
		const struct FAnimSetMeshLinkup& AnimLinkup,
		const TArray<FBoneData>& BoneData, 
		TArray<FTranslationTrack>& TranslationData,
		TArray<FRotationTrack>& RotationData);

	/**
	 * Compresses the tracks passed in using the underlying compressor for this key removal codec
	 */
	virtual void CompressUsingUnderlyingCompressor(
		UAnimSequence* AnimSeq, 
		USkeletalMesh* SkelMesh,
		const struct FAnimSetMeshLinkup& AnimLinkup,
		const TArray<FBoneData>& BoneData, 
		const TArray<FTranslationTrack>& TranslationData,
		const TArray<FRotationTrack>& RotationData,
		const UBOOL bFinalPass);

	/**
	  * Updates the world bone transforms for a range of bone indices
	  */
	void UpdateWorldBoneTransformRange(
		UAnimSequence* AnimSeq, 
		USkeletalMesh* SkelMesh, 
		const TArray<FBoneData>& BoneData, 
		const struct FAnimSetMeshLinkup& AnimLinkup,
		const TArray<FMeshBone>& RefSkel,
		const TArray<FTranslationTrack>& PositionTracks,
		const TArray<FRotationTrack>& RotationTracks,
		INT StartingBoneIndex,
		INT EndingBoneIndex,
		UBOOL UseRaw,
		TArray<FMatrix>& OutputWorldBones);

	/**
	 * To guide the key removal process, we need to maintain a table of world transforms
	 * for the bones we are investigating. This helper function fills a row of the 
	 * table for a specified bone.
	 */
	void UpdateWorldBoneTransformTable(
		UAnimSequence* AnimSeq, 
		USkeletalMesh* SkelMesh, 
		const TArray<FBoneData>& BoneData, 
		const struct FAnimSetMeshLinkup& AnimLinkup,
		const TArray<FMeshBone>& RefSkel,
		INT BoneIndex,
		UBOOL UseRaw,
		TArray<FMatrix>& OutputWorldBones);

	/**
	 * Creates a list of the bone atom result for every frame of a given track
	 */
	static void UpdateBoneAtomList(
		UAnimSequence* AnimSeq, 
		INT BoneIndex,
		INT TrackIndex,
		INT NumFrames,
		FLOAT TimePerFrame,
		TArray<FBoneAtom>& BoneAtoms,
		const struct FAnimSetMeshLinkup& AnimLinkup,
		const TArray<FMeshBone>& RefSkel);

	/**
	 * If the passed in animation sequence is additive, converts it to absolute (using the frame 0 pose) and returns TRUE
	 * (indicating it should be converted back to relative later with ConvertToRelativeSpace)
	 *
	 * @param AnimSeq			The animation sequence being compressed
	 *
	 * @return TRUE if the animation was additive and has been converted to absolute space.
	 */
	UBOOL ConvertFromRelativeSpace(UAnimSequence* AnimSeq, const struct FAnimSetMeshLinkup& AnimLinkup);

	/**
	 * Converts an absolute animation sequence to a relative (additive) one.
	 *
	 * @param AnimSeq			The animation sequence being compressed
	 * @param TranslationData	Translation Tracks to convert to relative space
	 * @param RotationData		Rotation Tracks  to convert to relative space
	 *
	 */
	void ConvertToRelativeSpace(UAnimSequence* AnimSeq, TArray<FTranslationTrack>& TranslationData, TArray<FRotationTrack>& RotationData, const struct FAnimSetMeshLinkup& AnimLinkup);

	/**
	 * Locates spans of keys within the position and rotation tracks provided which can be estimated
	 * through linear interpolation of the surrounding keys. The remaining key values are bit packed into
	 * the animation sequence provided
	 *
	 * @param	AnimSeq		The animation sequence being compressed
	 * @param	SkelMesh	The skeletal mesh to use to guide the compressor
	 * @param	AnimLinkup	The linkup between skeletal mesh an animation
	 * @param	BoneData	BoneData array describing the hierarchy of the animated skeleton
	 * @param	TranslationData		Translation Tracks to compress and bit-pack into the Animation Sequence.
	 * @param	RotationData		Rotation Tracks to compress and bit-pack into the Animation Sequence.
	 * @return				None.
	 */
	void ProcessAnimationTracks(
		UAnimSequence* AnimSeq, 
		USkeletalMesh* SkelMesh, 
		const struct FAnimSetMeshLinkup& AnimLinkup,
		const TArray<FBoneData>& BoneData, 
		TArray<FTranslationTrack>& PositionTracks,
		TArray<FRotationTrack>& RotationTracks);
};

class UAnimationCompressionAlgorithm_PerTrackCompression : public UAnimationCompressionAlgorithm_RemoveLinearKeys
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_PerTrackCompression
    FLOAT MaxZeroingThreshold;
    FLOAT MaxPosDiffBitwise;
    FLOAT MaxAngleDiffBitwise;
    TArrayNoInit<BYTE> AllowedRotationFormats;
    TArrayNoInit<BYTE> AllowedTranslationFormats;
    BITFIELD bResampleAnimation:1;
    BITFIELD bUseAdaptiveError:1;
    BITFIELD bUseOverrideForEndEffectors:1;
    BITFIELD bUseAdaptiveError2:1;
    FLOAT ResampledFramerate;
    INT MinKeysForResampling;
    INT TrackHeightBias;
    FLOAT ParentingDivisor;
    FLOAT ParentingDivisorExponent;
    FLOAT RotationErrorSourceRatio;
    FLOAT TranslationErrorSourceRatio;
    FLOAT MaxErrorPerTrackRatio;
    FLOAT PerturbationProbeSize;
    struct FPerTrackCachedInfo* PerReductionCachedData;
    //## END PROPS AnimationCompressionAlgorithm_PerTrackCompression

    DECLARE_CLASS(UAnimationCompressionAlgorithm_PerTrackCompression,UAnimationCompressionAlgorithm_RemoveLinearKeys,0,Engine)
protected:
	/**
	 * Animation compression algorithm that optionally:
	 *   1) Forcefully removes a portion of keys (every other key, 2 out of every 3, etc...)
	 *   2) Removes any keys which can be linearly approximated by neighboring keys
	 * but always packs each track using per-track compression settings.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);

	/**
	 * Compresses the tracks passed in using the underlying compressor for this key removal codec
	 */
	virtual void CompressUsingUnderlyingCompressor(
		UAnimSequence* AnimSeq,
		USkeletalMesh* SkelMesh,
		const struct FAnimSetMeshLinkup& AnimLinkup,
		const TArray<FBoneData>& BoneData, 
		const TArray<FTranslationTrack>& TranslationData,
		const TArray<FRotationTrack>& RotationData,
		const UBOOL bFinalPass);

	/**
	 * Pre-filters the tracks before running the main key removal algorithm
	 */
	virtual void FilterBeforeMainKeyRemoval(
		UAnimSequence* AnimSeq, 
		USkeletalMesh* SkelMesh, 
		const struct FAnimSetMeshLinkup& AnimLinkup,
		const TArray<FBoneData>& BoneData, 
		TArray<FTranslationTrack>& TranslationData,
		TArray<FRotationTrack>& RotationData);
};

class UAnimationCompressionAlgorithm_RemoveTrivialKeys : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_RemoveTrivialKeys
    FLOAT MaxPosDiff;
    FLOAT MaxAngleDiff;
    //## END PROPS AnimationCompressionAlgorithm_RemoveTrivialKeys

    DECLARE_CLASS(UAnimationCompressionAlgorithm_RemoveTrivialKeys,UAnimationCompressionAlgorithm,0,Engine)
protected:
	/**
	 * Removes trivial frames -- frames of tracks when position or orientation is constant
	 * over the entire animation -- from the raw animation data.  If both position and rotation
	 * go down to a single frame, the time is stripped out as well.
	 *
	 * @return		TRUE if the keyframe reduction was successful.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

class UDEPRECATED_AnimationCompressionAlgorithm_RevertToRaw : public UAnimationCompressionAlgorithm
{
public:
    //## BEGIN PROPS AnimationCompressionAlgorithm_RevertToRaw
    //## END PROPS AnimationCompressionAlgorithm_RevertToRaw

    DECLARE_CLASS(UDEPRECATED_AnimationCompressionAlgorithm_RevertToRaw,UAnimationCompressionAlgorithm,0|CLASS_Deprecated,Engine)
protected:
	/**
	 * Reverts any animation compression, restoring the animation to the raw data.
	 */
	virtual void DoReduction(class UAnimSequence* AnimSeq, class USkeletalMesh* SkelMesh, const TArray<class FBoneData>& BoneData);
};

class UAnimMetaData : public UObject
{
public:
    //## BEGIN PROPS AnimMetaData
    //## END PROPS AnimMetaData

    DECLARE_ABSTRACT_CLASS(UAnimMetaData,UObject,0,Engine)
	virtual void AnimSet(UAnimNodeSequence* SeqNode);
	virtual void AnimUnSet(UAnimNodeSequence* SeqNode);
	virtual void TickMetaData(UAnimNodeSequence* SeqNode);
};

class UAnimMetaData_SkelControl : public UAnimMetaData
{
public:
    //## BEGIN PROPS AnimMetaData_SkelControl
    TArrayNoInit<FName> SkelControlNameList;
    BITFIELD bFullControlOverController:1;
    FName SkelControlName_DEPRECATED;
    //## END PROPS AnimMetaData_SkelControl

    DECLARE_CLASS(UAnimMetaData_SkelControl,UAnimMetaData,0,Engine)
	virtual void PostLoad();
	virtual void AnimSet(UAnimNodeSequence* SeqNode);
	virtual void AnimUnSet(UAnimNodeSequence* SeqNode);
	virtual void TickMetaData(UAnimNodeSequence* SeqNode);
	virtual UBOOL ShouldCallSkelControlTick(USkelControlBase* SkelControl, UAnimNodeSequence* SeqNode);
	virtual void SkelControlTick(USkelControlBase* SkelControl, UAnimNodeSequence* SeqNode);
};

class UAnimMetaData_SkelControlKeyFrame : public UAnimMetaData_SkelControl
{
public:
    //## BEGIN PROPS AnimMetaData_SkelControlKeyFrame
    TArrayNoInit<struct FTimeModifier> KeyFrames;
    //## END PROPS AnimMetaData_SkelControlKeyFrame

    DECLARE_CLASS(UAnimMetaData_SkelControlKeyFrame,UAnimMetaData_SkelControl,0,Engine)
	virtual void SkelControlTick(USkelControlBase* SkelControl, UAnimNodeSequence* SeqNode);
};

class UAnimNotify : public UObject
{
public:
    //## BEGIN PROPS AnimNotify
#if WITH_EDITORONLY_DATA
    FColor NotifyColor;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS AnimNotify

    DECLARE_ABSTRACT_CLASS(UAnimNotify,UObject,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq ) {}
	virtual void NotifyTick( class UAnimNodeSequence* NodeSeq, FLOAT AnimCurrentTime, FLOAT AnimTimeStep, FLOAT InTotalDuration ) {}
	virtual void NotifyEnd( class UAnimNodeSequence* NodeSeq, FLOAT AnimCurrentTime ) {}

	virtual FString GetEditorComment() 
	{ 
		return TEXT(""); 
	}
	virtual FColor GetEditorColor() 
	{ 
#if WITH_EDITORONLY_DATA
		return NotifyColor; 
#else
		return FColor( 0 );
#endif // WITH_EDITORONLY_DATA
	}

	/**
	 *	Called by the AnimSet viewer when the 'parent' FAnimNotifyEvent is edited.
	 *
	 *	@param	NodeSeq			The AnimNodeSequence this notify is associated with.
	 *	@param	OwnerEvent		The FAnimNotifyEvent that 'owns' this AnimNotify.
	 */
	virtual void AnimNotifyEventChanged(class UAnimNodeSequence* NodeSeq, FAnimNotifyEvent* OwnerEvent) {}
};

class UAnimNotify_CameraEffect : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_CameraEffect
    class UClass* CameraLensEffect;
    //## END PROPS AnimNotify_CameraEffect

    DECLARE_CLASS(UAnimNotify_CameraEffect,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
	virtual FString GetEditorComment() { return TEXT("CameraEffect"); }
};

class UAnimNotify_ClothingMaxDistanceScale : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_ClothingMaxDistanceScale
    FLOAT StartScale;
    FLOAT EndScale;
    BYTE ScaleMode;
    FLOAT Duration;
    //## END PROPS AnimNotify_ClothingMaxDistanceScale

    DECLARE_CLASS(UAnimNotify_ClothingMaxDistanceScale,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
	virtual void NotifyEnd( class UAnimNodeSequence* NodeSeq, FLOAT AnimCurrentTime );
	
	/**
	 *	Called by the AnimSet viewer when the 'parent' FAnimNotifyEvent is edited.
	 *
	 *	@param	NodeSeq			The AnimNodeSequence this notify is associated with.
	 *	@param	OwnerEvent		The FAnimNotifyEvent that 'owns' this AnimNotify.
	 */
	virtual void AnimNotifyEventChanged(class UAnimNodeSequence* NodeSeq, FAnimNotifyEvent* OwnerEvent);
};

class UAnimNotify_Footstep : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Footstep
    INT FootDown;
    //## END PROPS AnimNotify_Footstep

    DECLARE_CLASS(UAnimNotify_Footstep,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
	virtual FString GetEditorComment() { return (FootDown == 0) ? TEXT("Left Footstep") : TEXT("Right Footstep"); }
};

class UAnimNotify_ForceField : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_ForceField
    class UNxForceFieldComponent* ForceFieldComponent;
    BITFIELD bAttach:1;
    FName SocketName;
    FName BoneName;
    //## END PROPS AnimNotify_ForceField

    DECLARE_CLASS(UAnimNotify_ForceField,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
	virtual FString GetEditorComment() { return TEXT("ForceField"); }
};

class UAnimNotify_Kismet : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Kismet
    FName NotifyName;
    //## END PROPS AnimNotify_Kismet

    DECLARE_CLASS(UAnimNotify_Kismet,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
	virtual FString GetEditorComment() { return TEXT("Kismet"); }
};

class UAnimNotify_PlayParticleEffect : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_PlayParticleEffect
    class UParticleSystem* PSTemplate;
    BITFIELD bIsExtremeContent:1;
    BITFIELD bAttach:1;
    BITFIELD bPreview:1;
    BITFIELD bSkipIfOwnerIsHidden:1;
    class UParticleSystem* PSNonExtremeContentTemplate;
    FName SocketName;
    FName BoneName;
    FName BoneSocketModuleActorName;
    //## END PROPS AnimNotify_PlayParticleEffect

    DECLARE_CLASS(UAnimNotify_PlayParticleEffect,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
	virtual FString GetEditorComment() { return TEXT("VFX"); }
};

class UAnimNotify_Rumble : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Rumble
    class UClass* PredefinedWaveForm;
    class UForceFeedbackWaveform* WaveForm;
    BITFIELD bCheckForBasedPlayer:1;
    FLOAT EffectRadius;
    //## END PROPS AnimNotify_Rumble

    DECLARE_CLASS(UAnimNotify_Rumble,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
	virtual FString GetEditorComment() { return TEXT("Rumble"); }
};

class UAnimNotify_Script : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Script
    FName NotifyName;
    FName NotifyTickName;
    FName NotifyEndName;
    //## END PROPS AnimNotify_Script

    DECLARE_CLASS(UAnimNotify_Script,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
	virtual void NotifyTick( class UAnimNodeSequence* NodeSeq, FLOAT AnimCurrentTime, FLOAT AnimTimeStep, FLOAT InTotalDuration );
	virtual void NotifyEnd( class UAnimNodeSequence* NodeSeq, FLOAT AnimCurrentTime );
	virtual FString GetEditorComment() { return (NotifyName == NAME_None) ? TEXT("Script") : NotifyName.ToString(); }
};

struct AnimNotify_Scripted_eventNotifyEnd_Parms
{
    class AActor* Owner;
    class UAnimNodeSequence* AnimSeqInstigator;
    AnimNotify_Scripted_eventNotifyEnd_Parms(EEventParm)
    {
    }
};
struct AnimNotify_Scripted_eventNotify_Parms
{
    class AActor* Owner;
    class UAnimNodeSequence* AnimSeqInstigator;
    AnimNotify_Scripted_eventNotify_Parms(EEventParm)
    {
    }
};
class UAnimNotify_Scripted : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Scripted
    //## END PROPS AnimNotify_Scripted

    void eventNotifyEnd(class AActor* Owner,class UAnimNodeSequence* AnimSeqInstigator)
    {
        AnimNotify_Scripted_eventNotifyEnd_Parms Parms(EC_EventParm);
        Parms.Owner=Owner;
        Parms.AnimSeqInstigator=AnimSeqInstigator;
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyEnd),&Parms);
    }
    void eventNotify(class AActor* Owner,class UAnimNodeSequence* AnimSeqInstigator)
    {
        AnimNotify_Scripted_eventNotify_Parms Parms(EC_EventParm);
        Parms.Owner=Owner;
        Parms.AnimSeqInstigator=AnimSeqInstigator;
        ProcessEvent(FindFunctionChecked(ENGINE_Notify),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(UAnimNotify_Scripted,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
	virtual void NotifyEnd( class UAnimNodeSequence* NodeSeq, FLOAT AnimCurrentTime );
};

class UAnimNotify_PawnMaterialParam : public UAnimNotify_Scripted
{
public:
    //## BEGIN PROPS AnimNotify_PawnMaterialParam
    TArrayNoInit<struct FScalarParameterInterpStruct> ScalarParameterInterpArray;
    //## END PROPS AnimNotify_PawnMaterialParam

    DECLARE_CLASS(UAnimNotify_PawnMaterialParam,UAnimNotify_Scripted,0,Engine)
	virtual FString GetEditorComment() { return TEXT("MatParam"); }
};

class UAnimNotify_ViewShake : public UAnimNotify_Scripted
{
public:
    //## BEGIN PROPS AnimNotify_ViewShake
    FLOAT Duration;
    FVector RotAmplitude;
    FVector RotFrequency;
    FVector LocAmplitude;
    FVector LocFrequency;
    FLOAT FOVAmplitude;
    FLOAT FOVFrequency;
    BITFIELD bDoControllerVibration:1;
    BITFIELD bUseBoneLocation:1;
    FLOAT ShakeRadius;
    FName BoneName;
    class UCameraShake* ShakeParams;
    //## END PROPS AnimNotify_ViewShake

    DECLARE_CLASS(UAnimNotify_ViewShake,UAnimNotify_Scripted,0,Engine)
	virtual void PostLoad();
	virtual FString GetEditorComment() { return TEXT("CameraShake"); }
};

class UAnimNotify_Sound : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Sound
    class USoundCue* SoundCue;
    BITFIELD bFollowActor:1;
    BITFIELD bIgnoreIfActorHidden:1;
    FName BoneName;
    FLOAT PercentToPlay;
    FLOAT VolumeMultiplier;
    FLOAT PitchMultiplier;
    //## END PROPS AnimNotify_Sound

    DECLARE_CLASS(UAnimNotify_Sound,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );

	virtual FString GetEditorComment() { return TEXT("Snd"); }
};

struct FTrailSocketSamplePoint
{
    FVector Position;
    FVector Velocity;

    /** Constructors */
    FTrailSocketSamplePoint() {}
    FTrailSocketSamplePoint(EEventParm)
    {
        appMemzero(this, sizeof(FTrailSocketSamplePoint));
    }
};

struct FTrailSamplePoint
{
    FLOAT RelativeTime;
    struct FTrailSocketSamplePoint FirstEdgeSample;
    struct FTrailSocketSamplePoint ControlPointSample;
    struct FTrailSocketSamplePoint SecondEdgeSample;

    /** Constructors */
    FTrailSamplePoint() {}
    FTrailSamplePoint(EEventParm)
    {
        appMemzero(this, sizeof(FTrailSamplePoint));
    }
};

struct FTrailSample
{
    FLOAT RelativeTime;
    FVector FirstEdgeSample;
    FVector ControlPointSample;
    FVector SecondEdgeSample;

    /** Constructors */
    FTrailSample() {}
    FTrailSample(EEventParm)
    {
        appMemzero(this, sizeof(FTrailSample));
    }
};

class UAnimNotify_Trails : public UAnimNotify
{
public:
    //## BEGIN PROPS AnimNotify_Trails
    class UParticleSystem* PSTemplate;
#if WITH_EDITORONLY_DATA
    class USkeletalMesh* SampledSkeletalMesh;
#endif // WITH_EDITORONLY_DATA
    BITFIELD bIsExtremeContent:1;
    BITFIELD bPreview:1;
    BITFIELD bPreviewForceExplicit:1;
    BITFIELD bSkipIfOwnerIsHidden:1;
    BITFIELD bResampleRequired:1;
    FName FirstEdgeSocketName;
    FName ControlPointSocketName;
    FName SecondEdgeSocketName;
    FLOAT LastStartTime;
    FLOAT EndTime;
    FLOAT SampleTimeStep_DEPRECATED;
    TArrayNoInit<struct FTrailSamplePoint> TrailSampleData_DEPRECATED;
    FLOAT SamplesPerSecond;
    TArrayNoInit<struct FTrailSample> TrailSampledData;
    FLOAT CurrentTime;
    FLOAT TimeStep;
    class UAnimNodeSequence* AnimNodeSeq;
    //## END PROPS AnimNotify_Trails

    virtual INT GetNumSteps(INT InLastTrailIndex) const;
    DECLARE_FUNCTION(execGetNumSteps)
    {
        P_GET_INT(InLastTrailIndex);
        P_FINISH;
        *(INT*)Result=this->GetNumSteps(InLastTrailIndex);
    }
    DECLARE_CLASS(UAnimNotify_Trails,UAnimNotify,0,Engine)
	// UObject interfrace.
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();

	// AnimNotify interface.
	virtual void Notify(class UAnimNodeSequence* NodeSeq);
	virtual void NotifyTick(class UAnimNodeSequence* NodeSeq, FLOAT AnimCurrentTime, FLOAT AnimTimeStep, FLOAT InTotalDuration);
	virtual void NotifyEnd(class UAnimNodeSequence* NodeSeq, FLOAT AnimCurrentTime);

protected:
	enum ETrailNotifyType
	{
		TrailNotifyType_Start,
		TrailNotifyType_Tick,
		TrailNotifyType_End
	};

	/**
	 *	Handle the various notifies. This should only be called internally!
	 *
	 *	@param	InNodeSeq		The anim node sequence triggering the notify
	 *	@param	InNotifyType	The type of notify that is being handled
	 */
	void HandleNotify(class UAnimNodeSequence* InNodeSeq, ETrailNotifyType InNotifyType);

public:
	virtual AActor* GetNotifyActor(class UAnimNodeSequence* NodeSeq);

	virtual FString GetEditorComment() { return TEXT("TRAILS"); }

	/** 
	 *	Find the ParticleSystemComponent used by this anim notify.
	 *
	 *	@param	NodeSeq						The AnimNodeSequence this notify is associated with.
	 *
	 *	@return	UParticleSystemComponent	The particle system component
	 */
	UParticleSystemComponent* GetPSysComponent(class UAnimNodeSequence* NodeSeq);

	/**
	 *	Called by the AnimSet viewer when the 'parent' FAnimNotifyEvent is edited.
	 *
	 *	@param	NodeSeq			The AnimNodeSequence this notify is associated with.
	 *	@param	OwnerEvent		The FAnimNotifyEvent that 'owns' this AnimNotify.
	 */
	virtual void AnimNotifyEventChanged(class UAnimNodeSequence* NodeSeq, FAnimNotifyEvent* OwnerEvent);

	/** Store the animation data for the current settings. Editor-only. */
	void StoreAnimationData(class UAnimNodeSequence* NodeSeq);

	/** Check if the active SkeletalMesh should be sampled by the anim trial, returning true if successful */
	UBOOL AssociateSkeletalMeshWithAnimTrailData(class UAnimNodeSequence* NodeSeq);

	/** Verify the notify is setup correctly for sampling animation data. Editor-only. */
	UBOOL IsSetupValid(class UAnimNodeSequence* NodeSeq);
};

class UAnimObject : public UObject
{
public:
    //## BEGIN PROPS AnimObject
#if WITH_EDITORONLY_DATA
    INT DrawWidth;
    INT DrawHeight;
    INT NodePosX;
    INT NodePosY;
    INT OutDrawY;
    FStringNoInit CategoryDesc;
#endif // WITH_EDITORONLY_DATA
    class USkeletalMeshComponent* SkelComponent;
    //## END PROPS AnimObject

    DECLARE_ABSTRACT_CLASS(UAnimObject,UObject,0,Engine)
	virtual UAnimNode * GetAnimNode() { return NULL;}
	virtual UMorphNodeBase * GetMorphNodeBase() { return NULL;}
	virtual USkelControlBase * GetSkelControlBase() { return NULL; }

    /**
	 * Draws this node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 */
	virtual void DrawNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes, UBOOL bShowWeight) {}
	/** Called after (copy/)pasted - reset values or re-link if needed**/
	virtual void OnPaste() {};

#if WITH_EDITORONLY_DATA
	/** Calculate the bounding box of this sequence object. For use by Kismet. */
	FIntRect GetObjBoundingBox()
	{
		return FIntRect(NodePosX, NodePosY, NodePosX + DrawWidth, NodePosY + DrawHeight);
	}
#endif
};

struct AnimNode_eventOnCeaseRelevant_Parms
{
    AnimNode_eventOnCeaseRelevant_Parms(EEventParm)
    {
    }
};
struct AnimNode_eventOnBecomeRelevant_Parms
{
    AnimNode_eventOnBecomeRelevant_Parms(EEventParm)
    {
    }
};
struct AnimNode_eventOnInit_Parms
{
    AnimNode_eventOnInit_Parms(EEventParm)
    {
    }
};
class UAnimNode : public UAnimObject
{
public:
    //## BEGIN PROPS AnimNode
    BITFIELD bRelevant:1;
    BITFIELD bJustBecameRelevant:1;
    BITFIELD bTickDuringPausedAnims:1;
    BITFIELD bEditorOnly:1;
    BITFIELD bDisableCaching:1;
    BITFIELD bCallScriptEventOnInit:1;
    BITFIELD bCallScriptEventOnBecomeRelevant:1;
    BITFIELD bCallScriptEventOnCeaseRelevant:1;
    INT NodeTickTag;
    INT NodeInitTag;
    INT NodeEndEventTick;
    INT TickArrayIndex;
    INT NodeCachedAtomsTag;
    FLOAT NodeTotalWeight;
    TArrayNoInit<class UAnimNodeBlendBase*> ParentNodes;
    FName NodeName;
    TArrayNoInit<FBoneAtom> CachedBoneAtoms;
    BYTE CachedNumDesiredBones;
    SCRIPT_ALIGN;
    FBoneAtom CachedRootMotionDelta;
    INT bCachedHasRootMotion;
    TArrayNoInit<FCurveKey> CachedCurveKeys;
    INT SearchTag;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<FCurveKey> LastUpdatedAnimMorphKeys;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS AnimNode

    class UAnimNode* FindAnimNode(FName InNodeName);
    virtual void PlayAnim(UBOOL bLoop=FALSE,FLOAT Rate=1.000000,FLOAT StartTime=0.000000);
    virtual void StopAnim();
    virtual void ReplayAnim();
    DECLARE_FUNCTION(execFindAnimNode)
    {
        P_GET_NAME(InNodeName);
        P_FINISH;
        *(class UAnimNode**)Result=this->FindAnimNode(InNodeName);
    }
    DECLARE_FUNCTION(execPlayAnim)
    {
        P_GET_UBOOL_OPTX(bLoop,FALSE);
        P_GET_FLOAT_OPTX(Rate,1.000000);
        P_GET_FLOAT_OPTX(StartTime,0.000000);
        P_FINISH;
        this->PlayAnim(bLoop,Rate,StartTime);
    }
    DECLARE_FUNCTION(execStopAnim)
    {
        P_FINISH;
        this->StopAnim();
    }
    DECLARE_FUNCTION(execReplayAnim)
    {
        P_FINISH;
        this->ReplayAnim();
    }
    void eventOnCeaseRelevant()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnCeaseRelevant),NULL);
    }
    void eventOnBecomeRelevant()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnBecomeRelevant),NULL);
    }
    void eventOnInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnInit),NULL);
    }
    DECLARE_ABSTRACT_CLASS(UAnimNode,UAnimObject,0,Engine)
	UAnimNode * GetAnimNode() { return this;}
	// UAnimNode interface

	/** Do any initialisation, and then call InitAnim on all children. Should not discard any existing anim state though. */
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	/** Deferred Initialization, called only when the node is relevant in the tree. */
	virtual void DeferredInitAnim() {}
	/** Call DeferredInitAnim() if the node required it. Recurses through the Tree. Increase UAnimNode::CurrentSeachTag before calling. */
	virtual void CallDeferredInitAnim();

	/** AnimSets have been updated, update all animations */
	virtual void AnimSetsUpdated() {}

	/**
	 *	Called just after a node has been copied from its AnimTreeTemplate version.
	 *	This is called on the copy, and SourceNode is the node within the AnimTreeTemplate.
	 */
	virtual void PostAnimNodeInstance(UAnimNode* SourceNode, TMap<UAnimNode*,UAnimNode*>& SrcToDestNodeMap) {}

	/** 
	 *  Called when we need to reset our values to the source. This is called on a node that already has all pointers set up correctly
	 */
	virtual void ResetAnimNodeToSource(UAnimNode *SourceNode);

	/**
	 *	Update this node, then call TickAnim on all children.
	 *	@param DeltaSeconds		Amount of time to advance this node.
	 *	@param TotalWeight		The eventual weight that this node will have in the final blend. This is the multiplication of weights of all nodes above this one.
	 */
	virtual	void	TickAnim(FLOAT DeltaSeconds) {}

	/** Parent node is requesting a blend out. Give node a chance to delay that. */
	virtual UBOOL	CanBlendOutFrom() { return TRUE; }

	/** parent node is requesting a blend in. Give node a chance to delay that. */
	virtual UBOOL	CanBlendTo() { return TRUE; }

	/** 
	 * Add this node and all children to array. Node are added so a parent is always before its children in the array.
	 * @param bForceTraversal	Disables optimization when calling this from the root. (precached AnimTickArray returned).
	 */
	void GetNodes(TArray<UAnimNode*>& Nodes, bool bForceTraversal=FALSE);

	/** Add this node and all children of the specified class to array. Node are added so a parent is always before its children in the array. */
	void GetNodesByClass(TArray<class UAnimNode*>& Nodes, class UClass* BaseClass);

	/** Return an array with all UAnimNodeSequence childs, including this node. */
	void GetAnimSeqNodes(TArray<UAnimNodeSequence*>& Nodes, FName InSynchGroupName=NAME_None);

	virtual void BuildParentNodesArray();
	/** Used for building array of AnimNodes in 'tick' order - that is, all parents of a node are added to array before it. */
	virtual void BuildTickArray(TArray<UAnimNode*>& OutTickArray) {}

	/**
	 *	Get the local transform for each bone. If a blend, will recursively ask children and blend etc.
	 *	DesiredBones should be in strictly increasing order.
	 */
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	/**
	 *	Will copy the cached results into the OutAtoms array if they are up to date and return TRUE
	 *	If cache is not up to date, does nothing and retuns FALSE.
	 */
	virtual UBOOL GetCachedResults(FBoneAtomArray& OutAtoms, FBoneAtom& OutRootMotionDelta, INT& bOutHasRootMotion, FCurveKeyArray& OutCurveKeys, INT NumDesiredBones);

	/** Save the supplied array of BoneAtoms in the CachedBoneAtoms. */
    virtual UBOOL ShouldSaveCachedResults();
	void SaveCachedResults(const FBoneAtomArray& NewAtoms, const FBoneAtom& NewRootMotionDelta, INT bNewHasRootMotion, const FCurveKeyArray& NewCurveKeys, INT NumDesiredBones);

	/** 
	 *	Whether we should keep the cached result for the next frame or not 
	 *	This is to avoid keeping cached result once it ticks. 
	 *	It will release cache result if this returns FALSE
	 **/
    virtual UBOOL ShouldKeepCachedResult() { return FALSE; }

	/** 
	 * Clear Cached Result 
	 **/
	virtual void ClearCachedResult();

	/** Get notification that this node has become relevant for the final blend. ie TotalWeight is now > 0 */
	virtual void OnBecomeRelevant();

	/** Get notification that this node is no longer relevant for the final blend. ie TotalWeight is now == 0 */
	virtual void OnCeaseRelevant();

	/** Utility for counting the number of parents of this node that have been ticked. */
	UBOOL WereAllParentsTicked() const;

	/** Returns TRUE if this node is a child of Node */
	UBOOL IsChildOf(UAnimNode* Node);

	/** Returns TRUE if this node is a child of Node */
	UBOOL IsChildOf_Internal(UAnimNode* Node);

	/** Optimisation way to see if this is a UAnimTree */
	virtual UAnimTree* GetAnimTree() { return NULL; }

	virtual void SetAnim( FName SequenceName ) {}
	virtual void SetPosition( FLOAT NewTime, UBOOL bFireNotifies ) {}

	/** Override these functions to disable loading of editor only nodes */
	virtual UBOOL NeedsLoadForClient() const;
	virtual UBOOL NeedsLoadForServer() const;

	/// ANIMTREE EDITOR

	/**
	 * Draws this node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 */
	virtual void DrawNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes, UBOOL bShowWeight) { DrawAnimNode(Canvas, SelectedNodes, bShowWeight); }
	
	/**
	 * Draws this anim node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 */
	virtual void DrawAnimNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes, UBOOL bShowWeight) {}

	/** Return title to display for this Node in the AnimTree editor. */
	virtual FString GetNodeTitle() { return TEXT(""); }

	/** For editor use. */
	virtual FIntPoint GetConnectionLocation(INT ConnType, int ConnIndex);

	/** Return the number of sliders */
	virtual INT GetNumSliders() const { return 0; }

	/** Return the slider type of slider Index */
	virtual ESliderType GetSliderType(INT InIndex) const { return ST_1D; }

	/** Return current position of slider for this node in the AnimTreeEditor. Return value should be within 0.0 to 1.0 range. */
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex) { return 0.f; }

	/** Called when slider is moved in the AnimTreeEditor. NewSliderValue is in range 0.0 to 1.0. */
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue) {}

	/** Get the number to draw under the slider to show the current value being previewed. */
	virtual FString GetSliderDrawValue(INT SliderIndex) { return FString(TEXT("")); }

	/** internal code for GetNodes(); should only be called from GetNodes() or from the GetNodesInternal() of this node's parent */
	virtual void GetNodesInternal(TArray<UAnimNode*>& Nodes);

	/** Called after (copy/)pasted - reset values or re-link if needed**/
	virtual void OnPaste();

	// STATIC ANIMTREE UTILS

	/** flag to prevent calling GetNodesInternal() from anywhere besides GetNodes() or another GetNodesInternal(), since
	 * we can't make it private/protected because UAnimNodeBlendBase needs to be able to call it on its children
	 */
	static UBOOL bNodeSearching;
	/** current tag value used for SearchTag on nodes being iterated over. Incremented every time a new search is started */
	static INT CurrentSearchTag;
	/** Array to keep track of those nodes requiring an actual clear of the cache */
	static TArray<UAnimNode*> NodesRequiringCacheClear;

	/**
	 * Fills the Atoms array with the specified skeletal mesh reference pose.
	 *
	 * @param Atoms				[out] Output array of relative bone transforms. Must be the same length as RefSkel when calling function.
	 * @param DesiredBones		Indices of bones we want to modify. Parents must occur before children.
	 * @param RefSkel			Input reference skeleton to create atoms from.
	 */
	static void FillWithRefPose(TArray<FBoneAtom>& Atoms, const TArray<BYTE>& DesiredBones, const TArray<struct FMeshBone>& RefSkel);
	static void FillWithRefPose(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, const TArray<struct FMeshBone>& RefSkel);

	/** Utility for taking an array of bone indices and ensuring that all parents are present (ie. all bones between those in the array and the root are present). */
	static void EnsureParentsPresent( TArray<BYTE>& BoneIndices, USkeletalMesh* SkelMesh );

	/** Utility functions to ease off Casting */
	virtual class UAnimNodeSlot* GetAnimNodeSlot() { return NULL; }
	virtual class UAnimNodeAimOffset* GetAnimNodeAimOffset() { return NULL; }
	virtual class UAnimNodeSequence* GetAnimNodeSequence() { return NULL; }
};

struct FAnimBlendChild
{
    FName Name;
    class UAnimNode* Anim;
    FLOAT Weight;
    FLOAT BlendWeight;
    BITFIELD bMirrorSkeleton:1;
    BITFIELD bIsAdditive:1;
#if WITH_EDITORONLY_DATA
    INT DrawY;
#else
    SCRIPT_ALIGN;
#endif // WITH_EDITORONLY_DATA

    /** Constructors */
    FAnimBlendChild() {}
    FAnimBlendChild(EEventParm)
    {
        appMemzero(this, sizeof(FAnimBlendChild));
    }
};

class UAnimNodeBlendBase : public UAnimNode
{
public:
    //## BEGIN PROPS AnimNodeBlendBase
    TArrayNoInit<struct FAnimBlendChild> Children;
    BITFIELD bFixNumChildren:1;
    SCRIPT_ALIGN;
    BYTE BlendType;
    SCRIPT_ALIGN;
    //## END PROPS AnimNodeBlendBase

    virtual void PlayAnim(UBOOL bLoop=FALSE,FLOAT Rate=1.000000,FLOAT StartTime=0.000000);
    virtual void StopAnim();
    virtual void ReplayAnim();
    DECLARE_ABSTRACT_CLASS(UAnimNodeBlendBase,UAnimNode,0,Engine)
	/** Call DeferredInitAnim() if the node required it. Recurses through the Tree. Increase UAnimNode::CurrentSeachTag before calling. */
	virtual void CallDeferredInitAnim();

	// UAnimNode interface
	virtual	void TickAnim(FLOAT DeltaSeconds);

	virtual void BuildParentNodesArray();
	virtual void BuildTickArray(TArray<UAnimNode*>& OutTickArray);

	FORCEINLINE FLOAT	GetBlendWeight(FLOAT ChildWeight);
	FORCEINLINE void	SetBlendTypeWeights();
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);
	virtual void GetChildBoneAtoms( INT ChildIdx, FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys );

	/**
	 * Get mirrored bone atoms from desired child index.
	 * Bones are mirrored using the SkelMirrorTable.
	 */
	void GetMirroredBoneAtoms(FBoneAtomArray& Atoms, INT ChildIndex, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	/**
	 * Draws this node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 */
	virtual void DrawAnimNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes, UBOOL bShowWeight);
	virtual FString GetNodeTitle();

	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);
	virtual INT Extend2DSlider(FCanvas* Canvas, const FIntPoint &SliderPos, INT SliderWidth, UBOOL bAABBLiesWithinViewport, INT LoSliderHandleHeight) { return 0; }

	/** For debugging. Return the sum of the weights of all children nodes. Should always be 1.0. */
	FLOAT GetChildWeightTotal();

	/** Notification to this blend that a child UAnimNodeSequence has reached the end and stopped playing. Not called if child has bLooping set to true or if user calls StopAnim. */
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);

	/** A child connector has been added */
	virtual void	OnAddChild(INT ChildNum);
	/** A child connector has been removed */
	virtual void	OnRemoveChild(INT ChildNum);
	/** A child Anim has been modified*/
	virtual void    OnChildAnimChange(INT ChildNum){};

	/** Rename all child nodes upon Add/Remove, so they match their position in the array. */
	virtual void	RenameChildConnectors();

	/** internal code for GetNodes(); should only be called from GetNodes() or from the GetNodesInternal() of this node's parent */
	virtual void GetNodesInternal(TArray<UAnimNode*>& Nodes);
	
	/** Called after (copy/)pasted - reset values or re-link if needed**/
	virtual void OnPaste();	

	/** 
	 * Resolve conflicts for blend curve weights if same morph target exists 
	 *
	 * @param	InChildrenCurveKeys	Array of curve keys for children. The index should match up with Children.
	 * @param	OutCurveKeys		Result output after blending is resolved
	 * 
	 * @return	Number of new addition to OutCurveKeys
	 */
	virtual INT BlendCurveWeights(const FArrayCurveKeyArray& InChildrenCurveKeys, FCurveKeyArray& OutCurveKeys);

protected:
	/** 
	 * Update Child Weight : Make sure childIndex isn't OOB
	 */
	virtual void UpdateChildWeight(INT ChildIndex);
};

struct FWeightNodeRule
{
    FName NodeName;
    class UAnimNodeBlendBase* CachedNode;
    class UAnimNodeSlot* CachedSlotNode;
    BYTE WeightCheck;
    INT ChildIndex;

    /** Constructors */
    FWeightNodeRule() {}
    FWeightNodeRule(EEventParm)
    {
        appMemzero(this, sizeof(FWeightNodeRule));
    }
};

struct FWeightRule
{
    struct FWeightNodeRule FirstNode;
    struct FWeightNodeRule SecondNode;

    /** Constructors */
    FWeightRule() {}
    FWeightRule(EEventParm)
    {
        appMemzero(this, sizeof(FWeightRule));
    }
};

struct FBranchInfo
{
    FName BoneName;
    FLOAT PerBoneWeightIncrease;

    /** Constructors */
    FBranchInfo() {}
    FBranchInfo(EEventParm)
    {
        appMemzero(this, sizeof(FBranchInfo));
    }
};

struct FPerBoneMaskInfo
{
    TArrayNoInit<struct FBranchInfo> BranchList;
    FLOAT DesiredWeight;
    FLOAT BlendTimeToGo;
    TArrayNoInit<struct FWeightRule> WeightRuleList;
    BITFIELD bWeightBasedOnNodeRules:1;
    BITFIELD bDisableForNonLocalHumanPlayers:1;
    BITFIELD bPendingBlend:1;
    TArrayNoInit<FLOAT> PerBoneWeights;
    TArrayNoInit<BYTE> TransformReqBone;
    INT TransformReqBoneIndex;

    /** Constructors */
    FPerBoneMaskInfo() {}
    FPerBoneMaskInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPerBoneMaskInfo));
    }
};

class UAnimNode_MultiBlendPerBone : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNode_MultiBlendPerBone
    class APawn* PawnOwner;
    TArrayNoInit<struct FPerBoneMaskInfo> MaskList;
    BYTE RotationBlendType;
    SCRIPT_ALIGN;
    //## END PROPS AnimNode_MultiBlendPerBone

    void SetMaskWeight(INT MaskIndex,FLOAT DesiredWeight,FLOAT BlendTime);
    DECLARE_FUNCTION(execSetMaskWeight)
    {
        P_GET_INT(MaskIndex);
        P_GET_FLOAT(DesiredWeight);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        this->SetMaskWeight(MaskIndex,DesiredWeight,BlendTime);
    }
    DECLARE_CLASS(UAnimNode_MultiBlendPerBone,UAnimNodeBlendBase,0,Engine)
	/** Do any initialisation, and then call InitAnim on all children. Should not discard any existing anim state though. */
	virtual void	InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);

	/** Ticking, updates weights... */
	virtual	void	TickAnim(FLOAT DeltaSeconds);

	/** @see UAnimNode::GetBoneAtoms. */
	virtual void	GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	// Special Optimized Paths
	FORCEINLINE void	MeshSpaceBlendMultipleMasks(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, TArray<INT>& RelevantChildren, FArrayBoneAtomArray& ChildAtomsArray, FArrayMatrixArray& MaskTMArray, const TArray<INT> & ChildrenHasRootMotion, const FBoneAtomArray & ChildrenRootMotion);
	FORCEINLINE void	LocalBlendMultipleMasks(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, TArray<INT>& RelevantChildren, FArrayBoneAtomArray& ChildAtomsArray, const TArray<INT> & ChildrenHasRootMotion, const FBoneAtomArray & ChildrenRootMotion);
	FORCEINLINE void	MeshSpaceBlendSingleMask(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, TArray<INT>& RelevantChildren, FArrayBoneAtomArray& ChildAtomsArray, FArrayMatrixArray& MaskTMArray, const TArray<INT> & ChildrenHasRootMotion, const FBoneAtomArray & ChildrenRootMotion);
	FORCEINLINE void	LocalBlendSingleMask(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, TArray<INT>& RelevantChildren, FArrayBoneAtomArray& ChildAtomsArray, const TArray<INT> & ChildrenHasRootMotion, const FBoneAtomArray & ChildrenRootMotion);

	/** Parent node is requesting a blend out. Give node a chance to delay that. */
	virtual UBOOL	CanBlendOutFrom();
	/** parent node is requesting a blend in. Give node a chance to delay that. */
	virtual UBOOL	CanBlendTo();

	/**
	 * Utility for creating the Mask PerBoneWeights array.
	 * Walks down the hierarchy increasing the weight by PerBoneWeightIncrease each step.
	 */
	virtual void	CalcMaskWeight(INT MaskIndex);

	virtual	void	UpdateRules();

	/** Track Changes, and trigger updates */
	virtual void	PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** Rename Child connectors upon edit/remove */
	virtual void	RenameChildConnectors();

	// AnimNodeBlendBase interface
	virtual void	OnAddChild(INT ChildNum);
	virtual void	OnRemoveChild(INT ChildNum);
};

struct FAimTransform
{
    FQuat Quaternion;
    FVector Translation;

    /** Constructors */
    FAimTransform() {}
    FAimTransform(EEventParm)
    {
        appMemzero(this, sizeof(FAimTransform));
    }
};

struct FAimComponent
{
    FName BoneName;
    struct FAimTransform LU;
    struct FAimTransform LC;
    struct FAimTransform LD;
    struct FAimTransform CU;
    struct FAimTransform CC;
    struct FAimTransform CD;
    struct FAimTransform RU;
    struct FAimTransform RC;
    struct FAimTransform RD;

    /** Constructors */
    FAimComponent() {}
    FAimComponent(EEventParm)
    {
        appMemzero(this, sizeof(FAimComponent));
    }
};

struct FAimOffsetProfile
{
    FName ProfileName;
    FVector2D HorizontalRange;
    FVector2D VerticalRange;
    TArrayNoInit<struct FAimComponent> AimComponents;
    FName AnimName_LU;
    FName AnimName_LC;
    FName AnimName_LD;
    FName AnimName_CU;
    FName AnimName_CC;
    FName AnimName_CD;
    FName AnimName_RU;
    FName AnimName_RC;
    FName AnimName_RD;

    /** Constructors */
    FAimOffsetProfile() {}
    FAimOffsetProfile(EEventParm)
    {
        appMemzero(this, sizeof(FAimOffsetProfile));
    }
};

class UAnimNodeAimOffset : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeAimOffset
    FVector2D Aim;
    FVector2D AngleOffset;
    BITFIELD bForceAimDir:1;
    BITFIELD bBakeFromAnimations:1;
    BITFIELD bPassThroughWhenNotRendered:1;
    BITFIELD bSynchronizeNodesInEditor:1;
    INT PassThroughAtOrAboveLOD;
    BYTE ForcedAimDir;
    TArrayNoInit<BYTE> RequiredBones;
    TArrayNoInit<BYTE> AimCpntIndexLUT;
    class UAnimNodeAimOffset* TemplateNode;
    TArrayNoInit<struct FAimOffsetProfile> Profiles;
    INT CurrentProfileIndex;
    //## END PROPS AnimNodeAimOffset

    virtual void SetActiveProfileByName(FName ProfileName);
    virtual void SetActiveProfileByIndex(INT ProfileIndex);
    DECLARE_FUNCTION(execSetActiveProfileByName)
    {
        P_GET_NAME(ProfileName);
        P_FINISH;
        this->SetActiveProfileByName(ProfileName);
    }
    DECLARE_FUNCTION(execSetActiveProfileByIndex)
    {
        P_GET_INT(ProfileIndex);
        P_FINISH;
        this->SetActiveProfileByIndex(ProfileIndex);
    }
    DECLARE_CLASS(UAnimNodeAimOffset,UAnimNodeBlendBase,0,Engine)
	// UObject interface
	virtual void		PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	/** Deferred Initialization, called only when the node is relevant in the tree. */
	virtual void        DeferredInitAnim();

	/** Used to save pointer to AimOffset node in package, to avoid duplicating profile data. */
	virtual void		PostAnimNodeInstance(UAnimNode* SourceNode, TMap<UAnimNode*,UAnimNode*>& SrcToDestNodeMap);

	/** returns current aim. Override this to pull information from somewhere else, like Pawn actor for example. */
	virtual FVector2D	GetAim() { return Aim; }

	virtual void		GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	/** 
	 * Function called after Aim has been extracted and processed (offsets, range, clamping...).
	 * Gives a chance to PostProcess it before being used by the AimOffset Node.
	 * Note that X,Y range should remain [-1,+1].
	 */
	virtual void		PostAimProcessing(FVector2D &AimOffsetPct) {}

	/** Util for getting the current AimOffsetProfile. */
	FAimOffsetProfile*	GetCurrentProfile();

	/** Update cached list of required bones, use to transform skeleton from parent space to component space. */
	void				UpdateListOfRequiredBones();

	/** Returns TRUE if AimComponents contains specified bone */
	UBOOL				ContainsBone(const FName &BoneName);

	/** Util for grabbing the quaternion on a specific bone in a specific direction. */
	FQuat				GetBoneAimQuaternion(INT CompIndex, EAnimAimDir InAimDir);
	/** Util for grabbing the translation on a specific bone in a specific direction. */
	FVector				GetBoneAimTranslation(INT CompIndex, EAnimAimDir InAimDir);

	/** Util for setting the quaternion on a specific bone in a specific direction. */
	void				SetBoneAimQuaternion(INT CompIndex, EAnimAimDir InAimDir, const FQuat & InQuat);
	/** Util for setting the translation on a specific bone in a specific direction. */
	void				SetBoneAimTranslation(INT CompIndex, EAnimAimDir InAimDir, FVector InTrans);

	/** Bake in Offsets from supplied Animations. */
	void				BakeOffsetsFromAnimations();
	void				ExtractOffsets(TArray<FBoneAtom>& RefBoneAtoms, TArray<FBoneAtom>& BoneAtoms, EAnimAimDir InAimDir);
	INT					GetComponentIdxFromBoneIdx(const INT BoneIndex, UBOOL bCreateIfNotFound=0);
	/**
	 * Extract Parent Space Bone Atoms from Animation Data specified by Name.
	 * Returns TRUE if successful.
	 */
	UBOOL				ExtractAnimationData(UAnimNodeSequence *SeqNode, FName AnimationName, TArray<FBoneAtom>& BoneAtoms);

	// For slider support
	virtual INT			GetNumSliders() const { return 1; }
	virtual ESliderType GetSliderType(INT InIndex) const { return ST_2D; }
	virtual FLOAT		GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void		HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual void		SynchronizeNodesInEditor();
	virtual FString		GetSliderDrawValue(INT SliderIndex);

	/** Utility functions to ease off Casting */
	virtual class UAnimNodeAimOffset* GetAnimNodeAimOffset() { return this; }
};

class UAnimNodeBlend : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeBlend
    FLOAT Child2Weight;
    FLOAT Child2WeightTarget;
    FLOAT BlendTimeToGo;
    BITFIELD bSkipBlendWhenNotRendered:1;
    SCRIPT_ALIGN;
    //## END PROPS AnimNodeBlend

    virtual void SetBlendTarget(FLOAT BlendTarget,FLOAT BlendTime);
    DECLARE_FUNCTION(execSetBlendTarget)
    {
        P_GET_FLOAT(BlendTarget);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        this->SetBlendTarget(BlendTarget,BlendTime);
    }
    DECLARE_CLASS(UAnimNodeBlend,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual	void TickAnim(FLOAT DeltaSeconds);

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UAnimNodeAdditiveBlending : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS AnimNodeAdditiveBlending
    BITFIELD bPassThroughWhenNotRendered:1;
    SCRIPT_ALIGN;
    //## END PROPS AnimNodeAdditiveBlending

    virtual void SetBlendTarget(FLOAT BlendTarget,FLOAT BlendTime);
    DECLARE_CLASS(UAnimNodeAdditiveBlending,UAnimNodeBlend,0,Engine)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds);
	void GetChildAtoms(INT ChildIndex, FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);
};

class UAnimNodeBlendPerBone : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS AnimNodeBlendPerBone
    BITFIELD bForceLocalSpaceBlend:1;
    TArrayNoInit<FName> BranchStartBoneName;
    TArrayNoInit<FLOAT> Child2PerBoneWeight;
    TArrayNoInit<BYTE> LocalToCompReqBones;
    //## END PROPS AnimNodeBlendPerBone

    virtual void SetBlendTarget(FLOAT BlendTarget,FLOAT BlendTime);
    DECLARE_CLASS(UAnimNodeBlendPerBone,UAnimNodeBlend,0,Engine)
	/** Do any initialisation, and then call InitAnim on all children. Should not discard any existing anim state though. */
	virtual void InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);
	// AnimNode interface
	virtual	void TickAnim(FLOAT DeltaSeconds);
	// AnimNode interface
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void BuildWeightList();
};

class UAnimNodeCrossfader : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS AnimNodeCrossfader
    FName DefaultAnimSeqName;
    BITFIELD bDontBlendOutOneShot:1;
    FLOAT PendingBlendOutTimeOneShot;
    //## END PROPS AnimNodeCrossfader

    FName GetAnimName();
    class UAnimNodeSequence* GetActiveChild();
    DECLARE_FUNCTION(execPlayOneShotAnim);
    DECLARE_FUNCTION(execBlendToLoopingAnim);
    DECLARE_FUNCTION(execGetAnimName)
    {
        P_FINISH;
        *(FName*)Result=this->GetAnimName();
    }
    DECLARE_FUNCTION(execGetActiveChild)
    {
        P_FINISH;
        *(class UAnimNodeSequence**)Result=this->GetActiveChild();
    }
    DECLARE_CLASS(UAnimNodeCrossfader,UAnimNodeBlend,0,Engine)
	// UAnimNode interface
	virtual	void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UAnimNodeSequence : public UAnimNode
{
public:
    //## BEGIN PROPS AnimNodeSequence
    FName AnimSeqName;
    FLOAT Rate;
    BITFIELD bPlaying:1;
    BITFIELD bLooping:1;
    BITFIELD bCauseActorAnimEnd:1;
    BITFIELD bCauseActorAnimPlay:1;
    BITFIELD bZeroRootRotation:1;
    BITFIELD bZeroRootTranslation:1;
    BITFIELD bDisableWarningWhenAnimNotFound:1;
    BITFIELD bNoNotifies:1;
    BITFIELD bForceRefposeWhenNotPlaying:1;
    BITFIELD bIsIssuingNotifies:1;
    BITFIELD bForceAlwaysSlave:1;
    BITFIELD bSynchronize:1;
    BITFIELD bReverseSync:1;
    BITFIELD bShowTimeLineSlider:1;
    BITFIELD bLoopCameraAnim:1;
    BITFIELD bRandomizeCameraAnimLoopStartTime:1;
    BITFIELD bEditorOnlyAddRefPoseToAdditiveAnimation:1;
    BITFIELD bCheckForFinishAnimEarly:1;
    BITFIELD bBlendingOut:1;
    FLOAT CurrentTime;
    FLOAT PreviousTime;
    FLOAT EndTime;
    class UAnimSequence* AnimSeq;
    INT AnimLinkupIndex;
    FLOAT NotifyWeightThreshold;
    FName SynchGroupName;
    FLOAT SynchPosOffset;
    class UCameraAnim* CameraAnim;
    class UCameraAnimInst* ActiveCameraAnimInstance;
    FLOAT CameraAnimScale;
    FLOAT CameraAnimPlayRate;
    FLOAT CameraAnimBlendInTime;
    FLOAT CameraAnimBlendOutTime;
    BYTE RootBoneOption[3];
    BYTE RootRotationOption[3];
    TArrayNoInit<class USkelControlBase*> MetaDataSkelControlList;
    //## END PROPS AnimNodeSequence

    virtual void SetAnim(FName Sequence);
    virtual void PlayAnim(UBOOL bLoop=FALSE,FLOAT InRate=1.000000,FLOAT StartTime=0.000000);
    virtual void StopAnim();
    virtual void ReplayAnim();
    virtual void SetPosition(FLOAT NewTime,UBOOL bFireNotifies);
    virtual FLOAT GetNormalizedPosition() const;
    virtual FLOAT FindGroupRelativePosition(FLOAT GroupRelativePosition) const;
    virtual FLOAT FindGroupPosition(FLOAT GroupRelativePosition) const;
    virtual FLOAT GetGroupRelativePosition() const;
    virtual FLOAT GetGlobalPlayRate();
    virtual FLOAT GetAnimPlaybackLength();
    virtual FLOAT GetTimeLeft();
    void SetRootBoneAxisOption(BYTE AxisX=0,BYTE AxisY=0,BYTE AxisZ=0);
    void SetRootBoneRotationOption(BYTE AxisX=0,BYTE AxisY=0,BYTE AxisZ=0);
    DECLARE_FUNCTION(execSetAnim)
    {
        P_GET_NAME(Sequence);
        P_FINISH;
        this->SetAnim(Sequence);
    }
    DECLARE_FUNCTION(execSetPosition)
    {
        P_GET_FLOAT(NewTime);
        P_GET_UBOOL(bFireNotifies);
        P_FINISH;
        this->SetPosition(NewTime,bFireNotifies);
    }
    DECLARE_FUNCTION(execGetNormalizedPosition)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetNormalizedPosition();
    }
    DECLARE_FUNCTION(execFindGroupRelativePosition)
    {
        P_GET_FLOAT(GroupRelativePosition);
        P_FINISH;
        *(FLOAT*)Result=this->FindGroupRelativePosition(GroupRelativePosition);
    }
    DECLARE_FUNCTION(execFindGroupPosition)
    {
        P_GET_FLOAT(GroupRelativePosition);
        P_FINISH;
        *(FLOAT*)Result=this->FindGroupPosition(GroupRelativePosition);
    }
    DECLARE_FUNCTION(execGetGroupRelativePosition)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetGroupRelativePosition();
    }
    DECLARE_FUNCTION(execGetGlobalPlayRate)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetGlobalPlayRate();
    }
    DECLARE_FUNCTION(execGetAnimPlaybackLength)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetAnimPlaybackLength();
    }
    DECLARE_FUNCTION(execGetTimeLeft)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetTimeLeft();
    }
    DECLARE_FUNCTION(execSetRootBoneAxisOption)
    {
        P_GET_BYTE_OPTX(AxisX,0);
        P_GET_BYTE_OPTX(AxisY,0);
        P_GET_BYTE_OPTX(AxisZ,0);
        P_FINISH;
        this->SetRootBoneAxisOption(AxisX,AxisY,AxisZ);
    }
    DECLARE_FUNCTION(execSetRootBoneRotationOption)
    {
        P_GET_BYTE_OPTX(AxisX,0);
        P_GET_BYTE_OPTX(AxisY,0);
        P_GET_BYTE_OPTX(AxisZ,0);
        P_FINISH;
        this->SetRootBoneRotationOption(AxisX,AxisY,AxisZ);
    }
    DECLARE_CLASS(UAnimNodeSequence,UAnimNode,0,Engine)
protected:
	// Internal
	/** Returns the camera associated with the skelmesh's owner, if any. */
	ACamera* GetPlayerCamera() const;

public:
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void BeginDestroy();

	// AnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	/** Deferred Initialization, called only when the node is relevant in the tree. */
	virtual void DeferredInitAnim();
	virtual void ResetAnimNodeToSource(UAnimNode *SourceNode);
    virtual UBOOL GetCachedResults(FBoneAtomArray& OutAtoms, FBoneAtom& OutRootMotionDelta, INT& bOutHasRootMotion, FCurveKeyArray& OutCurveKeys, INT NumDesiredBones);
    virtual UBOOL ShouldSaveCachedResults();
	void ConditionalClearCachedData();
	/** 
	 *	Whether we should keep the cached result for the next frame or not 
	 *	This is to avoid keeping cached result on memory once it ticks. 
	 *	It will release cache result if this returns FALSE
	 **/
	virtual UBOOL ShouldKeepCachedResult();	

	/** AnimSets have been updated, update all animations */
	virtual void AnimSetsUpdated();

	virtual	void TickAnim(FLOAT DeltaSeconds);	 // Progress the animation state, issue AnimEnd notifies.
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	/**
	 * Draws this node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 */
	virtual void DrawAnimNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes, UBOOL bShowWeight);
	virtual FString GetNodeTitle();

	// AnimNodeSequence interface
	void GetAnimationPose(UAnimSequence* InAnimSeq, INT& InAnimLinkupIndex, FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	// Extract root motion for animation using a specified start and end time
	void ExtractRootMotionUsingSpecifiedTimespan (UAnimSequence* InAnimSeq, const INT &TrackIndex, FBoneAtom& RootBoneAtom, FBoneAtom& RootBoneAtomDeltaMotion, INT& bHasRootMotion, FLOAT StartTime, FLOAT EndTime) const;

	/**
	*  Extract Root Motion for the current Animation Pose.
	*/
	inline virtual void ExtractRootMotion (UAnimSequence* InAnimSeq, const INT &TrackIndex, FBoneAtom& RootBoneAtom, FBoneAtom& RootBoneAtomDeltaMotion, INT& bHasRootMotion) 
	{
		ExtractRootMotionUsingSpecifiedTimespan(InAnimSeq, TrackIndex, RootBoneAtom, RootBoneAtomDeltaMotion, bHasRootMotion, PreviousTime, CurrentTime); 
	}

	/** Advance animation time. Take care of issuing notifies, looping and so on */
	void AdvanceBy(FLOAT MoveDelta, FLOAT DeltaSeconds, UBOOL bFireNotifies);

	/** Issue any notifies that are passed when moving from the current position to DeltaSeconds in the future. Called from TickAnim. */
	void IssueNotifies(FLOAT DeltaSeconds);

	/** Allow negative play rates and still get animnotifies$$$**/
	void IssueNegativeRateNotifies(FLOAT DeltaSecond);

	/** 
	 * notification that current animation has reached the end (will be called even if it loops, unlike OnAnimEnd)
	 * @param	PlayedTime	Time in seconds of animation played. (play rate independant).
	 * @param	ExcessTime	Time in seconds beyond end of animation. (play rate independant).
	 */
	virtual void OnAnimComplete( FLOAT PlayedTime, FLOAT ExcessTime ) {}

	/**
	 * notification that current animation finished playing.
	 * @param	PlayedTime	Time in seconds of animation played. (play rate independant).
	 * @param	ExcessTime	Time in seconds beyond end of animation. (play rate independant).
	 */
	virtual void OnAnimEnd(FLOAT PlayedTime, FLOAT ExcessTime);
	
	// AnimTree editor interface
	virtual INT GetNumSliders() const { return bShowTimeLineSlider ? 1 : 0; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);

	/** Restart camera animations */
	virtual void OnBecomeRelevant();

	/** Pause camera animations */
	virtual void OnCeaseRelevant();

	/** Starts playing any camera anim we want to play in conjunction with this anim. */
	void StartCameraAnim();
	/** Stops playing any active camera anim playing in conjunction with this anim. */
	void StopCameraAnim();

	/** Update animation usage **/
#if !FINAL_RELEASE
	virtual void UpdateAnimationUsage( FLOAT DeltaSeconds );
#endif	//#if !FINAL_RELEASE

	/** Initialize morph curve information **/
	void InitCurveData();

/** Utility functions to ease off Casting */
	virtual class UAnimNodeSequence* GetAnimNodeSequence() { return this; }
};

class UAnimNodePlayCustomAnim : public UAnimNodeBlend
{
public:
    //## BEGIN PROPS AnimNodePlayCustomAnim
    BITFIELD bIsPlayingCustomAnim:1;
    FLOAT CustomPendingBlendOutTime;
    //## END PROPS AnimNodePlayCustomAnim

    FLOAT PlayCustomAnim(FName AnimName,FLOAT Rate,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=FALSE);
    void PlayCustomAnimByDuration(FName AnimName,FLOAT Duration,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=FALSE);
    void StopCustomAnim(FLOAT BlendOutTime);
    DECLARE_FUNCTION(execPlayCustomAnim)
    {
        P_GET_NAME(AnimName);
        P_GET_FLOAT(Rate);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,FALSE);
        P_FINISH;
        *(FLOAT*)Result=this->PlayCustomAnim(AnimName,Rate,BlendInTime,BlendOutTime,bLooping,bOverride);
    }
    DECLARE_FUNCTION(execPlayCustomAnimByDuration)
    {
        P_GET_NAME(AnimName);
        P_GET_FLOAT(Duration);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,FALSE);
        P_FINISH;
        this->PlayCustomAnimByDuration(AnimName,Duration,BlendInTime,BlendOutTime,bLooping,bOverride);
    }
    DECLARE_FUNCTION(execStopCustomAnim)
    {
        P_GET_FLOAT(BlendOutTime);
        P_FINISH;
        this->StopCustomAnim(BlendOutTime);
    }
    DECLARE_CLASS(UAnimNodePlayCustomAnim,UAnimNodeBlend,0,Engine)
	virtual void TickAnim(FLOAT DeltaSeconds);

	virtual INT GetNumSliders() const { return 0; }
};

class UAnimNodeBlendDirectional : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeBlendDirectional
    FLOAT DirDegreesPerSecond;
    FLOAT DirAngle;
    INT SingleAnimAtOrAboveLOD;
    FRotator RotationOffset;
    BITFIELD bUseAcceleration:1;
    SCRIPT_ALIGN;
    //## END PROPS AnimNodeBlendDirectional

    DECLARE_CLASS(UAnimNodeBlendDirectional,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual	void TickAnim(FLOAT DeltaSeconds);

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UAnimNodeBlendList : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeBlendList
    TArrayNoInit<FLOAT> TargetWeight;
    FLOAT BlendTimeToGo;
    INT ActiveChildIndex;
    BITFIELD bPlayActiveChild:1;
    BITFIELD bForceChildFullWeightWhenBecomingRelevant:1;
    BITFIELD bSkipBlendWhenNotRendered:1;
    FLOAT SliderPosition;
#if WITH_EDITORONLY_DATA
    INT EditorActiveChildIndex;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS AnimNodeBlendList

    virtual void SetActiveChild(INT ChildIndex,FLOAT BlendTime);
    DECLARE_FUNCTION(execSetActiveChild)
    {
        P_GET_INT(ChildIndex);
        P_GET_FLOAT(BlendTime);
        P_FINISH;
        this->SetActiveChild(ChildIndex,BlendTime);
    }
    DECLARE_CLASS(UAnimNodeBlendList,UAnimNodeBlendBase,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// AnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual void ResetAnimNodeToSource(UAnimNode *SourceNode);
	virtual	void TickAnim(FLOAT DeltaSeconds);

	// AnimTree editor interface
	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);

	// AnimNodeBlendBase interface
	virtual void OnAddChild(INT ChildNum);
	virtual void OnRemoveChild(INT ChildNum);

	// AnimNodeBlendList interface
	/** Called after (copy/)pasted - reset values or re-link if needed**/
	virtual void OnPaste();	

};

class UAnimNodeBlendByBase : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeBlendByBase
    BYTE Type;
    FName ActorTag;
    class UClass* ActorClass;
    FLOAT BlendTime;
    class AActor* CachedBase;
    //## END PROPS AnimNodeBlendByBase

    DECLARE_CLASS(UAnimNodeBlendByBase,UAnimNodeBlendList,0,Engine)
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UAnimNodeBlendByPhysics : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeBlendByPhysics
    //## END PROPS AnimNodeBlendByPhysics

    DECLARE_CLASS(UAnimNodeBlendByPhysics,UAnimNodeBlendList,0,Engine)
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UAnimNodeBlendByPosture : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeBlendByPosture
    //## END PROPS AnimNodeBlendByPosture

    DECLARE_CLASS(UAnimNodeBlendByPosture,UAnimNodeBlendList,0,Engine)
	virtual	void TickAnim(FLOAT DeltaSeconds);
};

class UAnimNodeBlendByProperty : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeBlendByProperty
    FName PropertyName;
    BITFIELD bUseOwnersBase:1;
    BITFIELD bForceUpdate:1;
    BITFIELD bUseSpecificBlendTimes:1;
    BITFIELD bSynchronizeNodesInEditor:1;
    FName CachedPropertyName;
    UFloatProperty* CachedFloatProperty;
    UBoolProperty* CachedBoolProperty;
    UByteProperty* CachedByteProperty;
    class AActor* CachedOwner;
    FLOAT BlendTime;
    FLOAT FloatPropMin;
    FLOAT FloatPropMax;
    FLOAT BlendToChild1Time;
    FLOAT BlendToChild2Time;
    //## END PROPS AnimNodeBlendByProperty

    DECLARE_CLASS(UAnimNodeBlendByProperty,UAnimNodeBlendList,0,Engine)
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void TickAnim(FLOAT DeltaSeconds);
	virtual FString GetNodeTitle();
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	/** Parent node is requesting a blend out. Give node a chance to delay that. */
	virtual UBOOL	CanBlendOutFrom();
	/** parent node is requesting a blend in. Give node a chance to delay that. */
	virtual UBOOL	CanBlendTo();
};

class UAnimNodeBlendBySpeed : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeBlendBySpeed
    FLOAT Speed;
    INT LastChannel;
    FLOAT BlendUpTime;
    FLOAT BlendDownTime;
    FLOAT BlendDownPerc;
    TArrayNoInit<FLOAT> Constraints;
    BITFIELD bUseAcceleration:1;
    FLOAT BlendUpDelay;
    FLOAT BlendDownDelay;
    FLOAT BlendDelayRemaining;
    //## END PROPS AnimNodeBlendBySpeed

    DECLARE_CLASS(UAnimNodeBlendBySpeed,UAnimNodeBlendList,0,Engine)
	// AnimNode interface
	
	/**
	 * Blend animations based on an Owner's velocity.
	 *
	 * @param DeltaSeconds	Time since last tick in seconds.
	 */
	virtual	void TickAnim(FLOAT DeltaSeconds);

	/**
	 * Resets the last channel on becoming active.	
	 */
	virtual void OnBecomeRelevant();

	virtual INT GetNumSliders() const { return 1; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
	
	// AnimNodeBlendBySpeed interface

	/** 
	 *	Function called to calculate the speed that should be used for this node. 
	 *	Allows subclasses to easily modify the speed used.
	 */
	 virtual FLOAT CalcSpeed();
};

struct FRandomAnimInfo
{
    FLOAT Chance;
    BYTE LoopCountMin;
    BYTE LoopCountMax;
    FLOAT BlendInTime;
    FVector2D PlayRateRange;
    BITFIELD bStillFrame:1;
    SCRIPT_ALIGN;
    BYTE LoopCount;
    FLOAT LastPosition;

    /** Constructors */
    FRandomAnimInfo() {}
    FRandomAnimInfo(EEventParm)
    {
        appMemzero(this, sizeof(FRandomAnimInfo));
    }
};

class UAnimNodeRandom : public UAnimNodeBlendList
{
public:
    //## BEGIN PROPS AnimNodeRandom
    TArrayNoInit<struct FRandomAnimInfo> RandomInfo;
    class UAnimNodeSequence* PlayingSeqNode;
    INT PendingChildIndex;
    BITFIELD bPickedPendingChildIndex:1;
    SCRIPT_ALIGN;
    //## END PROPS AnimNodeRandom

    DECLARE_CLASS(UAnimNodeRandom,UAnimNodeBlendList,0,Engine)
	virtual void TickAnim(FLOAT DeltaSeconds);
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	/** A child has been added, update RandomInfo accordingly */
	virtual void OnAddChild(INT ChildNum);
	/** A child has been removed, update RandomInfo accordingly */
	virtual void OnRemoveChild(INT ChildNum);

	/** Notification to this blend that a child UAnimNodeSequence has reached the end and stopped playing. Not called if child has bLooping set to true or if user calls StopAnim. */
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);

	/** Notification when node becomes relevant. */
	virtual void OnBecomeRelevant();

	INT		PickNextAnimIndex();
	void	PlayPendingAnimation(FLOAT BlendTime=0.f, FLOAT StartTime=0.f);
};

struct FChildBoneBlendInfo
{
    TArrayNoInit<FLOAT> TargetPerBoneWeight;
    FName InitTargetStartBone;
    FLOAT InitPerBoneIncrease;
    FName OldStartBone;
    FLOAT OldBoneIncrease;
    TArrayNoInit<BYTE> TargetRequiredBones;

    /** Constructors */
    FChildBoneBlendInfo() {}
    FChildBoneBlendInfo(EEventParm)
    {
        appMemzero(this, sizeof(FChildBoneBlendInfo));
    }
};

class UAnimNodeBlendMultiBone : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeBlendMultiBone
    TArrayNoInit<struct FChildBoneBlendInfo> BlendTargetList;
    TArrayNoInit<BYTE> SourceRequiredBones;
    //## END PROPS AnimNodeBlendMultiBone

    DECLARE_FUNCTION(execSetTargetStartBone);
    DECLARE_CLASS(UAnimNodeBlendMultiBone,UAnimNodeBlendBase,0,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// AnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	/** Utility for creating the TargetPerBoneWeight array. Starting from the named bone, walk down the heirarchy increasing the weight by PerBoneIncrease each step. */
	virtual void SetTargetStartBone( INT TargetIdx, FName StartBoneName, FLOAT PerBoneIncrease = 1.f );
};

class UAnimNodeMirror : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeMirror
    BITFIELD bEnableMirroring:1;
    SCRIPT_ALIGN;
    //## END PROPS AnimNodeMirror

    DECLARE_CLASS(UAnimNodeMirror,UAnimNodeBlendBase,0,Engine)
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);
};

class UAnimNodeScalePlayRate : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeScalePlayRate
    FLOAT ScaleByValue;
    //## END PROPS AnimNodeScalePlayRate

    DECLARE_CLASS(UAnimNodeScalePlayRate,UAnimNodeBlendBase,0,Engine)
	virtual void	TickAnim(FLOAT DeltaSeconds);
	virtual FLOAT	GetScaleValue();
};

class UAnimNodeScaleRateBySpeed : public UAnimNodeScalePlayRate
{
public:
    //## BEGIN PROPS AnimNodeScaleRateBySpeed
    FLOAT BaseSpeed;
    //## END PROPS AnimNodeScaleRateBySpeed

    DECLARE_CLASS(UAnimNodeScaleRateBySpeed,UAnimNodeScalePlayRate,0,Engine)
	virtual FLOAT	GetScaleValue();
};

class UAnimNodeSlot : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeSlot
    BITFIELD bIsPlayingCustomAnim:1;
    BITFIELD bEarlyAnimEndNotify:1;
    BITFIELD bSkipBlendWhenNotRendered:1;
    BITFIELD bAdditiveAnimationsOverrideSource:1;
    BITFIELD bIsBeingUsedByInterpGroup:1;
    BITFIELD bDontAddToAlwaysTickArray:1;
    FLOAT PendingBlendOutTime;
    INT CustomChildIndex;
    INT TargetChildIndex;
    TArrayNoInit<FLOAT> TargetWeight;
    FLOAT BlendTimeToGo;
    //## END PROPS AnimNodeSlot

    FLOAT PlayCustomAnim(FName AnimName,FLOAT Rate,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=FALSE,FLOAT StartTime=0,FLOAT EndTime=0);
    UBOOL PlayCustomAnimByDuration(FName AnimName,FLOAT Duration,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLooping=FALSE,UBOOL bOverride=TRUE);
    FName GetPlayedAnimation();
    void StopCustomAnim(FLOAT BlendOutTime);
    void SetAllowPauseAnims(UBOOL bSet);
    void SetCustomAnim(FName AnimName);
    void SetActorAnimEndNotification(UBOOL bNewStatus);
    class UAnimNodeSequence* GetCustomAnimNodeSeq();
    void SetRootBoneAxisOption(BYTE AxisX=0,BYTE AxisY=0,BYTE AxisZ=0);
    void SetRootBoneRotationOption(BYTE AxisX=0,BYTE AxisY=0,BYTE AxisZ=0);
    void TickChildWeights(FLOAT DeltaSeconds);
    DECLARE_FUNCTION(execPlayCustomAnim)
    {
        P_GET_NAME(AnimName);
        P_GET_FLOAT(Rate);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,FALSE);
        P_GET_FLOAT_OPTX(StartTime,0);
        P_GET_FLOAT_OPTX(EndTime,0);
        P_FINISH;
        *(FLOAT*)Result=this->PlayCustomAnim(AnimName,Rate,BlendInTime,BlendOutTime,bLooping,bOverride,StartTime,EndTime);
    }
    DECLARE_FUNCTION(execPlayCustomAnimByDuration)
    {
        P_GET_NAME(AnimName);
        P_GET_FLOAT(Duration);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLooping,FALSE);
        P_GET_UBOOL_OPTX(bOverride,TRUE);
        P_FINISH;
        *(UBOOL*)Result=this->PlayCustomAnimByDuration(AnimName,Duration,BlendInTime,BlendOutTime,bLooping,bOverride);
    }
    DECLARE_FUNCTION(execGetPlayedAnimation)
    {
        P_FINISH;
        *(FName*)Result=this->GetPlayedAnimation();
    }
    DECLARE_FUNCTION(execStopCustomAnim)
    {
        P_GET_FLOAT(BlendOutTime);
        P_FINISH;
        this->StopCustomAnim(BlendOutTime);
    }
    DECLARE_FUNCTION(execSetAllowPauseAnims)
    {
        P_GET_UBOOL(bSet);
        P_FINISH;
        this->SetAllowPauseAnims(bSet);
    }
    DECLARE_FUNCTION(execSetCustomAnim)
    {
        P_GET_NAME(AnimName);
        P_FINISH;
        this->SetCustomAnim(AnimName);
    }
    DECLARE_FUNCTION(execSetActorAnimEndNotification)
    {
        P_GET_UBOOL(bNewStatus);
        P_FINISH;
        this->SetActorAnimEndNotification(bNewStatus);
    }
    DECLARE_FUNCTION(execGetCustomAnimNodeSeq)
    {
        P_FINISH;
        *(class UAnimNodeSequence**)Result=this->GetCustomAnimNodeSeq();
    }
    DECLARE_FUNCTION(execSetRootBoneAxisOption)
    {
        P_GET_BYTE_OPTX(AxisX,0);
        P_GET_BYTE_OPTX(AxisY,0);
        P_GET_BYTE_OPTX(AxisZ,0);
        P_FINISH;
        this->SetRootBoneAxisOption(AxisX,AxisY,AxisZ);
    }
    DECLARE_FUNCTION(execSetRootBoneRotationOption)
    {
        P_GET_BYTE_OPTX(AxisX,0);
        P_GET_BYTE_OPTX(AxisY,0);
        P_GET_BYTE_OPTX(AxisZ,0);
        P_FINISH;
        this->SetRootBoneRotationOption(AxisX,AxisY,AxisZ);
    }
    DECLARE_FUNCTION(execTickChildWeights)
    {
        P_GET_FLOAT(DeltaSeconds);
        P_FINISH;
        this->TickChildWeights(DeltaSeconds);
    }
    DECLARE_CLASS(UAnimNodeSlot,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);

	/** Update position of given channel */
	virtual void MAT_SetAnimPosition(INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bFireNotifies, UBOOL bLooping, UBOOL bEnableRootMotion);
	/** Update weight of channels */
	virtual void MAT_SetAnimWeights(const FAnimSlotInfo& SlotInfo);
	/** Rename all child nodes upon Add/Remove, so they match their position in the array. */
	virtual void RenameChildConnectors();

	// AnimNode interface
	virtual	void	TickAnim(FLOAT DeltaSeconds);
	virtual void	GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	// AnimNodeBlendBase interface
	virtual void	OnAddChild(INT ChildNum);
	virtual void	OnRemoveChild(INT ChildNum);
	/** A child Anim has been modified */
	virtual void    OnChildAnimChange(INT ChildNum);
	/** Child AnimNodeSequence hit end of animation */
	virtual void    OnChildAnimEnd(UAnimNodeSequence* Child, FLOAT PlayedTime, FLOAT ExcessTime);

	virtual INT		GetNumSliders() const { return 0; }

	/**
	 * When requested to play a new animation, we need to find a new child.
	 * We'd like to find one that is unused for smooth blending, 
	 * but that may be a luxury that is not available.
	 */
	INT		FindBestChildToPlayAnim(FName AnimToPlay, UBOOL bOverride);

	void	SetActiveChild(INT ChildIndex, FLOAT BlendTime);
	void	UpdateWeightsForAdditiveAnimations();
	
	/** Called after (copy/)pasted - reset values or re-link if needed**/
	virtual void OnPaste();		

	virtual void SelectedActiveSequence( UAnimNodeSequence* Seq ) {}

	/** Utility functions to ease off Casting */
	virtual class UAnimNodeSlot* GetAnimNodeSlot() { return this; }

	/** 
	 * Clean up Slot Node Sequence Pool if used 
	 * Called when world is cleaned up
	 */
	static void CleanUpSlotNodeSequencePool();

	/** 
	 * Release unused Sequence nodes if released
	 * Called before Tick is called, so that it doesn't leave any reference during tick
	 */
	static void FlushReleasedSequenceNodes(const USkeletalMeshComponent * SkelComp);

	/** 
	 * Release unused Sequence nodes if released
	 * Called before Tick is called, so that it doesn't leave any reference during tick
	 */
	static void ReleaseSequenceNodes(const USkeletalMeshComponent * SkelComp);

	/** 
	 * Release unused Sequence nodes if released
	 * Called before Tick is called, so that it doesn't leave any reference during tick
	 */
	static void PrintSlotNodeSequencePool();

protected:
	/** 
	 * Update Child Weight : Make sure childIndex isn't OOB
	 */
	virtual void UpdateChildWeight(INT ChildIndex);

	/** Make sure child exists **/
	void EnsureChildExists(INT ChildIndex, UBOOL bClaimOnly=FALSE);
};

struct FSynchGroup
{
    TArrayNoInit<class UAnimNodeSequence*> SeqNodes;
    class UAnimNodeSequence* MasterNode;
    FName GroupName;
    BITFIELD bFireSlaveNotifies:1;
    FLOAT RateScale;

    /** Constructors */
    FSynchGroup() {}
    FSynchGroup(EEventParm)
    {
        appMemzero(this, sizeof(FSynchGroup));
    }
};

class UAnimNodeSynch : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimNodeSynch
    TArrayNoInit<struct FSynchGroup> Groups;
    //## END PROPS AnimNodeSynch

    void AddNodeToGroup(class UAnimNodeSequence* SeqNode,FName GroupName);
    void RemoveNodeFromGroup(class UAnimNodeSequence* SeqNode,FName GroupName);
    class UAnimNodeSequence* GetMasterNodeOfGroup(FName GroupName);
    void ForceRelativePosition(FName GroupName,FLOAT RelativePosition);
    FLOAT GetRelativePosition(FName GroupName);
    void SetGroupRateScale(FName GroupName,FLOAT NewRateScale);
    DECLARE_FUNCTION(execAddNodeToGroup)
    {
        P_GET_OBJECT(UAnimNodeSequence,SeqNode);
        P_GET_NAME(GroupName);
        P_FINISH;
        this->AddNodeToGroup(SeqNode,GroupName);
    }
    DECLARE_FUNCTION(execRemoveNodeFromGroup)
    {
        P_GET_OBJECT(UAnimNodeSequence,SeqNode);
        P_GET_NAME(GroupName);
        P_FINISH;
        this->RemoveNodeFromGroup(SeqNode,GroupName);
    }
    DECLARE_FUNCTION(execGetMasterNodeOfGroup)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(class UAnimNodeSequence**)Result=this->GetMasterNodeOfGroup(GroupName);
    }
    DECLARE_FUNCTION(execForceRelativePosition)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(RelativePosition);
        P_FINISH;
        this->ForceRelativePosition(GroupName,RelativePosition);
    }
    DECLARE_FUNCTION(execGetRelativePosition)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(FLOAT*)Result=this->GetRelativePosition(GroupName);
    }
    DECLARE_FUNCTION(execSetGroupRateScale)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(NewRateScale);
        P_FINISH;
        this->SetGroupRateScale(GroupName,NewRateScale);
    }
    DECLARE_CLASS(UAnimNodeSynch,UAnimNodeBlendBase,0,Engine)
	virtual void	InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	virtual	void	TickAnim(FLOAT DeltaSeconds);

	void			UpdateMasterNodeForGroup(FSynchGroup& SynchGroup);
	void			RepopulateGroups();
};

struct FAnimGroup
{
    TArrayNoInit<class UAnimNodeSequence*> SeqNodes;
    class UAnimNodeSequence* SynchMaster;
    class UAnimNodeSequence* NotifyMaster;
    FName GroupName;
    FLOAT RateScale;
    FLOAT SynchPctPosition;

    /** Constructors */
    FAnimGroup() {}
    FAnimGroup(EEventParm)
    {
        appMemzero(this, sizeof(FAnimGroup));
    }
};

struct FSkelControlListHead
{
    FName BoneName;
    class USkelControlBase* ControlHead;
#if WITH_EDITORONLY_DATA
    INT DrawY;
#endif // WITH_EDITORONLY_DATA

    /** Constructors */
    FSkelControlListHead() {}
    FSkelControlListHead(EEventParm)
    {
        appMemzero(this, sizeof(FSkelControlListHead));
    }
};

struct FPreviewSkelMeshStruct
{
    FName DisplayName;
    class USkeletalMesh* PreviewSkelMesh;
    TArrayNoInit<class UMorphTargetSet*> PreviewMorphSets;

    /** Constructors */
    FPreviewSkelMeshStruct() {}
    FPreviewSkelMeshStruct(EEventParm)
    {
        appMemzero(this, sizeof(FPreviewSkelMeshStruct));
    }
};

struct FPreviewSocketStruct
{
    FName DisplayName;
    FName SocketName;
    class USkeletalMesh* PreviewSkelMesh;
    class UStaticMesh* PreviewStaticMesh;

    /** Constructors */
    FPreviewSocketStruct() {}
    FPreviewSocketStruct(EEventParm)
    {
        appMemzero(this, sizeof(FPreviewSocketStruct));
    }
};

struct FPreviewAnimSetsStruct
{
    FName DisplayName;
    TArrayNoInit<class UAnimSet*> PreviewAnimSets;

    /** Constructors */
    FPreviewAnimSetsStruct() {}
    FPreviewAnimSetsStruct(EEventParm)
    {
        appMemzero(this, sizeof(FPreviewAnimSetsStruct));
    }
};

class UAnimTree : public UAnimNodeBlendBase
{
public:
    //## BEGIN PROPS AnimTree
    class UAnimTree* AnimTreeTemplate;
    BITFIELD bEnablePooling:1;
    BITFIELD bUseSavedPose:1;
    BITFIELD bBeingEdited:1;
    BITFIELD bParentNodeArrayBuilt:1;
    BITFIELD bRebuildAnimTickArray:1;
    TArrayNoInit<struct FAnimGroup> AnimGroups;
    TArrayNoInit<FName> PrioritizedSkelBranches_DEPRECATED;
    TArrayNoInit<FName> ComposePrePassBoneNames;
    TArrayNoInit<FName> ComposePostPassBoneNames;
    TArrayNoInit<class UMorphNodeBase*> RootMorphNodes;
    TArrayNoInit<struct FSkelControlListHead> SkelControlLists;
    TArrayNoInit<FBoneAtom> SavedPose;
#if WITH_EDITORONLY_DATA
    INT MorphConnDrawY;
    FLOAT PreviewPlayRate;
    class USkeletalMesh* PreviewSkelMesh_DEPRECATED;
    class USkeletalMesh* SocketSkelMesh_DEPRECATED;
    class UStaticMesh* SocketStaticMesh_DEPRECATED;
    FName SocketName_DEPRECATED;
    TArrayNoInit<class UAnimSet*> PreviewAnimSets_DEPRECATED;
    TArrayNoInit<class UMorphTargetSet*> PreviewMorphSets_DEPRECATED;
    TArrayNoInit<struct FPreviewSkelMeshStruct> PreviewMeshList;
    INT PreviewMeshIndex;
    TArrayNoInit<struct FPreviewSocketStruct> PreviewSocketList;
    INT PreviewSocketIndex;
    TArrayNoInit<struct FPreviewAnimSetsStruct> PreviewAnimSetList;
    INT PreviewAnimSetListIndex;
    INT PreviewAnimSetIndex;
    FVector PreviewCamPos;
    FRotator PreviewCamRot;
    FVector PreviewFloorPos;
    INT PreviewFloorYaw;
    TArrayNoInit<class UAnimNodeFrame*> AnimNodeFrames;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<class UAnimNode*> AnimTickArray;
    //## END PROPS AnimTree

    class USkelControlBase* FindSkelControl(FName InControlName);
    class UMorphNodeBase* FindMorphNode(FName InNodeName);
    void SetUseSavedPose(UBOOL bUseSaved);
    UBOOL SetAnimGroupForNode(class UAnimNodeSequence* SeqNode,FName GroupName,UBOOL bCreateIfNotFound=FALSE);
    class UAnimNodeSequence* GetGroupSynchMaster(FName GroupName);
    class UAnimNodeSequence* GetGroupNotifyMaster(FName GroupName);
    void ForceGroupRelativePosition(FName GroupName,FLOAT RelativePosition);
    FLOAT GetGroupRelativePosition(FName GroupName);
    void SetGroupRateScale(FName GroupName,FLOAT NewRateScale);
    FLOAT GetGroupRateScale(FName GroupName);
    INT GetGroupIndex(FName GroupName);
    DECLARE_FUNCTION(execFindSkelControl)
    {
        P_GET_NAME(InControlName);
        P_FINISH;
        *(class USkelControlBase**)Result=this->FindSkelControl(InControlName);
    }
    DECLARE_FUNCTION(execFindMorphNode)
    {
        P_GET_NAME(InNodeName);
        P_FINISH;
        *(class UMorphNodeBase**)Result=this->FindMorphNode(InNodeName);
    }
    DECLARE_FUNCTION(execSetUseSavedPose)
    {
        P_GET_UBOOL(bUseSaved);
        P_FINISH;
        this->SetUseSavedPose(bUseSaved);
    }
    DECLARE_FUNCTION(execSetAnimGroupForNode)
    {
        P_GET_OBJECT(UAnimNodeSequence,SeqNode);
        P_GET_NAME(GroupName);
        P_GET_UBOOL_OPTX(bCreateIfNotFound,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->SetAnimGroupForNode(SeqNode,GroupName,bCreateIfNotFound);
    }
    DECLARE_FUNCTION(execGetGroupSynchMaster)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(class UAnimNodeSequence**)Result=this->GetGroupSynchMaster(GroupName);
    }
    DECLARE_FUNCTION(execGetGroupNotifyMaster)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(class UAnimNodeSequence**)Result=this->GetGroupNotifyMaster(GroupName);
    }
    DECLARE_FUNCTION(execForceGroupRelativePosition)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(RelativePosition);
        P_FINISH;
        this->ForceGroupRelativePosition(GroupName,RelativePosition);
    }
    DECLARE_FUNCTION(execGetGroupRelativePosition)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(FLOAT*)Result=this->GetGroupRelativePosition(GroupName);
    }
    DECLARE_FUNCTION(execSetGroupRateScale)
    {
        P_GET_NAME(GroupName);
        P_GET_FLOAT(NewRateScale);
        P_FINISH;
        this->SetGroupRateScale(GroupName,NewRateScale);
    }
    DECLARE_FUNCTION(execGetGroupRateScale)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(FLOAT*)Result=this->GetGroupRateScale(GroupName);
    }
    DECLARE_FUNCTION(execGetGroupIndex)
    {
        P_GET_NAME(GroupName);
        P_FINISH;
        *(INT*)Result=this->GetGroupIndex(GroupName);
    }
    DECLARE_CLASS(UAnimTree,UAnimNodeBlendBase,0,Engine)
	virtual void    PostLoad();
	virtual void	PostAnimNodeInstance(UAnimNode* SourceNode, TMap<UAnimNode*,UAnimNode*>& SrcToDestNodeMap);
	virtual void    ResetAnimNodeToSource(UAnimNode *SourceNode);

	virtual void	InitAnim(USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent);
	virtual void	GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	/** Optimisation way to see if this is a UAnimTree */
	virtual UAnimTree* GetAnimTree() { return this; }

	/** Remove from Sync Group **/
	void            RemoveFromSyncGroup(UAnimNodeSequence * SeqNode);
	void            SyncGroupPreTickUpdate();
	void			UpdateAnimNodeSeqGroups(FLOAT DeltaSeconds);
	void			PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** Get all SkelControls within this AnimTree. */
	void			GetSkelControls(TArray<USkelControlBase*>& OutControls);

	/** Get all MorphNodes within this AnimTree. */
	void			GetMorphNodes(TArray<class UMorphNodeBase*>& OutNodes);

	/** Call InitMorph on all morph nodes attached to the tree. */
	void			InitTreeMorphNodes(USkeletalMeshComponent* InSkelComp);

	/** Calls GetActiveMorphs on each element of the RootMorphNodes array. */
	void			GetTreeActiveMorphs(TArray<FActiveMorph>& OutMorphs);

	/** Make a copy of entire tree, including all AnimNodes and SkelControls. 
	 *  @param  NewTreeOuter    Component that will hold this 
	 *  @param  bAcceptPooled   If true, function is allowed to return pooled anim tree*/
	UAnimTree*		CopyAnimTree(UObject* NewTreeOuter, UBOOL bAcceptPooled = FALSE);

	/** Returns this Anim Tree to the global pool, if it is safe to do so */
	void            ReturnToPool();

	/** Utility function to return the size of the AnimTree pool */
	static INT      GetPoolSize();

	/** Utility function for copying a selection of nodes, maintaining any references between them, but leaving any external references. */
	static void		CopyAnimNodes(const TArray<class UAnimNode*>& SrcNodes, UObject* NewOuter, TArray<class UAnimNode*>& DestNodes, TMap<class UAnimNode*,class UAnimNode*>& SrcToDestNodeMap);

	/** Utility function for copying a selection of controls, maintaining any references between them, but leaving any external references. */
	static void		CopySkelControls(const TArray<class USkelControlBase*>& SrcControls, UObject* NewOuter, TArray<class USkelControlBase*>& DestControls, TMap<class USkelControlBase*,class USkelControlBase*>& SrcToDestControlMap);

	/** Utility function for copying a selection of morph nodes, maintaining any references between them, but leaving any external references. */
	static void		CopyMorphNodes(const TArray<class UMorphNodeBase*>& SrcNodes, UObject* NewOuter, TArray<class UMorphNodeBase*>& DestNodes, TMap<class UMorphNodeBase*,class UMorphNodeBase*>& SrcToDestNodeMap);


	// UAnimNode interface
	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);

	/**
	 * Draws this node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 */
	virtual void DrawAnimNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes, UBOOL bShowWeight);

	/**
	* This returns total size for this animtree including animnodes, skelcontrols, morphnodes
	* This is only for ListAnimTress to get idea of how much size each tree cost in run-time
	* Do not use this in GetResourceSize as it will be calculate multiple times of same data
	*/
	INT GetTotalNodeBytes();

	/** 
	 *  Custom Serialize function
	 *  This function will save some information we can use in InitAnimTree
	 */
	void Serialize( FArchive& Ar );
};

struct FAnimInfo
{
    FName AnimSeqName;
    class UAnimSequence* AnimSeq;
    INT AnimLinkupIndex;

    /** Constructors */
    FAnimInfo() {}
    FAnimInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAnimInfo));
    }
};

struct FAnimBlendInfo
{
    FName AnimName;
    struct FAnimInfo AnimInfo;
    FLOAT Weight;

    /** Constructors */
    FAnimBlendInfo() {}
    FAnimBlendInfo(EEventParm)
    {
        appMemzero(this, sizeof(FAnimBlendInfo));
    }
};

class UAnimNodeSequenceBlendBase : public UAnimNodeSequence
{
public:
    //## BEGIN PROPS AnimNodeSequenceBlendBase
    TArrayNoInit<struct FAnimBlendInfo> Anims;
    //## END PROPS AnimNodeSequenceBlendBase

    DECLARE_ABSTRACT_CLASS(UAnimNodeSequenceBlendBase,UAnimNodeSequence,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	virtual void InitAnim(USkeletalMeshComponent* MeshComp, UAnimNodeBlendBase* Parent);
	/** Deferred Initialization, called only when the node is relevant in the tree. */
	virtual void DeferredInitAnim();
	/** AnimSets have been updated, update all animations */
	virtual void AnimSetsUpdated();

	/** make sure animations are up date */
	virtual void CheckAnimsUpToDate();

	/** Lookup animation data for a given animation name */
	void SetAnimInfo(FName InSequenceName, FAnimInfo& InAnimInfo);
	
	/** Extract animations and do the blend. */
	virtual void GetBoneAtoms(FBoneAtomArray& Atoms, const TArray<BYTE>& DesiredBones, FBoneAtom& RootMotionDelta, INT& bHasRootMotion, FCurveKeyArray& CurveKeys);

	/** Update animation usage **/
	virtual void UpdateAnimationUsage( FLOAT DeltaSeconds );

	/** Get AnimInfo total weight */
	FLOAT GetAnimInfoTotalWeight();


	/** 
	 * Resolve conflicts for blend curve weights if same morph target exists 
	 *
	 * @param	InChildrenCurveKeys	Array of curve keys for children. The index should match up with Children.
	 * @param	OutCurveKeys		Result output after blending is resolved
	 * 
	 * @return	Number of new addition to OutCurveKeys
	 */
	virtual INT BlendCurveWeights(const FArrayCurveKeyArray& InChildrenCurveKeys, FCurveKeyArray& OutCurveKeys);
};

class UAnimNodeSequenceBlendByAim : public UAnimNodeSequenceBlendBase
{
public:
    //## BEGIN PROPS AnimNodeSequenceBlendByAim
    FVector2D Aim;
    FVector2D PreviousAim;
    FVector2D HorizontalRange;
    FVector2D VerticalRange;
    FVector2D AngleOffset;
    FName AnimName_LU;
    FName AnimName_LC;
    FName AnimName_LD;
    FName AnimName_CU;
    FName AnimName_CC;
    FName AnimName_CD;
    FName AnimName_RU;
    FName AnimName_RC;
    FName AnimName_RD;
    //## END PROPS AnimNodeSequenceBlendByAim

    void CheckAnimsUpToDate();
    DECLARE_FUNCTION(execCheckAnimsUpToDate)
    {
        P_FINISH;
        this->CheckAnimsUpToDate();
    }
    DECLARE_CLASS(UAnimNodeSequenceBlendByAim,UAnimNodeSequenceBlendBase,0,Engine)
	/** Override this function in a subclass, and return normalized Aim from Pawn. */
	virtual FVector2D GetAim();

	// AnimNode interface
	virtual	void TickAnim(FLOAT DeltaSeconds);

	// For slider support	
	virtual INT GetNumSliders() const { return 1; }
	virtual ESliderType GetSliderType(INT InIndex) const { return ST_2D; }
	virtual FLOAT GetSliderPosition(INT SliderIndex, INT ValueIndex);
	virtual void HandleSliderMove(INT SliderIndex, INT ValueIndex, FLOAT NewSliderValue);
	virtual FString GetSliderDrawValue(INT SliderIndex);
};

class UAnimNodeFrame : public UAnimObject
{
public:
    //## BEGIN PROPS AnimNodeFrame
    INT SizeX;
    INT SizeY;
    INT BorderWidth;
    BITFIELD bDrawBox:1;
    BITFIELD bFilled:1;
    BITFIELD bTileFill:1;
    SCRIPT_ALIGN;
    FColor BorderColor;
    FColor FillColor;
#if WITH_EDITORONLY_DATA
    class UTexture2D* FillTexture;
    class UMaterial* FillMaterial;
    FStringNoInit ObjComment;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS AnimNodeFrame

    DECLARE_CLASS(UAnimNodeFrame,UAnimObject,0,Engine)
#if WITH_EDITOR
	/** Draws the box part of the comment (including handle) */
	void DrawFrameBox(FCanvas* Canvas, UBOOL bSelected);

	/**
	 * Draws this node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 */
	virtual void DrawNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes, UBOOL bShowWeight);
	
#endif
};

class UMorphNodeBase : public UAnimObject
{
public:
    //## BEGIN PROPS MorphNodeBase
    FName NodeName;
    BITFIELD bDrawSlider:1;
    SCRIPT_ALIGN;
    //## END PROPS MorphNodeBase

    DECLARE_ABSTRACT_CLASS(UMorphNodeBase,UAnimObject,0,Engine)
	UMorphNodeBase * GetMorphNodeBase() { return this;}

	/** Add to array all the active morphs below this one, including their weight. */
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs) {}

	/** Do any initialisation necessary for this MorphNode. */
	virtual void InitMorphNode(USkeletalMeshComponent* InSkelComp);

	/** Add all nodes at or below this one to the output array. */
	virtual void GetNodes(TArray<UMorphNodeBase*>& OutNodes);

	// EDITOR
	
	/**
	 * Draws this morph node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 */
	virtual void DrawNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes, UBOOL bShowWeight) { DrawMorphNode(Canvas, SelectedNodes); }
	/**
	 * Draws this morph node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 */
	virtual void DrawMorphNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes) {}

	/** Get location of a connection of a particular type. */
	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);

	/** Return current position of slider for this node in the AnimTreeEditor. Return value should be within 0.0 to 1.0 range. */
	virtual FLOAT GetSliderPosition() { return 0.f; }

	/** Called when slider is moved in the AnimTreeEditor. NewSliderValue is in range 0.0 to 1.0. */
	virtual void HandleSliderMove(FLOAT NewSliderValue) {}

	/** Render on 3d viewport when node is selected. */
	virtual void Render(const FSceneView* View, FPrimitiveDrawInterface* PDI) {}
	/** Draw on 3d viewport canvas when node is selected */
	virtual void Draw(FViewport* Viewport, FCanvas* Canvas, const FSceneView* View) {}
	/** Called after (copy/)pasted - reset values or re-link if needed**/
	virtual void OnPaste();
};

class UMorphNodeMultiPose : public UMorphNodeBase
{
public:
    //## BEGIN PROPS MorphNodeMultiPose
    TArrayNoInit<class UMorphTarget*> Targets;
    TArrayNoInit<FName> MorphNames;
    TArrayNoInit<FLOAT> Weights;
    //## END PROPS MorphNodeMultiPose

    UBOOL AddMorphTarget(FName MorphTargetName,FLOAT InWeight=1.000000);
    void RemoveMorphTarget(FName MorphTargetName);
    UBOOL UpdateMorphTarget(class UMorphTarget* Target,FLOAT InWeight);
    DECLARE_FUNCTION(execAddMorphTarget)
    {
        P_GET_NAME(MorphTargetName);
        P_GET_FLOAT_OPTX(InWeight,1.000000);
        P_FINISH;
        *(UBOOL*)Result=this->AddMorphTarget(MorphTargetName,InWeight);
    }
    DECLARE_FUNCTION(execRemoveMorphTarget)
    {
        P_GET_NAME(MorphTargetName);
        P_FINISH;
        this->RemoveMorphTarget(MorphTargetName);
    }
    DECLARE_FUNCTION(execUpdateMorphTarget)
    {
        P_GET_OBJECT(UMorphTarget,Target);
        P_GET_FLOAT(InWeight);
        P_FINISH;
        *(UBOOL*)Result=this->UpdateMorphTarget(Target,InWeight);
    }
    DECLARE_CLASS(UMorphNodeMultiPose,UMorphNodeBase,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// MorphNodeBase interface
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs);
	virtual void InitMorphNode(USkeletalMeshComponent* InSkelComp);

	/** 
	 * Draws this morph node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 */	
	virtual void DrawMorphNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes);
	
	/**
	 * If exists, it returns Index in the array
	 * Returns -1 if fails
	 */
	INT ExistsIn(const FName & InName);
	INT ExistsIn(const UMorphTarget * InTarget);	
	
	/**
	 * Get weights if exists. Since weight list is editable, there is no guarantee this would exists. 
	 */
	FLOAT GetMorphTargetWeight(INT Index)
	{
		return ( Weights.Num() > Index )? Weights(Index):0.f;
	};
	
	/**
	 * Refresh all morph target information from internal data(name/weights)
	 */
	 void RefreshMorphTargets();
	 
	/** 
	 *	Clear all names and weights - deletes all data 
	 */
	void ClearAll();
};

class UMorphNodePose : public UMorphNodeBase
{
public:
    //## BEGIN PROPS MorphNodePose
    class UMorphTarget* Target;
    FName MorphName;
    FLOAT Weight;
    //## END PROPS MorphNodePose

    void SetMorphTarget(FName MorphTargetName);
    DECLARE_FUNCTION(execSetMorphTarget)
    {
        P_GET_NAME(MorphTargetName);
        P_FINISH;
        this->SetMorphTarget(MorphTargetName);
    }
    DECLARE_CLASS(UMorphNodePose,UMorphNodeBase,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// MorphNodeBase interface
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs);
	virtual void InitMorphNode(USkeletalMeshComponent* InSkelComp);

	/** 
	 * Draws this morph node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 */	
	virtual void DrawMorphNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes);
};

struct FMorphNodeConn
{
    TArrayNoInit<class UMorphNodeBase*> ChildNodes;
    FName ConnName;
    INT DrawY;

    /** Constructors */
    FMorphNodeConn() {}
    FMorphNodeConn(EEventParm)
    {
        appMemzero(this, sizeof(FMorphNodeConn));
    }
};

class UMorphNodeWeightBase : public UMorphNodeBase
{
public:
    //## BEGIN PROPS MorphNodeWeightBase
    TArrayNoInit<struct FMorphNodeConn> NodeConns;
    //## END PROPS MorphNodeWeightBase

    DECLARE_ABSTRACT_CLASS(UMorphNodeWeightBase,UMorphNodeBase,0,Engine)
	virtual void GetNodes(TArray<UMorphNodeBase*>& OutNodes);

	/**
	 * Draws this morph node in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 */
	virtual void DrawMorphNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes);

	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);
};

class UMorphNodeWeight : public UMorphNodeWeightBase
{
public:
    //## BEGIN PROPS MorphNodeWeight
    FLOAT NodeWeight;
    //## END PROPS MorphNodeWeight

    virtual void SetNodeWeight(FLOAT NewWeight);
    DECLARE_FUNCTION(execSetNodeWeight)
    {
        P_GET_FLOAT(NewWeight);
        P_FINISH;
        this->SetNodeWeight(NewWeight);
    }
    DECLARE_CLASS(UMorphNodeWeight,UMorphNodeWeightBase,0,Engine)
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs);
	
	virtual FLOAT GetSliderPosition();
	virtual void HandleSliderMove(FLOAT NewSliderValue);
};

struct FBoneAngleMorph
{
    FLOAT Angle;
    FLOAT TargetWeight;

    /** Constructors */
    FBoneAngleMorph() {}
    FBoneAngleMorph(EEventParm)
    {
        appMemzero(this, sizeof(FBoneAngleMorph));
    }
};

class UMorphNodeWeightByBoneAngle : public UMorphNodeWeightBase
{
public:
    //## BEGIN PROPS MorphNodeWeightByBoneAngle
    FLOAT Angle;
    FLOAT NodeWeight;
    FName BaseBoneName;
    BYTE BaseBoneAxis;
    BYTE AngleBoneAxis;
    SCRIPT_ALIGN;
    BITFIELD bInvertBaseBoneAxis:1;
    BITFIELD bInvertAngleBoneAxis:1;
    BITFIELD bControlMaterialParameter:1;
    FName AngleBoneName;
    INT MaterialSlotId;
    FName ScalarParameterName;
    class UMaterialInstanceConstant* MaterialInstanceConstant;
    TArrayNoInit<struct FBoneAngleMorph> WeightArray;
    //## END PROPS MorphNodeWeightByBoneAngle

    DECLARE_CLASS(UMorphNodeWeightByBoneAngle,UMorphNodeWeightBase,0,Engine)
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs);
	/** Render on 3d viewport when node is selected. */
	virtual void Render(const FSceneView* View, FPrimitiveDrawInterface* PDI);
	/** Draw on 3d viewport canvas when node is selected */
	virtual void Draw(FViewport* Viewport, FCanvas* Canvas, const FSceneView* View);
};

class UMorphNodeWeightByBoneRotation : public UMorphNodeWeightBase
{
public:
    //## BEGIN PROPS MorphNodeWeightByBoneRotation
    FLOAT Angle;
    FLOAT NodeWeight;
    FName BoneName;
    BYTE BoneAxis;
    SCRIPT_ALIGN;
    BITFIELD bInvertBoneAxis:1;
    BITFIELD bControlMaterialParameter:1;
    TArrayNoInit<struct FBoneAngleMorph> WeightArray;
    INT MaterialSlotId;
    FName ScalarParameterName;
    class UMaterialInstanceConstant* MaterialInstanceConstant;
    //## END PROPS MorphNodeWeightByBoneRotation

    DECLARE_CLASS(UMorphNodeWeightByBoneRotation,UMorphNodeWeightBase,0,Engine)
	virtual void GetActiveMorphs(TArray<FActiveMorph>& OutMorphs);
	/** Draw on 3d viewport canvas when node is selected */
	virtual void Draw(FViewport* Viewport, FCanvas* Canvas, const FSceneView* View);
	virtual void Render(const FSceneView* View, FPrimitiveDrawInterface* PDI);
	void DrawDebugCoordSystem(FPrimitiveDrawInterface* PDI, FColor Color, const FBoneAtom& LocalBoneAtom, const FBoneAtom& ParentBoneTransform);
	FQuat GetAlignedQuat(INT BoneIndex);
};

struct SkelControlBase_eventTickSkelControl_Parms
{
    FLOAT DeltaTime;
    class USkeletalMeshComponent* SkelComp;
    SkelControlBase_eventTickSkelControl_Parms(EEventParm)
    {
    }
};
class USkelControlBase : public UAnimObject
{
public:
    //## BEGIN PROPS SkelControlBase
    FName ControlName;
    FLOAT ControlStrength;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    BYTE BlendType;
    SCRIPT_ALIGN;
    BITFIELD bPostPhysicsController:1;
    BITFIELD bSetStrengthFromAnimNode:1;
    BITFIELD bInitializedCachedNodeList:1;
    BITFIELD bControlledByAnimMetada:1;
    BITFIELD bInvertMetadataWeight:1;
    BITFIELD bPropagateSetActive:1;
    BITFIELD bIgnoreWhenNotRendered:1;
    BITFIELD bShouldTickInScript:1;
    BITFIELD bShouldTickOwner:1;
    BITFIELD bEnableEaseInOut_DEPRECATED:1;
    FLOAT StrengthTarget;
    FLOAT BlendTimeToGo;
    TArrayNoInit<FName> StrengthAnimNodeNameList;
    TArrayNoInit<class UAnimNode*> CachedNodeList;
    FLOAT AnimMetadataWeight;
    INT AnimMetaDataUpdateTag;
    FLOAT BoneScale;
    INT ControlTickTag;
    INT IgnoreAtOrAboveLOD;
    class USkelControlBase* NextControl;
    INT ControlPosX_DEPRECATED;
    INT ControlPosY_DEPRECATED;
    //## END PROPS SkelControlBase

    void SetSkelControlActive(UBOOL bInActive);
    void SetSkelControlStrength(FLOAT NewStrength,FLOAT InBlendTime);
    FLOAT GetControlMetadataWeight() const;
    DECLARE_FUNCTION(execSetSkelControlActive)
    {
        P_GET_UBOOL(bInActive);
        P_FINISH;
        this->SetSkelControlActive(bInActive);
    }
    DECLARE_FUNCTION(execSetSkelControlStrength)
    {
        P_GET_FLOAT(NewStrength);
        P_GET_FLOAT(InBlendTime);
        P_FINISH;
        this->SetSkelControlStrength(NewStrength,InBlendTime);
    }
    DECLARE_FUNCTION(execGetControlMetadataWeight)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetControlMetadataWeight();
    }
    void eventTickSkelControl(FLOAT DeltaTime,class USkeletalMeshComponent* SkelComp)
    {
        SkelControlBase_eventTickSkelControl_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        Parms.SkelComp=SkelComp;
        ProcessEvent(FindFunctionChecked(ENGINE_TickSkelControl),&Parms);
    }
    DECLARE_ABSTRACT_CLASS(USkelControlBase,UAnimObject,0,Engine)
	USkelControlBase * GetSkelControlBase() { return this; }
	/**
	*	Called from the SkeletalMeshComponent Tick function, to allow SkelControls to do any time-based update,
	*	such as adjusting their current blend amount.
	*/
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);

	/**
	*	Get the array of bones that this controller affects. Must be in hierarchy order, that is, parents before children.
	*/
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices) {}

	/**
	*	Calculate the new component-space transforms for the affected bones.
	*	The output array OutBoneTransforms must correspond to the OutBoneIndices array returned above (be in the same order etc).
	*/
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms) {}

	/**
	*	Allows you to modify the scaling of all affected bones.
	*	The output array OutBoneScales must correspond to the OutBoneIndices array returned above (be in the same order etc).
	*/
	virtual void CalculateNewBoneScales(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FLOAT>& OutBoneScales) {}

	/** Allows you to modify the scaling of the controller bone. */
	virtual FLOAT GetBoneScale(INT BoneIndex, USkeletalMeshComponent* SkelComp) { return BoneScale; }

	// UObject functions
	virtual void PostLoad();
	virtual void Serialize(FArchive& Ar);

	// UTILS

	/** Utility function for turning axis indicator enum into direction vector, possibly inverted. */
	static FVector GetAxisDirVector(BYTE InAxis, UBOOL bInvert);

	/**
	*	Create a matrix given two arbitrary rows of it.
	*	We generate the missing row using another cross product, but we have to get the order right to avoid changing handedness.
	*/
	static FMatrix BuildMatrixFromVectors(BYTE Vec1Axis, const FVector& Vec1, BYTE Vec2Axis, const FVector& Vec2);

	/** Given two unit direction vectors, find the axis and angle between them. */
	static void FindAxisAndAngle(const FVector& A, const FVector& B, FVector& OutAxis, FLOAT& OutAngle);

	// ANIMTREE EDITOR SUPPORT

	/**
	 * Draws this SkelControl in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 * @param	bShowWeight		If TRUE, show the global percentage weight of this node, if applicable.
	 */
	virtual void DrawNode(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes, UBOOL bShowWeight) { DrawSkelControl(Canvas, SelectedNodes); }
	
	/**
	 * Draws this SkelControl in the AnimTreeEditor.
	 *
	 * @param	Canvas			The canvas to use.
	 * @param	SelectedNodes	Reference to array of all currently selected nodes, potentially including this node
	 */
	virtual void DrawSkelControl(FCanvas* Canvas, const TArray<UAnimObject*>& SelectedNodes);

	/** For editor use. */
	FIntPoint GetConnectionLocation(INT ConnType);

	/** If we should draw manipulation widget in 3D viewport. */
	virtual INT GetWidgetCount() { return 0; }

	/** The transform to use when drawing the widget, in world space. */
	virtual FBoneAtom GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex) { return FMatrix::Identity; }

	/** Update properties of this controller based on the widget being manipulated in the 3D viewport. */
	virtual void HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec) {}

	/** Extra function for drawing special debug info in the 3D viewport if desired. */
	virtual void DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex) {}

	/** Called when slider is moved in the AnimTreeEditor. NewSliderValue is in range 0.0 to 1.0. */
	void HandleControlSliderMove(FLOAT NewSliderValue);

	/**
	* Get Alpha for this control. By default it is ControlStrength.
	* 0.f means no effect, 1.f means full effect.
	* ControlStrength controls whether or not CalculateNewBoneTransforms() is called.
	* By modifying GetControlAlpha() you can still get CalculateNewBoneTransforms() called
	* but not have the controller's effect applied on the mesh.
	* This is useful for cases where you need to have the skeleton built in mesh space
	* for testing, which is not available in TickSkelControl().
	*/
	virtual FLOAT	GetControlAlpha();

	/** Used by high level systems to assign a 'target' for a generic control. One example is the ControlTargets array in SkeletalMeshActor. */
	virtual void SetControlTargetLocation(const FVector& TargetLocation) {}
	/** Called after (copy/)pasted - reset values or re-link if needed**/
	virtual void OnPaste();
};

class USkelControl_CCD_IK : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControl_CCD_IK
    FVector EffectorLocation;
    BYTE EffectorLocationSpace;
    FName EffectorSpaceBoneName;
    FVector EffectorTranslationFromBone;
    INT NumBones;
    INT MaxPerBoneIterations;
    INT IterationsCount;
    FLOAT Precision;
    BITFIELD bStartFromTail:1;
    BITFIELD bNoTurnOptimization:1;
    TArrayNoInit<FLOAT> AngleConstraint;
    FLOAT MaxAngleSteps;
    //## END PROPS SkelControl_CCD_IK

    DECLARE_CLASS(USkelControl_CCD_IK,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);	

	virtual INT GetWidgetCount();
	virtual FBoneAtom GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex);
	virtual void HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec);
};

class USkelControl_Multiply : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControl_Multiply
    FLOAT Multiplier;
    //## END PROPS SkelControl_Multiply

    DECLARE_CLASS(USkelControl_Multiply,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);
	FQuat ExtractAngle(INT BoneIndex, USkeletalMeshComponent* SkelComp);
};

class USkelControl_TwistBone : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControl_TwistBone
    FName SourceBoneName;
    FLOAT TwistAngleScale;
    //## END PROPS SkelControl_TwistBone

    DECLARE_CLASS(USkelControl_TwistBone,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);
	FQuat ExtractRollAngle(INT BoneIndex, USkeletalMeshComponent* SkelComp);
};

class USkelControlLimb : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlLimb
    FVector EffectorLocation;
    BYTE EffectorLocationSpace;
    BYTE JointTargetLocationSpace;
    BYTE JointOffsetSpace;
    BYTE BoneAxis;
    BYTE JointAxis;
    FName EffectorSpaceBoneName;
    FVector JointTargetLocation;
    FName JointTargetSpaceBoneName;
    FVector JointOffset;
    FName JointOffsetBoneName;
    BITFIELD bInvertBoneAxis:1;
    BITFIELD bInvertJointAxis:1;
    BITFIELD bRotateJoint:1;
    BITFIELD bMaintainEffectorRelRot:1;
    BITFIELD bTakeRotationFromEffectorSpace:1;
    BITFIELD bAllowStretching:1;
    SCRIPT_ALIGN;
    FVector2D StretchLimits;
    FName StretchRollBoneName;
    //## END PROPS SkelControlLimb

    DECLARE_CLASS(USkelControlLimb,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);

	virtual INT GetWidgetCount();
	virtual FBoneAtom GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex);
	virtual void HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec);
	virtual void DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex);
};

class USkelControlFootPlacement : public USkelControlLimb
{
public:
    //## BEGIN PROPS SkelControlFootPlacement
    FLOAT FootOffset;
    BYTE FootUpAxis;
    SCRIPT_ALIGN;
    FRotator FootRotOffset;
    BITFIELD bInvertFootUpAxis:1;
    BITFIELD bOrientFootToGround:1;
    BITFIELD bOnlyEnableForUpAdjustment:1;
    FLOAT MaxUpAdjustment;
    FLOAT MaxDownAdjustment;
    FLOAT MaxFootOrientAdjust;
    //## END PROPS SkelControlFootPlacement

    DECLARE_CLASS(USkelControlFootPlacement,USkelControlLimb,0,Engine)
	// USkelControlBase interface
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);	
};

class USkelControlLookAt : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlLookAt
    FVector TargetLocation;
    BYTE TargetLocationSpace;
    BYTE LookAtAxis;
    BYTE UpAxis;
    BYTE AllowRotationSpace;
    FName TargetSpaceBoneName;
    BITFIELD bInvertLookAtAxis:1;
    BITFIELD bDefineUpAxis:1;
    BITFIELD bInvertUpAxis:1;
    BITFIELD bEnableLimit:1;
    BITFIELD bLimitBasedOnRefPose:1;
    BITFIELD bDisableBeyondLimit:1;
    BITFIELD bNotifyBeyondLimit:1;
    BITFIELD bShowLimit:1;
    BITFIELD bAllowRotationX:1;
    BITFIELD bAllowRotationY:1;
    BITFIELD bAllowRotationZ:1;
    FLOAT TargetLocationInterpSpeed;
    FVector DesiredTargetLocation;
    FVector ActorSpaceLookAtTarget;
    FLOAT MaxAngle;
    FLOAT OuterMaxAngle;
    FLOAT DeadZoneAngle;
    FVector2D RotationAngleRangeX;
    FVector2D RotationAngleRangeY;
    FVector2D RotationAngleRangeZ;
    FName AllowRotationOtherBoneName;
    FLOAT LookAtAlpha;
    FLOAT LookAtAlphaTarget;
    FLOAT LookAtAlphaBlendTimeToGo;
    FVector LimitLookDir;
    FVector BaseLookDir;
    FVector BaseBonePos;
    FLOAT LastCalcTime;
    INT ControlBoneIndex;
    //## END PROPS SkelControlLookAt

    virtual void SetTargetLocation(FVector NewTargetLocation);
    void InterpolateTargetLocation(FLOAT DeltaTime);
    void SetLookAtAlpha(FLOAT DesiredAlpha,FLOAT DesiredBlendTime);
    UBOOL CanLookAtPoint(FVector PointLoc,UBOOL bDrawDebugInfo=FALSE,UBOOL bDebugUsePersistentLines=FALSE,UBOOL bDebugFlushLinesFirst=FALSE);
    DECLARE_FUNCTION(execSetTargetLocation)
    {
        P_GET_STRUCT(FVector,NewTargetLocation);
        P_FINISH;
        this->SetTargetLocation(NewTargetLocation);
    }
    DECLARE_FUNCTION(execInterpolateTargetLocation)
    {
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        this->InterpolateTargetLocation(DeltaTime);
    }
    DECLARE_FUNCTION(execSetLookAtAlpha)
    {
        P_GET_FLOAT(DesiredAlpha);
        P_GET_FLOAT(DesiredBlendTime);
        P_FINISH;
        this->SetLookAtAlpha(DesiredAlpha,DesiredBlendTime);
    }
    DECLARE_FUNCTION(execCanLookAtPoint)
    {
        P_GET_STRUCT(FVector,PointLoc);
        P_GET_UBOOL_OPTX(bDrawDebugInfo,FALSE);
        P_GET_UBOOL_OPTX(bDebugUsePersistentLines,FALSE);
        P_GET_UBOOL_OPTX(bDebugFlushLinesFirst,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->CanLookAtPoint(PointLoc,bDrawDebugInfo,bDebugUsePersistentLines,bDebugFlushLinesFirst);
    }
    DECLARE_CLASS(USkelControlLookAt,USkelControlBase,0,Engine)
	// USkelControlBase interface
	/** LookAtAlpha allows to cancel head look when going beyond boundaries */
	virtual	FLOAT	GetControlAlpha();
	virtual void	TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void	GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void	CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);	
	
	virtual INT		GetWidgetCount() { return 1; }
	virtual FBoneAtom GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex);
	virtual void	HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec);
	virtual void	DrawSkelControl3D(const FSceneView* View, FPrimitiveDrawInterface* PDI, USkeletalMeshComponent* SkelComp, INT BoneIndex);

	virtual void SetControlTargetLocation(const FVector& InTargetLocation);

protected:
	virtual UBOOL	ApplyLookDirectionLimits(FVector& DesiredLookDir, const FVector &CurrentLookDir, INT BoneIndex, USkeletalMeshComponent* SkelComp);

public:
};

class USkelControlSingleBone : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlSingleBone
    BITFIELD bApplyTranslation:1;
    BITFIELD bApplyRotation:1;
    BITFIELD bAddTranslation:1;
    BITFIELD bAddRotation:1;
    BITFIELD bRemoveMeshRotation:1;
    SCRIPT_ALIGN;
    FVector BoneTranslation;
    BYTE BoneTranslationSpace;
    BYTE BoneRotationSpace;
    FName TranslationSpaceBoneName;
    FRotator BoneRotation;
    FName RotationSpaceBoneName;
    //## END PROPS SkelControlSingleBone

    DECLARE_CLASS(USkelControlSingleBone,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);

	virtual INT GetWidgetCount();
	virtual FBoneAtom GetWidgetTM(INT WidgetIndex, USkeletalMeshComponent* SkelComp, INT BoneIndex);
	virtual void HandleWidgetDrag(INT WidgetIndex, const FVector& DragVec);
};

class USkelControlHandlebars : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS SkelControlHandlebars
    BYTE WheelRollAxis;
    BYTE HandlebarRotateAxis;
    FName WheelBoneName;
    BITFIELD bInvertRotation:1;
    INT SteerWheelBoneIndex;
    //## END PROPS SkelControlHandlebars

    DECLARE_CLASS(USkelControlHandlebars,USkelControlSingleBone,0,Engine)
	// SkelControl interface
	void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);

	// Editor modification
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class USkelControlWheel : public USkelControlSingleBone
{
public:
    //## BEGIN PROPS SkelControlWheel
    FLOAT WheelDisplacement;
    FLOAT WheelMaxRenderDisplacement;
    FLOAT WheelRoll;
    BYTE WheelRollAxis;
    BYTE WheelSteeringAxis;
    FLOAT WheelSteering;
    BITFIELD bInvertWheelRoll:1;
    BITFIELD bInvertWheelSteering:1;
    SCRIPT_ALIGN;
    //## END PROPS SkelControlWheel

    DECLARE_CLASS(USkelControlWheel,USkelControlSingleBone,0,Engine)
	// SkelControlWheel interface
	void UpdateWheelControl( FLOAT InDisplacement, FLOAT InRoll, FLOAT InSteering );
	void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);
};

class USkelControlSpline : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlSpline
    INT SplineLength;
    BYTE SplineBoneAxis;
    BYTE BoneRotMode;
    SCRIPT_ALIGN;
    BITFIELD bInvertSplineBoneAxis:1;
    FLOAT EndSplineTension;
    FLOAT StartSplineTension;
    //## END PROPS SkelControlSpline

    DECLARE_CLASS(USkelControlSpline,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);	
};

class USkelControlTrail : public USkelControlBase
{
public:
    //## BEGIN PROPS SkelControlTrail
    INT ChainLength;
    BYTE ChainBoneAxis;
    SCRIPT_ALIGN;
    BITFIELD bInvertChainBoneAxis:1;
    BITFIELD bLimitStretch:1;
    BITFIELD bActorSpaceFakeVel:1;
    BITFIELD bHadValidStrength:1;
    FLOAT TrailRelaxation;
    FLOAT StretchLimit;
    FVector FakeVelocity;
    FLOAT ThisTimstep;
    TArrayNoInit<FVector> TrailBoneLocations;
    FMatrix OldLocalToWorld;
    //## END PROPS SkelControlTrail

    DECLARE_CLASS(USkelControlTrail,USkelControlBase,0,Engine)
	// USkelControlBase interface
	virtual void TickSkelControl(FLOAT DeltaSeconds, USkeletalMeshComponent* SkelComp);
	virtual void GetAffectedBones(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<INT>& OutBoneIndices);
	virtual void CalculateNewBoneTransforms(INT BoneIndex, USkeletalMeshComponent* SkelComp, TArray<FBoneAtom>& OutBoneTransforms);	
};

struct FAnimSetMeshLinkup
{
    TArrayNoInit<INT> BoneToTrackTable;

		/** Reset this linkup and re-create between the provided skeletal mesh and anim set. */
		void BuildLinkup(USkeletalMesh* InSkelMesh, UAnimSet* InAnimSet);
	
};

class UAnimSet : public UObject
{
public:
    //## BEGIN PROPS AnimSet
    BITFIELD bAnimRotationOnly:1;
    TArrayNoInit<FName> TrackBoneNames;
    TArrayNoInit<class UAnimSequence*> Sequences;
    TMap< FName,INT > SequenceCache;
    TArrayNoInit<struct FAnimSetMeshLinkup> LinkupCache;
    TMap< FName,INT > SkelMesh2LinkupCache;
    TArrayNoInit<BYTE> BoneUseAnimTranslation;
    TArrayNoInit<BYTE> ForceUseMeshTranslation;
    TArrayNoInit<FName> UseTranslationBoneNames;
    TArrayNoInit<FName> ForceMeshTranslationBoneNames;
    FName PreviewSkelMeshName;
    FName BestRatioSkelMeshName;
    //## END PROPS AnimSet

    DECLARE_CLASS(UAnimSet,UObject,0,Engine)
	// UObject interface
	virtual void PreSave();
	virtual void PostLoad();
	virtual void BeginDestroy();
	
	// UAnimSet interface
	/**
	 * See if we can play sequences from this AnimSet on the provided SkeletalMesh.
	 * Returns true if there is a bone in SkelMesh for every track in the AnimSet,
	 * or there is a track of animation for every bone of the SkelMesh.
	 * 
	 * @param	SkelMesh	SkeletalMesh to compare the AnimSet against.
	 * @return				TRUE if animation set can play on supplied SkeletalMesh, FALSE if not.
	 */
	UBOOL CanPlayOnSkeletalMesh(USkeletalMesh* SkelMesh) const;

	/** Get Ratio of how much that mesh fits that animation set */
	FLOAT GetSkeletalMeshMatchRatio(USkeletalMesh* SkelMesh) const;

	/**
	 * Returns the AnimSequence with the specified name in this set.
	 * 
	 * @param		SequenceName	Name of sequence to find.
	 * @return						Pointer to AnimSequence with desired name, or NULL if sequence was not found.
	 */
	UAnimSequence* FindAnimSequence(FName SequenceName);

	/** 
	 * Find a mesh linkup table (mapping of sequence tracks to bone indices) for a particular SkeletalMesh
	 * If one does not already exist, create it now.
	 */
	INT GetMeshLinkupIndex(USkeletalMesh* SkelMesh);

	/**
	 * @return		The track index for the bone with the supplied name, or INDEX_NONE if no track exists for that bone.
	 */
	INT FindTrackWithName(FName BoneName) const
	{
		return TrackBoneNames.FindItemIndex( BoneName );
	}

	/**
	 * Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	 *
	 * @return size of resource as to be displayed to artists/ LDs in the Editor.
	 */
	INT GetResourceSize();

	/**
	 * Clears all sequences and resets the TrackBoneNames table.
	 */
	void ResetAnimSet();
	/** 
	 * Properly remove an AnimSequence from an AnimSet, and updates references it might have.
	 * @return TRUE if AnimSequence was properly removed, FALSE if it wasn't found.
	 */
	UBOOL RemoveAnimSequenceFromAnimSet(UAnimSequence* AnimSeq);

	/** Util that find all AnimSets and flushes their LinkupCache, then calls InitAnimTree on all SkeletalMeshComponents. */
	static void ClearAllAnimSetLinkupCaches();
	
	/**
	 * Animation Usage Tracking
	 */
	void	TraceAnimationUsage();
	void	RecordAnimationUsage();	

	static void OutputAnimationUsage();	
	static void CleanUpAnimationUsage();	
	static void TickAnimationUsage();
};

class UMorphTargetSet : public UObject
{
public:
    //## BEGIN PROPS MorphTargetSet
    TArrayNoInit<class UMorphTarget*> Targets;
    class USkeletalMesh* BaseSkelMesh;
    TArrayNoInit< TArray<DWORD> > RawWedgePointIndices;
    //## END PROPS MorphTargetSet

    class UMorphTarget* FindMorphTarget(FName MorphTargetName);
    DECLARE_FUNCTION(execFindMorphTarget)
    {
        P_GET_NAME(MorphTargetName);
        P_FINISH;
        *(class UMorphTarget**)Result=this->FindMorphTarget(MorphTargetName);
    }
    DECLARE_CLASS(UMorphTargetSet,UObject,0,Engine)
	/** 
	* Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	*/
	virtual FString GetDesc();

	/**
	* Returns the size of the object/ resource for display to artists/ LDs in the Editor.
	*
	* @return size of resource as to be displayed to artists/ LDs in the Editor.
	*/
	INT GetResourceSize();

	/** 
	* Verify if the current BaseSkelMesh is still valid
	* 
	* @return TRUE if so. FALSE otherwise. 
	*/
	UBOOL IsValidBaseMesh();

	/** 
	* Update vertex indices for all morph targets from the base mesh
	*
	*/
	void UpdateMorphTargetsFromBaseMesh();

	/**
	* Refill data assuming current base mesh exactly works
	* This is only for compatibility to support old morph targets to re-fill base mesh information 
	* 
	* @param DoNotOverwriteIfExists:	Set to TRUE if you'd like to not overwrite if exists
	*							This can be used for filling up LOD data when morph target doesn't have LOD data imported yet
	*
	*/
	void FillBaseMeshData(UBOOL DoNotOverwriteIfExists);

	/** Serialize **/
	virtual void Serialize(FArchive& Ar);
};

class UMorphWeightSequence : public UObject
{
public:
    //## BEGIN PROPS MorphWeightSequence
    //## END PROPS MorphWeightSequence

    DECLARE_CLASS(UMorphWeightSequence,UObject,0,Engine)
	/** 
	 * Returns a one line description of an object for viewing in the thumbnail view of the generic browser
	 */
	virtual FString GetDesc();
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_ANIM_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(ASkeletalMeshActor,-1,execMAT_FinishAnimControl);
AUTOGENERATE_FUNCTION(ASkeletalMeshActor,-1,execMAT_BeginAnimControl);
AUTOGENERATE_FUNCTION(ASkeletalMeshActor,-1,execUpdateAnimSetList);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_SetAnimPosition);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_SetSkelControlStrength);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_SetSkelControlScale);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_SetMorphWeight);
AUTOGENERATE_FUNCTION(ASkeletalMeshActorMAT,-1,execMAT_SetAnimWeights);
AUTOGENERATE_FUNCTION(UAnimNotify_Trails,-1,execGetNumSteps);
AUTOGENERATE_FUNCTION(UAnimNode,-1,execReplayAnim);
AUTOGENERATE_FUNCTION(UAnimNode,-1,execStopAnim);
AUTOGENERATE_FUNCTION(UAnimNode,-1,execPlayAnim);
AUTOGENERATE_FUNCTION(UAnimNode,-1,execFindAnimNode);
AUTOGENERATE_FUNCTION(UAnimNodeBlendBase,-1,execReplayAnim);
AUTOGENERATE_FUNCTION(UAnimNodeBlendBase,-1,execStopAnim);
AUTOGENERATE_FUNCTION(UAnimNodeBlendBase,-1,execPlayAnim);
AUTOGENERATE_FUNCTION(UAnimNode_MultiBlendPerBone,-1,execSetMaskWeight);
AUTOGENERATE_FUNCTION(UAnimNodeAimOffset,-1,execSetActiveProfileByIndex);
AUTOGENERATE_FUNCTION(UAnimNodeAimOffset,-1,execSetActiveProfileByName);
AUTOGENERATE_FUNCTION(UAnimNodeBlend,-1,execSetBlendTarget);
AUTOGENERATE_FUNCTION(UAnimNodeAdditiveBlending,-1,execSetBlendTarget);
AUTOGENERATE_FUNCTION(UAnimNodeBlendPerBone,-1,execSetBlendTarget);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execGetActiveChild);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execGetAnimName);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execBlendToLoopingAnim);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execPlayOneShotAnim);
AUTOGENERATE_FUNCTION(UAnimNodePlayCustomAnim,-1,execStopCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodePlayCustomAnim,-1,execPlayCustomAnimByDuration);
AUTOGENERATE_FUNCTION(UAnimNodePlayCustomAnim,-1,execPlayCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodeBlendList,-1,execSetActiveChild);
AUTOGENERATE_FUNCTION(UAnimNodeBlendMultiBone,-1,execSetTargetStartBone);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execTickChildWeights);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execSetRootBoneRotationOption);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execSetRootBoneAxisOption);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execGetCustomAnimNodeSeq);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execSetActorAnimEndNotification);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execSetCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execSetAllowPauseAnims);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execStopCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execGetPlayedAnimation);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execPlayCustomAnimByDuration);
AUTOGENERATE_FUNCTION(UAnimNodeSlot,-1,execPlayCustomAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execSetGroupRateScale);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execGetRelativePosition);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execForceRelativePosition);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execGetMasterNodeOfGroup);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execRemoveNodeFromGroup);
AUTOGENERATE_FUNCTION(UAnimNodeSynch,-1,execAddNodeToGroup);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupIndex);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupRateScale);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execSetGroupRateScale);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupRelativePosition);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execForceGroupRelativePosition);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupNotifyMaster);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execGetGroupSynchMaster);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execSetAnimGroupForNode);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execSetUseSavedPose);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execFindMorphNode);
AUTOGENERATE_FUNCTION(UAnimTree,-1,execFindSkelControl);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execSetRootBoneRotationOption);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execSetRootBoneAxisOption);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetTimeLeft);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetAnimPlaybackLength);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetGlobalPlayRate);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetGroupRelativePosition);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execFindGroupPosition);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execFindGroupRelativePosition);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetNormalizedPosition);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execSetPosition);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execReplayAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execStopAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execPlayAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execSetAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequenceBlendByAim,-1,execCheckAnimsUpToDate);
AUTOGENERATE_FUNCTION(UMorphNodeMultiPose,-1,execUpdateMorphTarget);
AUTOGENERATE_FUNCTION(UMorphNodeMultiPose,-1,execRemoveMorphTarget);
AUTOGENERATE_FUNCTION(UMorphNodeMultiPose,-1,execAddMorphTarget);
AUTOGENERATE_FUNCTION(UMorphNodePose,-1,execSetMorphTarget);
AUTOGENERATE_FUNCTION(UMorphNodeWeight,-1,execSetNodeWeight);
AUTOGENERATE_FUNCTION(USkelControlBase,-1,execGetControlMetadataWeight);
AUTOGENERATE_FUNCTION(USkelControlBase,-1,execSetSkelControlStrength);
AUTOGENERATE_FUNCTION(USkelControlBase,-1,execSetSkelControlActive);
AUTOGENERATE_FUNCTION(USkelControlLookAt,-1,execCanLookAtPoint);
AUTOGENERATE_FUNCTION(USkelControlLookAt,-1,execSetLookAtAlpha);
AUTOGENERATE_FUNCTION(USkelControlLookAt,-1,execInterpolateTargetLocation);
AUTOGENERATE_FUNCTION(USkelControlLookAt,-1,execSetTargetLocation);
AUTOGENERATE_FUNCTION(UAnimSequence,-1,execGetNotifyTimeByClass);
AUTOGENERATE_FUNCTION(UMorphTargetSet,-1,execFindMorphTarget);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_ANIM_NATIVE_DEFS
#define ENGINE_ANIM_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_ANIM \
	ASkeletalMeshActor::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SkeletalMeshActor"), GEngineASkeletalMeshActorNatives); \
	ASkeletalMeshActorBasedOnExtremeContent::StaticClass(); \
	ASkeletalMeshActorSpawnable::StaticClass(); \
	ASkeletalMeshCinematicActor::StaticClass(); \
	ASkeletalMeshActorMAT::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SkeletalMeshActorMAT"), GEngineASkeletalMeshActorMATNatives); \
	UHeadTrackingComponent::StaticClass(); \
	UAnimationCompressionAlgorithm::StaticClass(); \
	UAnimationCompressionAlgorithm_Automatic::StaticClass(); \
	UAnimationCompressionAlgorithm_BitwiseCompressOnly::StaticClass(); \
	UAnimationCompressionAlgorithm_LeastDestructive::StaticClass(); \
	UAnimationCompressionAlgorithm_RemoveEverySecondKey::StaticClass(); \
	UAnimationCompressionAlgorithm_RemoveLinearKeys::StaticClass(); \
	UAnimationCompressionAlgorithm_PerTrackCompression::StaticClass(); \
	UAnimationCompressionAlgorithm_RemoveTrivialKeys::StaticClass(); \
	UDEPRECATED_AnimationCompressionAlgorithm_RevertToRaw::StaticClass(); \
	UAnimMetaData::StaticClass(); \
	UAnimMetaData_SkelControl::StaticClass(); \
	UAnimMetaData_SkelControlKeyFrame::StaticClass(); \
	UAnimNotify::StaticClass(); \
	UAnimNotify_CameraEffect::StaticClass(); \
	UAnimNotify_ClothingMaxDistanceScale::StaticClass(); \
	UAnimNotify_Footstep::StaticClass(); \
	UAnimNotify_ForceField::StaticClass(); \
	UAnimNotify_Kismet::StaticClass(); \
	UAnimNotify_PlayParticleEffect::StaticClass(); \
	UAnimNotify_Rumble::StaticClass(); \
	UAnimNotify_Script::StaticClass(); \
	UAnimNotify_Scripted::StaticClass(); \
	UAnimNotify_PawnMaterialParam::StaticClass(); \
	UAnimNotify_ViewShake::StaticClass(); \
	UAnimNotify_Sound::StaticClass(); \
	UAnimNotify_Trails::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNotify_Trails"), GEngineUAnimNotify_TrailsNatives); \
	UAnimObject::StaticClass(); \
	UAnimNode::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNode"), GEngineUAnimNodeNatives); \
	UAnimNodeBlendBase::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeBlendBase"), GEngineUAnimNodeBlendBaseNatives); \
	UAnimNode_MultiBlendPerBone::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNode_MultiBlendPerBone"), GEngineUAnimNode_MultiBlendPerBoneNatives); \
	UAnimNodeAimOffset::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeAimOffset"), GEngineUAnimNodeAimOffsetNatives); \
	UAnimNodeBlend::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeBlend"), GEngineUAnimNodeBlendNatives); \
	UAnimNodeAdditiveBlending::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeAdditiveBlending"), GEngineUAnimNodeAdditiveBlendingNatives); \
	UAnimNodeBlendPerBone::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeBlendPerBone"), GEngineUAnimNodeBlendPerBoneNatives); \
	UAnimNodeCrossfader::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeCrossfader"), GEngineUAnimNodeCrossfaderNatives); \
	UAnimNodePlayCustomAnim::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodePlayCustomAnim"), GEngineUAnimNodePlayCustomAnimNatives); \
	UAnimNodeBlendDirectional::StaticClass(); \
	UAnimNodeBlendList::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeBlendList"), GEngineUAnimNodeBlendListNatives); \
	UAnimNodeBlendByBase::StaticClass(); \
	UAnimNodeBlendByPhysics::StaticClass(); \
	UAnimNodeBlendByPosture::StaticClass(); \
	UAnimNodeBlendByProperty::StaticClass(); \
	UAnimNodeBlendBySpeed::StaticClass(); \
	UAnimNodeRandom::StaticClass(); \
	UAnimNodeBlendMultiBone::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeBlendMultiBone"), GEngineUAnimNodeBlendMultiBoneNatives); \
	UAnimNodeMirror::StaticClass(); \
	UAnimNodeScalePlayRate::StaticClass(); \
	UAnimNodeScaleRateBySpeed::StaticClass(); \
	UAnimNodeSlot::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeSlot"), GEngineUAnimNodeSlotNatives); \
	UAnimNodeSynch::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeSynch"), GEngineUAnimNodeSynchNatives); \
	UAnimTree::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimTree"), GEngineUAnimTreeNatives); \
	UAnimNodeSequence::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeSequence"), GEngineUAnimNodeSequenceNatives); \
	UAnimNodeSequenceBlendBase::StaticClass(); \
	UAnimNodeSequenceBlendByAim::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimNodeSequenceBlendByAim"), GEngineUAnimNodeSequenceBlendByAimNatives); \
	UAnimNodeFrame::StaticClass(); \
	UMorphNodeBase::StaticClass(); \
	UMorphNodeMultiPose::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MorphNodeMultiPose"), GEngineUMorphNodeMultiPoseNatives); \
	UMorphNodePose::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MorphNodePose"), GEngineUMorphNodePoseNatives); \
	UMorphNodeWeightBase::StaticClass(); \
	UMorphNodeWeight::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MorphNodeWeight"), GEngineUMorphNodeWeightNatives); \
	UMorphNodeWeightByBoneAngle::StaticClass(); \
	UMorphNodeWeightByBoneRotation::StaticClass(); \
	USkelControlBase::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SkelControlBase"), GEngineUSkelControlBaseNatives); \
	USkelControl_CCD_IK::StaticClass(); \
	USkelControl_Multiply::StaticClass(); \
	USkelControl_TwistBone::StaticClass(); \
	USkelControlLimb::StaticClass(); \
	USkelControlFootPlacement::StaticClass(); \
	USkelControlLookAt::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SkelControlLookAt"), GEngineUSkelControlLookAtNatives); \
	USkelControlSingleBone::StaticClass(); \
	USkelControlHandlebars::StaticClass(); \
	USkelControlWheel::StaticClass(); \
	USkelControlSpline::StaticClass(); \
	USkelControlTrail::StaticClass(); \
	UAnimSequence::StaticClass(); \
	GNativeLookupFuncs.Set(FName("AnimSequence"), GEngineUAnimSequenceNatives); \
	UAnimSet::StaticClass(); \
	UMorphTarget::StaticClass(); \
	UMorphTargetSet::StaticClass(); \
	GNativeLookupFuncs.Set(FName("MorphTargetSet"), GEngineUMorphTargetSetNatives); \
	UMorphWeightSequence::StaticClass(); \

#endif // ENGINE_ANIM_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineASkeletalMeshActorNatives[] = 
{ 
	MAP_NATIVE(ASkeletalMeshActor, execMAT_FinishAnimControl)
	MAP_NATIVE(ASkeletalMeshActor, execMAT_BeginAnimControl)
	MAP_NATIVE(ASkeletalMeshActor, execUpdateAnimSetList)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineASkeletalMeshActorMATNatives[] = 
{ 
	MAP_NATIVE(ASkeletalMeshActorMAT, execMAT_SetAnimPosition)
	MAP_NATIVE(ASkeletalMeshActorMAT, execMAT_SetSkelControlStrength)
	MAP_NATIVE(ASkeletalMeshActorMAT, execMAT_SetSkelControlScale)
	MAP_NATIVE(ASkeletalMeshActorMAT, execMAT_SetMorphWeight)
	MAP_NATIVE(ASkeletalMeshActorMAT, execMAT_SetAnimWeights)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNotify_TrailsNatives[] = 
{ 
	MAP_NATIVE(UAnimNotify_Trails, execGetNumSteps)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeNatives[] = 
{ 
	MAP_NATIVE(UAnimNode, execReplayAnim)
	MAP_NATIVE(UAnimNode, execStopAnim)
	MAP_NATIVE(UAnimNode, execPlayAnim)
	MAP_NATIVE(UAnimNode, execFindAnimNode)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeBlendBaseNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlendBase, execReplayAnim)
	MAP_NATIVE(UAnimNodeBlendBase, execStopAnim)
	MAP_NATIVE(UAnimNodeBlendBase, execPlayAnim)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNode_MultiBlendPerBoneNatives[] = 
{ 
	MAP_NATIVE(UAnimNode_MultiBlendPerBone, execSetMaskWeight)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeAimOffsetNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeAimOffset, execSetActiveProfileByIndex)
	MAP_NATIVE(UAnimNodeAimOffset, execSetActiveProfileByName)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeBlendNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlend, execSetBlendTarget)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeAdditiveBlendingNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeAdditiveBlending, execSetBlendTarget)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeBlendPerBoneNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlendPerBone, execSetBlendTarget)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeCrossfaderNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeCrossfader, execGetActiveChild)
	MAP_NATIVE(UAnimNodeCrossfader, execGetAnimName)
	MAP_NATIVE(UAnimNodeCrossfader, execBlendToLoopingAnim)
	MAP_NATIVE(UAnimNodeCrossfader, execPlayOneShotAnim)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodePlayCustomAnimNatives[] = 
{ 
	MAP_NATIVE(UAnimNodePlayCustomAnim, execStopCustomAnim)
	MAP_NATIVE(UAnimNodePlayCustomAnim, execPlayCustomAnimByDuration)
	MAP_NATIVE(UAnimNodePlayCustomAnim, execPlayCustomAnim)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeBlendListNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlendList, execSetActiveChild)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeBlendMultiBoneNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeBlendMultiBone, execSetTargetStartBone)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeSlotNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeSlot, execTickChildWeights)
	MAP_NATIVE(UAnimNodeSlot, execSetRootBoneRotationOption)
	MAP_NATIVE(UAnimNodeSlot, execSetRootBoneAxisOption)
	MAP_NATIVE(UAnimNodeSlot, execGetCustomAnimNodeSeq)
	MAP_NATIVE(UAnimNodeSlot, execSetActorAnimEndNotification)
	MAP_NATIVE(UAnimNodeSlot, execSetCustomAnim)
	MAP_NATIVE(UAnimNodeSlot, execSetAllowPauseAnims)
	MAP_NATIVE(UAnimNodeSlot, execStopCustomAnim)
	MAP_NATIVE(UAnimNodeSlot, execGetPlayedAnimation)
	MAP_NATIVE(UAnimNodeSlot, execPlayCustomAnimByDuration)
	MAP_NATIVE(UAnimNodeSlot, execPlayCustomAnim)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeSynchNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeSynch, execSetGroupRateScale)
	MAP_NATIVE(UAnimNodeSynch, execGetRelativePosition)
	MAP_NATIVE(UAnimNodeSynch, execForceRelativePosition)
	MAP_NATIVE(UAnimNodeSynch, execGetMasterNodeOfGroup)
	MAP_NATIVE(UAnimNodeSynch, execRemoveNodeFromGroup)
	MAP_NATIVE(UAnimNodeSynch, execAddNodeToGroup)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimTreeNatives[] = 
{ 
	MAP_NATIVE(UAnimTree, execGetGroupIndex)
	MAP_NATIVE(UAnimTree, execGetGroupRateScale)
	MAP_NATIVE(UAnimTree, execSetGroupRateScale)
	MAP_NATIVE(UAnimTree, execGetGroupRelativePosition)
	MAP_NATIVE(UAnimTree, execForceGroupRelativePosition)
	MAP_NATIVE(UAnimTree, execGetGroupNotifyMaster)
	MAP_NATIVE(UAnimTree, execGetGroupSynchMaster)
	MAP_NATIVE(UAnimTree, execSetAnimGroupForNode)
	MAP_NATIVE(UAnimTree, execSetUseSavedPose)
	MAP_NATIVE(UAnimTree, execFindMorphNode)
	MAP_NATIVE(UAnimTree, execFindSkelControl)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeSequenceNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeSequence, execSetRootBoneRotationOption)
	MAP_NATIVE(UAnimNodeSequence, execSetRootBoneAxisOption)
	MAP_NATIVE(UAnimNodeSequence, execGetTimeLeft)
	MAP_NATIVE(UAnimNodeSequence, execGetAnimPlaybackLength)
	MAP_NATIVE(UAnimNodeSequence, execGetGlobalPlayRate)
	MAP_NATIVE(UAnimNodeSequence, execGetGroupRelativePosition)
	MAP_NATIVE(UAnimNodeSequence, execFindGroupPosition)
	MAP_NATIVE(UAnimNodeSequence, execFindGroupRelativePosition)
	MAP_NATIVE(UAnimNodeSequence, execGetNormalizedPosition)
	MAP_NATIVE(UAnimNodeSequence, execSetPosition)
	MAP_NATIVE(UAnimNodeSequence, execReplayAnim)
	MAP_NATIVE(UAnimNodeSequence, execStopAnim)
	MAP_NATIVE(UAnimNodeSequence, execPlayAnim)
	MAP_NATIVE(UAnimNodeSequence, execSetAnim)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimNodeSequenceBlendByAimNatives[] = 
{ 
	MAP_NATIVE(UAnimNodeSequenceBlendByAim, execCheckAnimsUpToDate)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMorphNodeMultiPoseNatives[] = 
{ 
	MAP_NATIVE(UMorphNodeMultiPose, execUpdateMorphTarget)
	MAP_NATIVE(UMorphNodeMultiPose, execRemoveMorphTarget)
	MAP_NATIVE(UMorphNodeMultiPose, execAddMorphTarget)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMorphNodePoseNatives[] = 
{ 
	MAP_NATIVE(UMorphNodePose, execSetMorphTarget)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMorphNodeWeightNatives[] = 
{ 
	MAP_NATIVE(UMorphNodeWeight, execSetNodeWeight)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSkelControlBaseNatives[] = 
{ 
	MAP_NATIVE(USkelControlBase, execGetControlMetadataWeight)
	MAP_NATIVE(USkelControlBase, execSetSkelControlStrength)
	MAP_NATIVE(USkelControlBase, execSetSkelControlActive)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUSkelControlLookAtNatives[] = 
{ 
	MAP_NATIVE(USkelControlLookAt, execCanLookAtPoint)
	MAP_NATIVE(USkelControlLookAt, execSetLookAtAlpha)
	MAP_NATIVE(USkelControlLookAt, execInterpolateTargetLocation)
	MAP_NATIVE(USkelControlLookAt, execSetTargetLocation)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUAnimSequenceNatives[] = 
{ 
	MAP_NATIVE(UAnimSequence, execGetNotifyTimeByClass)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUMorphTargetSetNatives[] = 
{ 
	MAP_NATIVE(UMorphTargetSet, execFindMorphTarget)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(ASkeletalMeshActor,SkeletalMeshActor,SkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(ASkeletalMeshActor,SkeletalMeshActor,SavedCurrentTime)
VERIFY_CLASS_SIZE_NODIE(ASkeletalMeshActor)
VERIFY_CLASS_OFFSET_NODIE(ASkeletalMeshActorBasedOnExtremeContent,SkeletalMeshActorBasedOnExtremeContent,ExtremeContent)
VERIFY_CLASS_OFFSET_NODIE(ASkeletalMeshActorBasedOnExtremeContent,SkeletalMeshActorBasedOnExtremeContent,NonExtremeContent)
VERIFY_CLASS_SIZE_NODIE(ASkeletalMeshActorBasedOnExtremeContent)
VERIFY_CLASS_SIZE_NODIE(ASkeletalMeshActorSpawnable)
VERIFY_CLASS_SIZE_NODIE(ASkeletalMeshCinematicActor)
VERIFY_CLASS_OFFSET_NODIE(ASkeletalMeshActorMAT,SkeletalMeshActorMAT,SlotNodes)
VERIFY_CLASS_SIZE_NODIE(ASkeletalMeshActorMAT)
VERIFY_CLASS_OFFSET_NODIE(UHeadTrackingComponent,HeadTrackingComponent,TrackControllerName)
VERIFY_CLASS_OFFSET_NODIE(UHeadTrackingComponent,HeadTrackingComponent,RootMeshRotation)
VERIFY_CLASS_SIZE_NODIE(UHeadTrackingComponent)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm,AnimationCompressionAlgorithm,Description)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm,AnimationCompressionAlgorithm,RotationCompressionFormat)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm_Automatic,AnimationCompressionAlgorithm_Automatic,MaxEndEffectorError)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_Automatic)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_BitwiseCompressOnly)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_LeastDestructive)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm_RemoveEverySecondKey,AnimationCompressionAlgorithm_RemoveEverySecondKey,MinKeys)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_RemoveEverySecondKey)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm_RemoveLinearKeys,AnimationCompressionAlgorithm_RemoveLinearKeys,MaxPosDiff)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm_RemoveLinearKeys,AnimationCompressionAlgorithm_RemoveLinearKeys,ParentKeyScale)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_RemoveLinearKeys)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm_PerTrackCompression,AnimationCompressionAlgorithm_PerTrackCompression,MaxZeroingThreshold)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm_PerTrackCompression,AnimationCompressionAlgorithm_PerTrackCompression,PerReductionCachedData)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_PerTrackCompression)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm_RemoveTrivialKeys,AnimationCompressionAlgorithm_RemoveTrivialKeys,MaxPosDiff)
VERIFY_CLASS_OFFSET_NODIE(UAnimationCompressionAlgorithm_RemoveTrivialKeys,AnimationCompressionAlgorithm_RemoveTrivialKeys,MaxAngleDiff)
VERIFY_CLASS_SIZE_NODIE(UAnimationCompressionAlgorithm_RemoveTrivialKeys)
VERIFY_CLASS_SIZE_NODIE(UDEPRECATED_AnimationCompressionAlgorithm_RevertToRaw)
VERIFY_CLASS_SIZE_NODIE(UAnimMetaData)
VERIFY_CLASS_OFFSET_NODIE(UAnimMetaData_SkelControl,AnimMetaData_SkelControl,SkelControlNameList)
VERIFY_CLASS_OFFSET_NODIE(UAnimMetaData_SkelControl,AnimMetaData_SkelControl,SkelControlName_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(UAnimMetaData_SkelControl)
VERIFY_CLASS_OFFSET_NODIE(UAnimMetaData_SkelControlKeyFrame,AnimMetaData_SkelControlKeyFrame,KeyFrames)
VERIFY_CLASS_SIZE_NODIE(UAnimMetaData_SkelControlKeyFrame)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify,AnimNotify,NotifyColor)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify,AnimNotify,NotifyColor)
#endif
VERIFY_CLASS_SIZE_NODIE(UAnimNotify)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_CameraEffect,AnimNotify_CameraEffect,CameraLensEffect)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_CameraEffect)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_ClothingMaxDistanceScale,AnimNotify_ClothingMaxDistanceScale,StartScale)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_ClothingMaxDistanceScale,AnimNotify_ClothingMaxDistanceScale,Duration)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_ClothingMaxDistanceScale)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Footstep,AnimNotify_Footstep,FootDown)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Footstep)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_ForceField,AnimNotify_ForceField,ForceFieldComponent)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_ForceField,AnimNotify_ForceField,BoneName)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_ForceField)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Kismet,AnimNotify_Kismet,NotifyName)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Kismet)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_PlayParticleEffect,AnimNotify_PlayParticleEffect,PSTemplate)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_PlayParticleEffect,AnimNotify_PlayParticleEffect,BoneSocketModuleActorName)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_PlayParticleEffect)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Rumble,AnimNotify_Rumble,PredefinedWaveForm)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Rumble,AnimNotify_Rumble,EffectRadius)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Rumble)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Script,AnimNotify_Script,NotifyName)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Script,AnimNotify_Script,NotifyEndName)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Script)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Scripted)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_PawnMaterialParam,AnimNotify_PawnMaterialParam,ScalarParameterInterpArray)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_PawnMaterialParam)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_ViewShake,AnimNotify_ViewShake,Duration)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_ViewShake,AnimNotify_ViewShake,ShakeParams)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_ViewShake)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Sound,AnimNotify_Sound,SoundCue)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Sound,AnimNotify_Sound,PitchMultiplier)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Sound)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Trails,AnimNotify_Trails,PSTemplate)
VERIFY_CLASS_OFFSET_NODIE(UAnimNotify_Trails,AnimNotify_Trails,AnimNodeSeq)
VERIFY_CLASS_SIZE_NODIE(UAnimNotify_Trails)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UAnimObject,AnimObject,DrawWidth)
#else
VERIFY_CLASS_OFFSET_NODIE(UAnimObject,AnimObject,SkelComponent)
#endif
VERIFY_CLASS_OFFSET_NODIE(UAnimObject,AnimObject,SkelComponent)
VERIFY_CLASS_SIZE_NODIE(UAnimObject)
VERIFY_CLASS_OFFSET_NODIE(UAnimNode,AnimNode,NodeTickTag)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UAnimNode,AnimNode,LastUpdatedAnimMorphKeys)
#else
VERIFY_CLASS_OFFSET_NODIE(UAnimNode,AnimNode,SearchTag)
#endif
VERIFY_CLASS_SIZE_NODIE(UAnimNode)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendBase,AnimNodeBlendBase,Children)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendBase,AnimNodeBlendBase,BlendType)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendBase)
VERIFY_CLASS_OFFSET_NODIE(UAnimNode_MultiBlendPerBone,AnimNode_MultiBlendPerBone,PawnOwner)
VERIFY_CLASS_OFFSET_NODIE(UAnimNode_MultiBlendPerBone,AnimNode_MultiBlendPerBone,RotationBlendType)
VERIFY_CLASS_SIZE_NODIE(UAnimNode_MultiBlendPerBone)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeAimOffset,AnimNodeAimOffset,Aim)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeAimOffset,AnimNodeAimOffset,CurrentProfileIndex)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeAimOffset)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlend,AnimNodeBlend,Child2Weight)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlend,AnimNodeBlend,BlendTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlend)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeAdditiveBlending)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendPerBone,AnimNodeBlendPerBone,BranchStartBoneName)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendPerBone,AnimNodeBlendPerBone,LocalToCompReqBones)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendPerBone)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeCrossfader,AnimNodeCrossfader,DefaultAnimSeqName)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeCrossfader,AnimNodeCrossfader,PendingBlendOutTimeOneShot)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeCrossfader)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodePlayCustomAnim,AnimNodePlayCustomAnim,CustomPendingBlendOutTime)
VERIFY_CLASS_SIZE_NODIE(UAnimNodePlayCustomAnim)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendDirectional,AnimNodeBlendDirectional,DirDegreesPerSecond)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendDirectional,AnimNodeBlendDirectional,RotationOffset)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendDirectional)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendList,AnimNodeBlendList,TargetWeight)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendList,AnimNodeBlendList,EditorActiveChildIndex)
#else
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendList,AnimNodeBlendList,SliderPosition)
#endif
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendList)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendByBase,AnimNodeBlendByBase,Type)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendByBase,AnimNodeBlendByBase,CachedBase)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendByBase)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendByPhysics)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendByPosture)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendByProperty,AnimNodeBlendByProperty,PropertyName)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendByProperty,AnimNodeBlendByProperty,BlendToChild2Time)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendByProperty)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendBySpeed,AnimNodeBlendBySpeed,Speed)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendBySpeed,AnimNodeBlendBySpeed,BlendDelayRemaining)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendBySpeed)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeRandom,AnimNodeRandom,RandomInfo)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeRandom,AnimNodeRandom,PendingChildIndex)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeRandom)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendMultiBone,AnimNodeBlendMultiBone,BlendTargetList)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeBlendMultiBone,AnimNodeBlendMultiBone,SourceRequiredBones)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeBlendMultiBone)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeMirror)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeScalePlayRate,AnimNodeScalePlayRate,ScaleByValue)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeScalePlayRate)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeScaleRateBySpeed,AnimNodeScaleRateBySpeed,BaseSpeed)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeScaleRateBySpeed)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeSlot,AnimNodeSlot,PendingBlendOutTime)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeSlot,AnimNodeSlot,BlendTimeToGo)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSlot)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeSynch,AnimNodeSynch,Groups)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSynch)
VERIFY_CLASS_OFFSET_NODIE(UAnimTree,AnimTree,AnimTreeTemplate)
VERIFY_CLASS_OFFSET_NODIE(UAnimTree,AnimTree,AnimTickArray)
VERIFY_CLASS_SIZE_NODIE(UAnimTree)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeSequence,AnimNodeSequence,AnimSeqName)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeSequence,AnimNodeSequence,MetaDataSkelControlList)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSequence)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeSequenceBlendBase,AnimNodeSequenceBlendBase,Anims)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSequenceBlendBase)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeSequenceBlendByAim,AnimNodeSequenceBlendByAim,Aim)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeSequenceBlendByAim,AnimNodeSequenceBlendByAim,AnimName_RD)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeSequenceBlendByAim)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeFrame,AnimNodeFrame,SizeX)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeFrame,AnimNodeFrame,ObjComment)
#else
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeFrame,AnimNodeFrame,FillColor)
#endif
VERIFY_CLASS_SIZE_NODIE(UAnimNodeFrame)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodeBase,MorphNodeBase,NodeName)
VERIFY_CLASS_SIZE_NODIE(UMorphNodeBase)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodeMultiPose,MorphNodeMultiPose,Targets)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodeMultiPose,MorphNodeMultiPose,Weights)
VERIFY_CLASS_SIZE_NODIE(UMorphNodeMultiPose)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodePose,MorphNodePose,Target)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodePose,MorphNodePose,Weight)
VERIFY_CLASS_SIZE_NODIE(UMorphNodePose)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodeWeightBase,MorphNodeWeightBase,NodeConns)
VERIFY_CLASS_SIZE_NODIE(UMorphNodeWeightBase)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodeWeight,MorphNodeWeight,NodeWeight)
VERIFY_CLASS_SIZE_NODIE(UMorphNodeWeight)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodeWeightByBoneAngle,MorphNodeWeightByBoneAngle,Angle)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodeWeightByBoneAngle,MorphNodeWeightByBoneAngle,WeightArray)
VERIFY_CLASS_SIZE_NODIE(UMorphNodeWeightByBoneAngle)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodeWeightByBoneRotation,MorphNodeWeightByBoneRotation,Angle)
VERIFY_CLASS_OFFSET_NODIE(UMorphNodeWeightByBoneRotation,MorphNodeWeightByBoneRotation,MaterialInstanceConstant)
VERIFY_CLASS_SIZE_NODIE(UMorphNodeWeightByBoneRotation)
VERIFY_CLASS_OFFSET_NODIE(USkelControlBase,SkelControlBase,ControlName)
VERIFY_CLASS_OFFSET_NODIE(USkelControlBase,SkelControlBase,ControlPosY_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(USkelControlBase)
VERIFY_CLASS_OFFSET_NODIE(USkelControl_CCD_IK,SkelControl_CCD_IK,EffectorLocation)
VERIFY_CLASS_OFFSET_NODIE(USkelControl_CCD_IK,SkelControl_CCD_IK,MaxAngleSteps)
VERIFY_CLASS_SIZE_NODIE(USkelControl_CCD_IK)
VERIFY_CLASS_OFFSET_NODIE(USkelControl_Multiply,SkelControl_Multiply,Multiplier)
VERIFY_CLASS_SIZE_NODIE(USkelControl_Multiply)
VERIFY_CLASS_OFFSET_NODIE(USkelControl_TwistBone,SkelControl_TwistBone,SourceBoneName)
VERIFY_CLASS_OFFSET_NODIE(USkelControl_TwistBone,SkelControl_TwistBone,TwistAngleScale)
VERIFY_CLASS_SIZE_NODIE(USkelControl_TwistBone)
VERIFY_CLASS_OFFSET_NODIE(USkelControlLimb,SkelControlLimb,EffectorLocation)
VERIFY_CLASS_OFFSET_NODIE(USkelControlLimb,SkelControlLimb,StretchRollBoneName)
VERIFY_CLASS_SIZE_NODIE(USkelControlLimb)
VERIFY_CLASS_OFFSET_NODIE(USkelControlFootPlacement,SkelControlFootPlacement,FootOffset)
VERIFY_CLASS_OFFSET_NODIE(USkelControlFootPlacement,SkelControlFootPlacement,MaxFootOrientAdjust)
VERIFY_CLASS_SIZE_NODIE(USkelControlFootPlacement)
VERIFY_CLASS_OFFSET_NODIE(USkelControlLookAt,SkelControlLookAt,TargetLocation)
VERIFY_CLASS_OFFSET_NODIE(USkelControlLookAt,SkelControlLookAt,ControlBoneIndex)
VERIFY_CLASS_SIZE_NODIE(USkelControlLookAt)
VERIFY_CLASS_OFFSET_NODIE(USkelControlSingleBone,SkelControlSingleBone,BoneTranslation)
VERIFY_CLASS_OFFSET_NODIE(USkelControlSingleBone,SkelControlSingleBone,RotationSpaceBoneName)
VERIFY_CLASS_SIZE_NODIE(USkelControlSingleBone)
VERIFY_CLASS_OFFSET_NODIE(USkelControlHandlebars,SkelControlHandlebars,WheelRollAxis)
VERIFY_CLASS_OFFSET_NODIE(USkelControlHandlebars,SkelControlHandlebars,SteerWheelBoneIndex)
VERIFY_CLASS_SIZE_NODIE(USkelControlHandlebars)
VERIFY_CLASS_OFFSET_NODIE(USkelControlWheel,SkelControlWheel,WheelDisplacement)
VERIFY_CLASS_OFFSET_NODIE(USkelControlWheel,SkelControlWheel,WheelSteering)
VERIFY_CLASS_SIZE_NODIE(USkelControlWheel)
VERIFY_CLASS_OFFSET_NODIE(USkelControlSpline,SkelControlSpline,SplineLength)
VERIFY_CLASS_OFFSET_NODIE(USkelControlSpline,SkelControlSpline,StartSplineTension)
VERIFY_CLASS_SIZE_NODIE(USkelControlSpline)
VERIFY_CLASS_OFFSET_NODIE(USkelControlTrail,SkelControlTrail,ChainLength)
VERIFY_CLASS_OFFSET_NODIE(USkelControlTrail,SkelControlTrail,OldLocalToWorld)
VERIFY_CLASS_SIZE_NODIE(USkelControlTrail)
VERIFY_CLASS_OFFSET_NODIE(UAnimSequence,AnimSequence,SequenceName)
VERIFY_CLASS_OFFSET_NODIE(UAnimSequence,AnimSequence,UseScore)
VERIFY_CLASS_SIZE_NODIE(UAnimSequence)
VERIFY_CLASS_OFFSET_NODIE(UAnimSet,AnimSet,TrackBoneNames)
VERIFY_CLASS_OFFSET_NODIE(UAnimSet,AnimSet,BestRatioSkelMeshName)
VERIFY_CLASS_SIZE_NODIE(UAnimSet)
VERIFY_CLASS_OFFSET_NODIE(UMorphTarget,MorphTarget,MorphLODModels)
VERIFY_CLASS_OFFSET_NODIE(UMorphTarget,MorphTarget,MaterialSlotId)
VERIFY_CLASS_OFFSET_NODIE(UMorphTarget,MorphTarget,ScalarParameterName)
VERIFY_CLASS_SIZE_NODIE(UMorphTarget)
VERIFY_CLASS_OFFSET_NODIE(UMorphTargetSet,MorphTargetSet,Targets)
VERIFY_CLASS_OFFSET_NODIE(UMorphTargetSet,MorphTargetSet,RawWedgePointIndices)
VERIFY_CLASS_SIZE_NODIE(UMorphTargetSet)
VERIFY_CLASS_SIZE_NODIE(UMorphWeightSequence)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
