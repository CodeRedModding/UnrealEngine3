/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(Notify)
AUTOGENERATE_NAME(OnBecomeActive)
AUTOGENERATE_NAME(OnCeaseActive)
AUTOGENERATE_NAME(OnInit)

#ifndef NAMES_ONLY


struct AnimNode_eventOnInit_Parms
{
};
struct AnimNode_eventOnCeaseActive_Parms
{
};
struct AnimNode_eventOnBecomeActive_Parms
{
};
class UAnimNode : public UObject
{
public:
    class USkeletalMeshComponent* SkelComponent;
    class UAnimNodeBlendBase* ParentNode;
    FName NodeName;
    class UTexture2D* DebugIcon;
    FLOAT DebugHeight;
    INT NodePosX;
    INT NodePosY;
    INT OutDrawY;
    DECLARE_FUNCTION(execFindAnimNode);
    void eventOnInit()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnInit),NULL);
    }
    void eventOnCeaseActive()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnCeaseActive),NULL);
    }
    void eventOnBecomeActive()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_OnBecomeActive),NULL);
    }
    DECLARE_CLASS(UAnimNode,UObject,0,Engine)
	// UObject interface
	virtual void Destroy();

	// UAnimNode interface

	/** Do any initialisation, and then call InitAnim on all children. Should not discard any existing anim state though. */
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );

	/** 
	 *	Update this node, then call TickAnim on all children. 
	 *	@param DeltaSeconds		Amount of time to advance this node.
	 *	@param TotalWeight		The eventual weight that this node will have in the final blend. This is the multiplication of weights of all nodes above this one.
	 */
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight ) {}

	/** Add this node and all children to array. Node are added so a parent is always before its children in the array. */
	virtual void GetNodes( TArray<UAnimNode*>& Nodes );

	/** Get the local transform for each bone. If a blend, will recursively ask children and blend etc. */
	virtual void GetBoneAtoms( TArray<FBoneAtom>& Atoms );

	/** Get notification that this node has just become active ie. now has weight of more than 0.0. Note, this is only weight within parent blend, not overall. */
	virtual void OnBecomeActive();

	/** Get notification that this node's parent has just become active. */
	virtual void OnParentBecomeActive();

	/** Get notification that this node is stopped being active ie. now has weight of 0.0. See OnBecomeActive. */
	virtual void OnCeaseActive();

	/** Get notification that this node's parent has stopped being active */
	virtual void OnParentCeaseActive();

	/** Delete all children AnimNode Objects. */
	virtual void DestroyChildren() {}

	/** Find a node whose NodeName matches InNodeName. Will search this node and all below it. */
	UAnimNode* FindAnimNode(FName InNodeName);


	virtual void SetAnim( FName SequenceName ) {}
	virtual void PlayAnim( UBOOL bLoop=false, FLOAT Rate=1.0f, FLOAT StartTime=0.0f ) {}
	virtual void StopAnim() {}
	virtual void SetPosition( FLOAT NewTime ) {}

	/// DEBUGGING

	/** Draw debug info about this node. Will call this on its children. */
	virtual void DrawDebug(FRenderInterface* RI, FLOAT ParentPosX, FLOAT ParentPosY, FLOAT PosX, FLOAT PosY, FLOAT Weight);

	/** Recalculate heights used when displaying debug tree view. */
	virtual FLOAT CalcDebugHeight();


	/// ANIMTREE EDITOR

	/** For editor use. */
	virtual void DrawAnimNode(FRenderInterface* RI, UBOOL bSelected) {}

	/** For editor use. */
	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);


	// STATIC ANIMTREE UTILS

	/** Take the parent-space bone transform atoms and back into mesh-space transforms. Need RefSkel for parent info. */
	static void ComposeSkeleton( TArray<FBoneAtom>& LocalTransforms, TArray<struct FMeshBone>& RefSkel, TArray<FMatrix>& MeshTransforms, USkeletalMeshComponent* meshComp);

	/** Use supplied reference skeleton pose information to fill the in the array of FBoneAtoms with a 'default' pose. */
	static void FillWithRefPose( TArray<FBoneAtom>& Atoms, TArray<struct FMeshBone>& RefSkel );
};

struct FAnimBlendChild
{
    FName Name;
    class UAnimNode* Anim;
    FLOAT Weight;
    INT bActive;
    INT DrawY;
};


class UAnimNodeBlendBase : public UAnimNode
{
public:
    TArrayNoInit<FAnimBlendChild> Children;
    BITFIELD bFixNumChildren:1 GCC_PACK(PROPERTY_ALIGNMENT);
    INT DrawWidth GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(UAnimNodeBlendBase,UAnimNode,0,Engine)
	// UAnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	virtual void GetNodes( TArray<UAnimNode*>& Nodes );
	virtual void GetBoneAtoms( TArray<FBoneAtom>& Atoms );
	virtual void DestroyChildren();

	virtual void DrawDebug(FRenderInterface* RI, FLOAT ParentPosX, FLOAT ParentPosY, FLOAT PosX, FLOAT PosY, FLOAT Weight);
	virtual FLOAT CalcDebugHeight();

	virtual void DrawAnimNode(FRenderInterface* RI, UBOOL bSelected);
	virtual FIntPoint GetConnectionLocation(INT ConnType, INT ConnIndex);

	// UAnimNodeBlendBase interface



	/** Return the current weight of the supplied child. Returns 0.0 if this node is part of this blend. */
	FLOAT GetChildWeight(UAnimNode* Child);

	/** For debugging. Return the sum of the weights of all children nodes. Should always be 1.0. */
	FLOAT GetChildWeightTotal();

	/** Notification to this blend that a child UAnimNodeSequence has reached the end and stopped playing. Not called if child has bLooping set to true or if user calls StopAnim. */
	virtual void OnChildAnimEnd(UAnimNodeSequence* Child);

	/** Blends need to pass OnXXXXActive events to their children */

	virtual void OnBecomeActive();
	virtual void OnCeaseActive();
};


class UAnimNodeBlend : public UAnimNodeBlendBase
{
public:
    FLOAT Child2Weight;
    FLOAT Child2WeightTarget;
    FLOAT BlendTimeToGo;
    DECLARE_FUNCTION(execSetBlendTarget);
    DECLARE_CLASS(UAnimNodeBlend,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	// AnimNodeBlend interface

	/** Set the desired weight for the second animation (element 1 in the Children array) and how long to get there. */
	virtual void SetBlendTarget( FLOAT BlendTarget, FLOAT BlendTime );
};


class UAnimNodeBlendPerBone : public UAnimNodeBlend
{
public:
    TArrayNoInit<FLOAT> Child2PerBoneWeight;
    FName InitChild2StartBone;
    FLOAT InitPerBoneIncrease;
    DECLARE_FUNCTION(execSetChild2StartBone);
    DECLARE_CLASS(UAnimNodeBlendPerBone,UAnimNodeBlend,0,Engine)
	// AnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual void GetBoneAtoms( TArray<FBoneAtom>& Atoms);

	// AnimNodeBlendPerBone interface

	/** Utility for creating the Child2PerBoneWeight array. Starting from the named bone, walk down the heirarchy increasing the weight by PerBoneIncrease each step. */
	virtual void SetChild2StartBone( FName StartBoneName, FLOAT PerBoneIncrease=1.f );
};


class UAnimNodeCrossfader : public UAnimNodeBlend
{
public:
    BITFIELD bDontBlendOutOneShot:1 GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT PendingBlendOutTimeOneShot GCC_PACK(PROPERTY_ALIGNMENT);
    FName DefaultAnimSeqName;
    DECLARE_FUNCTION(execGetActiveChild);
    DECLARE_FUNCTION(execGetActiveAnimSeq);
    DECLARE_FUNCTION(execBlendToLoopingAnim);
    DECLARE_FUNCTION(execPlayOneShotAnim);
    DECLARE_CLASS(UAnimNodeCrossfader,UAnimNodeBlend,0,Engine)
	// UAnimNode interface
	virtual	void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
	UAnimNodeSequence *GetActiveChild();
};


class UAnimNodeBlendDirectional : public UAnimNodeBlendBase
{
public:
    FLOAT DirDegreesPerSecond;
    FLOAT DirAngle;
    DECLARE_CLASS(UAnimNodeBlendDirectional,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};


class UAnimNodeBlendList : public UAnimNodeBlendBase
{
public:
    TArrayNoInit<FLOAT> TargetWeight;
    FLOAT BlendTimeToGo;
    INT ActiveChildIndex;
    DECLARE_FUNCTION(execSetActiveChild);
    DECLARE_CLASS(UAnimNodeBlendList,UAnimNodeBlendBase,0,Engine)
	// AnimNode interface
	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	// AnimNodeBlendList interface

	/** Set the child we want to have be active ie. full weight. BlendTime indicates how long to get there. */
	virtual void SetActiveChild( INT ChildIndex, FLOAT BlendTime );
};


class UAnimNodeBlendByPosture : public UAnimNodeBlendList
{
public:
    DECLARE_CLASS(UAnimNodeBlendByPosture,UAnimNodeBlendList,0,Engine)
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );
};


class UAnimNodeBlendBySpeed : public UAnimNodeBlendList
{
public:
    FLOAT LastSpeed;
    INT LastChannel;
    FLOAT BlendUpTime;
    FLOAT BlendDownTime;
    FLOAT BlendDownPerc;
    TArrayNoInit<FLOAT> Constraints;
    DECLARE_CLASS(UAnimNodeBlendBySpeed,UAnimNodeBlendList,0,Engine)
	/**
	 * Blend animations based on an Owner's velocity.
	 *
	 * @param DeltaSeconds	Time since last tick in seconds.
	 */
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );

	/**
	 * Resets the last channel on becoming active.	
	 */
	virtual void OnBecomeActive();
};


class UAnimTree : public UAnimNodeBlendBase
{
public:
    DECLARE_CLASS(UAnimTree,UAnimNodeBlendBase,0,Engine)
	// UObject interface
	void DrawThumbnail( EThumbnailPrimType InPrimType, INT InX, INT InY, struct FChildViewport* InViewport, struct FRenderInterface* InRI, FLOAT InZoom, UBOOL InShowBackground, FLOAT InZoomPct, INT InFixedSz );
	FThumbnailDesc GetThumbnailDesc( FRenderInterface* InRI, FLOAT InZoom, INT InFixedSz );
	INT GetThumbnailLabels( TArray<FString>* InLabels );
};


class UAnimNodeSequence : public UAnimNode
{
public:
    FName AnimSeqName;
    FLOAT Rate;
    BITFIELD bPlaying:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bLooping:1;
    BITFIELD bNoNotifies:1;
    BITFIELD bCauseActorAnimEnd:1;
    BITFIELD bCauseActorAnimPlay:1;
    BITFIELD bZeroRootTranslationX:1;
    BITFIELD bZeroRootTranslationY:1;
    BITFIELD bZeroRootTranslationZ:1;
    FLOAT CurrentTime GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT NotifyWeightThreshold;
    class UAnimSequence* AnimSeq;
    Fpointer AnimLinkup;
    class UTexture2D* DebugTrack;
    class UTexture2D* DebugCarat;
    DECLARE_FUNCTION(execGetAnimLength);
    DECLARE_FUNCTION(execSetPosition);
    DECLARE_FUNCTION(execStopAnim);
    DECLARE_FUNCTION(execPlayAnim);
    DECLARE_FUNCTION(execSetAnim);
    DECLARE_CLASS(UAnimNodeSequence,UAnimNode,0,Engine)
	// UObject interface

	virtual void PostEditChange(UProperty* PropertyThatChanged);


	// AnimNode interface

	virtual void InitAnim( USkeletalMeshComponent* meshComp, UAnimNodeBlendBase* Parent );
	virtual	void TickAnim( FLOAT DeltaSeconds, FLOAT TotalWeight );	 // Progress the animation state, issue AnimEnd notifies.
	virtual void GetBoneAtoms( TArray<struct FBoneAtom>& Atoms);

	virtual void DrawDebug(FRenderInterface* RI, FLOAT ParentPosX, FLOAT ParentPosY, FLOAT PosX, FLOAT PosY, FLOAT Weight);

	virtual void DrawAnimNode(FRenderInterface* RI, UBOOL bSelected);

	// AnimNodeSequence interface

	void SetAnim( FName SequenceName );
	void PlayAnim( UBOOL bLoop=false, FLOAT Rate=1.0f, FLOAT StartTime=0.0f );
	void StopAnim();
	void SetPosition( FLOAT NewTime );

	FLOAT GetAnimLength();

	/** Issue any notifies tha are passed when moving from the current position to DeltaSeconds in the future. Called from TickAnim. */
	void IssueNotifies(FLOAT DeltaSeconds);
};


class UAnimNotify : public UObject
{
public:
    DECLARE_CLASS(UAnimNotify,UObject,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq ) {};

	// UObject interface.
	virtual void PostEditChange(UProperty* PropertyThatChanged);
};


class UAnimNotify_DestroyEffect : public UAnimNotify
{
public:
    FName DestroyTag;
    BITFIELD bExpireParticles:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(UAnimNotify_DestroyEffect,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
};


class UAnimNotify_Effect : public UAnimNotify
{
public:
    class UClass* EffectClass;
    FName Bone;
    FVector OffsetLocation;
    FRotator OffsetRotation;
    BITFIELD Attach:1 GCC_PACK(PROPERTY_ALIGNMENT);
    FName Tag GCC_PACK(PROPERTY_ALIGNMENT);
    FLOAT DrawScale;
    FVector DrawScale3D;
    class AActor* LastSpawnedEffect;
    DECLARE_CLASS(UAnimNotify_Effect,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
};


class UAnimNotify_Footstep : public UAnimNotify
{
public:
    INT FootDown;
    DECLARE_CLASS(UAnimNotify_Footstep,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
};


class UAnimNotify_Script : public UAnimNotify
{
public:
    FName NotifyName;
    DECLARE_CLASS(UAnimNotify_Script,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
};


struct AnimNotify_Scripted_eventNotify_Parms
{
    class AActor* Owner;
    class UAnimNodeSequence* AnimSeqInstigator;
};
class UAnimNotify_Scripted : public UAnimNotify
{
public:
    void eventNotify(class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator)
    {
        AnimNotify_Scripted_eventNotify_Parms Parms;
        Parms.Owner=Owner;
        Parms.AnimSeqInstigator=AnimSeqInstigator;
        ProcessEvent(FindFunctionChecked(ENGINE_Notify),&Parms);
    }
    DECLARE_CLASS(UAnimNotify_Scripted,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
};


class UAnimNotify_Sound : public UAnimNotify
{
public:
    class USoundCue* SoundCue;
    BITFIELD bFollowActor:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(UAnimNotify_Sound,UAnimNotify,0,Engine)
	// AnimNotify interface.
	virtual void Notify( class UAnimNodeSequence* NodeSeq );
};

struct FAnimNotifyEvent
{
    FLOAT Time;
    class UAnimNotify* Notify;
    FName Comment;
};


class UAnimSequence : public UObject
{
public:
    FName SequenceName;
    TArrayNoInit<FAnimNotifyEvent> Notifies;
    FLOAT SequenceLength;
    INT NumFrames;
    FLOAT RateScale;
    DECLARE_CLASS(UAnimSequence,UObject,0,Engine)
	/** One element for each track. */
	TLazyArray<FRawAnimSequenceTrack>			RawAnimData;



	// UObject interface

	virtual void Serialize(FArchive& Ar);
	virtual void PostLoad();


	// AnimSequence interface

	/** Interpolate the given track to the given time and return the bone information (position/orientation). */
	void GetBoneAtom(FBoneAtom& OutAtom, INT TrackIndex, FLOAT Time, UBOOL bLooping);

	/** Remove trivial frames from the Raw data (that is, if position or orientation is constant over whole animation). */
	void CompressRawAnimData();

	/** Sort the Notifies array by time, earliest first. */
	void SortNotifies();

	/** Size of total animation data in this AnimSequence in bytes. */
	INT GetAnimSequenceMemory();
};

struct FAnimSetMeshLinkup
{
    class USkeletalMesh* SkelMesh;
    TArrayNoInit<INT> BoneToTrackTable;
};


class UAnimSet : public UObject
{
public:
    TArrayNoInit<FName> TrackBoneNames;
    TArrayNoInit<class UAnimSequence*> Sequences;
    TArrayNoInit<FAnimSetMeshLinkup> LinkupCache;
    DECLARE_CLASS(UAnimSet,UObject,0,Engine)
	// UObject interface

	void DrawThumbnail( EThumbnailPrimType InPrimType, INT InX, INT InY, struct FChildViewport* InViewport, struct FRenderInterface* InRI, FLOAT InZoom, UBOOL InShowBackground, FLOAT InZoomPct, INT InFixedSz );
	FThumbnailDesc GetThumbnailDesc( FRenderInterface* InRI, FLOAT InZoom, INT InFixedSz );
	INT GetThumbnailLabels( TArray<FString>* InLabels );


	// UAnimSet interface

	/** 
	 * See if we can play sequences from this AnimSet on the provided SkeletalMesh.
	 * Returns true if there is a bone in SkelMesh for every track in the AnimSet - so will allow animation to play if mesh has too many bones.
	 */
	UBOOL CanPlayOnSkeletalMesh(USkeletalMesh* SkelMesh);

	/** Find an AnimSequence with the given name in this set. */
	UAnimSequence* FindAnimSequence(FName SequenceName);

	/** 
	 * Find a mesh linkup table (mapping of sequence tracks to bone indices) for a particular SkeletalMesh
	 * If one does not already exist, create it now.
	 */
	FAnimSetMeshLinkup* GetMeshLinkup(USkeletalMesh* SkelMesh);

	/** Find the track index for the bone with the supplied name. Returns INDEX_NONE if no track exists for that bone. */
	INT FindTrackWithName(FName BoneName);

	/** Size of total animation data in this AnimSet in bytes. */
	INT GetAnimSetMemory(); 

	/** Clear all sequences and reset the TrackBoneNames table. */
	void ResetAnimSet();
};

#endif

AUTOGENERATE_FUNCTION(UAnimNode,-1,execFindAnimNode);
AUTOGENERATE_FUNCTION(UAnimNodeBlend,-1,execSetBlendTarget);
AUTOGENERATE_FUNCTION(UAnimNodeBlendList,-1,execSetActiveChild);
AUTOGENERATE_FUNCTION(UAnimNodeBlendPerBone,-1,execSetChild2StartBone);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execGetActiveChild);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execGetActiveAnimSeq);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execBlendToLoopingAnim);
AUTOGENERATE_FUNCTION(UAnimNodeCrossfader,-1,execPlayOneShotAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execGetAnimLength);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execSetPosition);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execStopAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execPlayAnim);
AUTOGENERATE_FUNCTION(UAnimNodeSequence,-1,execSetAnim);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif

