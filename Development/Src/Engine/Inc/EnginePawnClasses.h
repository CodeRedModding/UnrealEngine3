/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_PAWN_ENUMS
#define INCLUDED_ENGINE_PAWN_ENUMS 1

enum EPathSearchType
{
    PST_Default             =0,
    PST_Breadth             =1,
    PST_NewBestPathTo       =2,
    PST_Constraint          =3,
    PST_MAX                 =4,
};
#define FOREACH_ENUM_EPATHSEARCHTYPE(op) \
    op(PST_Default) \
    op(PST_Breadth) \
    op(PST_NewBestPathTo) \
    op(PST_Constraint) 

#endif // !INCLUDED_ENGINE_PAWN_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_PAWN_CLASSES
#define INCLUDED_ENGINE_PAWN_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct FScalarParameterInterpStruct
{
    FName ParameterName;
    FLOAT ParameterValue;
    FLOAT InterpTime;
    FLOAT WarmupTime;

    /** Constructors */
    FScalarParameterInterpStruct() {}
    FScalarParameterInterpStruct(EEventParm)
    {
        appMemzero(this, sizeof(FScalarParameterInterpStruct));
    }
};

struct Pawn_eventSpeak_Parms
{
    class USoundCue* Cue;
    Pawn_eventSpeak_Parms(EEventParm)
    {
    }
};
struct Pawn_eventSoakPause_Parms
{
    Pawn_eventSoakPause_Parms(EEventParm)
    {
    }
};
struct Pawn_eventMessagePlayer_Parms
{
    FString msg;
    Pawn_eventMessagePlayer_Parms(EEventParm)
    {
    }
};
struct Pawn_eventCreateInventory_Parms
{
    class UClass* NewInvClass;
    UBOOL bDoNotActivate;
    class AInventory* ReturnValue;
    Pawn_eventCreateInventory_Parms(EEventParm)
    {
    }
};
struct Pawn_eventStopDriving_Parms
{
    class AVehicle* V;
    Pawn_eventStopDriving_Parms(EEventParm)
    {
    }
};
struct Pawn_eventStartDriving_Parms
{
    class AVehicle* V;
    Pawn_eventStartDriving_Parms(EEventParm)
    {
    }
};
struct Pawn_eventPlayFootStepSound_Parms
{
    INT FootDown;
    Pawn_eventPlayFootStepSound_Parms(EEventParm)
    {
    }
};
struct Pawn_eventBreathTimer_Parms
{
    Pawn_eventBreathTimer_Parms(EEventParm)
    {
    }
};
struct Pawn_eventHeadVolumeChange_Parms
{
    class APhysicsVolume* newHeadVolume;
    Pawn_eventHeadVolumeChange_Parms(EEventParm)
    {
    }
};
struct Pawn_eventTickSpecial_Parms
{
    FLOAT DeltaTime;
    Pawn_eventTickSpecial_Parms(EEventParm)
    {
    }
};
struct Pawn_eventIsSameTeam_Parms
{
    class APawn* Other;
    UBOOL ReturnValue;
    Pawn_eventIsSameTeam_Parms(EEventParm)
    {
    }
};
struct Pawn_eventTakeRadiusDamageOnBones_Parms
{
    class AController* InstigatedBy;
    FLOAT BaseDamage;
    FLOAT DamageRadius;
    class UClass* DamageType;
    FLOAT Momentum;
    FVector HurtOrigin;
    UBOOL bFullDamage;
    class AActor* DamageCauser;
    TArray<FName> Bones;
    UBOOL ReturnValue;
    Pawn_eventTakeRadiusDamageOnBones_Parms(EEventParm)
    {
    }
};
struct Pawn_eventStuckOnPawn_Parms
{
    class APawn* OtherPawn;
    Pawn_eventStuckOnPawn_Parms(EEventParm)
    {
    }
};
struct Pawn_eventUpdatePawnRotation_Parms
{
    FRotator NewRotation;
    Pawn_eventUpdatePawnRotation_Parms(EEventParm)
    {
    }
};
struct Pawn_eventStartCrouch_Parms
{
    FLOAT HeightAdjust;
    Pawn_eventStartCrouch_Parms(EEventParm)
    {
    }
};
struct Pawn_eventEndCrouch_Parms
{
    FLOAT HeightAdjust;
    Pawn_eventEndCrouch_Parms(EEventParm)
    {
    }
};
struct Pawn_eventClientMessage_Parms
{
    FString S;
    FName Type;
    Pawn_eventClientMessage_Parms(EEventParm)
    {
    }
};
struct Pawn_eventInFreeCam_Parms
{
    UBOOL ReturnValue;
    Pawn_eventInFreeCam_Parms(EEventParm)
    {
    }
};
struct Pawn_eventGetBaseAimRotation_Parms
{
    FRotator ReturnValue;
    Pawn_eventGetBaseAimRotation_Parms(EEventParm)
    {
    }
};
struct Pawn_eventGetWeaponStartTraceLocation_Parms
{
    class AWeapon* CurrentWeapon;
    FVector ReturnValue;
    Pawn_eventGetWeaponStartTraceLocation_Parms(EEventParm)
    {
    }
};
struct Pawn_eventGetPawnViewLocation_Parms
{
    FVector ReturnValue;
    Pawn_eventGetPawnViewLocation_Parms(EEventParm)
    {
    }
};
struct Pawn_eventGetViewRotation_Parms
{
    FRotator ReturnValue;
    Pawn_eventGetViewRotation_Parms(EEventParm)
    {
    }
};
struct Pawn_eventSetWalking_Parms
{
    UBOOL bNewIsWalking;
    Pawn_eventSetWalking_Parms(EEventParm)
    {
    }
};
struct Pawn_eventSpecialMoveThruEdge_Parms
{
    BYTE EdgeType;
    INT Dir;
    FVector MoveStart;
    FVector MoveDest;
    class AActor* RelActor;
    INT RelItem;
    class UNavigationHandle* NavHandle;
    UBOOL ReturnValue;
    Pawn_eventSpecialMoveThruEdge_Parms(EEventParm)
    {
    }
};
struct Pawn_eventMAT_FinishAIGroup_Parms
{
    Pawn_eventMAT_FinishAIGroup_Parms(EEventParm)
    {
    }
};
struct Pawn_eventMAT_BeginAIGroup_Parms
{
    FVector StartLoc;
    FRotator StartRot;
    Pawn_eventMAT_BeginAIGroup_Parms(EEventParm)
    {
    }
};
struct Pawn_eventRestoreAnimSetsToDefault_Parms
{
    UBOOL ReturnValue;
    Pawn_eventRestoreAnimSetsToDefault_Parms(EEventParm)
    {
    }
};
struct Pawn_eventAnimSetListUpdated_Parms
{
    Pawn_eventAnimSetListUpdated_Parms(EEventParm)
    {
    }
};
struct Pawn_eventBuildScriptAnimSetList_Parms
{
    Pawn_eventBuildScriptAnimSetList_Parms(EEventParm)
    {
    }
};
struct Pawn_eventCacheAnimNodes_Parms
{
    Pawn_eventCacheAnimNodes_Parms(EEventParm)
    {
    }
};
class APawn : public AActor, public IInterface_Speaker
{
public:
    //## BEGIN PROPS Pawn
    FLOAT MaxStepHeight;
    FLOAT MaxJumpHeight;
    FLOAT WalkableFloorZ;
    FLOAT LedgeCheckThreshold;
    FVector PartialLedgeMoveDir;
    class AController* Controller;
    class APawn* NextPawn;
    FLOAT NetRelevancyTime;
    class APlayerController* LastRealViewer;
    class AActor* LastViewer;
    BITFIELD bScriptTickSpecial:1;
    BITFIELD bUpAndOut:1;
    BITFIELD bIsWalking:1;
    BITFIELD bWantsToCrouch:1;
    BITFIELD bIsCrouched:1;
    BITFIELD bTryToUncrouch:1;
    BITFIELD bCanCrouch:1;
    BITFIELD bCrawler:1;
    BITFIELD bReducedSpeed:1;
    BITFIELD bJumpCapable:1;
    BITFIELD bCanJump:1;
    BITFIELD bCanWalk:1;
    BITFIELD bCanSwim:1;
    BITFIELD bCanFly:1;
    BITFIELD bCanClimbLadders:1;
    BITFIELD bCanStrafe:1;
    BITFIELD bAvoidLedges:1;
    BITFIELD bStopAtLedges:1;
    BITFIELD bAllowLedgeOverhang:1;
    BITFIELD bPartiallyOverLedge:1;
    BITFIELD bSimulateGravity:1;
    BITFIELD bIgnoreForces:1;
    BITFIELD bCanWalkOffLedges:1;
    BITFIELD bCanBeBaseForPawns:1;
    BITFIELD bSimGravityDisabled:1;
    BITFIELD bDirectHitWall:1;
    BITFIELD bPushesRigidBodies:1;
    BITFIELD bForceFloorCheck:1;
    BITFIELD bForceKeepAnchor:1;
    BITFIELD bCanMantle:1;
    BITFIELD bCanClimbUp:1;
    BITFIELD bCanClimbCeilings:1;
    BITFIELD bCanSwatTurn:1;
    BITFIELD bCanLeap:1;
    BITFIELD bCanCoverSlip:1;
    BITFIELD bDisplayPathErrors:1;
    BITFIELD bCanPickupInventory:1;
    BITFIELD bAmbientCreature:1;
    BITFIELD bLOSHearing:1;
    BITFIELD bMuffledHearing:1;
    BITFIELD bDontPossess:1;
    BITFIELD bRollToDesired:1;
    BITFIELD bStationary:1;
    BITFIELD bCachedRelevant:1;
    BITFIELD bNoWeaponFiring:1;
    BITFIELD bModifyReachSpecCost:1;
    BITFIELD bModifyNavPointDest:1;
    BITFIELD bPathfindsAsVehicle:1;
    BITFIELD bPrevBypassSimulatedClientPhysics:1;
    BITFIELD bRunPhysicsWithNoController:1;
    BITFIELD bForceMaxAccel:1;
    BITFIELD bLimitFallAccel:1;
    BITFIELD bReplicateHealthToAll:1;
    BITFIELD bForceRMVelocity:1;
    BITFIELD bForceRegularVelocity:1;
    BITFIELD bPlayedDeath:1;
private:
    BITFIELD bDesiredRotationSet:1;
    BITFIELD bLockDesiredRotation:1;
    BITFIELD bUnlockWhenReached:1;
public:
    BITFIELD bNeedsBaseTickedFirst:1;
    BITFIELD bUsedByMatinee:1;
    BITFIELD bRootMotionFromInterpCurve:1;
    BITFIELD bDebugShowCameraLocation:1;
    BITFIELD bFastAttachedMove:1;
    SCRIPT_ALIGN;
    BYTE WalkingPhysics;
    BYTE PathSearchType;
    BYTE RemoteViewPitch;
    BYTE FlashCount;
    BYTE FiringMode;
    FLOAT UncrouchTime;
    FLOAT CrouchHeight;
    FLOAT CrouchRadius;
    INT FullHeight;
    FLOAT NonPreferredVehiclePathMultiplier;
    class UPathConstraint* PathConstraintList;
    class UPathGoalEvaluator* PathGoalList;
    FLOAT DesiredSpeed;
    FLOAT MaxDesiredSpeed;
    FLOAT HearingThreshold;
    FLOAT Alertness;
    FLOAT SightRadius;
    FLOAT PeripheralVision;
    FLOAT AvgPhysicsTime;
    FLOAT Mass;
    FLOAT Buoyancy;
    FLOAT MeleeRange;
    class ANavigationPoint* Anchor;
    INT AnchorItem;
    class ANavigationPoint* LastAnchor;
    FLOAT FindAnchorFailedTime;
    FLOAT LastValidAnchorTime;
    FLOAT DestinationOffset;
    FLOAT NextPathRadius;
    FVector SerpentineDir;
    FLOAT SerpentineDist;
    FLOAT SerpentineTime;
    FLOAT SpawnTime;
    INT MaxPitchLimit;
    FLOAT GroundSpeed;
    FLOAT WaterSpeed;
    FLOAT AirSpeed;
    FLOAT LadderSpeed;
    FLOAT AccelRate;
    FLOAT JumpZ;
    FLOAT OutofWaterZ;
    FLOAT MaxOutOfWaterStepHeight;
    FLOAT AirControl;
    FLOAT WalkingPct;
    FLOAT MovementSpeedModifier;
    FLOAT CrouchedPct;
    FLOAT MaxFallSpeed;
    FLOAT AIMaxFallSpeedFactor;
    FLOAT BaseEyeHeight;
    FLOAT EyeHeight;
    FVector Floor;
    FLOAT SplashTime;
    class APhysicsVolume* HeadVolume;
    INT Health;
    INT HealthMax;
    FLOAT BreathTime;
    FLOAT UnderWaterTime;
    FLOAT LastPainTime;
    FLOAT KismetDeathDelayTime;
    FVector RMVelocity;
    FVector noise1spot;
    FLOAT noise1time;
    class APawn* noise1other;
    FLOAT noise1loudness;
    FVector noise2spot;
    FLOAT noise2time;
    class APawn* noise2other;
    FLOAT noise2loudness;
    FLOAT SoundDampening;
    FLOAT DamageScaling;
    FStringNoInit MenuName;
    class UClass* ControllerClass;
    class APlayerReplicationInfo* PlayerReplicationInfo;
    class ALadderVolume* OnLadder;
    FName LandMovementState;
    FName WaterMovementState;
    class APlayerStart* LastStartSpot;
    FLOAT LastStartTime;
    FVector TakeHitLocation;
    class UClass* HitDamageType;
    FVector TearOffMomentum;
    class USkeletalMeshComponent* Mesh;
    class UCylinderComponent* CylinderComponent;
    FLOAT RBPushRadius;
    FLOAT RBPushStrength;
    class AVehicle* DrivenVehicle;
    FLOAT AlwaysRelevantDistanceSquared;
    FLOAT VehicleCheckRadius;
    class AController* LastHitBy;
    FLOAT ViewPitchMin;
    FLOAT ViewPitchMax;
    INT AllowedYawError;
    FRotator DesiredRotation;
    class UClass* InventoryManagerClass;
    class AInventoryManager* InvManager;
    class AWeapon* Weapon;
    FVector FlashLocation;
    FVector LastFiringFlashLocation;
    INT ShotCount;
    class UPrimitiveComponent* PreRagdollCollisionComponent;
    class URB_BodyInstance* PhysicsPushBody;
    INT FailedLandingCount;
    TArrayNoInit<class UAnimNodeSlot*> SlotNodes;
    TArrayNoInit<class UInterpGroup*> InterpGroupList;
    class UAudioComponent* FacialAudioComp;
    class UMaterialInstanceConstant* MIC_PawnMat;
    class UMaterialInstanceConstant* MIC_PawnHair;
    TArrayNoInit<struct FScalarParameterInterpStruct> ScalarParameterInterpArray;
    struct FRootMotionCurve RootMotionInterpCurve;
    FLOAT RootMotionInterpRate;
    FLOAT RootMotionInterpCurrentTime;
    FVector RootMotionInterpCurveLastValue;
    //## END PROPS Pawn

    UBOOL PickWallAdjust(FVector WallHitNormal,class AActor* HitActor);
    UBOOL SetDesiredRotation(FRotator TargetDesiredRotation,UBOOL InLockDesiredRotation=FALSE,UBOOL InUnlockWhenReached=FALSE,FLOAT InterpolationTime=-1.000000,UBOOL bResetRotationRate=TRUE);
    void LockDesiredRotation(UBOOL Lock,UBOOL InUnlockWhenReached=FALSE);
    void ResetDesiredRotation();
    void CheckDesiredRotation();
    UBOOL IsDesiredRotationInUse();
    UBOOL IsDesiredRotationLocked();
    virtual void CacheAnimNodes();
    void UpdateAnimSetList();
    void AddAnimSets(const TArray<class UAnimSet*>& CustomAnimSets);
    virtual void MAT_BeginAnimControl(class UInterpGroup* InInterpGroup);
    virtual void MAT_FinishAnimControl(class UInterpGroup* InInterpGroup);
    virtual void MAT_SetAnimPosition(FName SlotName,INT ChannelIndex,FName InAnimSeqName,FLOAT InPosition,UBOOL bFireNotifies,UBOOL bLooping,UBOOL bEnableRootMotion);
    virtual void MAT_SetAnimWeights(const TArray<struct FAnimSlotInfo>& SlotInfos);
    virtual void MAT_SetMorphWeight(FName MorphNodeName,FLOAT MorphWeight);
    virtual void MAT_SetSkelControlScale(FName SkelControlName,FLOAT Scale);
    virtual void MAT_SetSkelControlStrength(FName SkelControlName,FLOAT ControlStrength);
    virtual UBOOL IsAliveAndWell() const;
    virtual FVector AdjustDestination(class AActor* GoalActor,FVector Dest=FVector(EC_EventParm));
    UBOOL ValidAnchor();
    virtual UBOOL SuggestJumpVelocity(FVector& JumpVelocity,FVector Destination,FVector Start,UBOOL bRequireFallLanding=FALSE);
    virtual FLOAT GetFallDuration();
    virtual UBOOL IsValidEnemyTargetFor(const class APlayerReplicationInfo* PRI,UBOOL bNoPRIisEnemy);
    virtual UBOOL IsInvisible();
    void SetRemoteViewPitch(INT NewRemoteViewPitch);
    virtual void SetAnchor(class ANavigationPoint* NewAnchor);
    virtual class ANavigationPoint* GetBestAnchor(class AActor* TestActor,FVector TestLocation,UBOOL bStartPoint,UBOOL bOnlyCheckVisible,FLOAT& out_Dist);
    virtual UBOOL ReachedDestination(class AActor* Goal);
    virtual UBOOL ReachedPoint(FVector Point,class AActor* NewAnchor);
    virtual void ForceCrouch();
    virtual void SetPushesRigidBodies(UBOOL NewPush);
    virtual UBOOL ReachedDesiredRotation();
    virtual void GetBoundingCylinder(FLOAT& CollisionRadius,FLOAT& CollisionHeight) const;
    virtual UBOOL InitRagdoll();
    virtual UBOOL TermRagdoll();
    UBOOL IsHumanControlled(class AController* PawnController=NULL);
    UBOOL IsLocallyControlled();
    virtual UBOOL IsPlayerPawn() const;
    virtual FRotator GetViewRotation();
    virtual FVector GetPawnViewLocation();
    virtual BYTE GetTeamNum();
    virtual class AVehicle* GetVehicleBase();
    virtual void ClearConstraints();
    virtual void AddPathConstraint(class UPathConstraint* Constraint);
    virtual void AddGoalEvaluator(class UPathGoalEvaluator* Evaluator);
    virtual void IncrementPathStep(INT Cnt,class UCanvas* C);
    virtual void IncrementPathChild(INT Cnt,class UCanvas* C);
    virtual void DrawPathStep(class UCanvas* C);
    virtual void ClearPathStep();
    virtual void SetRootMotionInterpCurrentTime(FLOAT inTime,FLOAT DeltaTime=0,UBOOL bUpdateSkelPose=FALSE);
    void SetScalarParameterInterp(const struct FScalarParameterInterpStruct& ScalarParameterInterp);
    DECLARE_FUNCTION(execPickWallAdjust)
    {
        P_GET_STRUCT(FVector,WallHitNormal);
        P_GET_OBJECT(AActor,HitActor);
        P_FINISH;
        *(UBOOL*)Result=this->PickWallAdjust(WallHitNormal,HitActor);
    }
    DECLARE_FUNCTION(execSetDesiredRotation)
    {
        P_GET_STRUCT(FRotator,TargetDesiredRotation);
        P_GET_UBOOL_OPTX(InLockDesiredRotation,FALSE);
        P_GET_UBOOL_OPTX(InUnlockWhenReached,FALSE);
        P_GET_FLOAT_OPTX(InterpolationTime,-1.000000);
        P_GET_UBOOL_OPTX(bResetRotationRate,TRUE);
        P_FINISH;
        *(UBOOL*)Result=this->SetDesiredRotation(TargetDesiredRotation,InLockDesiredRotation,InUnlockWhenReached,InterpolationTime,bResetRotationRate);
    }
    DECLARE_FUNCTION(execLockDesiredRotation)
    {
        P_GET_UBOOL(Lock);
        P_GET_UBOOL_OPTX(InUnlockWhenReached,FALSE);
        P_FINISH;
        this->LockDesiredRotation(Lock,InUnlockWhenReached);
    }
    DECLARE_FUNCTION(execResetDesiredRotation)
    {
        P_FINISH;
        this->ResetDesiredRotation();
    }
    DECLARE_FUNCTION(execCheckDesiredRotation)
    {
        P_FINISH;
        this->CheckDesiredRotation();
    }
    DECLARE_FUNCTION(execIsDesiredRotationInUse)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsDesiredRotationInUse();
    }
    DECLARE_FUNCTION(execIsDesiredRotationLocked)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsDesiredRotationLocked();
    }
    DECLARE_FUNCTION(execCacheAnimNodes)
    {
        P_FINISH;
        this->CacheAnimNodes();
    }
    DECLARE_FUNCTION(execUpdateAnimSetList)
    {
        P_FINISH;
        this->UpdateAnimSetList();
    }
    DECLARE_FUNCTION(execAddAnimSets)
    {
        P_GET_TARRAY_REF(class UAnimSet*,CustomAnimSets);
        P_FINISH;
        this->AddAnimSets(CustomAnimSets);
    }
    DECLARE_FUNCTION(execMAT_BeginAnimControl)
    {
        P_GET_OBJECT(UInterpGroup,InInterpGroup);
        P_FINISH;
        this->MAT_BeginAnimControl(InInterpGroup);
    }
    DECLARE_FUNCTION(execMAT_FinishAnimControl)
    {
        P_GET_OBJECT(UInterpGroup,InInterpGroup);
        P_FINISH;
        this->MAT_FinishAnimControl(InInterpGroup);
    }
    DECLARE_FUNCTION(execMAT_SetAnimPosition)
    {
        P_GET_NAME(SlotName);
        P_GET_INT(ChannelIndex);
        P_GET_NAME(InAnimSeqName);
        P_GET_FLOAT(InPosition);
        P_GET_UBOOL(bFireNotifies);
        P_GET_UBOOL(bLooping);
        P_GET_UBOOL(bEnableRootMotion);
        P_FINISH;
        this->MAT_SetAnimPosition(SlotName,ChannelIndex,InAnimSeqName,InPosition,bFireNotifies,bLooping,bEnableRootMotion);
    }
    DECLARE_FUNCTION(execMAT_SetAnimWeights)
    {
        P_GET_TARRAY(struct FAnimSlotInfo,SlotInfos);
        P_FINISH;
        this->MAT_SetAnimWeights(SlotInfos);
    }
    DECLARE_FUNCTION(execMAT_SetMorphWeight)
    {
        P_GET_NAME(MorphNodeName);
        P_GET_FLOAT(MorphWeight);
        P_FINISH;
        this->MAT_SetMorphWeight(MorphNodeName,MorphWeight);
    }
    DECLARE_FUNCTION(execMAT_SetSkelControlScale)
    {
        P_GET_NAME(SkelControlName);
        P_GET_FLOAT(Scale);
        P_FINISH;
        this->MAT_SetSkelControlScale(SkelControlName,Scale);
    }
    DECLARE_FUNCTION(execMAT_SetSkelControlStrength)
    {
        P_GET_NAME(SkelControlName);
        P_GET_FLOAT(ControlStrength);
        P_FINISH;
        this->MAT_SetSkelControlStrength(SkelControlName,ControlStrength);
    }
    DECLARE_FUNCTION(execIsAliveAndWell)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsAliveAndWell();
    }
    DECLARE_FUNCTION(execAdjustDestination)
    {
        P_GET_OBJECT(AActor,GoalActor);
        P_GET_STRUCT_OPTX(FVector,Dest,FVector(EC_EventParm));
        P_FINISH;
        *(FVector*)Result=this->AdjustDestination(GoalActor,Dest);
    }
    DECLARE_FUNCTION(execValidAnchor)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ValidAnchor();
    }
    DECLARE_FUNCTION(execSuggestJumpVelocity)
    {
        P_GET_STRUCT_REF(FVector,JumpVelocity);
        P_GET_STRUCT(FVector,Destination);
        P_GET_STRUCT(FVector,Start);
        P_GET_UBOOL_OPTX(bRequireFallLanding,FALSE);
        P_FINISH;
        *(UBOOL*)Result=this->SuggestJumpVelocity(JumpVelocity,Destination,Start,bRequireFallLanding);
    }
    DECLARE_FUNCTION(execGetFallDuration)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetFallDuration();
    }
    DECLARE_FUNCTION(execIsValidEnemyTargetFor)
    {
        P_GET_OBJECT(APlayerReplicationInfo,PRI);
        P_GET_UBOOL(bNoPRIisEnemy);
        P_FINISH;
        *(UBOOL*)Result=this->IsValidEnemyTargetFor(PRI,bNoPRIisEnemy);
    }
    DECLARE_FUNCTION(execIsInvisible)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsInvisible();
    }
    DECLARE_FUNCTION(execSetRemoteViewPitch)
    {
        P_GET_INT(NewRemoteViewPitch);
        P_FINISH;
        this->SetRemoteViewPitch(NewRemoteViewPitch);
    }
    DECLARE_FUNCTION(execSetAnchor)
    {
        P_GET_OBJECT(ANavigationPoint,NewAnchor);
        P_FINISH;
        this->SetAnchor(NewAnchor);
    }
    DECLARE_FUNCTION(execGetBestAnchor)
    {
        P_GET_OBJECT(AActor,TestActor);
        P_GET_STRUCT(FVector,TestLocation);
        P_GET_UBOOL(bStartPoint);
        P_GET_UBOOL(bOnlyCheckVisible);
        P_GET_FLOAT_REF(out_Dist);
        P_FINISH;
        *(class ANavigationPoint**)Result=this->GetBestAnchor(TestActor,TestLocation,bStartPoint,bOnlyCheckVisible,out_Dist);
    }
    DECLARE_FUNCTION(execReachedDestination)
    {
        P_GET_OBJECT(AActor,Goal);
        P_FINISH;
        *(UBOOL*)Result=this->ReachedDestination(Goal);
    }
    DECLARE_FUNCTION(execReachedPoint)
    {
        P_GET_STRUCT(FVector,Point);
        P_GET_OBJECT(AActor,NewAnchor);
        P_FINISH;
        *(UBOOL*)Result=this->ReachedPoint(Point,NewAnchor);
    }
    DECLARE_FUNCTION(execForceCrouch)
    {
        P_FINISH;
        this->ForceCrouch();
    }
    DECLARE_FUNCTION(execSetPushesRigidBodies)
    {
        P_GET_UBOOL(NewPush);
        P_FINISH;
        this->SetPushesRigidBodies(NewPush);
    }
    DECLARE_FUNCTION(execReachedDesiredRotation)
    {
        P_FINISH;
        *(UBOOL*)Result=this->ReachedDesiredRotation();
    }
    DECLARE_FUNCTION(execInitRagdoll)
    {
        P_FINISH;
        *(UBOOL*)Result=this->InitRagdoll();
    }
    DECLARE_FUNCTION(execTermRagdoll)
    {
        P_FINISH;
        *(UBOOL*)Result=this->TermRagdoll();
    }
    DECLARE_FUNCTION(execIsHumanControlled)
    {
        P_GET_OBJECT_OPTX(AController,PawnController,NULL);
        P_FINISH;
        *(UBOOL*)Result=this->IsHumanControlled(PawnController);
    }
    DECLARE_FUNCTION(execIsLocallyControlled)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsLocallyControlled();
    }
    DECLARE_FUNCTION(execIsPlayerPawn)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsPlayerPawn();
    }
    DECLARE_FUNCTION(execGetViewRotation)
    {
        P_FINISH;
        *(FRotator*)Result=this->GetViewRotation();
    }
    DECLARE_FUNCTION(execGetPawnViewLocation)
    {
        P_FINISH;
        *(FVector*)Result=this->GetPawnViewLocation();
    }
    DECLARE_FUNCTION(execGetVehicleBase)
    {
        P_FINISH;
        *(class AVehicle**)Result=this->GetVehicleBase();
    }
    DECLARE_FUNCTION(execClearConstraints)
    {
        P_FINISH;
        this->ClearConstraints();
    }
    DECLARE_FUNCTION(execAddPathConstraint)
    {
        P_GET_OBJECT(UPathConstraint,Constraint);
        P_FINISH;
        this->AddPathConstraint(Constraint);
    }
    DECLARE_FUNCTION(execAddGoalEvaluator)
    {
        P_GET_OBJECT(UPathGoalEvaluator,Evaluator);
        P_FINISH;
        this->AddGoalEvaluator(Evaluator);
    }
    DECLARE_FUNCTION(execIncrementPathStep)
    {
        P_GET_INT(Cnt);
        P_GET_OBJECT(UCanvas,C);
        P_FINISH;
        this->IncrementPathStep(Cnt,C);
    }
    DECLARE_FUNCTION(execIncrementPathChild)
    {
        P_GET_INT(Cnt);
        P_GET_OBJECT(UCanvas,C);
        P_FINISH;
        this->IncrementPathChild(Cnt,C);
    }
    DECLARE_FUNCTION(execDrawPathStep)
    {
        P_GET_OBJECT(UCanvas,C);
        P_FINISH;
        this->DrawPathStep(C);
    }
    DECLARE_FUNCTION(execClearPathStep)
    {
        P_FINISH;
        this->ClearPathStep();
    }
    DECLARE_FUNCTION(execSetRootMotionInterpCurrentTime)
    {
        P_GET_FLOAT(inTime);
        P_GET_FLOAT_OPTX(DeltaTime,0);
        P_GET_UBOOL_OPTX(bUpdateSkelPose,FALSE);
        P_FINISH;
        this->SetRootMotionInterpCurrentTime(inTime,DeltaTime,bUpdateSkelPose);
    }
    DECLARE_FUNCTION(execSetScalarParameterInterp)
    {
        P_GET_STRUCT_REF(struct FScalarParameterInterpStruct,ScalarParameterInterp);
        P_FINISH;
        this->SetScalarParameterInterp(ScalarParameterInterp);
    }
    void eventSpeak(class USoundCue* Cue)
    {
        Pawn_eventSpeak_Parms Parms(EC_EventParm);
        Parms.Cue=Cue;
        ProcessEvent(FindFunctionChecked(ENGINE_Speak),&Parms);
    }
    void eventSoakPause()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_SoakPause),NULL);
    }
    void eventMessagePlayer(const FString& msg)
    {
        Pawn_eventMessagePlayer_Parms Parms(EC_EventParm);
        Parms.msg=msg;
        ProcessEvent(FindFunctionChecked(ENGINE_MessagePlayer),&Parms);
    }
    class AInventory* eventCreateInventory(class UClass* NewInvClass,UBOOL bDoNotActivate=FALSE)
    {
        Pawn_eventCreateInventory_Parms Parms(EC_EventParm);
        Parms.ReturnValue=NULL;
        Parms.NewInvClass=NewInvClass;
        Parms.bDoNotActivate=bDoNotActivate ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_CreateInventory),&Parms);
        return Parms.ReturnValue;
    }
    void eventStopDriving(class AVehicle* V)
    {
        Pawn_eventStopDriving_Parms Parms(EC_EventParm);
        Parms.V=V;
        ProcessEvent(FindFunctionChecked(ENGINE_StopDriving),&Parms);
    }
    void eventStartDriving(class AVehicle* V)
    {
        Pawn_eventStartDriving_Parms Parms(EC_EventParm);
        Parms.V=V;
        ProcessEvent(FindFunctionChecked(ENGINE_StartDriving),&Parms);
    }
    void eventPlayFootStepSound(INT FootDown)
    {
        Pawn_eventPlayFootStepSound_Parms Parms(EC_EventParm);
        Parms.FootDown=FootDown;
        ProcessEvent(FindFunctionChecked(ENGINE_PlayFootStepSound),&Parms);
    }
    void eventBreathTimer()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_BreathTimer),NULL);
    }
    void eventHeadVolumeChange(class APhysicsVolume* newHeadVolume)
    {
        Pawn_eventHeadVolumeChange_Parms Parms(EC_EventParm);
        Parms.newHeadVolume=newHeadVolume;
        ProcessEvent(FindFunctionChecked(ENGINE_HeadVolumeChange),&Parms);
    }
    void eventTickSpecial(FLOAT DeltaTime)
    {
        Pawn_eventTickSpecial_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_TickSpecial),&Parms);
    }
    UBOOL eventIsSameTeam(class APawn* Other)
    {
        Pawn_eventIsSameTeam_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Other=Other;
        ProcessEvent(FindFunctionChecked(ENGINE_IsSameTeam),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventTakeRadiusDamageOnBones(class AController* InstigatedBy,FLOAT BaseDamage,FLOAT DamageRadius,class UClass* DamageType,FLOAT Momentum,FVector HurtOrigin,UBOOL bFullDamage,class AActor* DamageCauser,const TArray<FName>& Bones)
    {
        Pawn_eventTakeRadiusDamageOnBones_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.InstigatedBy=InstigatedBy;
        Parms.BaseDamage=BaseDamage;
        Parms.DamageRadius=DamageRadius;
        Parms.DamageType=DamageType;
        Parms.Momentum=Momentum;
        Parms.HurtOrigin=HurtOrigin;
        Parms.bFullDamage=bFullDamage ? FIRST_BITFIELD : FALSE;
        Parms.DamageCauser=DamageCauser;
        Parms.Bones=Bones;
        ProcessEvent(FindFunctionChecked(ENGINE_TakeRadiusDamageOnBones),&Parms);
        return Parms.ReturnValue;
    }
    void eventStuckOnPawn(class APawn* OtherPawn)
    {
        Pawn_eventStuckOnPawn_Parms Parms(EC_EventParm);
        Parms.OtherPawn=OtherPawn;
        ProcessEvent(FindFunctionChecked(ENGINE_StuckOnPawn),&Parms);
    }
    void eventUpdatePawnRotation(FRotator NewRotation)
    {
        Pawn_eventUpdatePawnRotation_Parms Parms(EC_EventParm);
        Parms.NewRotation=NewRotation;
        ProcessEvent(FindFunctionChecked(ENGINE_UpdatePawnRotation),&Parms);
    }
    void eventStartCrouch(FLOAT HeightAdjust)
    {
        Pawn_eventStartCrouch_Parms Parms(EC_EventParm);
        Parms.HeightAdjust=HeightAdjust;
        ProcessEvent(FindFunctionChecked(ENGINE_StartCrouch),&Parms);
    }
    void eventEndCrouch(FLOAT HeightAdjust)
    {
        Pawn_eventEndCrouch_Parms Parms(EC_EventParm);
        Parms.HeightAdjust=HeightAdjust;
        ProcessEvent(FindFunctionChecked(ENGINE_EndCrouch),&Parms);
    }
    void eventClientMessage(const FString& S,FName Type=NAME_None)
    {
        Pawn_eventClientMessage_Parms Parms(EC_EventParm);
        Parms.S=S;
        Parms.Type=Type;
        ProcessEvent(FindFunctionChecked(ENGINE_ClientMessage),&Parms);
    }
    UBOOL eventInFreeCam()
    {
        Pawn_eventInFreeCam_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_InFreeCam),&Parms);
        return Parms.ReturnValue;
    }
    FRotator eventGetBaseAimRotation()
    {
        Pawn_eventGetBaseAimRotation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetBaseAimRotation),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetWeaponStartTraceLocation(class AWeapon* CurrentWeapon=NULL)
    {
        Pawn_eventGetWeaponStartTraceLocation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        Parms.CurrentWeapon=CurrentWeapon;
        ProcessEvent(FindFunctionChecked(ENGINE_GetWeaponStartTraceLocation),&Parms);
        return Parms.ReturnValue;
    }
    FVector eventGetPawnViewLocation()
    {
        Pawn_eventGetPawnViewLocation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetPawnViewLocation),&Parms);
        return Parms.ReturnValue;
    }
    FRotator eventGetViewRotation()
    {
        Pawn_eventGetViewRotation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetViewRotation),&Parms);
        return Parms.ReturnValue;
    }
    void eventSetWalking(UBOOL bNewIsWalking)
    {
        Pawn_eventSetWalking_Parms Parms(EC_EventParm);
        Parms.bNewIsWalking=bNewIsWalking ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_SetWalking),&Parms);
    }
    UBOOL eventSpecialMoveThruEdge(BYTE EdgeType,INT Dir,FVector MoveStart,FVector MoveDest,class AActor* RelActor=NULL,INT RelItem=0,class UNavigationHandle* NavHandle=NULL)
    {
        Pawn_eventSpecialMoveThruEdge_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.EdgeType=EdgeType;
        Parms.Dir=Dir;
        Parms.MoveStart=MoveStart;
        Parms.MoveDest=MoveDest;
        Parms.RelActor=RelActor;
        Parms.RelItem=RelItem;
        Parms.NavHandle=NavHandle;
        ProcessEvent(FindFunctionChecked(ENGINE_SpecialMoveThruEdge),&Parms);
        return Parms.ReturnValue;
    }
    void eventMAT_FinishAIGroup()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_MAT_FinishAIGroup),NULL);
    }
    void eventMAT_BeginAIGroup(FVector StartLoc,FRotator StartRot)
    {
        Pawn_eventMAT_BeginAIGroup_Parms Parms(EC_EventParm);
        Parms.StartLoc=StartLoc;
        Parms.StartRot=StartRot;
        ProcessEvent(FindFunctionChecked(ENGINE_MAT_BeginAIGroup),&Parms);
    }
    UBOOL eventRestoreAnimSetsToDefault()
    {
        Pawn_eventRestoreAnimSetsToDefault_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_RestoreAnimSetsToDefault),&Parms);
        return Parms.ReturnValue;
    }
    void eventAnimSetListUpdated()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_AnimSetListUpdated),NULL);
    }
    void eventBuildScriptAnimSetList()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_BuildScriptAnimSetList),NULL);
    }
    void eventCacheAnimNodes()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_CacheAnimNodes),NULL);
    }
    DECLARE_ABSTRACT_CLASS(APawn,AActor,0|CLASS_Config|CLASS_NativeReplication,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Game");}

    virtual UObject* GetUObjectInterfaceInterface_Speaker(){return this;}
	// declare type for node evaluation functions
	typedef FLOAT ( *NodeEvaluator ) (ANavigationPoint*, APawn*, FLOAT);

	virtual void PostBeginPlay();
	virtual void PostScriptDestroyed();

	// AActor interface.

	APawn* GetPlayerPawn() const;
	virtual FLOAT GetNetPriority(const FVector& ViewPos, const FVector& ViewDir, APlayerController* Viewer, UActorChannel* InChannel, FLOAT Time, UBOOL bLowBandwidth);
	virtual INT* GetOptimizedRepList( BYTE* InDefault, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel );
	virtual void NotifyBump(AActor *Other, UPrimitiveComponent* OtherComp, const FVector &HitNormal);
	virtual void TickSimulated( FLOAT DeltaSeconds );
	virtual void TickSpecial( FLOAT DeltaSeconds );
	UBOOL PlayerControlled();
	virtual void SetBase(AActor *NewBase, FVector NewFloor = FVector(0,0,1), INT bNotifyActor=1, USkeletalMeshComponent* SkelComp=NULL, FName BoneName=NAME_None );
#if WITH_EDITOR
	virtual void EditorApplyRotation(const FRotator& DeltaRotation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);
	virtual void CheckForErrors();
#endif
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);
	UBOOL CacheNetRelevancy(UBOOL bIsRelevant, APlayerController* RealViewer, AActor* Viewer);
	virtual UBOOL ShouldTrace(UPrimitiveComponent* Primitive,AActor *SourceActor, DWORD TraceFlags);
	virtual void PreNetReceive();
	virtual void PostNetReceiveLocation();
	virtual void SmoothCorrection(const FVector& OldLocation);
	virtual APawn* GetAPawn() { return this; }
	virtual const APawn* GetAPawn() const { return this; }

	/**
	 * Used for SkelControlLimb in BCS_BaseMeshSpace mode.
	 *
	 * @param SkelControlled - the mesh being modified by the skel control
	 *
	 * @return the skeletal mesh component to use for the transform calculation
	 */
	virtual USkeletalMeshComponent* GetMeshForSkelControlLimbTransform(const USkeletalMeshComponent* SkelControlled) { return Mesh; }

	/**
	 * Sets the hard attach flag by first handling the case of already being
	 * based upon another actor
	 *
	 * @param bNewHardAttach the new hard attach setting
	 */
	virtual void SetHardAttach(UBOOL bNewHardAttach);

	virtual UBOOL CanCauseFractureOnTouch()
	{
		return TRUE;
	}

	// Level functions
	void SetZone( UBOOL bTest, UBOOL bForceRefresh );

	// AI sensing
	virtual void CheckNoiseHearing(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType=NAME_None );
	virtual FLOAT DampenNoise(AActor* NoiseMaker, FLOAT Loudness, FName NoiseType=NAME_None );


	// Latent movement
	virtual void setMoveTimer(FVector MoveDir);
	FLOAT GetMaxSpeed();
	virtual UBOOL moveToward(const FVector &Dest, AActor *GoalActor);
	virtual UBOOL IsGlider();
	virtual void rotateToward(FVector FocalPoint);
	void StartNewSerpentine(const FVector& Dir, const FVector& Start);
	void ClearSerpentine();
	virtual UBOOL SharingVehicleWith(APawn *P);
	void InitSerpentine();
	virtual void HandleSerpentineMovement(FVector& out_Direction, FLOAT Distance, const FVector& Dest);

	// reach tests
	virtual UBOOL ReachedDestination(const FVector &Start, const FVector &Dest, AActor* GoalActor, UBOOL bCheckHandle=FALSE);
	virtual int pointReachable(FVector aPoint, int bKnowVisible=0);
	virtual int actorReachable(AActor *Other, UBOOL bKnowVisible=0, UBOOL bNoAnchorCheck=0);
	virtual int Reachable(FVector aPoint, AActor* GoalActor);
	int walkReachable(const FVector &Dest, const FVector &Start, int reachFlags, AActor* GoalActor);
	int flyReachable(const FVector &Dest, const FVector &Start, int reachFlags, AActor* GoalActor);
	int swimReachable(const FVector &Dest, const FVector &Start, int reachFlags, AActor* GoalActor);
	int ladderReachable(const FVector &Dest, const FVector &Start, int reachFlags, AActor* GoalActor);
	INT spiderReachable( const FVector &Dest, const FVector &Start, INT reachFlags, AActor* GoalActor );
	FVector GetGravityDirection();
	virtual UBOOL TryJumpUp(FVector Dir, FVector Destination, DWORD TraceFlags, UBOOL bNoVisibility);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual UBOOL ReachThresholdTest(const FVector &TestPosition, const FVector &Dest, AActor* GoalActor, FLOAT UpThresholdAdjust, FLOAT DownThresholdAdjust, FLOAT ThresholdAdjust);
	virtual UBOOL SetHighJumpFlag() { return false; }

	// movement component tests (used by reach tests)
	void TestMove(const FVector &Delta, FVector &CurrentPosition, FCheckResult& Hit, const FVector &CollisionExtent);
	FVector GetDefaultCollisionSize();
	FVector GetCrouchSize();
	ETestMoveResult walkMove(FVector Delta, FVector &CurrentPosition, const FVector &CollisionExtent, FCheckResult& Hit, AActor* GoalActor, FLOAT threshold);
	ETestMoveResult flyMove(FVector Delta, FVector &CurrentPosition, AActor* GoalActor, FLOAT threshold);
	ETestMoveResult swimMove(FVector Delta, FVector &CurrentPosition, AActor* GoalActor, FLOAT threshold);
	virtual ETestMoveResult FindBestJump(FVector Dest, FVector &CurrentPosition);
	virtual ETestMoveResult FindJumpUp(FVector Direction, FVector &CurrentPosition);
	ETestMoveResult HitGoal(AActor *GoalActor);
	virtual UBOOL HurtByDamageType(class UClass* DamageType);
	UBOOL CanCrouchWalk( const FVector& StartLocation, const FVector& EndLocation, AActor* HitActor );
	/** updates the highest landing Z axis velocity encountered during a reach test */
	virtual void SetMaxLandingVelocity(FLOAT NewLandingVelocity) {}

	// Path finding
	UBOOL GeneratePath();
	FLOAT findPathToward(AActor *goal, FVector GoalLocation, NodeEvaluator NodeEval, FLOAT BestWeight, UBOOL bWeightDetours, INT MaxPathLength = 0, UBOOL bReturnPartial = FALSE, INT SoftMaxNodes = 200);
	ANavigationPoint* BestPathTo(NodeEvaluator NodeEval, ANavigationPoint *start, FLOAT *Weight, UBOOL bWeightDetours, INT MaxPathLength = 0, INT SoftMaxNodes = 200);
	virtual ANavigationPoint* CheckDetour(ANavigationPoint* BestDest, ANavigationPoint* Start, UBOOL bWeightDetours);
	virtual INT calcMoveFlags();
	/** returns the maximum falling speed an AI will accept along a path */
	FORCEINLINE FLOAT GetAIMaxFallSpeed() { return MaxFallSpeed * AIMaxFallSpeedFactor; }
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
	virtual FLOAT SecondRouteAttempt(ANavigationPoint* Anchor, ANavigationPoint* EndAnchor, NodeEvaluator NodeEval, FLOAT BestWeight, AActor *goal, const FVector& GoalLocation, FLOAT StartDist, FLOAT EndDist, INT MaxPathLength, INT SoftMaxNodes);
	/** finds the closest NavigationPoint within MAXPATHDIST that is usable by this pawn and directly reachable to/from TestLocation
	 * @param TestActor the Actor to find an anchor for
	 * @param TestLocation the location to find an anchor for
	 * @param bStartPoint true if we're finding the start point for a path search, false if we're finding the end point
	 * @param bOnlyCheckVisible if true, only check visibility - skip reachability test
	 * @param Dist (out) if an anchor is found, set to the distance TestLocation is from it. Set to 0.f if the anchor overlaps TestLocation
	 * @return a suitable anchor on the navigation network for reaching TestLocation, or NULL if no such point exists
	 */
	ANavigationPoint* FindAnchor(AActor* TestActor, const FVector& TestLocation, UBOOL bStartPoint, UBOOL bOnlyCheckVisible, FLOAT& Dist);
	virtual INT		ModifyCostForReachSpec( UReachSpec* Spec, INT Cost ) { return 0; }
	virtual void	InitForPathfinding( AActor* Goal, ANavigationPoint* EndAnchor ) {}
	// allows pawn subclasses to veto anchor validity
	virtual UBOOL	IsValidAnchor( ANavigationPoint* AnchorCandidate ){ return TRUE; }

	/*
	 * Route finding notifications (sent to target)
	 */
	virtual ANavigationPoint* SpecifyEndAnchor(APawn* RouteFinder);
	virtual UBOOL AnchorNeedNotBeReachable();
	virtual void NotifyAnchorFindingResult(ANavigationPoint* EndAnchor, APawn* RouteFinder);

	// Pawn physics modes
	virtual void setPhysics(BYTE NewPhysics, AActor* NewFloor = NULL, FVector NewFloorV = FVector(0,0,1));
	virtual void performPhysics(FLOAT DeltaSeconds);
	/** Called in PerformPhysics(), after StartNewPhysics() is done moving the Actor, and before the PendingTouch() event is dispatched. */
	virtual void PostProcessPhysics( FLOAT DeltaSeconds, const FVector& OldVelocity );
	/** If TRUE, bypass simulated client physics, and run owned/server physics instead. Do not perform simulation/correction. */
	virtual UBOOL ShouldBypassSimulatedClientPhysics();
	virtual FVector CheckForLedges(FVector AccelDir, FVector Delta, FVector GravDir, int &bCheckedFall, int &bMustJump );
	virtual void physWalking(FLOAT deltaTime, INT Iterations);
	virtual void physNavMeshWalking(FLOAT deltaTime);
	virtual void physFlying(FLOAT deltaTime, INT Iterations);
	virtual void physSwimming(FLOAT deltaTime, INT Iterations);
	virtual void physFalling(FLOAT deltaTime, INT Iterations);
	virtual void physSpider(FLOAT deltaTime, INT Iterations);
	virtual void physLadder(FLOAT deltaTime, INT Iterations);
	virtual void startNewPhysics(FLOAT deltaTime, INT Iterations);
	virtual void GetNetBuoyancy(FLOAT &NetBuoyancy, FLOAT &NetFluidFriction);
	virtual void StartFalling(INT Iterations, FLOAT remainingTime, FLOAT timeTick, const FVector& Delta, const FVector& subLoc);
	virtual UBOOL ShouldCatchAir(const FVector& OldFloor, const FVector& Floor);
	void startSwimming(FVector OldLocation, FVector OldVelocity, FLOAT timeTick, FLOAT remainingTime, INT Iterations);
	virtual void physicsRotation(FLOAT deltaTime, FVector OldVelocity);
	void processLanded(FVector const& HitNormal, AActor *HitActor, FLOAT remainingTime, INT Iterations);
	virtual void SetPostLandedPhysics(AActor *HitActor, FVector HitNormal);
	virtual void processHitWall(FCheckResult const& Hit, FLOAT TimeSlice=0.f);
	virtual void Crouch(INT bClientSimulation=0);
	virtual void UnCrouch(INT bClientSimulation=0);
	void SmoothHitWall(FVector const& HitNormal, AActor *HitActor);
	virtual FVector NewFallVelocity(FVector OldVelocity, FVector OldAcceleration, FLOAT timeTick);
	void stepUp(const FVector& GravDir, const FVector& DesiredDir, const FVector& Delta, FCheckResult &Hit);
	virtual FLOAT MaxSpeedModifier();
	virtual FLOAT GetMaxAccel( FLOAT SpeedModifier = 1.f );
	virtual FVector CalculateSlopeSlide(const FVector& Adjusted, const FCheckResult& Hit);
	virtual UBOOL IgnoreBlockingBy(const AActor* Other) const;
	virtual void PushedBy(AActor* Other);
	virtual void UpdateBasedRotation(FRotator &FinalRotation, const FRotator& ReducedRotation);
	virtual void ReverseBasedRotation();

	virtual void InitRBPhys();
	virtual void TermRBPhys(FRBPhysScene* Scene);

	/** Update information used to detect overlaps between this actor and physics objects, used for 'pushing' things */
	virtual void UpdatePushBody();

	/** Called when the push body 'sensor' overlaps a physics body. Allows you to add a force to that body to move it. */
	virtual void ProcessPushNotify(const FRigidBodyCollisionInfo& PushedInfo, const TArray<FRigidBodyContactInfo>& ContactInfos);

	virtual UBOOL HasAudibleAmbientSound(const FVector& SrcLocation) { return FALSE; }

	//superville: Chance for pawn to say he has reached a location w/o touching it (ie cover slot)
	virtual UBOOL HasReached( ANavigationPoint *Nav, UBOOL& bFinalDecision ) { return FALSE; }

	virtual FVector GetIdealCameraOrigin()
	{
		return FVector(Location.X,Location.Y,Location.Z + BaseEyeHeight);
	}

	/**
	 * Checks whether this pawn needs to have its base ticked first and does so if requested
	 *
	 * @return TRUE if the actor was ticked, FALSE if it was aborted (e.g. because it's in stasis)
	 */
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );

	/** Build AnimSet list, called by UpdateAnimSetList() */
	virtual void BuildAnimSetList();
	void RestoreAnimSetsToDefault();

	// AnimControl Matinee Track support

	/** Used to provide information on the slots that this Actor provides for animation to Matinee. */
	virtual void GetAnimControlSlotDesc(TArray<struct FAnimSlotDesc>& OutSlotDescs);

	/**
	 *	Called by Matinee when we open it to start controlling animation on this Actor.
	 *	Is also called again when the GroupAnimSets array changes in Matinee, so must support multiple calls.
	 */
	virtual void PreviewBeginAnimControl(class UInterpGroup* InInterpGroup);

	/** Called each frame by Matinee to update the desired sequence by name and position within it. */
	virtual void PreviewSetAnimPosition(FName SlotName, INT ChannelIndex, FName InAnimSeqName, FLOAT InPosition, UBOOL bLooping, UBOOL bFireNotifies, UBOOL bEnableRootMotion, FLOAT DeltaTime);

	/** Called each frame by Matinee to update the desired animation channel weights for this Actor. */
	virtual void PreviewSetAnimWeights(TArray<FAnimSlotInfo>& SlotInfos);

	/** Called by Matinee when we close it after we have been controlling animation on this Actor. */
	virtual void PreviewFinishAnimControl(class UInterpGroup* InInterpGroup);

	/** Function used to control FaceFX animation in the editor (Matinee). */
	virtual void PreviewUpdateFaceFX(UBOOL bForceAnim, const FString& GroupName, const FString& SeqName, FLOAT InPosition);

	/** Used by Matinee playback to start a FaceFX animation playing. */
	virtual void PreviewActorPlayFaceFX(const FString& GroupName, const FString& SeqName, USoundCue* InSoundCue);

	/** Used by Matinee to stop current FaceFX animation playing. */
	virtual void PreviewActorStopFaceFX();

	/** Used in Matinee to get the AudioComponent we should play facial animation audio on. */
	virtual UAudioComponent* PreviewGetFaceFXAudioComponent();

	/** Get the UFaceFXAsset that is currently being used by this Actor when playing facial animations. */
	virtual class UFaceFXAsset* PreviewGetActorFaceFXAsset();

	/** Called each frame by Matinee to update the weight of a particular MorphNodeWeight. */
	virtual void PreviewSetMorphWeight(FName MorphNodeName, FLOAT MorphWeight);

	/** Called each frame by Matinee to update the scaling on a SkelControl. */
	virtual void PreviewSetSkelControlScale(FName SkelControlName, FLOAT Scale);

	/** Called each frame by Matinee to update the controlstrength on a SkelControl. */
	virtual void SetSkelControlStrength(FName SkelControlName, FLOAT ControlStrength);

	/** Called each from while the Matinee action is running, to set the animation weights for the actor. */
	virtual void SetAnimWeights( const TArray<struct FAnimSlotInfo>& SlotInfos );

	/** Called each frame by Matinee for InterpMoveTrack to adjust their location/rotation **/
	virtual void AdjustInterpTrackMove(FVector& Pos, FRotator& Rot, FLOAT DeltaTime, UBOOL bIgnoreRotation = FALSE);

	virtual UBOOL FindInterpMoveTrack(class UInterpTrackMove** MoveTrack, class UInterpTrackInstMove** MoveTrackInst, class USeqAct_Interp** OutSeq);

	void UpdateScalarParameterInterp(FLOAT DeltaTime);

protected:
	virtual void ApplyVelocityBraking(FLOAT DeltaTime, FLOAT Friction);
	virtual void CalcVelocity(FVector &AccelDir, FLOAT DeltaTime, FLOAT MaxSpeed, FLOAT Friction, INT bFluid, INT bBrake, INT bBuoyant);

private:
	UBOOL Pick3DWallAdjust(FVector WallHitNormal, AActor* HitActor);
	FLOAT Swim(FVector Delta, FCheckResult &Hit);
	FVector findWaterLine(FVector Start, FVector End);
	void SpiderstepUp(const FVector& DesiredDir, const FVector& Delta, FCheckResult &Hit);
	int findNewFloor(FVector OldLocation, FLOAT deltaTime, FLOAT remainingTime, INT Iterations);
	int checkFloor(FVector Dir, FCheckResult &Hit);
};

class AMatineePawn : public APawn
{
public:
    //## BEGIN PROPS MatineePawn
#if WITH_EDITORONLY_DATA
    class USkeletalMesh* PreviewMesh;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS MatineePawn

    DECLARE_CLASS(AMatineePawn,APawn,0|CLASS_Config,Engine)
	// Sets Mesh to PreviewMesh
	void ReplacePreviewMesh(USkeletalMesh * NewPreviewMesh);
};

struct FPathSizeInfo
{
    FName Desc;
    FLOAT Radius;
    FLOAT Height;
    FLOAT CrouchHeight;
    BYTE PathColor;
    SCRIPT_ALIGN;

    /** Constructors */
    FPathSizeInfo() {}
    FPathSizeInfo(EEventParm)
    {
        appMemzero(this, sizeof(FPathSizeInfo));
    }
};

class AScout : public APawn
{
public:
    //## BEGIN PROPS Scout
    TArrayNoInit<struct FPathSizeInfo> PathSizes;
    FLOAT TestJumpZ;
    FLOAT TestGroundSpeed;
    FLOAT TestMaxFallSpeed;
    FLOAT TestFallSpeed;
    FLOAT MaxLandingVelocity;
    INT MinNumPlayerStarts;
    class UClass* DefaultReachSpecClass;
    TArrayNoInit<FColor> EdgePathColors;
    FLOAT NavMeshGen_StepSize;
    FLOAT NavMeshGen_EntityHalfHeight;
    FLOAT NavMeshGen_StartingHeightOffset;
    FLOAT NavMeshGen_MaxDropHeight;
    FLOAT NavMeshGen_MaxStepHeight;
    FLOAT NavMeshGen_VertZDeltaSnapThresh;
    FLOAT NavMeshGen_MinPolyArea;
    FLOAT NavMeshGen_BorderBackfill_CheckDist;
    FLOAT NavMeshGen_MinMergeDotAreaThreshold;
    FLOAT NavMeshGen_MinMergeDotSmallArea;
    FLOAT NavMeshGen_MinMergeDotLargeArea;
    FLOAT NavMeshGen_MaxPolyHeight;
    FLOAT NavMeshGen_HeightMergeThreshold;
    FLOAT NavMeshGen_EdgeMaxDelta;
    FLOAT NavMeshGen_MaxGroundCheckSize;
    FLOAT NavMeshGen_MinEdgeLength;
    BITFIELD NavMeshGen_ExpansionDoObstacleMeshSimplification:1;
    BITFIELD bHightlightOneWayReachSpecs:1;
    FLOAT MinMantleFallDist;
    FLOAT MaxMantleFallDist;
    FLOAT MinMantleLateralDist;
    FLOAT MaxMantleLateralDist;
    FLOAT MaxMantleFallTime;
    //## END PROPS Scout

    DECLARE_CLASS(AScout,APawn,0|CLASS_Transient|CLASS_Config,Engine)
	NO_DEFAULT_CONSTRUCTOR(AScout)

	virtual FVector GetSize(FName desc)
	{
		for (INT idx = 0; idx < PathSizes.Num(); idx++)
		{
			if (PathSizes(idx).Desc == desc)
			{
				return FVector(PathSizes(idx).Radius,PathSizes(idx).Height,0.f);
			}
		}
		return FVector(PathSizes(0).Radius,PathSizes(0).Height,0.f);
	}

	virtual void InitForPathing( ANavigationPoint* Start, ANavigationPoint* End )
	{
		Physics = PHYS_Walking;
		JumpZ = TestJumpZ;
		bCanWalk = 1;
		bJumpCapable = 1;
		bCanJump = 1;
		bCanSwim = 1;
		bCanClimbLadders = 1;
		bCanFly = 0;
		GroundSpeed = TestGroundSpeed;
		MaxFallSpeed = TestMaxFallSpeed;
	}

	virtual void SetPathColor(UReachSpec* ReachSpec)
	{
		FVector CommonSize = GetSize(FName(TEXT("Common"),FNAME_Find));
		if ( ReachSpec->CollisionRadius >= CommonSize.X )
		{
			FVector MaxSize = GetSize(FName(TEXT("Max"),FNAME_Find));
			if ( ReachSpec->CollisionRadius >= MaxSize.X )
			{
				ReachSpec->PathColorIndex = 2;
			}
			else
			{
				ReachSpec->PathColorIndex = 1;
			}
		}
		else
		{
			ReachSpec->PathColorIndex = 0;
		}
	}

	virtual FVector GetDefaultForcedPathSize(UReachSpec* Spec)
	{
		return GetSize(FName(TEXT("Common"),FNAME_Find));
	}

	virtual void PostBeginPlay();
	virtual void SetPrototype();

#if WITH_EDITOR

	/** returns the largest size in the PathSizes list */
	FVector GetMaxSize();


	virtual void AddSpecialPaths(INT NumPaths, UBOOL bOnlyChanged) {};
	/** updates the highest landing Z axis velocity encountered during a reach test */
	virtual void SetMaxLandingVelocity(FLOAT NewLandingVelocity)
	{
		if (-NewLandingVelocity > MaxLandingVelocity)
		{
			MaxLandingVelocity = -NewLandingVelocity;
		}
	}

	virtual UClass* GetDefaultReachSpecClass() { return DefaultReachSpecClass; }

	/**
	* Toggles collision on all actors for path building.
	*/
	virtual void SetPathCollision(UBOOL bEnabled);

	/**
	* Moves all interp actors to the path building position.
	*/
	virtual void UpdateInterpActors(UBOOL &bProblemsMoving, TArray<USeqAct_Interp*> &InterpActs);

	/**
	* Moves all updated interp actors back to their original position.
	*/
	virtual void RestoreInterpActors(TArray<USeqAct_Interp*> &InterpActs);

	/**
	* Clears all the paths and rebuilds them.
	*
	* @param	bReviewPaths	If TRUE, review paths if any were created.
	* @param	bShowMapCheck	If TRUE, conditionally show the Map Check dialog.
	* @param	bUndefinePaths	IF TRUE, paths will be undefined first
	*/
	virtual void DefinePaths( UBOOL bReviewPaths, UBOOL bShowMapCheck, UBOOL bUndefinePaths );

	/**
	* Clears all pathing information in the level.
	*/
	virtual void UndefinePaths();

	virtual void AddLongReachSpecs( INT NumPaths );

	virtual void PrunePaths(INT NumPaths);

	// interface to allow easy overides of path prune behavior (without copy+pasting ;) )
	virtual INT PrunePathsForNav(ANavigationPoint* Nav);
	// called after PrunePathsForNav is called on all pathnodes
	virtual INT SecondPassPrunePathsForNav(ANavigationPoint* Nav){return 0;}


	virtual void ReviewPaths();

	virtual void Exec( const TCHAR* Str );
	virtual void AdjustCover( UBOOL bFromDefinePaths = FALSE );
	virtual void BuildCover(  UBOOL bFromDefinePaths = FALSE );
	virtual void FinishPathBuild();

	/**
	 *	Rebuilds nav meshes
	 *	@param PassNum			Pass number given.
	 *	@param bShowMapCheck	If TRUE, conditionally show the Map Check dialog.
	 *  @param bOnlyBuildSelected if TRUE only pylons which are selected will be built
	 */
	virtual UBOOL GenerateNavMesh( UBOOL bShowMapCheck, UBOOL bOnlyBuildSelected );
	virtual void  AbortNavMeshGeneration( TArray<USeqAct_Interp*>& InterpActs );

#endif

	static AScout* GetGameSpecificDefaultScoutObject();

	// ** Navigation mesh functions follow
typedef UBOOL(APylon::*NavMashPassFunc)();
	
	/**
	 * Prepares list of NavMesh generation passes executed for every pylon
	 * @param PassList - list of passes
	 * @param GeneratorType - NavMesh generator type (check ENavigationMeshGeneratorType for details)
	 */
	virtual void  GetNavMeshPassList( TArray<NavMashPassFunc>& PassList, BYTE GeneratorType = 0 );
	// ** End navigation mesh functions

	virtual UBOOL CanDoMove( const TCHAR* Str, ANavigationPoint* Nav, INT Item = -1, UBOOL inbSeedPylon = FALSE ) { return FALSE; }
	virtual void CreateMantleEdge( struct FNavMeshPolyBase* SrcPoly, FVector& EdgeEndPt1, FVector& EdgeEndPt2, FRotator& EdgeEndRot1, FRotator& EdgeEndRot2, INT Dir, AActor* RelActor, INT RelItem ) {}

	/**
	 * NavMeshGen_IsValidGroundHit
	 * allows the scout to determien if the passed ground hit is a valid spot for navmesh to exist
	 * @param Hit - the hit to determine validity for
	 * @return - TRUE If the passed spot was valid
	 */
	virtual UBOOL NavMeshGen_IsValidGroundHit( FCheckResult& Hit );

	/**
	 * if your game adds custom edge types, you should call Register() on them in your overidden scout class here
	 */
	virtual void InitializeCustomEdgeClasses() {}

protected:
#if WITH_EDITOR
	/**
	* Builds the per-level nav lists and then assembles the world list.
	*/
	virtual void BuildNavLists();
#endif
};

struct Vehicle_eventGetEntryLocation_Parms
{
    FVector ReturnValue;
    Vehicle_eventGetEntryLocation_Parms(EEventParm)
    {
    }
};
struct Vehicle_eventDriverLeave_Parms
{
    UBOOL bForceLeave;
    UBOOL ReturnValue;
    Vehicle_eventDriverLeave_Parms(EEventParm)
    {
    }
};
struct Vehicle_eventContinueOnFoot_Parms
{
    UBOOL ReturnValue;
    Vehicle_eventContinueOnFoot_Parms(EEventParm)
    {
    }
};
class AVehicle : public APawn
{
public:
    //## BEGIN PROPS Vehicle
    class APawn* Driver;
    BITFIELD bDriving:1;
    BITFIELD bDriverIsVisible:1;
    BITFIELD bAttachDriver:1;
    BITFIELD bTurnInPlace:1;
    BITFIELD bSeparateTurretFocus:1;
    BITFIELD bFollowLookDir:1;
    BITFIELD bHasHandbrake:1;
    BITFIELD bScriptedRise:1;
    BITFIELD bDuckObstacles:1;
    BITFIELD bAvoidReversing:1;
    BITFIELD bRetryPathfindingWithDriver:1;
    BITFIELD bIgnoreStallZ:1;
    BITFIELD bDoExtraNetRelevancyTraces:1;
    TArrayNoInit<FVector> ExitPositions;
    FLOAT ExitRadius;
    FVector ExitOffset;
    FLOAT Steering;
    FLOAT Throttle;
    FLOAT Rise;
    FVector TargetLocationAdjustment;
    FLOAT DriverDamageMult;
    FLOAT MomentumMult;
    class UClass* CrushedDamageType;
    FLOAT MinCrushSpeed;
    FLOAT ForceCrushPenetration;
    BYTE StuckCount;
    FLOAT ThrottleTime;
    FLOAT StuckTime;
    FLOAT OldSteering;
    FLOAT OnlySteeringStartTime;
    FLOAT OldThrottle;
    FLOAT AIMoveCheckTime;
    FLOAT VehicleMovingTime;
    FLOAT TurnTime;
    //## END PROPS Vehicle

    virtual FLOAT GetMaxRiseForce();
    virtual FVector GetTargetLocation(class AActor* RequestedBy=NULL,UBOOL bRequestAlternateLoc=FALSE) const;
    DECLARE_FUNCTION(execGetMaxRiseForce)
    {
        P_FINISH;
        *(FLOAT*)Result=this->GetMaxRiseForce();
    }
    FVector eventGetEntryLocation()
    {
        Vehicle_eventGetEntryLocation_Parms Parms(EC_EventParm);
        appMemzero(&Parms.ReturnValue,sizeof(Parms.ReturnValue));
        ProcessEvent(FindFunctionChecked(ENGINE_GetEntryLocation),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventDriverLeave(UBOOL bForceLeave)
    {
        Vehicle_eventDriverLeave_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.bForceLeave=bForceLeave ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_DriverLeave),&Parms);
        return Parms.ReturnValue;
    }
    UBOOL eventContinueOnFoot()
    {
        Vehicle_eventContinueOnFoot_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_ContinueOnFoot),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(AVehicle,APawn,0|CLASS_Config|CLASS_NativeReplication,Engine)
	virtual INT* GetOptimizedRepList(BYTE* Recent, FPropertyRetirement* Retire, INT* Ptr, UPackageMap* Map, UActorChannel* Channel);
	virtual UBOOL IsNetRelevantFor(APlayerController* RealViewer, AActor* Viewer, const FVector& SrcLocation);
	virtual UBOOL ReachedBy(APawn* P, const FVector& TestPosition, const FVector& Dest);
	virtual ANavigationPoint* CheckDetour(ANavigationPoint* BestDest, ANavigationPoint* Start, UBOOL bWeightDetours);
	virtual void performPhysics(FLOAT DeltaSeconds);
	virtual UBOOL HasRelevantDriver();
	virtual AVehicle* GetAVehicle() { return this; }

	/**
	 * Check if this actor is the owner when doing relevancy checks for actors marked bOnlyRelevantToOwner
	 * 
	 * @param ReplicatedActor - the actor we're doing a relevancy test on
	 * 
	 * @param ActorOwner - the owner of ReplicatedActor
	 * 
	 * @param ConnectionActor - the controller of the connection that we're doing relevancy checks for
	 * 
	 * @return TRUE if this actor should be considered the owner
	 */
	virtual UBOOL IsRelevancyOwnerFor(AActor* ReplicatedActor, AActor* ActorOwner, AActor* ConnectionActor);

	// AI Interface
	virtual void setMoveTimer(FVector MoveDir);
	virtual UBOOL IsStuck();
	virtual UBOOL AdjustFlight(FLOAT ZDiff, UBOOL bFlyingDown, FLOAT Distance, AActor* GoalActor);
	virtual void SteerVehicle(FVector Direction);
	virtual void AdjustThrottle( FLOAT Distance );
	virtual UBOOL moveToward(const FVector &Dest, AActor *GoalActor);
	virtual void rotateToward(FVector FocalPoint);
	virtual UBOOL JumpOutCheck(AActor *GoalActor, FLOAT Distance, FLOAT ZDiff);
	virtual void MarkEndPoints(ANavigationPoint* EndAnchor, AActor* Goal, const FVector& GoalLocation);
	virtual FLOAT SecondRouteAttempt(ANavigationPoint* Anchor, ANavigationPoint* EndAnchor, NodeEvaluator NodeEval, FLOAT BestWeight, AActor *goal, const FVector& GoalLocation, FLOAT StartDist, FLOAT EndDist, INT MaxPathLength, INT SoftMaxNodes);
	virtual UBOOL IsGlider();
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_PAWN_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(APawn,-1,execSetScalarParameterInterp);
AUTOGENERATE_FUNCTION(APawn,-1,execSetRootMotionInterpCurrentTime);
AUTOGENERATE_FUNCTION(APawn,-1,execClearPathStep);
AUTOGENERATE_FUNCTION(APawn,-1,execDrawPathStep);
AUTOGENERATE_FUNCTION(APawn,-1,execIncrementPathChild);
AUTOGENERATE_FUNCTION(APawn,-1,execIncrementPathStep);
AUTOGENERATE_FUNCTION(APawn,-1,execAddGoalEvaluator);
AUTOGENERATE_FUNCTION(APawn,-1,execAddPathConstraint);
AUTOGENERATE_FUNCTION(APawn,-1,execClearConstraints);
AUTOGENERATE_FUNCTION(APawn,-1,execGetVehicleBase);
AUTOGENERATE_FUNCTION(APawn,-1,execGetTeamNum);
AUTOGENERATE_FUNCTION(APawn,-1,execGetPawnViewLocation);
AUTOGENERATE_FUNCTION(APawn,-1,execGetViewRotation);
AUTOGENERATE_FUNCTION(APawn,-1,execIsPlayerPawn);
AUTOGENERATE_FUNCTION(APawn,-1,execIsLocallyControlled);
AUTOGENERATE_FUNCTION(APawn,-1,execIsHumanControlled);
AUTOGENERATE_FUNCTION(APawn,-1,execTermRagdoll);
AUTOGENERATE_FUNCTION(APawn,-1,execInitRagdoll);
AUTOGENERATE_FUNCTION(APawn,-1,execGetBoundingCylinder);
AUTOGENERATE_FUNCTION(APawn,-1,execReachedDesiredRotation);
AUTOGENERATE_FUNCTION(APawn,-1,execSetPushesRigidBodies);
AUTOGENERATE_FUNCTION(APawn,-1,execForceCrouch);
AUTOGENERATE_FUNCTION(APawn,-1,execReachedPoint);
AUTOGENERATE_FUNCTION(APawn,-1,execReachedDestination);
AUTOGENERATE_FUNCTION(APawn,-1,execGetBestAnchor);
AUTOGENERATE_FUNCTION(APawn,-1,execSetAnchor);
AUTOGENERATE_FUNCTION(APawn,-1,execSetRemoteViewPitch);
AUTOGENERATE_FUNCTION(APawn,-1,execIsInvisible);
AUTOGENERATE_FUNCTION(APawn,-1,execIsValidEnemyTargetFor);
AUTOGENERATE_FUNCTION(APawn,-1,execGetFallDuration);
AUTOGENERATE_FUNCTION(APawn,-1,execSuggestJumpVelocity);
AUTOGENERATE_FUNCTION(APawn,-1,execValidAnchor);
AUTOGENERATE_FUNCTION(APawn,-1,execAdjustDestination);
AUTOGENERATE_FUNCTION(APawn,-1,execIsAliveAndWell);
AUTOGENERATE_FUNCTION(APawn,-1,execMAT_SetSkelControlStrength);
AUTOGENERATE_FUNCTION(APawn,-1,execMAT_SetSkelControlScale);
AUTOGENERATE_FUNCTION(APawn,-1,execMAT_SetMorphWeight);
AUTOGENERATE_FUNCTION(APawn,-1,execMAT_SetAnimWeights);
AUTOGENERATE_FUNCTION(APawn,-1,execMAT_SetAnimPosition);
AUTOGENERATE_FUNCTION(APawn,-1,execMAT_FinishAnimControl);
AUTOGENERATE_FUNCTION(APawn,-1,execMAT_BeginAnimControl);
AUTOGENERATE_FUNCTION(APawn,-1,execAddAnimSets);
AUTOGENERATE_FUNCTION(APawn,-1,execUpdateAnimSetList);
AUTOGENERATE_FUNCTION(APawn,-1,execCacheAnimNodes);
AUTOGENERATE_FUNCTION(APawn,-1,execIsDesiredRotationLocked);
AUTOGENERATE_FUNCTION(APawn,-1,execIsDesiredRotationInUse);
AUTOGENERATE_FUNCTION(APawn,-1,execCheckDesiredRotation);
AUTOGENERATE_FUNCTION(APawn,-1,execResetDesiredRotation);
AUTOGENERATE_FUNCTION(APawn,-1,execLockDesiredRotation);
AUTOGENERATE_FUNCTION(APawn,-1,execSetDesiredRotation);
AUTOGENERATE_FUNCTION(APawn,-1,execPickWallAdjust);
AUTOGENERATE_FUNCTION(AVehicle,-1,execGetTargetLocation);
AUTOGENERATE_FUNCTION(AVehicle,-1,execGetMaxRiseForce);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_PAWN_NATIVE_DEFS
#define ENGINE_PAWN_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_PAWN \
	APawn::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Pawn"), GEngineAPawnNatives); \
	AMatineePawn::StaticClass(); \
	AScout::StaticClass(); \
	AVehicle::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Vehicle"), GEngineAVehicleNatives); \

#endif // ENGINE_PAWN_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineAPawnNatives[] = 
{ 
	MAP_NATIVE(APawn, execSetScalarParameterInterp)
	MAP_NATIVE(APawn, execSetRootMotionInterpCurrentTime)
	MAP_NATIVE(APawn, execClearPathStep)
	MAP_NATIVE(APawn, execDrawPathStep)
	MAP_NATIVE(APawn, execIncrementPathChild)
	MAP_NATIVE(APawn, execIncrementPathStep)
	MAP_NATIVE(APawn, execAddGoalEvaluator)
	MAP_NATIVE(APawn, execAddPathConstraint)
	MAP_NATIVE(APawn, execClearConstraints)
	MAP_NATIVE(APawn, execGetVehicleBase)
	MAP_NATIVE(APawn, execGetTeamNum)
	MAP_NATIVE(APawn, execGetPawnViewLocation)
	MAP_NATIVE(APawn, execGetViewRotation)
	MAP_NATIVE(APawn, execIsPlayerPawn)
	MAP_NATIVE(APawn, execIsLocallyControlled)
	MAP_NATIVE(APawn, execIsHumanControlled)
	MAP_NATIVE(APawn, execTermRagdoll)
	MAP_NATIVE(APawn, execInitRagdoll)
	MAP_NATIVE(APawn, execGetBoundingCylinder)
	MAP_NATIVE(APawn, execReachedDesiredRotation)
	MAP_NATIVE(APawn, execSetPushesRigidBodies)
	MAP_NATIVE(APawn, execForceCrouch)
	MAP_NATIVE(APawn, execReachedPoint)
	MAP_NATIVE(APawn, execReachedDestination)
	MAP_NATIVE(APawn, execGetBestAnchor)
	MAP_NATIVE(APawn, execSetAnchor)
	MAP_NATIVE(APawn, execSetRemoteViewPitch)
	MAP_NATIVE(APawn, execIsInvisible)
	MAP_NATIVE(APawn, execIsValidEnemyTargetFor)
	MAP_NATIVE(APawn, execGetFallDuration)
	MAP_NATIVE(APawn, execSuggestJumpVelocity)
	MAP_NATIVE(APawn, execValidAnchor)
	MAP_NATIVE(APawn, execAdjustDestination)
	MAP_NATIVE(APawn, execIsAliveAndWell)
	MAP_NATIVE(APawn, execMAT_SetSkelControlStrength)
	MAP_NATIVE(APawn, execMAT_SetSkelControlScale)
	MAP_NATIVE(APawn, execMAT_SetMorphWeight)
	MAP_NATIVE(APawn, execMAT_SetAnimWeights)
	MAP_NATIVE(APawn, execMAT_SetAnimPosition)
	MAP_NATIVE(APawn, execMAT_FinishAnimControl)
	MAP_NATIVE(APawn, execMAT_BeginAnimControl)
	MAP_NATIVE(APawn, execAddAnimSets)
	MAP_NATIVE(APawn, execUpdateAnimSetList)
	MAP_NATIVE(APawn, execCacheAnimNodes)
	MAP_NATIVE(APawn, execIsDesiredRotationLocked)
	MAP_NATIVE(APawn, execIsDesiredRotationInUse)
	MAP_NATIVE(APawn, execCheckDesiredRotation)
	MAP_NATIVE(APawn, execResetDesiredRotation)
	MAP_NATIVE(APawn, execLockDesiredRotation)
	MAP_NATIVE(APawn, execSetDesiredRotation)
	MAP_NATIVE(APawn, execPickWallAdjust)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAVehicleNatives[] = 
{ 
	MAP_NATIVE(AVehicle, execGetTargetLocation)
	MAP_NATIVE(AVehicle, execGetMaxRiseForce)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(APawn,Pawn,MaxStepHeight)
VERIFY_CLASS_OFFSET_NODIE(APawn,Pawn,RootMotionInterpCurveLastValue)
VERIFY_CLASS_SIZE_NODIE(APawn)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AMatineePawn,MatineePawn,PreviewMesh)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AMatineePawn,MatineePawn,PreviewMesh)
#endif
VERIFY_CLASS_SIZE_NODIE(AMatineePawn)
VERIFY_CLASS_OFFSET_NODIE(AScout,Scout,PathSizes)
VERIFY_CLASS_OFFSET_NODIE(AScout,Scout,MaxMantleFallTime)
VERIFY_CLASS_SIZE_NODIE(AScout)
VERIFY_CLASS_OFFSET_NODIE(AVehicle,Vehicle,Driver)
VERIFY_CLASS_OFFSET_NODIE(AVehicle,Vehicle,TurnTime)
VERIFY_CLASS_SIZE_NODIE(AVehicle)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
