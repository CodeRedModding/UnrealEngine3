/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_CAMERA_ENUMS
#define INCLUDED_ENGINE_CAMERA_ENUMS 1

enum ECameraAnimPlaySpace
{
    CAPS_CameraLocal        =0,
    CAPS_World              =1,
    CAPS_UserDefined        =2,
    CAPS_MAX                =3,
};
#define FOREACH_ENUM_ECAMERAANIMPLAYSPACE(op) \
    op(CAPS_CameraLocal) \
    op(CAPS_World) \
    op(CAPS_UserDefined) 
enum EViewTargetBlendFunction
{
    VTBlend_Linear          =0,
    VTBlend_Cubic           =1,
    VTBlend_EaseIn          =2,
    VTBlend_EaseOut         =3,
    VTBlend_EaseInOut       =4,
    VTBlend_MAX             =5,
};
#define FOREACH_ENUM_EVIEWTARGETBLENDFUNCTION(op) \
    op(VTBlend_Linear) \
    op(VTBlend_Cubic) \
    op(VTBlend_EaseIn) \
    op(VTBlend_EaseOut) \
    op(VTBlend_EaseInOut) 
enum EInitialOscillatorOffset
{
    EOO_OffsetRandom        =0,
    EOO_OffsetZero          =1,
    EOO_MAX                 =2,
};
#define FOREACH_ENUM_EINITIALOSCILLATOROFFSET(op) \
    op(EOO_OffsetRandom) \
    op(EOO_OffsetZero) 

#endif // !INCLUDED_ENGINE_CAMERA_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_CAMERA_CLASSES
#define INCLUDED_ENGINE_CAMERA_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

#define UCONST_MAX_ACTIVE_CAMERA_ANIMS 8

struct FTCameraCache
{
    FLOAT TimeStamp;
    FTPOV POV;

    /** Constructors */
    FTCameraCache() {}
    FTCameraCache(EEventParm)
    {
        appMemzero(this, sizeof(FTCameraCache));
    }
};

struct FTViewTarget
{
    class AActor* Target;
    class AController* Controller;
    FTPOV POV;
    FLOAT AspectRatio;
    class APlayerReplicationInfo* PRI;

    /** Constructors */
    FTViewTarget() {}
    FTViewTarget(EEventParm)
    {
        appMemzero(this, sizeof(FTViewTarget));
    }
};

struct FViewTargetTransitionParams
{
    FLOAT BlendTime;
    BYTE BlendFunction;
    FLOAT BlendExp;
    BITFIELD bLockOutgoing:1;
    SCRIPT_ALIGN;

		FViewTargetTransitionParams()
		{}
		FViewTargetTransitionParams(EEventParm)
		: BlendTime(0.f), BlendFunction(VTBlend_Cubic), BlendExp(2.f), bLockOutgoing(FALSE)
		{}
	
};

struct Camera_eventUpdateCamera_Parms
{
    FLOAT DeltaTime;
    Camera_eventUpdateCamera_Parms(EEventParm)
    {
    }
};
class ACamera : public AActor
{
public:
    //## BEGIN PROPS Camera
    class APlayerController* PCOwner;
    FName CameraStyle;
    FLOAT DefaultFOV;
    BITFIELD bLockedFOV:1;
    BITFIELD bConstrainAspectRatio:1;
    BITFIELD bEnableFading:1;
    BITFIELD bFadeAudio:1;
    BITFIELD bForceDisableTemporalAA:1;
    BITFIELD bEnableColorScaling:1;
    BITFIELD bEnableColorScaleInterp:1;
    BITFIELD bUseClientSideCameraUpdates:1;
    BITFIELD bDebugClientSideCamera:1;
    BITFIELD bShouldSendClientSideCameraUpdate:1;
    FLOAT LockedFOV;
    FLOAT ConstrainedAspectRatio;
    FLOAT DefaultAspectRatio;
    FLOAT OffAxisYawAngle;
    FLOAT OffAxisPitchAngle;
    FColor FadeColor;
    FLOAT FadeAmount;
    FLOAT CamOverridePostProcessAlpha;
    struct FPostProcessSettings CamPostProcessSettings;
    struct FRenderingPerformanceOverrides RenderingOverrides;
    FVector ColorScale;
    FVector DesiredColorScale;
    FVector OriginalColorScale;
    FLOAT ColorScaleInterpDuration;
    FLOAT ColorScaleInterpStartTime;
    struct FTCameraCache CameraCache;
    struct FTCameraCache LastFrameCameraCache;
    struct FTViewTarget ViewTarget;
    struct FTViewTarget PendingViewTarget;
    FLOAT BlendTimeToGo;
    struct FViewTargetTransitionParams BlendParams;
    TArrayNoInit<class UCameraModifier*> ModifierList;
    FLOAT FreeCamDistance;
    FVector FreeCamOffset;
    FVector2D FadeAlpha;
    FLOAT FadeTime;
    FLOAT FadeTimeRemaining;
    TArrayNoInit<class AEmitterCameraLensEffectBase*> CameraLensEffects;
    class UCameraModifier_CameraShake* CameraShakeCamMod;
    class UClass* CameraShakeCamModClass;
    class UCameraAnimInst* AnimInstPool[8];
    TArrayNoInit<class UCameraAnimInst*> ActiveAnims;
    TArrayNoInit<class UCameraAnimInst*> FreeAnims;
    class ADynamicCameraActor* AnimCameraActor;
    //## END PROPS Camera

    virtual void ApplyCameraModifiers(FLOAT DeltaTime,FTPOV& OutPOV);
    virtual void ApplyAudioFade();
    virtual void CheckViewTarget(struct FTViewTarget& VT);
    void SetViewTarget(class AActor* NewViewTarget,struct FViewTargetTransitionParams TransitionParams=FViewTargetTransitionParams(EC_EventParm));
    virtual class UCameraAnimInst* PlayCameraAnim(class UCameraAnim* Anim,FLOAT Rate=1.000000,FLOAT Scale=1.000000,FLOAT BlendInTime=0,FLOAT BlendOutTime=0,UBOOL bLoop=FALSE,UBOOL bRandomStartTime=FALSE,FLOAT Duration=0,UBOOL bSingleInstance=FALSE);
    virtual void StopAllCameraAnims(UBOOL bImmediate=FALSE);
    virtual void StopAllCameraAnimsByType(class UCameraAnim* Anim,UBOOL bImmediate=FALSE);
    virtual void StopCameraAnim(class UCameraAnimInst* AnimInst,UBOOL bImmediate=FALSE);
    DECLARE_FUNCTION(execApplyCameraModifiers)
    {
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(FTPOV,OutPOV);
        P_FINISH;
        this->ApplyCameraModifiers(DeltaTime,OutPOV);
    }
    DECLARE_FUNCTION(execApplyAudioFade)
    {
        P_FINISH;
        this->ApplyAudioFade();
    }
    DECLARE_FUNCTION(execCheckViewTarget)
    {
        P_GET_STRUCT_REF(struct FTViewTarget,VT);
        P_FINISH;
        this->CheckViewTarget(VT);
    }
    DECLARE_FUNCTION(execSetViewTarget)
    {
        P_GET_OBJECT(AActor,NewViewTarget);
        P_GET_STRUCT_OPTX(struct FViewTargetTransitionParams,TransitionParams,FViewTargetTransitionParams(EC_EventParm));
        P_FINISH;
        this->SetViewTarget(NewViewTarget,TransitionParams);
    }
    DECLARE_FUNCTION(execPlayCameraAnim)
    {
        P_GET_OBJECT(UCameraAnim,Anim);
        P_GET_FLOAT_OPTX(Rate,1.000000);
        P_GET_FLOAT_OPTX(Scale,1.000000);
        P_GET_FLOAT_OPTX(BlendInTime,0);
        P_GET_FLOAT_OPTX(BlendOutTime,0);
        P_GET_UBOOL_OPTX(bLoop,FALSE);
        P_GET_UBOOL_OPTX(bRandomStartTime,FALSE);
        P_GET_FLOAT_OPTX(Duration,0);
        P_GET_UBOOL_OPTX(bSingleInstance,FALSE);
        P_FINISH;
        *(class UCameraAnimInst**)Result=this->PlayCameraAnim(Anim,Rate,Scale,BlendInTime,BlendOutTime,bLoop,bRandomStartTime,Duration,bSingleInstance);
    }
    DECLARE_FUNCTION(execStopAllCameraAnims)
    {
        P_GET_UBOOL_OPTX(bImmediate,FALSE);
        P_FINISH;
        this->StopAllCameraAnims(bImmediate);
    }
    DECLARE_FUNCTION(execStopAllCameraAnimsByType)
    {
        P_GET_OBJECT(UCameraAnim,Anim);
        P_GET_UBOOL_OPTX(bImmediate,FALSE);
        P_FINISH;
        this->StopAllCameraAnimsByType(Anim,bImmediate);
    }
    DECLARE_FUNCTION(execStopCameraAnim)
    {
        P_GET_OBJECT(UCameraAnimInst,AnimInst);
        P_GET_UBOOL_OPTX(bImmediate,FALSE);
        P_FINISH;
        this->StopCameraAnim(AnimInst,bImmediate);
    }
    void eventUpdateCamera(FLOAT DeltaTime)
    {
        Camera_eventUpdateCamera_Parms Parms(EC_EventParm);
        Parms.DeltaTime=DeltaTime;
        ProcessEvent(FindFunctionChecked(ENGINE_UpdateCamera),&Parms);
    }
    DECLARE_CLASS(ACamera,AActor,0|CLASS_Transient,Engine)
protected:
	void InitTempCameraActor(class ACameraActor* CamActor, class UCameraAnim* AnimToInitFor) const;
	void ApplyAnimToCamera(class ACameraActor const* AnimatedCamActor, class UCameraAnimInst const* AnimInst, FTPOV& OutPOV);

	UCameraAnimInst* AllocCameraAnimInst();
	void ReleaseCameraAnimInst(UCameraAnimInst* Inst);
	UCameraAnimInst* FindExistingCameraAnimInst(UCameraAnim const* Anim);

public:
	virtual void ModifyPostProcessSettings(FPostProcessSettings& PPSettings) const;

	void	AssignViewTarget(AActor* NewTarget, FTViewTarget& VT, struct FViewTargetTransitionParams TransitionParams=FViewTargetTransitionParams(EC_EventParm));
	AActor* GetViewTarget();
	virtual UBOOL	PlayerControlled();
};

class ACameraActor : public AActor
{
public:
    //## BEGIN PROPS CameraActor
    BITFIELD bConstrainAspectRatio:1;
    BITFIELD bCamOverridePostProcess_DEPRECATED:1;
    FLOAT AspectRatio;
    FLOAT FOVAngle;
    FLOAT CamOverridePostProcessAlpha;
    struct FPostProcessSettings CamOverridePostProcess;
    class UDrawFrustumComponent* DrawFrustum;
    class UStaticMeshComponent* MeshComp;
    //## END PROPS CameraActor

    DECLARE_CLASS(ACameraActor,AActor,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostLoad();

	// AActor interface
	virtual void Spawned();
protected:
	virtual void UpdateComponentsInternal(UBOOL bCollisionUpdate = FALSE);
public:

	// ACameraActor interface
	void UpdateDrawFrustum();

#if WITH_EDITOR
	virtual void CheckForErrors();
#endif
};

class ADynamicCameraActor : public ACameraActor
{
public:
    //## BEGIN PROPS DynamicCameraActor
    //## END PROPS DynamicCameraActor

    DECLARE_CLASS(ADynamicCameraActor,ACameraActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ADynamicCameraActor)
};

class UCameraAnim : public UObject
{
public:
    //## BEGIN PROPS CameraAnim
    class UInterpGroupCamera* CameraInterpGroup;
#if WITH_EDITORONLY_DATA
    class UInterpGroup* PreviewInterpGroup;
#endif // WITH_EDITORONLY_DATA
    FLOAT AnimLength;
    FBox BoundingBox;
    struct FPostProcessSettings BasePPSettings;
    FLOAT BasePPSettingsAlpha;
    FLOAT BaseFOV;
    //## END PROPS CameraAnim

    DECLARE_CLASS(UCameraAnim,UObject,0,Engine)
protected:
	void CalcLocalAABB();

public:
	/** Overridden to calculate the bbox at save time. */
	virtual void PreSave();
	virtual void PostLoad();
	INT GetResourceSize();

	UBOOL CreateFromInterpGroup(class UInterpGroup* SrcGroup, class USeqAct_Interp* Interp);
	FBox GetAABB(FVector const& BaseLoc, FRotator const& BaseRot, FLOAT Scale) const;

	UBOOL InitializeCamera(class UInterpGroup* SrcGroup, class USeqAct_Interp* Interp);
};

class UCameraAnimInst : public UObject
{
public:
    //## BEGIN PROPS CameraAnimInst
    class UCameraAnim* CamAnim;
    class UInterpGroupInst* InterpGroupInst;
    FLOAT CurTime;
    BITFIELD bLooping:1;
    BITFIELD bFinished:1;
    BITFIELD bAutoReleaseWhenFinished:1;
    BITFIELD bBlendingIn:1;
    BITFIELD bBlendingOut:1;
    FLOAT BlendInTime;
    FLOAT BlendOutTime;
    FLOAT CurBlendInTime;
    FLOAT CurBlendOutTime;
    FLOAT PlayRate;
    FLOAT BasePlayScale;
    FLOAT TransientScaleModifier;
    FLOAT CurrentBlendWeight;
    FLOAT RemainingTime;
    class UInterpTrackMove* MoveTrack;
    class UInterpTrackInstMove* MoveInst;
    class UAnimNodeSequence* SourceAnimNode;
    BYTE PlaySpace;
    SCRIPT_ALIGN;
    FMatrix UserPlaySpaceMatrix;
    struct FPostProcessSettings LastPPSettings;
    FLOAT LastPPSettingsAlpha;
    FVector LastCameraLoc;
    //## END PROPS CameraAnimInst

    void Play(class UCameraAnim* Anim,class AActor* CamActor,FLOAT InRate,FLOAT InScale,FLOAT InBlendInTime,FLOAT InBlendOutTime,UBOOL bInLoop,UBOOL bRandomStartTime,FLOAT Duration=0);
    void Update(FLOAT NewRate,FLOAT NewScale,FLOAT NewBlendInTime,FLOAT NewBlendOutTime,FLOAT NewDuration=0);
    void AdvanceAnim(FLOAT DeltaTime,UBOOL bJump);
    void Stop(UBOOL bImmediate=FALSE);
    void ApplyTransientScaling(FLOAT Scalar);
    void SetPlaySpace(BYTE NewSpace,FRotator UserPlaySpace=FRotator(EC_EventParm));
    DECLARE_FUNCTION(execPlay)
    {
        P_GET_OBJECT(UCameraAnim,Anim);
        P_GET_OBJECT(AActor,CamActor);
        P_GET_FLOAT(InRate);
        P_GET_FLOAT(InScale);
        P_GET_FLOAT(InBlendInTime);
        P_GET_FLOAT(InBlendOutTime);
        P_GET_UBOOL(bInLoop);
        P_GET_UBOOL(bRandomStartTime);
        P_GET_FLOAT_OPTX(Duration,0);
        P_FINISH;
        this->Play(Anim,CamActor,InRate,InScale,InBlendInTime,InBlendOutTime,bInLoop,bRandomStartTime,Duration);
    }
    DECLARE_FUNCTION(execUpdate)
    {
        P_GET_FLOAT(NewRate);
        P_GET_FLOAT(NewScale);
        P_GET_FLOAT(NewBlendInTime);
        P_GET_FLOAT(NewBlendOutTime);
        P_GET_FLOAT_OPTX(NewDuration,0);
        P_FINISH;
        this->Update(NewRate,NewScale,NewBlendInTime,NewBlendOutTime,NewDuration);
    }
    DECLARE_FUNCTION(execAdvanceAnim)
    {
        P_GET_FLOAT(DeltaTime);
        P_GET_UBOOL(bJump);
        P_FINISH;
        this->AdvanceAnim(DeltaTime,bJump);
    }
    DECLARE_FUNCTION(execStop)
    {
        P_GET_UBOOL_OPTX(bImmediate,FALSE);
        P_FINISH;
        this->Stop(bImmediate);
    }
    DECLARE_FUNCTION(execApplyTransientScaling)
    {
        P_GET_FLOAT(Scalar);
        P_FINISH;
        this->ApplyTransientScaling(Scalar);
    }
    DECLARE_FUNCTION(execSetPlaySpace)
    {
        P_GET_BYTE(NewSpace);
        P_GET_STRUCT_OPTX(FRotator,UserPlaySpace,FRotator(EC_EventParm));
        P_FINISH;
        this->SetPlaySpace(NewSpace,UserPlaySpace);
    }
    DECLARE_CLASS(UCameraAnimInst,UObject,0,Engine)
	void RegisterAnimNode(class UAnimNodeSequence* AnimNode);
};

struct CameraModifier_eventDisableModifier_Parms
{
    UBOOL bImmediate;
    CameraModifier_eventDisableModifier_Parms(EEventParm)
    {
    }
};
class UCameraModifier : public UObject
{
public:
    //## BEGIN PROPS CameraModifier
    BITFIELD bDisabled:1;
    BITFIELD bPendingDisable:1;
    BITFIELD bExclusive:1;
    BITFIELD bDebug:1;
    class ACamera* CameraOwner;
    BYTE Priority;
    FLOAT AlphaInTime;
    FLOAT AlphaOutTime;
    FLOAT Alpha;
    FLOAT TargetAlpha;
    //## END PROPS CameraModifier

    virtual UBOOL ModifyCamera(class ACamera* Camera,FLOAT DeltaTime,FTPOV& OutPOV);
    virtual UBOOL IsDisabled() const;
    virtual void UpdateAlpha(class ACamera* Camera,FLOAT DeltaTime);
    DECLARE_FUNCTION(execModifyCamera)
    {
        P_GET_OBJECT(ACamera,Camera);
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(FTPOV,OutPOV);
        P_FINISH;
        *(UBOOL*)Result=this->ModifyCamera(Camera,DeltaTime,OutPOV);
    }
    DECLARE_FUNCTION(execIsDisabled)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsDisabled();
    }
    DECLARE_FUNCTION(execUpdateAlpha)
    {
        P_GET_OBJECT(ACamera,Camera);
        P_GET_FLOAT(DeltaTime);
        P_FINISH;
        this->UpdateAlpha(Camera,DeltaTime);
    }
    void eventDisableModifier(UBOOL bImmediate=FALSE)
    {
        CameraModifier_eventDisableModifier_Parms Parms(EC_EventParm);
        Parms.bImmediate=bImmediate ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(ENGINE_DisableModifier),&Parms);
    }
    DECLARE_CLASS(UCameraModifier,UObject,0,Engine)
protected:
	virtual FLOAT GetTargetAlpha(class ACamera* Camera);
public:
	virtual void GetDebugText(TArray<FString>& Lines) {};
};

struct FFOscillator
{
    FLOAT Amplitude;
    FLOAT Frequency;
    BYTE InitialOffset;
    SCRIPT_ALIGN;

    /** Constructors */
    FFOscillator() {}
    FFOscillator(EEventParm)
    {
        appMemzero(this, sizeof(FFOscillator));
    }
};

struct FROscillator
{
    struct FFOscillator Pitch;
    struct FFOscillator Yaw;
    struct FFOscillator Roll;

    /** Constructors */
    FROscillator() {}
    FROscillator(EEventParm)
    {
        appMemzero(this, sizeof(FROscillator));
    }
};

struct FVOscillator
{
    struct FFOscillator X;
    struct FFOscillator Y;
    struct FFOscillator Z;

    /** Constructors */
    FVOscillator() {}
    FVOscillator(EEventParm)
    {
        appMemzero(this, sizeof(FVOscillator));
    }
};

class UCameraShake : public UObject
{
public:
    //## BEGIN PROPS CameraShake
    BITFIELD bSingleInstance:1;
    BITFIELD bRandomAnimSegment:1;
    FLOAT OscillationDuration;
    FLOAT OscillationBlendInTime;
    FLOAT OscillationBlendOutTime;
    struct FROscillator RotOscillation;
    struct FVOscillator LocOscillation;
    struct FFOscillator FOVOscillation;
    class UCameraAnim* Anim;
    FLOAT AnimPlayRate;
    FLOAT AnimScale;
    FLOAT AnimBlendInTime;
    FLOAT AnimBlendOutTime;
    FLOAT RandomAnimSegmentDuration;
    //## END PROPS CameraShake

    DECLARE_CLASS(UCameraShake,UObject,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UCameraShake)
};

struct FCameraShakeInstance
{
    class UCameraShake* SourceShake;
    FName SourceShakeName;
    FLOAT OscillatorTimeRemaining;
    BITFIELD bBlendingIn:1;
    FLOAT CurrentBlendInTime;
    BITFIELD bBlendingOut:1;
    FLOAT CurrentBlendOutTime;
    FVector LocSinOffset;
    FVector RotSinOffset;
    FLOAT FOVSinOffset;
    FLOAT Scale;
    class UCameraAnimInst* AnimInst;
    BYTE PlaySpace;
    SCRIPT_ALIGN;
    FMatrix UserPlaySpaceMatrix;

    /** Constructors */
    FCameraShakeInstance() {}
    FCameraShakeInstance(EEventParm)
    {
        appMemzero(this, sizeof(FCameraShakeInstance));
    }
};

class UCameraModifier_CameraShake : public UCameraModifier
{
public:
    //## BEGIN PROPS CameraModifier_CameraShake
    TArrayNoInit<struct FCameraShakeInstance> ActiveShakes;
    FLOAT SplitScreenShakeScale;
    //## END PROPS CameraModifier_CameraShake

    virtual void UpdateCameraShake(FLOAT DeltaTime,struct FCameraShakeInstance& Shake,FTPOV& OutPOV);
    virtual UBOOL ModifyCamera(class ACamera* Camera,FLOAT DeltaTime,FTPOV& OutPOV);
    DECLARE_FUNCTION(execUpdateCameraShake)
    {
        P_GET_FLOAT(DeltaTime);
        P_GET_STRUCT_REF(struct FCameraShakeInstance,Shake);
        P_GET_STRUCT_REF(FTPOV,OutPOV);
        P_FINISH;
        this->UpdateCameraShake(DeltaTime,Shake,OutPOV);
    }
    DECLARE_CLASS(UCameraModifier_CameraShake,UCameraModifier,0,Engine)
    static const TCHAR* StaticConfigName() {return TEXT("Camera");}

protected:
	/** For situational scaling of individual shakes. */
	virtual FLOAT GetShakeScale(FCameraShakeInstance const& ShakeInst) const;
public:
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_CAMERA_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(ACamera,-1,execStopCameraAnim);
AUTOGENERATE_FUNCTION(ACamera,-1,execStopAllCameraAnimsByType);
AUTOGENERATE_FUNCTION(ACamera,-1,execStopAllCameraAnims);
AUTOGENERATE_FUNCTION(ACamera,-1,execPlayCameraAnim);
AUTOGENERATE_FUNCTION(ACamera,-1,execSetViewTarget);
AUTOGENERATE_FUNCTION(ACamera,-1,execCheckViewTarget);
AUTOGENERATE_FUNCTION(ACamera,-1,execApplyAudioFade);
AUTOGENERATE_FUNCTION(ACamera,-1,execApplyCameraModifiers);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execSetPlaySpace);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execApplyTransientScaling);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execStop);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execAdvanceAnim);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execUpdate);
AUTOGENERATE_FUNCTION(UCameraAnimInst,-1,execPlay);
AUTOGENERATE_FUNCTION(UCameraModifier,-1,execUpdateAlpha);
AUTOGENERATE_FUNCTION(UCameraModifier,-1,execIsDisabled);
AUTOGENERATE_FUNCTION(UCameraModifier,-1,execModifyCamera);
AUTOGENERATE_FUNCTION(UCameraModifier_CameraShake,-1,execModifyCamera);
AUTOGENERATE_FUNCTION(UCameraModifier_CameraShake,-1,execUpdateCameraShake);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_CAMERA_NATIVE_DEFS
#define ENGINE_CAMERA_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_CAMERA \
	ACamera::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Camera"), GEngineACameraNatives); \
	ACameraActor::StaticClass(); \
	ADynamicCameraActor::StaticClass(); \
	UCameraAnim::StaticClass(); \
	UCameraAnimInst::StaticClass(); \
	GNativeLookupFuncs.Set(FName("CameraAnimInst"), GEngineUCameraAnimInstNatives); \
	UCameraModifier::StaticClass(); \
	GNativeLookupFuncs.Set(FName("CameraModifier"), GEngineUCameraModifierNatives); \
	UCameraModifier_CameraShake::StaticClass(); \
	GNativeLookupFuncs.Set(FName("CameraModifier_CameraShake"), GEngineUCameraModifier_CameraShakeNatives); \
	UCameraShake::StaticClass(); \

#endif // ENGINE_CAMERA_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineACameraNatives[] = 
{ 
	MAP_NATIVE(ACamera, execStopCameraAnim)
	MAP_NATIVE(ACamera, execStopAllCameraAnimsByType)
	MAP_NATIVE(ACamera, execStopAllCameraAnims)
	MAP_NATIVE(ACamera, execPlayCameraAnim)
	MAP_NATIVE(ACamera, execSetViewTarget)
	MAP_NATIVE(ACamera, execCheckViewTarget)
	MAP_NATIVE(ACamera, execApplyAudioFade)
	MAP_NATIVE(ACamera, execApplyCameraModifiers)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUCameraAnimInstNatives[] = 
{ 
	MAP_NATIVE(UCameraAnimInst, execSetPlaySpace)
	MAP_NATIVE(UCameraAnimInst, execApplyTransientScaling)
	MAP_NATIVE(UCameraAnimInst, execStop)
	MAP_NATIVE(UCameraAnimInst, execAdvanceAnim)
	MAP_NATIVE(UCameraAnimInst, execUpdate)
	MAP_NATIVE(UCameraAnimInst, execPlay)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUCameraModifierNatives[] = 
{ 
	MAP_NATIVE(UCameraModifier, execUpdateAlpha)
	MAP_NATIVE(UCameraModifier, execIsDisabled)
	MAP_NATIVE(UCameraModifier, execModifyCamera)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUCameraModifier_CameraShakeNatives[] = 
{ 
	MAP_NATIVE(UCameraModifier_CameraShake, execModifyCamera)
	MAP_NATIVE(UCameraModifier_CameraShake, execUpdateCameraShake)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(ACamera,Camera,PCOwner)
VERIFY_CLASS_OFFSET_NODIE(ACamera,Camera,AnimCameraActor)
VERIFY_CLASS_SIZE_NODIE(ACamera)
VERIFY_CLASS_OFFSET_NODIE(ACameraActor,CameraActor,AspectRatio)
VERIFY_CLASS_OFFSET_NODIE(ACameraActor,CameraActor,MeshComp)
VERIFY_CLASS_SIZE_NODIE(ACameraActor)
VERIFY_CLASS_SIZE_NODIE(ADynamicCameraActor)
VERIFY_CLASS_OFFSET_NODIE(UCameraAnim,CameraAnim,CameraInterpGroup)
VERIFY_CLASS_OFFSET_NODIE(UCameraAnim,CameraAnim,BaseFOV)
VERIFY_CLASS_SIZE_NODIE(UCameraAnim)
VERIFY_CLASS_OFFSET_NODIE(UCameraAnimInst,CameraAnimInst,CamAnim)
VERIFY_CLASS_OFFSET_NODIE(UCameraAnimInst,CameraAnimInst,LastCameraLoc)
VERIFY_CLASS_SIZE_NODIE(UCameraAnimInst)
VERIFY_CLASS_OFFSET_NODIE(UCameraModifier,CameraModifier,CameraOwner)
VERIFY_CLASS_OFFSET_NODIE(UCameraModifier,CameraModifier,TargetAlpha)
VERIFY_CLASS_SIZE_NODIE(UCameraModifier)
VERIFY_CLASS_OFFSET_NODIE(UCameraModifier_CameraShake,CameraModifier_CameraShake,ActiveShakes)
VERIFY_CLASS_OFFSET_NODIE(UCameraModifier_CameraShake,CameraModifier_CameraShake,SplitScreenShakeScale)
VERIFY_CLASS_SIZE_NODIE(UCameraModifier_CameraShake)
VERIFY_CLASS_OFFSET_NODIE(UCameraShake,CameraShake,OscillationDuration)
VERIFY_CLASS_OFFSET_NODIE(UCameraShake,CameraShake,RandomAnimSegmentDuration)
VERIFY_CLASS_SIZE_NODIE(UCameraShake)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
