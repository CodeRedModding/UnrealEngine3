/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_SOUND_ENUMS
#define INCLUDED_ENGINE_SOUND_ENUMS 1

enum ESoundDistanceCalc
{
    SOUNDDISTANCE_Normal    =0,
    SOUNDDISTANCE_InfiniteXYPlane=1,
    SOUNDDISTANCE_InfiniteXZPlane=2,
    SOUNDDISTANCE_InfiniteYZPlane=3,
    SOUNDDISTANCE_MAX       =4,
};
#define FOREACH_ENUM_ESOUNDDISTANCECALC(op) \
    op(SOUNDDISTANCE_Normal) \
    op(SOUNDDISTANCE_InfiniteXYPlane) \
    op(SOUNDDISTANCE_InfiniteXZPlane) \
    op(SOUNDDISTANCE_InfiniteYZPlane) 
enum SoundDistanceModel
{
    ATTENUATION_Linear      =0,
    ATTENUATION_Logarithmic =1,
    ATTENUATION_Inverse     =2,
    ATTENUATION_LogReverse  =3,
    ATTENUATION_NaturalSound=4,
    ATTENUATION_MAX         =5,
};
#define FOREACH_ENUM_SOUNDDISTANCEMODEL(op) \
    op(ATTENUATION_Linear) \
    op(ATTENUATION_Logarithmic) \
    op(ATTENUATION_Inverse) \
    op(ATTENUATION_LogReverse) \
    op(ATTENUATION_NaturalSound) 
enum EDecompressionType
{
    DTYPE_Setup             =0,
    DTYPE_Invalid           =1,
    DTYPE_Preview           =2,
    DTYPE_Native            =3,
    DTYPE_RealTime          =4,
    DTYPE_Procedural        =5,
    DTYPE_Xenon             =6,
    DTYPE_MAX               =7,
};
#define FOREACH_ENUM_EDECOMPRESSIONTYPE(op) \
    op(DTYPE_Setup) \
    op(DTYPE_Invalid) \
    op(DTYPE_Preview) \
    op(DTYPE_Native) \
    op(DTYPE_RealTime) \
    op(DTYPE_Procedural) \
    op(DTYPE_Xenon) 

#endif // !INCLUDED_ENGINE_SOUND_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_SOUND_CLASSES
#define INCLUDED_ENGINE_SOUND_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class AAmbientSound : public AKeypoint
{
public:
    //## BEGIN PROPS AmbientSound
    BITFIELD bAutoPlay:1;
    BITFIELD bIsPlaying:1;
    class UAudioComponent* AudioComponent;
    //## END PROPS AmbientSound

    DECLARE_CLASS(AAmbientSound,AKeypoint,0,Engine)
    #include "AAmbientSound.h"
};

class AAmbientSoundMovable : public AAmbientSound
{
public:
    //## BEGIN PROPS AmbientSoundMovable
    //## END PROPS AmbientSoundMovable

    DECLARE_CLASS(AAmbientSoundMovable,AAmbientSound,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AAmbientSoundMovable)
};

class AAmbientSoundSimple : public AAmbientSound
{
public:
    //## BEGIN PROPS AmbientSoundSimple
    class USoundNodeAmbient* AmbientProperties;
    class USoundCue* SoundCueInstance;
    class USoundNodeAmbient* SoundNodeInstance;
    //## END PROPS AmbientSoundSimple

    DECLARE_CLASS(AAmbientSoundSimple,AAmbientSound,0,Engine)
    #include "AAmbientSoundSimple.h"
};

class AAmbientSoundNonLoop : public AAmbientSoundSimple
{
public:
    //## BEGIN PROPS AmbientSoundNonLoop
    //## END PROPS AmbientSoundNonLoop

    DECLARE_CLASS(AAmbientSoundNonLoop,AAmbientSoundSimple,0,Engine)
    #include "AAmbientSoundNonLoop.h"
};

class AAmbientSoundSimpleToggleable : public AAmbientSoundSimple
{
public:
    //## BEGIN PROPS AmbientSoundSimpleToggleable
    BITFIELD bCurrentlyPlaying:1;
    BITFIELD bFadeOnToggle:1;
    BITFIELD bIgnoreAutoPlay:1;
    FLOAT FadeInDuration;
    FLOAT FadeInVolumeLevel;
    FLOAT FadeOutDuration;
    FLOAT FadeOutVolumeLevel;
    //## END PROPS AmbientSoundSimpleToggleable

    DECLARE_CLASS(AAmbientSoundSimpleToggleable,AAmbientSoundSimple,0,Engine)
    #include "AAmbientSoundSimpleToggleable.h"
};

class AAmbientSoundNonLoopingToggleable : public AAmbientSoundSimpleToggleable
{
public:
    //## BEGIN PROPS AmbientSoundNonLoopingToggleable
    //## END PROPS AmbientSoundNonLoopingToggleable

    DECLARE_CLASS(AAmbientSoundNonLoopingToggleable,AAmbientSoundSimpleToggleable,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(AAmbientSoundNonLoopingToggleable)
};

class AAmbientSoundSpline : public AAmbientSound
{
public:
    //## BEGIN PROPS AmbientSoundSpline
#if WITH_EDITORONLY_DATA
    FLOAT DistanceBetweenPoints;
    class USplineComponent* SplineComponent;
    FVector TestPoint;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS AmbientSoundSpline

    DECLARE_CLASS(AAmbientSoundSpline,AAmbientSound,0,Engine)
	virtual void PostLoad();
	virtual void PostEditMove(UBOOL bFinished);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

#if WITH_EDITOR
	virtual void EditorApplyTranslation(const FVector& DeltaTranslation, UBOOL bAltDown, UBOOL bShiftDown, UBOOL bCtrlDown);

	/** Force all spline data to be consistent. */
	virtual void UpdateSpline();

	/** Recalculate spline after any control point was moved. */
    virtual void UpdateSplineGeometry();
#endif
};

class AAmbientSoundSimpleSpline : public AAmbientSoundSpline
{
public:
    //## BEGIN PROPS AmbientSoundSimpleSpline
#if WITH_EDITORONLY_DATA
    INT EditedSlot;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS AmbientSoundSimpleSpline

    DECLARE_CLASS(AAmbientSoundSimpleSpline,AAmbientSoundSpline,0,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class AAmbientSoundSplineMultiCue : public AAmbientSoundSpline
{
public:
    //## BEGIN PROPS AmbientSoundSplineMultiCue
#if WITH_EDITORONLY_DATA
    INT EditedSlot;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS AmbientSoundSplineMultiCue

    DECLARE_CLASS(AAmbientSoundSplineMultiCue,AAmbientSoundSpline,0,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class UDistributionFloatSoundParameter : public UDistributionFloatParameterBase
{
public:
    //## BEGIN PROPS DistributionFloatSoundParameter
    //## END PROPS DistributionFloatSoundParameter

    DECLARE_CLASS(UDistributionFloatSoundParameter,UDistributionFloatParameterBase,0,Engine)
	virtual UBOOL GetParamValue(UObject* Data, FName ParamName, FLOAT& OutFloat);
};

class USoundNode : public UObject
{
public:
    //## BEGIN PROPS SoundNode
    INT NodeUpdateHint;
    TArrayNoInit<class USoundNode*> ChildNodes;
    //## END PROPS SoundNode

    DECLARE_ABSTRACT_CLASS(USoundNode,UObject,0,Engine)
    #include "USoundNode.h"
};

class UForcedLoopSoundNode : public USoundNode
{
public:
    //## BEGIN PROPS ForcedLoopSoundNode
    //## END PROPS ForcedLoopSoundNode

    DECLARE_CLASS(UForcedLoopSoundNode,USoundNode,0,Engine)
	virtual UBOOL NotifyWaveInstanceFinished( struct FWaveInstance* WaveInstance );
	virtual FLOAT GetDuration( );
	/** 
	 * Returns the maximum distance this sound can be heard from. Very large for looping sounds as the
	 * player can move into the hearable range during a loop.
	 */
	virtual FLOAT MaxAudibleDistance( FLOAT CurrentMaxDistance );
};

class USoundNodeAttenuation : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeAttenuation
    BITFIELD bAttenuate:1;
    BITFIELD bSpatialize:1;
    BITFIELD bAttenuateWithLPF:1;
    FLOAT dBAttenuationAtMax;
    FLOAT OmniRadius;
    BYTE DistanceAlgorithm;
    BYTE DistanceType;
    FLOAT RadiusMin;
    FLOAT RadiusMax;
    FLOAT LPFRadiusMin;
    FLOAT LPFRadiusMax;
    //## END PROPS SoundNodeAttenuation

    DECLARE_CLASS(USoundNodeAttenuation,USoundNode,0,Engine)
    #include "USoundNodeAttenuation.h"
};

struct FAmbientSoundSlot
{
    class USoundNodeWave* Wave;
    FLOAT PitchScale;
    FLOAT VolumeScale;
    FLOAT Weight;

		FAmbientSoundSlot( void )
		{
			PitchScale = 1.0f;
			VolumeScale = 1.0f;
			Weight = 1.0f;
		}
	
};

class USoundNodeAmbient : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeAmbient
    BITFIELD bAttenuate:1;
    BITFIELD bSpatialize:1;
    BITFIELD bAttenuateWithLPF:1;
    FLOAT dBAttenuationAtMax;
    BYTE DistanceModel;
    FLOAT RadiusMin;
    FLOAT RadiusMax;
    FLOAT LPFRadiusMin;
    FLOAT LPFRadiusMax;
    FLOAT PitchMin;
    FLOAT PitchMax;
    FLOAT VolumeMin;
    FLOAT VolumeMax;
    TArrayNoInit<struct FAmbientSoundSlot> SoundSlots;
    //## END PROPS SoundNodeAmbient

    DECLARE_CLASS(USoundNodeAmbient,USoundNode,0,Engine)
    #include "USoundNodeAmbient.h"
};

class USoundNodeAmbientNonLoop : public USoundNodeAmbient
{
public:
    //## BEGIN PROPS SoundNodeAmbientNonLoop
    FLOAT DelayMin;
    FLOAT DelayMax;
    struct FRawDistributionFloat DelayTime_DEPRECATED;
    //## END PROPS SoundNodeAmbientNonLoop

    DECLARE_CLASS(USoundNodeAmbientNonLoop,USoundNodeAmbient,0,Engine)
    #include "USoundNodeAmbientNonLoop.h"
};

class USoundNodeAmbientNonLoopToggle : public USoundNodeAmbientNonLoop
{
public:
    //## BEGIN PROPS SoundNodeAmbientNonLoopToggle
    //## END PROPS SoundNodeAmbientNonLoopToggle

    DECLARE_CLASS(USoundNodeAmbientNonLoopToggle,USoundNodeAmbientNonLoop,0,Engine)
    #include "USoundNodeAmbientNonLoopToggle.h"
};

class USoundNodeAttenuationAndGain : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeAttenuationAndGain
    BITFIELD bAttenuate:1;
    BITFIELD bSpatialize:1;
    BITFIELD bAttenuateWithLPF:1;
    FLOAT dBAttenuationAtMax;
    FLOAT OmniRadius;
    BYTE GainDistanceAlgorithm;
    BYTE AttenuateDistanceAlgorithm;
    BYTE DistanceType;
    FLOAT MinimalVolume;
    FLOAT RadiusMin;
    FLOAT RadiusPeak;
    FLOAT RadiusMax;
    FLOAT LPFMinimal;
    FLOAT LPFRadiusMin;
    FLOAT LPFRadiusPeak;
    FLOAT LPFRadiusMax;
    //## END PROPS SoundNodeAttenuationAndGain

    DECLARE_CLASS(USoundNodeAttenuationAndGain,USoundNode,0,Engine)
    #include "USoundNodeAttenuationAndGain.h"
};

class USoundNodeConcatenator : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeConcatenator
    TArrayNoInit<FLOAT> InputVolume;
    //## END PROPS SoundNodeConcatenator

    DECLARE_CLASS(USoundNodeConcatenator,USoundNode,0,Engine)
    #include "USoundNodeConcatenator.h"
};

class USoundNodeConcatenatorRadio : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeConcatenatorRadio
    //## END PROPS SoundNodeConcatenatorRadio

    DECLARE_CLASS(USoundNodeConcatenatorRadio,USoundNode,0,Engine)
    #include "USoundNodeConcatenatorRadio.h"
};

class USoundNodeDelay : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeDelay
    FLOAT DelayMin;
    FLOAT DelayMax;
    struct FRawDistributionFloat DelayDuration_DEPRECATED;
    //## END PROPS SoundNodeDelay

    DECLARE_CLASS(USoundNodeDelay,USoundNode,0,Engine)
    #include "USoundNodeDelay.h"
};

struct FDistanceDatum
{
    FLOAT FadeInDistanceStart;
    FLOAT FadeInDistanceEnd;
    FLOAT FadeOutDistanceStart;
    FLOAT FadeOutDistanceEnd;
    FLOAT Volume;
    struct FRawDistributionFloat FadeInDistance_DEPRECATED;
    struct FRawDistributionFloat FadeOutDistance_DEPRECATED;

    /** Constructors */
    FDistanceDatum() {}
    FDistanceDatum(EEventParm)
    {
        appMemzero(this, sizeof(FDistanceDatum));
    }
};

class USoundNodeDistanceCrossFade : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeDistanceCrossFade
    TArrayNoInit<struct FDistanceDatum> CrossFadeInput;
    //## END PROPS SoundNodeDistanceCrossFade

    DECLARE_CLASS(USoundNodeDistanceCrossFade,USoundNode,0,Engine)
    #include "USoundNodeDistanceCrossFade.h"
};

class USoundNodeDoppler : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeDoppler
    FLOAT DopplerIntensity;
    //## END PROPS SoundNodeDoppler

    DECLARE_CLASS(USoundNodeDoppler,USoundNode,0,Engine)
public:
	/** 
	 * USoundNode interface. 
	 */
	virtual void ParseNodes( UAudioDevice* AudioDevice, USoundNode* Parent, INT ChildIndex, class UAudioComponent* AudioComponent, TArray<FWaveInstance*>& WaveInstances );

	/** 
	 * Used to create a unique string to identify unique nodes
	 */
	virtual FString GetUniqueString( void );

protected:
	FLOAT GetDopplerPitchMultiplier(FListener const& InListener, UAudioComponent const& AudioComponent) const;
};

class USoundNodeEnveloper : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeEnveloper
    FLOAT LoopStart;
    FLOAT LoopEnd;
    FLOAT DurationAfterLoop;
    INT LoopCount;
    BITFIELD bLoopIndefinitely:1;
    BITFIELD bLoop:1;
    class UDistributionFloatConstantCurve* VolumeInterpCurve;
    class UDistributionFloatConstantCurve* PitchInterpCurve;
    //## END PROPS SoundNodeEnveloper

    DECLARE_CLASS(USoundNodeEnveloper,USoundNode,0,Engine)
    #include "USoundNodeEnveloper.h"
};

class USoundNodeLooping : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeLooping
    BITFIELD bLoopIndefinitely:1;
    FLOAT LoopCountMin;
    FLOAT LoopCountMax;
    struct FRawDistributionFloat LoopCount_DEPRECATED;
    //## END PROPS SoundNodeLooping

    DECLARE_CLASS(USoundNodeLooping,USoundNode,0,Engine)
    #include "USoundNodeLooping.h"
};

class USoundNodeMature : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeMature
    //## END PROPS SoundNodeMature

    DECLARE_CLASS(USoundNodeMature,USoundNode,0,Engine)
    #include "USoundNodeMature.h"
};

class USoundNodeMixer : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeMixer
    TArrayNoInit<FLOAT> InputVolume;
    //## END PROPS SoundNodeMixer

    DECLARE_CLASS(USoundNodeMixer,USoundNode,0,Engine)
    #include "USoundNodeMixer.h"
};

class USoundNodeModulator : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeModulator
    FLOAT PitchMin;
    FLOAT PitchMax;
    FLOAT VolumeMin;
    FLOAT VolumeMax;
    struct FRawDistributionFloat PitchModulation_DEPRECATED;
    struct FRawDistributionFloat VolumeModulation_DEPRECATED;
    //## END PROPS SoundNodeModulator

    DECLARE_CLASS(USoundNodeModulator,USoundNode,0,Engine)
    #include "USoundNodeModulator.h"
};

class USoundNodeModulatorContinuous : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeModulatorContinuous
    struct FRawDistributionFloat PitchModulation;
    struct FRawDistributionFloat VolumeModulation;
    //## END PROPS SoundNodeModulatorContinuous

    DECLARE_CLASS(USoundNodeModulatorContinuous,USoundNode,0,Engine)
    #include "USoundNodeModulatorContinuous.h"
};

class USoundNodeOscillator : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeOscillator
    BITFIELD bModulateVolume:1;
    BITFIELD bModulatePitch:1;
    FLOAT AmplitudeMin;
    FLOAT AmplitudeMax;
    FLOAT FrequencyMin;
    FLOAT FrequencyMax;
    FLOAT OffsetMin;
    FLOAT OffsetMax;
    FLOAT CenterMin;
    FLOAT CenterMax;
    struct FRawDistributionFloat Amplitude_DEPRECATED;
    struct FRawDistributionFloat Frequency_DEPRECATED;
    struct FRawDistributionFloat Offset_DEPRECATED;
    struct FRawDistributionFloat Center_DEPRECATED;
    //## END PROPS SoundNodeOscillator

    DECLARE_CLASS(USoundNodeOscillator,USoundNode,0,Engine)
    #include "USoundNodeOscillator.h"
};

class USoundNodeRandom : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeRandom
    TArrayNoInit<FLOAT> Weights;
    INT PreselectAtLevelLoad;
    BITFIELD bRandomizeWithoutReplacement:1;
    TArrayNoInit<UBOOL> HasBeenUsed;
    INT NumRandomUsed;
    //## END PROPS SoundNodeRandom

    DECLARE_CLASS(USoundNodeRandom,USoundNode,0,Engine)
    #include "USoundNodeRandom.h"
};

struct SoundNodeWave_eventGeneratePCMData_Parms
{
    TArray<BYTE> Buffer;
    INT SamplesNeeded;
    SoundNodeWave_eventGeneratePCMData_Parms(EEventParm)
    {
    }
};
class USoundNodeWave : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeWave
    INT CompressionQuality;
    BITFIELD bForceRealTimeDecompression:1;
    BITFIELD bLoopingSound:1;
    BITFIELD bDynamicResource:1;
    BITFIELD bUseTTS:1;
    BITFIELD bProcedural:1;
    BITFIELD bMature:1;
    BITFIELD bManualWordWrap:1;
    BITFIELD bSingleLine:1;
    SCRIPT_ALIGN;
    BYTE TTSSpeaker;
    BYTE DecompressionType;
    BYTE MobileDetailMode;
    FStringNoInit SpokenText;
    FLOAT Volume;
    FLOAT Pitch;
    FLOAT Duration;
    INT NumChannels;
    INT SampleRate;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<INT> ChannelOffsets;
    TArrayNoInit<INT> ChannelSizes;
#endif // WITH_EDITORONLY_DATA
    FByteBulkData RawData;
    FAsyncVorbisDecompress* VorbisDecompressor;
    BYTE* RawPCMData;
    INT RawPCMDataSize;
    FByteBulkData CompressedPCData;
    FByteBulkData CompressedXbox360Data;
    FByteBulkData CompressedPS3Data;
    FByteBulkData CompressedWiiUData;
    FByteBulkData CompressedIPhoneData;
    FByteBulkData CompressedFlashData;
    INT ResourceID;
    INT ResourceSize;
    BYTE* ResourceData;
    TArrayNoInit<struct FSubtitleCue> Subtitles;
#if WITH_EDITORONLY_DATA
    FStringNoInit Comment;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<struct FLocalizedSubtitle> LocalizedSubtitles;
#if WITH_EDITORONLY_DATA
    FStringNoInit SourceFilePath;
    FStringNoInit SourceFileTimestamp;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS SoundNodeWave

    void eventGeneratePCMData(TArray<BYTE>& Buffer,INT SamplesNeeded)
    {
        SoundNodeWave_eventGeneratePCMData_Parms Parms(EC_EventParm);
        Parms.Buffer=Buffer;
        Parms.SamplesNeeded=SamplesNeeded;
        ProcessEvent(FindFunctionChecked(ENGINE_GeneratePCMData),&Parms);
        Buffer=Parms.Buffer;
    }
    DECLARE_CLASS(USoundNodeWave,USoundNode,0,Engine)
    #include "USoundNodeWave.h"
};

struct SoundNodeWaveStreaming_eventAvailableAudioBytes_Parms
{
    INT ReturnValue;
    SoundNodeWaveStreaming_eventAvailableAudioBytes_Parms(EEventParm)
    {
    }
};
struct SoundNodeWaveStreaming_eventResetAudio_Parms
{
    SoundNodeWaveStreaming_eventResetAudio_Parms(EEventParm)
    {
    }
};
struct SoundNodeWaveStreaming_eventQueueSilence_Parms
{
    FLOAT Seconds;
    SoundNodeWaveStreaming_eventQueueSilence_Parms(EEventParm)
    {
    }
};
struct SoundNodeWaveStreaming_eventQueueAudio_Parms
{
    TArray<BYTE> Data;
    SoundNodeWaveStreaming_eventQueueAudio_Parms(EEventParm)
    {
    }
};
class USoundNodeWaveStreaming : public USoundNodeWave
{
public:
    //## BEGIN PROPS SoundNodeWaveStreaming
    TArrayNoInit<BYTE> QueuedAudio;
    FLOAT InactiveDuration;
    //## END PROPS SoundNodeWaveStreaming

    virtual void QueueAudio(const TArray<BYTE>& Data);
    virtual void QueueSilence(FLOAT Seconds);
    virtual void ResetAudio();
    virtual INT AvailableAudioBytes();
    virtual void GeneratePCMData(TArray<BYTE>& Buffer,INT SamplesNeeded);
    DECLARE_FUNCTION(execQueueAudio)
    {
        P_GET_TARRAY(BYTE,Data);
        P_FINISH;
        this->QueueAudio(Data);
    }
    DECLARE_FUNCTION(execQueueSilence)
    {
        P_GET_FLOAT(Seconds);
        P_FINISH;
        this->QueueSilence(Seconds);
    }
    DECLARE_FUNCTION(execResetAudio)
    {
        P_FINISH;
        this->ResetAudio();
    }
    DECLARE_FUNCTION(execAvailableAudioBytes)
    {
        P_FINISH;
        *(INT*)Result=this->AvailableAudioBytes();
    }
    DECLARE_FUNCTION(execGeneratePCMData)
    {
        P_GET_TARRAY_REF(BYTE,Buffer);
        P_GET_INT(SamplesNeeded);
        P_FINISH;
        this->GeneratePCMData(Buffer,SamplesNeeded);
    }
    INT eventAvailableAudioBytes()
    {
        SoundNodeWaveStreaming_eventAvailableAudioBytes_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        ProcessEvent(FindFunctionChecked(ENGINE_AvailableAudioBytes),&Parms);
        return Parms.ReturnValue;
    }
    void eventResetAudio()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_ResetAudio),NULL);
    }
    void eventQueueSilence(FLOAT Seconds)
    {
        SoundNodeWaveStreaming_eventQueueSilence_Parms Parms(EC_EventParm);
        Parms.Seconds=Seconds;
        ProcessEvent(FindFunctionChecked(ENGINE_QueueSilence),&Parms);
    }
    void eventQueueAudio(const TArray<BYTE>& Data)
    {
        SoundNodeWaveStreaming_eventQueueAudio_Parms Parms(EC_EventParm);
        Parms.Data=Data;
        ProcessEvent(FindFunctionChecked(ENGINE_QueueAudio),&Parms);
    }
    DECLARE_CLASS(USoundNodeWaveStreaming,USoundNodeWave,0,Engine)
    #include "USoundNodeWaveStreaming.h"
};

class USoundNodeWaveParam : public USoundNode
{
public:
    //## BEGIN PROPS SoundNodeWaveParam
    FName WaveParameterName;
    //## END PROPS SoundNodeWaveParam

    DECLARE_CLASS(USoundNodeWaveParam,USoundNode,0,Engine)
    #include "USoundNodeWaveParam.h"
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_SOUND_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(USoundNodeWaveStreaming,-1,execGeneratePCMData);
AUTOGENERATE_FUNCTION(USoundNodeWaveStreaming,-1,execAvailableAudioBytes);
AUTOGENERATE_FUNCTION(USoundNodeWaveStreaming,-1,execResetAudio);
AUTOGENERATE_FUNCTION(USoundNodeWaveStreaming,-1,execQueueSilence);
AUTOGENERATE_FUNCTION(USoundNodeWaveStreaming,-1,execQueueAudio);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_SOUND_NATIVE_DEFS
#define ENGINE_SOUND_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_SOUND \
	AAmbientSound::StaticClass(); \
	AAmbientSoundMovable::StaticClass(); \
	AAmbientSoundSimple::StaticClass(); \
	AAmbientSoundNonLoop::StaticClass(); \
	AAmbientSoundSimpleToggleable::StaticClass(); \
	AAmbientSoundNonLoopingToggleable::StaticClass(); \
	AAmbientSoundSpline::StaticClass(); \
	AAmbientSoundSimpleSpline::StaticClass(); \
	AAmbientSoundSplineMultiCue::StaticClass(); \
	UDistributionFloatSoundParameter::StaticClass(); \
	USoundNode::StaticClass(); \
	UForcedLoopSoundNode::StaticClass(); \
	USoundNodeAmbient::StaticClass(); \
	USoundNodeAmbientNonLoop::StaticClass(); \
	USoundNodeAmbientNonLoopToggle::StaticClass(); \
	USoundNodeAttenuation::StaticClass(); \
	USoundNodeAttenuationAndGain::StaticClass(); \
	USoundNodeConcatenator::StaticClass(); \
	USoundNodeConcatenatorRadio::StaticClass(); \
	USoundNodeDelay::StaticClass(); \
	USoundNodeDistanceCrossFade::StaticClass(); \
	USoundNodeDoppler::StaticClass(); \
	USoundNodeEnveloper::StaticClass(); \
	USoundNodeLooping::StaticClass(); \
	USoundNodeMature::StaticClass(); \
	USoundNodeMixer::StaticClass(); \
	USoundNodeModulator::StaticClass(); \
	USoundNodeModulatorContinuous::StaticClass(); \
	USoundNodeOscillator::StaticClass(); \
	USoundNodeRandom::StaticClass(); \
	USoundNodeWave::StaticClass(); \
	USoundNodeWaveStreaming::StaticClass(); \
	GNativeLookupFuncs.Set(FName("SoundNodeWaveStreaming"), GEngineUSoundNodeWaveStreamingNatives); \
	USoundNodeWaveParam::StaticClass(); \

#endif // ENGINE_SOUND_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineUSoundNodeWaveStreamingNatives[] = 
{ 
	MAP_NATIVE(USoundNodeWaveStreaming, execGeneratePCMData)
	MAP_NATIVE(USoundNodeWaveStreaming, execAvailableAudioBytes)
	MAP_NATIVE(USoundNodeWaveStreaming, execResetAudio)
	MAP_NATIVE(USoundNodeWaveStreaming, execQueueSilence)
	MAP_NATIVE(USoundNodeWaveStreaming, execQueueAudio)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(AAmbientSound,AmbientSound,AudioComponent)
VERIFY_CLASS_SIZE_NODIE(AAmbientSound)
VERIFY_CLASS_SIZE_NODIE(AAmbientSoundMovable)
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSimple,AmbientSoundSimple,AmbientProperties)
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSimple,AmbientSoundSimple,SoundNodeInstance)
VERIFY_CLASS_SIZE_NODIE(AAmbientSoundSimple)
VERIFY_CLASS_SIZE_NODIE(AAmbientSoundNonLoop)
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSimpleToggleable,AmbientSoundSimpleToggleable,FadeInDuration)
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSimpleToggleable,AmbientSoundSimpleToggleable,FadeOutVolumeLevel)
VERIFY_CLASS_SIZE_NODIE(AAmbientSoundSimpleToggleable)
VERIFY_CLASS_SIZE_NODIE(AAmbientSoundNonLoopingToggleable)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSpline,AmbientSoundSpline,DistanceBetweenPoints)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSpline,AmbientSoundSpline,TestPoint)
#endif
VERIFY_CLASS_SIZE_NODIE(AAmbientSoundSpline)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSimpleSpline,AmbientSoundSimpleSpline,EditedSlot)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSimpleSpline,AmbientSoundSimpleSpline,EditedSlot)
#endif
VERIFY_CLASS_SIZE_NODIE(AAmbientSoundSimpleSpline)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSplineMultiCue,AmbientSoundSplineMultiCue,EditedSlot)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AAmbientSoundSplineMultiCue,AmbientSoundSplineMultiCue,EditedSlot)
#endif
VERIFY_CLASS_SIZE_NODIE(AAmbientSoundSplineMultiCue)
VERIFY_CLASS_SIZE_NODIE(UDistributionFloatSoundParameter)
VERIFY_CLASS_OFFSET_NODIE(USoundNode,SoundNode,NodeUpdateHint)
VERIFY_CLASS_OFFSET_NODIE(USoundNode,SoundNode,ChildNodes)
VERIFY_CLASS_SIZE_NODIE(USoundNode)
VERIFY_CLASS_SIZE_NODIE(UForcedLoopSoundNode)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeAmbient,SoundNodeAmbient,dBAttenuationAtMax)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeAmbient,SoundNodeAmbient,SoundSlots)
VERIFY_CLASS_SIZE_NODIE(USoundNodeAmbient)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeAmbientNonLoop,SoundNodeAmbientNonLoop,DelayMin)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeAmbientNonLoop,SoundNodeAmbientNonLoop,DelayTime_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(USoundNodeAmbientNonLoop)
VERIFY_CLASS_SIZE_NODIE(USoundNodeAmbientNonLoopToggle)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeAttenuation,SoundNodeAttenuation,dBAttenuationAtMax)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeAttenuation,SoundNodeAttenuation,LPFRadiusMax)
VERIFY_CLASS_SIZE_NODIE(USoundNodeAttenuation)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeAttenuationAndGain,SoundNodeAttenuationAndGain,dBAttenuationAtMax)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeAttenuationAndGain,SoundNodeAttenuationAndGain,LPFRadiusMax)
VERIFY_CLASS_SIZE_NODIE(USoundNodeAttenuationAndGain)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeConcatenator,SoundNodeConcatenator,InputVolume)
VERIFY_CLASS_SIZE_NODIE(USoundNodeConcatenator)
VERIFY_CLASS_SIZE_NODIE(USoundNodeConcatenatorRadio)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeDelay,SoundNodeDelay,DelayMin)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeDelay,SoundNodeDelay,DelayDuration_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(USoundNodeDelay)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeDistanceCrossFade,SoundNodeDistanceCrossFade,CrossFadeInput)
VERIFY_CLASS_SIZE_NODIE(USoundNodeDistanceCrossFade)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeDoppler,SoundNodeDoppler,DopplerIntensity)
VERIFY_CLASS_SIZE_NODIE(USoundNodeDoppler)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeEnveloper,SoundNodeEnveloper,LoopStart)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeEnveloper,SoundNodeEnveloper,PitchInterpCurve)
VERIFY_CLASS_SIZE_NODIE(USoundNodeEnveloper)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeLooping,SoundNodeLooping,LoopCountMin)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeLooping,SoundNodeLooping,LoopCount_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(USoundNodeLooping)
VERIFY_CLASS_SIZE_NODIE(USoundNodeMature)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeMixer,SoundNodeMixer,InputVolume)
VERIFY_CLASS_SIZE_NODIE(USoundNodeMixer)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeModulator,SoundNodeModulator,PitchMin)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeModulator,SoundNodeModulator,VolumeModulation_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(USoundNodeModulator)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeModulatorContinuous,SoundNodeModulatorContinuous,PitchModulation)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeModulatorContinuous,SoundNodeModulatorContinuous,VolumeModulation)
VERIFY_CLASS_SIZE_NODIE(USoundNodeModulatorContinuous)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeOscillator,SoundNodeOscillator,AmplitudeMin)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeOscillator,SoundNodeOscillator,Center_DEPRECATED)
VERIFY_CLASS_SIZE_NODIE(USoundNodeOscillator)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeRandom,SoundNodeRandom,Weights)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeRandom,SoundNodeRandom,NumRandomUsed)
VERIFY_CLASS_SIZE_NODIE(USoundNodeRandom)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeWave,SoundNodeWave,CompressionQuality)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(USoundNodeWave,SoundNodeWave,SourceFileTimestamp)
#else
VERIFY_CLASS_OFFSET_NODIE(USoundNodeWave,SoundNodeWave,LocalizedSubtitles)
#endif
VERIFY_CLASS_SIZE_NODIE(USoundNodeWave)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeWaveStreaming,SoundNodeWaveStreaming,QueuedAudio)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeWaveStreaming,SoundNodeWaveStreaming,InactiveDuration)
VERIFY_CLASS_SIZE_NODIE(USoundNodeWaveStreaming)
VERIFY_CLASS_OFFSET_NODIE(USoundNodeWaveParam,SoundNodeWaveParam,WaveParameterName)
VERIFY_CLASS_SIZE_NODIE(USoundNodeWaveParam)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
