/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_AI_ENUMS
#define INCLUDED_ENGINE_AI_ENUMS 1

enum EEdgeHandlingStatus
{
    EHS_AddedBothDirs       =0,
    EHS_Added0to1           =1,
    EHS_Added1to0           =2,
    EHS_AddedNone           =3,
    EHS_MAX                 =4,
};
#define FOREACH_ENUM_EEDGEHANDLINGSTATUS(op) \
    op(EHS_AddedBothDirs) \
    op(EHS_Added0to1) \
    op(EHS_Added1to0) \
    op(EHS_AddedNone) 

#endif // !INCLUDED_ENGINE_AI_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_AI_CLASSES
#define INCLUDED_ENGINE_AI_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UInterface_NavMeshPathObstacle : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UInterface_NavMeshPathObstacle,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterface_NavMeshPathObstacle)
};

class IInterface_NavMeshPathObstacle
{
protected:
	virtual ~IInterface_NavMeshPathObstacle() {}
public:
	typedef UInterface_NavMeshPathObstacle UClassType;
	virtual UObject* GetUObjectInterfaceInterface_NavMeshPathObstacle()=0;
	/**
	 * this will register the passed shape/bounds with the passed polys 
	 * @param BoundingShape - bounding shape of the obstacle
 	 * @param Bounds - bounds of the bounding shape (for octree queries)	 
	 * @param Polys - polys to register this obstacle with 
	 * @return - TRUE If registration was succesful 
	 */
	UBOOL RegisterObstacleWithPolys( const TArray<FVector>& BoundingShape, const TArray<FNavMeshPolyBase*>& Polys);

	/**
	 * Rebuilds all submesh data for any submeshes within the passed top level polygons
	 * @param Polys - polys to trigger rebuild for
	 */
	static void TriggerRebuildForPassedTLPolys( const TArray<FNavMeshPolyBase*>& Polys );

	/**
	 * this is called on polys which have just had all obstacles cleared and won't get a normal build step
	 * and thus need to have edges created to adjacent sub-meshes
	 */
	UBOOL DoEdgeFixupForNewlyClearedPolys(const TArray<FNavMeshPolyBase*> PolysThatNeedFixup);

	/**
	 * given a list of pylons will update all the obstacles that need updating within it
	 * also does post steps after update is finished
	 * @param Pylons - list of pylons to update obstacles for
	 */
	static void UpdateAllDynamicObstaclesInPylonList(TArray<APylon*>& Pylons);

	/**
	 * this will register this shape with the obstacle mesh, indicating it should be considered
	 * when generating paths
	 * @return - TRUE If registration was successful
	 */
	UBOOL RegisterObstacleWithNavMesh();

	/**
	 * this will register the passed list of obstacles, and then perform a build at the end.
	 * useful for registering a big list of obstacles all at once and paying much less cost (mesh doesn't have to be rebuilt each registration, only at the end)
	 * @param ObstaclesToRegister - list of obstacles to register
	 * @return - TRUE if registration and build was successful
	 */
	static UBOOL RegisterObstacleListWithNavMesh(TArray<IInterface_NavMeshPathObstacle*>& Obstacles);

	/**
	 * this will remove this shape from the obstacle mesh, indicating it is no longer relevant to 
	 * generating paths
	 * @return TRUE if unregistration was successful
	 */
	UBOOL UnregisterObstacleWithNavMesh();

	/** 
	 * called when the owner of this interface is being unloaded or destroyed and this obstacle needs to be cleaned up
	 */
	virtual void CleanupOnRemoval();

	/**
	 * this function should populate out_polyshape with a list of verts which describe this object's 
	 * convex bounding shape
	 * (verts should be clockwise wound)
	 * @param out_PolyShape - output array which holds the vertex buffer for this obstacle's bounding polyshape
	 * @param ShapeIdx - index of the shape being requested
	 * @return TRUE if this object should block things right now (FALSE means this obstacle shouldn't affect the mesh)
	 */
	virtual UBOOL GetBoundingShape(TArray<FVector>& out_PolyShape,INT ShapeIdx)=0;

	/**
	 * return the number of shapes this obstacle needs to represent itself 
	 */
	virtual INT GetNumBoundingShapes(){ return 1; }

	/**
	 * when TRUE polys internal to this obstacle will be preserved, but still split. (useful for things like cost volumes that 
	 * need to adjust cost but not completely destroy parts of the mesh
	 * @return TRUE if polys should be preserved internal to this obstacle
	 */
	virtual UBOOL PreserveInternalPolys() { return FALSE; }

	/**
	 * This function is called when an edge is going to be added connecting a polygon internal to this obstacle to another polygon which is not
	 * Default behavior just a normal edge, override to add special costs or behavior (e.g. link a pathobject to the obstacle)
	 * @param Status - current status of edges (e.g. what still needs adding)	 
	 * @param inV1 - vertex location of first vert in the edge
	 * @param inV2 - vertex location of second vert in the edge
	 * @param ConnectedPolys - the polys this edge links
	 * @param bEdgesNeedToBeDynamic - whether or not added edges need to be dynamic (e.g. we're adding edges between meshes)
	 * @param PolyAssocatedWithThisPO - the index into the connected polys array parmaeter which tells us which poly from that array is associated with this path object
	 * @(optional) param SupportedEdgeWidth - width of unit that this edge supports, defaults to -1.0f meaning the length of the edge itself will be used
	 * @(optional) param EdgeGroupID - ID of the edgegroup this edge is a part of (defaults to no group)
	 * @return returns an enum describing what just happened (what actions did we take) - used to determien what accompanying actions need to be taken 
	 *         by other obstacles and calling code
	 */
	virtual EEdgeHandlingStatus AddObstacleEdge( EEdgeHandlingStatus Status, const FVector& inV1, const FVector& inV2, TArray<FNavMeshPolyBase*>& ConnectedPolys, UBOOL bEdgesNeedToBeDynamic, INT PolyAssocatedWithThisPO, FLOAT SupportedEdgeWidth=-1.0f, BYTE EdgeGroupID=MAXBYTE);

	/**
	 * this function is called after a top level mesh's submeshes have all been built (e.g. at the end of UNavigationMeshBase::UpdateDynamicObstacles) 
	 * and that mesh is affected by this obstacle
	 * and it gives this obstacle a chance to do any extra work after the mesh is built (e.g. add specialized edges)
	 * @param MeshThatWasUpdated - the top level navmesh that just had all submeshes built
	 */
	virtual void PostSubMeshUpdateForTopLevelMesh(UNavigationMeshBase* MeshThatWasUpdated) {}

	/**
	 * For debugging.  Verifies that this pathobject is still alive and well and not orphaned or deleted
	 * @return - TRUE If this path object is in good working order
	 */
	virtual UBOOL VerifyObstacle()
	{
		return FALSE;
	}
};

class UInterface_NavMeshPathObject : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UInterface_NavMeshPathObject,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterface_NavMeshPathObject)
};

class IInterface_NavMeshPathObject
{
protected:
	virtual ~IInterface_NavMeshPathObject() {}
public:
	typedef UInterface_NavMeshPathObject UClassType;
	virtual UObject* GetUObjectInterfaceInterface_NavMeshPathObject()=0;
	/************************************************************************
	 * Runtime Edge Query interface                                         *
	 ************************************************************************/

	virtual void InitGuid( TArray<FGuid>& ExistingNavGuids )
	{
		AActor* Actor = Cast<AActor>(GetUObjectInterfaceInterface_NavMeshPathObject());
		if( Actor != NULL )
		{
			FGuid* pGuid = Actor->GetGuid();
			if( pGuid )
			{
				if( !pGuid->IsValid() || ExistingNavGuids.ContainsItem(*pGuid) )
				{
					*pGuid = appCreateGuid();
				}
				else
				{
					// save the existing guid to check for duplicates
					ExistingNavGuids.AddItem(*pGuid);
				}
			}
		}
	}

	/** 
	 *  Called from edges linked to this PO
	 *  @param Interface     - the navhandle interface of the entity pathing 
	 *  @param PreviousPoint - the previous point in the path search (e.g. the point along the predecessor edge)
	 *  @param out_PathEdgePoint - the point we used along this edge to determine the cost 
	 *  @param Edge - the edge linked to this PO which needs to compute cost	 
	 *  @return     - the cost for traversing this edge
	 */
	virtual INT CostFor( const FNavMeshPathParams& PathParams, const FVector& PreviousPoint, FVector& out_PathEdgePoint, FNavMeshPathObjectEdge* Edge, FNavMeshPolyBase* SourcePoly )
	{
		return Edge->FNavMeshEdgeBase::CostFor(PathParams, PreviousPoint, out_PathEdgePoint, SourcePoly);
	}
	
	/**
	 * passthru function from edge to determine if the passed searcher supports this pathobject's movement
	 * @param Interface - the interface of the searcher
	 * @param CurPoly   - the poly being checked for support
	 * @param Edge      - the edge linked to this path object which is being considered
	 * @param PredecessorEdge - the edge we are coming from to get to 'Edge'
	 * @return TRUE if this path object supports the searcher
	 */
	virtual UBOOL Supports( const FNavMeshPathParams& PathParams,
							FNavMeshPolyBase* CurPoly,
							FNavMeshPathObjectEdge* Edge,
							FNavMeshEdgeBase* PredecessorEdge)
	{
		return Edge->FNavMeshEdgeBase::Supports(PathParams,CurPoly,PredecessorEdge);
	}

	/** 
	 *  called when an entity is about to move through an edge linked to this path object.  Allows the path object to 
	 *  trigger animations, etc related to this PO
	 *  @param Interface - the entity which is traversing this PO
	 *  @param out_MovePt - the point generated by GetEdgeDestination which the entity is moving toward 
	 *  @param Edge      - the edge linked to this PathObject which is being moved through
	 *  @return          - whether or not the move was successful (true means we're done with this edge, remove it from path)
	 */
	virtual UBOOL PrepareMoveThru( class IInterface_NavigationHandle* Interface,
									FVector& out_MovePt,
									FNavMeshPathObjectEdge* Edge )
	{
		return FALSE;
	}

	/**
	 * called to determine the optimal position along this edge for the passed parameters (e.g. string pulling)
	 * @param EntityRadius - the radius of the entity we are computing the position for
	 * @param InfluencePosition - the position we are trying to get close to (e.g. previous point in path)
	 * @param EntityPosition    - the current position of the entity (e.g. starting position of bot)
	 * @param Edge              - the edge which is associated with this PO which we're being asked about
	 * @param out_EdgeDest      - the destination we want to use
	 * @return whether this PO modified the destination or not (FALSE indicates the default edge functionality should be used)
	 */
	virtual UBOOL GetEdgeDestination( const FNavMeshPathParams& PathParams,
										FLOAT EntityRadius,
										const FVector& InfluencePosition,
										const FVector& EntityPosition,
										FVector& out_EdgeDest,
										FNavMeshPathObjectEdge* Edge,
										UNavigationHandle* Handle)
	{
		return FALSE;
	}

	/**
	 * called to allow this PO to draw custom stuff for edges linked to it
	 * @param DRSP          - the sceneproxy we're drawing for
	 * @param DrawOffset    - offset from the actual location we should be drawing 
	 * @param Edge          - the edge we're drawing
	 * @return - whether this PO is doing custom drawing for the passed edge (FALSE indicates the default edge drawing functionality should be used)
	 */
	virtual UBOOL DrawEdge( FDebugRenderSceneProxy* DRSP, FColor C, FVector DrawOffset, FNavMeshPathObjectEdge* Edge )
	{
		return FALSE;		
	}

	/**
	 * allows path objects to dictate when it's OK for GetNextMoveLocation to push the current edge past this one in the AI's path.
	 * (normally the edge the AI is running to is figured out automatically based on which polygon the AI is in)
	 * @param PathParams - the parameters associated with the AI wondering if it is OK to run normal behavior
	 * @param bInPoly0 - whether the AI is currently in poly0 of this edge
	 * @param bInPoly1 - whether the AI is currently in poly1 of this edge
	 * @return - TRUE if it's OK to automatically progress the edge past this one 
	 */
	virtual UBOOL AllowMoveToNextEdge(FNavMeshPathParams& PathParams, UBOOL bInPoly0, UBOOL bInPoly1){ return TRUE; }

	/**
	 * this function is called after a poly linked to this edge is replaced with a submesh for a pathobstacle
	 * allows special edges to have a chance to add extra data after the mesh is split
	 * @params Edge - the edge that we are updating for
	 * @param Poly - the poly that was just disabled and replaced with a submesh
	 * @param NewSubMesh - the submesh that now represents the poly
	 */
	virtual void PostSubMeshUpdateForOwningPoly(FNavMeshPathObjectEdge* Edge, FNavMeshPolyBase* Poly, UNavigationMeshBase* New_SubMesh){}

	/**
	 * This is a helper function which is useful when this pathobject is being used in conjunction with the pathobstacle interface
	 * - just does all the work normally done in AddObstacleEdge, except convenienty tuned for use with pathobjects
	 * @param Status - current status of edges (e.g. what still needs adding)	 
	 * @param inV1 - vertex location of first vert in the edge
	 * @param inV2 - vertex location of second vert in the edge
	 * @param ConnectedPolys - the polys this edge links
	 * @param bEdgesNeedToBeDynamic - whether or not added edges need to be dynamic (e.g. we're adding edges between meshes)
	 * @param PolyAssocatedWithThisPO - the index into the connected polys array of the poly which is associated with this path object
	 * @param POOwner - the owner of the pathobject interface (e.g. the actor that implements interface)
	 * @param SupportedEdgeWidth - widht of unit this edge supports (defaults to -1.0 in which case the length of the edge will be used)
	 * @(optional) param EdgeGroupID - ID of the edgegroup this edge is a part of (defaults to no group)
	 * @return returns an enum describing what just happened (what actions did we take) - used to determien what accompanying actions need to be taken 
	 *         by other obstacles and calling code
	 */
	EEdgeHandlingStatus AddObstacleEdgeForObstacle( EEdgeHandlingStatus Status, const FVector& inV1, const FVector& inV2, TArray<FNavMeshPolyBase*>& ConnectedPolys, UBOOL bEdgesNeedToBeDynamic, INT PolyAssocatedWithThisPO, AActor* POOwner, FLOAT SupportedEdgeWidth=-1.0f, BYTE EdgeGroupID=MAXBYTE)
	{
		// if an edge has already been added in the direction we want to add an edge then there is probably a conflicting pathobstacle (e.g. we're butted
		// up against another obstacle which has already added an edge.. so just bail)
		if(Status == EHS_AddedBothDirs)
		{
			return Status;
		}

		// if there is already an edge point back into this PO from the other poly, bail
		if( (PolyAssocatedWithThisPO == 0 && Status == EHS_Added1to0) || 
			(PolyAssocatedWithThisPO == 1 && Status == EHS_Added0to1) )
		{
			return Status;
		}

		TArray<FNavMeshPolyBase*> ReversedConnectedPolys=ConnectedPolys;

		// so we want to add an edge back into the poly associated with this PO, so swap the order if we need to
		if(PolyAssocatedWithThisPO == 0)
		{
			ReversedConnectedPolys.SwapItems(0,1);
		}

		UNavigationMeshBase* Mesh = ReversedConnectedPolys(0)->NavMesh;

		if( Mesh == NULL )
		{
			return Status;
		}

		FNavMeshPathObjectEdge* NewEdge = NULL;
		if( bEdgesNeedToBeDynamic )
		{
			TArray<FNavMeshPathObjectEdge*> CreatedEdges;
			Mesh->AddDynamicCrossPylonEdge<FNavMeshPathObjectEdge>(inV1,inV2,ReversedConnectedPolys,SupportedEdgeWidth,EdgeGroupID,TRUE, &CreatedEdges);

			NewEdge = (CreatedEdges.Num() > 0) ? CreatedEdges(0) : NULL;
			checkSlowish(CreatedEdges.Num() <2);
		}
		else
		{
			if (! Mesh->AddOneWayCrossPylonEdgeToMesh<FNavMeshPathObjectEdge>(inV1,inV2,ReversedConnectedPolys,SupportedEdgeWidth,EdgeGroupID,&NewEdge) )
			{
				// we failed to add an edge for some reason.. if it returns true, we added an edge or there was already an identical edge there
				return Status;
			}

		}
		
		// bind new edge to this avoidance vol
		if(NewEdge != NULL)
		{
			NewEdge->PathObject = POOwner;
			NewEdge->InternalPathObjectID = 0;
		}

		// indicate that we added an edge from dest poly to src poly
		if(Status == EHS_AddedNone)
		{
			if(PolyAssocatedWithThisPO == 0)
			{
				return EHS_Added1to0;
			}
			else
			{
				return EHS_Added0to1;
			}
		}
		else
		{
			// if we get here that means someone should have already added an edge in the opposite direction
			return EHS_AddedBothDirs;
		}
	}


	/************************************************************************
	 * Mesh generation interface                                            *
	 ************************************************************************/

	/**
	 * this function describes a 'cookie cutter' edge that will be used to split the mesh beneath it
	 * for example if you have a cost inflicting volume that needs to conform the mesh to itself
	 * you could return an array of verts along the bottom boundary of the volume, and a height up to the top of the volume
	 * and then you have poly boundaries exactly along the border of the volume with which you can add 
	 * edges which affect cost
	 * @param Poly - array of vectors that describe bottom of 'cookie cutter' volume (should be CW and convex)
	 * @param PolyHeight - height above the poly within which polys should be split (extrude passed poly up by this amount and use faces for clip)
	 * @return - TRUE if this shape should be used to split the mesh FALSE if no splitting is necessary
	 */
	virtual UBOOL GetMeshSplittingPoly( TArray<FVector>& Poly, FLOAT& PolyHeight ){ return FALSE; }

	/**
	 * called for each pylon's exploration to see if this path object needs to be consulted during exploration
	 * @param Py - the pylon being explored that we need to know if this PO should be asked about
	 * @return - TRUE if this path object needs to have its IsExplorationAllowed function considered during path exploration
	 */
	virtual UBOOL NeedsForbidExploreCheck(APylon* Py) { return FALSE; }

	/**
	 * called during mesh exploration, allows this PO to forbid exploration through specific areas
	 * @param Py - the pylon being explored right now
	 * @param TestPosition - the position of the new poly we are asking about
	 * @return - TRUE if exploration is allowed
	 */
	virtual UBOOL IsExplorationAllowed( APylon* Py, const FVector& TestPosition) { return TRUE; }

	/**
	 * called after initial exploration, gives this PO a chance to add seeds to the exploration process
	 * @param SeedPointList - reference to the main array of seeds that need to be expanded after initial explore
	 * @param Py            - the pylon which is being expanded
	 */
	virtual void AddAuxSeedPoints( APylon* Py ){}

	/**
	 * called after edge creation is complete for each pylon to allow this PO to add edges for itself
	 * @param Py - the pylon which we are creating edges for
	 */
	virtual void CreateEdgesForPathObject( APylon* Py ){}

	/**
	 *  Function to be used from within CreateEdgesForPathObject
	 *  @param Interface_Owner - the actor which owns this interface
	 *  @param StartPoly - Source poly for edge
	 *  @param EndPoly   - Destination poly for edge
	 *  @param Vert0     - One end point of the edge
	 *  @param Vert1     - Another end point of the edge
	 *  @param InternalPOID - optional param for extra identifier which is attached to the edge being added (to distinguish between edges linked to this PO)
	 *  @return - T/F indicating success
	 */
	UBOOL AddEdgeForThisPO(AActor* Interface_Owner, 
						    APylon* Py,
						    FNavMeshPolyBase* StartPoly,
						    FNavMeshPolyBase* EndPoly,
							const FVector& Vert0,
							const FVector& Vert1,
							INT InternalPOID=-1,
							UBOOL bForce=FALSE)
	{
		UNavigationMeshBase* Mesh = Py->GetNavMesh();
		if( Mesh == NULL )
		{
			return FALSE;
		}

		if( StartPoly == EndPoly || StartPoly == NULL || EndPoly == NULL )
		{
			warnf(NAME_Warning,TEXT("WARNING! A pathobject (%s) tried to add an edge that links a poly to itself, or links a poly to nothing.  This add is being IGNORED!"), *Interface_Owner->GetName());
			return FALSE;
		}
		TArray<FNavMeshPolyBase*> ConnectedPolys;
		ConnectedPolys.AddItem(StartPoly);
		ConnectedPolys.AddItem(EndPoly);

		FNavMeshPathObjectEdge* NewEdge = NULL;
		if( Mesh->AddOneWayCrossPylonEdgeToMesh<FNavMeshPathObjectEdge>(Vert0,Vert1,ConnectedPolys,-1.0f,MAXBYTE,&NewEdge,bForce) )
		{
			if(NewEdge != NULL)
			{
				NewEdge->PathObject = Interface_Owner;
				NewEdge->InternalPathObjectID = InternalPOID;
			}

			// still want to return true if newedge is null, false indicates we ran out of vert indices
			return TRUE;
		}
		
		return FALSE;
	}

	/** 
	 *  This is called offline when edges are about to be added from the exterior of the pathobject to the interior or vice versa
	 * Default behavior just a normal edge, override to add special costs or behavior 
	 * @param Status - current status of edges (e.g. what still needs adding)	 
	 * @param inV1 - vertex location of first vert in the edge
	 * @param inV2 - vertex location of second vert in the edge
	 * @param ConnectedPolys - the polys this edge links
	 * @param PolyAssocatedWithThisPO - the index into the connected polys array parmaeter which tells us which poly from that array is associated with this path object
	 * @(optional) param SupportedEdgeWidth - width of unit that this edge supports, defaults to -1.0f meaning the length of the edge itself will be used
	 * @(optional) param EdgeGroupID - ID of the edgegroup this edge is a part of (defaults to no group)
	 * @return returns an enum describing what just happened (what actions did we take) - used to determien what accompanying actions need to be taken 
	 *         by other obstacles and calling code
	 */
	virtual EEdgeHandlingStatus AddStaticEdgeIntoThisPO( EEdgeHandlingStatus Status, const FVector& inV1, const FVector& inV2, TArray<FNavMeshPolyBase*>& ConnectedPolys, INT PolyAssocatedWithThisPO, FLOAT SupportedEdgeWidth=-1.0f, BYTE EdgeGroupID=MAXBYTE);


	/**
	 * Allows this path object to modify the final path generated for a bot when the path 
	 * uses an edge linked to this path object.. default is to do nothing
	 * @param Handle - the navigation handle whose path we are molesting
	 * @param Idx - the index into the pathcache that the edge associated with this path object is at
	 * @return - TRUE if we modified the path
	 */
	virtual UBOOL ModifyFinalPath( UNavigationHandle* Handle, INT Idx )
	{
		return FALSE;
	}

	/**
	 * For debugging.  Verifies that this pathobject is still alive and well and not orphaned or deleted
	 * @return - TRUE If this path object is in good working order
	 */
	virtual UBOOL Verify()
	{
		return FALSE;
	}
};

class AEnvironmentVolume : public AVolume, public IInterface_NavMeshPathObstacle, public IInterface_NavMeshPathObject
{
public:
    //## BEGIN PROPS EnvironmentVolume
    BITFIELD bSplitNavMesh:1;
    SCRIPT_ALIGN;
    //## END PROPS EnvironmentVolume

    void SetSplitNavMesh(UBOOL bNewValue);
    DECLARE_FUNCTION(execSetSplitNavMesh)
    {
        P_GET_UBOOL(bNewValue);
        P_FINISH;
        this->SetSplitNavMesh(bNewValue);
    }
    DECLARE_CLASS(AEnvironmentVolume,AVolume,0,Engine)
    virtual UObject* GetUObjectInterfaceInterface_NavMeshPathObstacle(){return this;}
    virtual UObject* GetUObjectInterfaceInterface_NavMeshPathObject(){return this;}
	virtual UBOOL ShouldAIAvoidMe(AAIController* AIC);

	virtual void BeginDestroy()
	{
		Super::BeginDestroy();

		// Unsplit if it was split.
		if( bSplitNavMesh )
		{
			SetSplitNavMesh(FALSE);
		}
	}

	//////////////////////////////////////////////////////////////////////////
	// Interface_NavMeshPathObject
	/** 
	 *  Called from edges linked to this PO
	 *  @param Interface     - the navhandle interface of the entity pathing 
	 *  @param PreviousPoint - the previous point in the path search (e.g. the point along the predecessor edge)
	 *  @param out_PathEdgePoint - the point we used along this edge to determine the cost 
	 *  @param Edge - the edge linked to this PO which needs to compute cost	 
	 *  @return     - the cost for traversing this edge
	 */
	virtual INT CostFor( const FNavMeshPathParams& PathParams, const FVector& PreviousPoint, FVector& out_PathEdgePoint, FNavMeshPathObjectEdge* Edge, FNavMeshPolyBase* SourcePoly );
	
	/**
	 * called to allow this PO to draw custom stuff for edges linked to it
	 * @param DRSP          - the sceneproxy we're drawing for
	 * @param DrawOffset    - offset from the actual location we should be drawing 
	 * @param Edge          - the edge we're drawing
	 * @return - whether this PO is doing custom drawing for the passed edge (FALSE indicates the default edge drawing functionality should be used)
	 */
	virtual UBOOL DrawEdge( FDebugRenderSceneProxy* DRSP, FColor C, FVector DrawOffset, FNavMeshPathObjectEdge* Edge );
	// END path object interface
	//////////////////////////////////////////////////////////////////////////


	//////////////////////////////////////////////////////////////////////////
	// Interface_NavMeshPathObstacle 
	/**
	 * this function should populate out_polyshape with a list of verts which describe this object's 
	 * convex bounding shape
	 * @param out_PolyShape - output array which holds the vertex buffer for this obstacle's bounding polyshape
	 * @return TRUE if this object should block things right now (FALSE means this obstacle shouldn't affect the mesh)
	 */
	virtual UBOOL GetBoundingShape(TArray<FVector>& out_PolyShape,INT ShapeIdx);

	/**
	 * when TRUE polys internal to this obstacle will be preserved, but still split. (useful for things like cost volumes that 
	 * need to adjust cost but not completely destroy parts of the mesh
	 * @return TRUE if polys should be preserved internal to this obstacle
	 */
	virtual UBOOL PreserveInternalPolys() { return TRUE; }

	/**
	 * This function is called when an edge is going to be added connecting a polygon internal to this obstacle to another polygon which is not
	 * Default behavior just a normal edge, override to add special costs or behavior (e.g. link a pathobject to the obstacle)
	 * @param Status - current status of edges (e.g. what still needs adding)	 
	 * @param inV1 - vertex location of first vert in the edge
	 * @param inV2 - vertex location of second vert in the edge
	 * @param ConnectedPolys - the polys this edge links
	 * @param bEdgesNeedToBeDynamic - whether or not added edges need to be dynamic (e.g. we're adding edges between meshes)
	 * @param PolyAssocatedWithThisPO - the index into the connected polys array parmaeter which tells us which poly from that array is associated with this path object
	 * @(optional) param SupportedEdgeWidth - width of unit that this edge supports, defaults to -1.0f meaning the length of the edge itself will be used
	 * @(optional) param EdgeGroupID - ID of the edgegroup this edge is a part of (defaults to no group)
	 * @return returns an enum describing what just happened (what actions did we take) - used to determien what accompanying actions need to be taken 
	 *         by other obstacles and calling code
	 */
	virtual EEdgeHandlingStatus AddObstacleEdge( EEdgeHandlingStatus Status, const FVector& inV1, const FVector& inV2, TArray<FNavMeshPolyBase*>& ConnectedPolys, UBOOL bEdgesNeedToBeDynamic, INT PolyAssocatedWithThisPO, FLOAT SupportedEdgeWidth=-1.0f, BYTE EdgeGroupID=MAXBYTE);


	/**
	 * For debugging.  Verifies that this pathobject is still alive and well and not orphaned or deleted
	 * @return - TRUE If this path object is in good working order
	 */
	virtual UBOOL Verify()
	{
		return !IsPendingKill();
	}

	virtual UBOOL VerifyObstacle()
	{
		return Verify();
	}

	// END Interface_NavMeshPathObstacle
	//////////////////////////////////////////////////////////////////////////

	/**
	 * Removes the volume from world info's list of environment volumes.
	 */
	virtual void ClearComponents( void );

protected:
	/**
	 * Adds the volume to world info's list of environment volumes.
	 */
	virtual void UpdateComponentsInternal( UBOOL bCollisionUpdate = FALSE );
public:
};

class ATestSplittingVolume : public AVolume, public IInterface_NavMeshPathObject
{
public:
    //## BEGIN PROPS TestSplittingVolume
    //## END PROPS TestSplittingVolume

    DECLARE_CLASS(ATestSplittingVolume,AVolume,0,Engine)
    virtual UObject* GetUObjectInterfaceInterface_NavMeshPathObject(){return this;}
			/**
	 * this function describes a 'cookie cutter' edge that will be used to split the mesh beneath it
	 * for example if you have a cost inflicting volume that needs to conform the mesh to itself
	 * you could return an array of verts along the bottom boundary of the volume, and a height up to the top of the volume
	 * and then you have poly boundaries exactly along the border of the volume with which you can add 
	 * edges which affect cost
	 * @param Poly - array of vectors that describe bottom of 'cookie cutter' volume (should be CW and convex)
	 * @param PolyHeight - height above the poly within which polys should be split (extrude passed poly up by this amount and use faces for clip)
	 * @return - TRUE if this shape should be used to split the mesh FALSE if no splitting is necessary
	 */
	virtual UBOOL GetMeshSplittingPoly( TArray<FVector>& out_PolyShape, FLOAT& PolyHeight );
};

struct AIController_eventSetTeam_Parms
{
    INT inTeamIdx;
    AIController_eventSetTeam_Parms(EEventParm)
    {
    }
};
class AAIController : public AController
{
public:
    //## BEGIN PROPS AIController
    BITFIELD bAdjustFromWalls:1;
    BITFIELD bReverseScriptedRoute:1;
    FLOAT Skill;
    class AActor* ScriptedMoveTarget;
    class ARoute* ScriptedRoute;
    INT ScriptedRouteIndex;
    class AActor* ScriptedFocus;
    //## END PROPS AIController

    void eventSetTeam(INT inTeamIdx)
    {
        AIController_eventSetTeam_Parms Parms(EC_EventParm);
        Parms.inTeamIdx=inTeamIdx;
        ProcessEvent(FindFunctionChecked(ENGINE_SetTeam),&Parms);
    }
    DECLARE_CLASS(AAIController,AController,0,Engine)
	INT AcceptNearbyPath(AActor *goal);
	void AdjustFromWall(FVector HitNormal, AActor* HitActor);
	virtual void SetAdjustLocation(FVector NewLoc,UBOOL bAdjust,UBOOL bOffsetFromBase=FALSE);
	virtual FVector DesiredDirection();
	
	/** Called when the AIController is destroyed via script */
	virtual void PostScriptDestroyed();
};

struct CrowdAgentBase_eventNotifyPathChanged_Parms
{
    CrowdAgentBase_eventNotifyPathChanged_Parms(EEventParm)
    {
    }
};
class ACrowdAgentBase : public AActor, public IInterface_NavigationHandle
{
public:
    //## BEGIN PROPS CrowdAgentBase
    //## END PROPS CrowdAgentBase

    void eventNotifyPathChanged()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_NotifyPathChanged),NULL);
    }
    DECLARE_ABSTRACT_CLASS(ACrowdAgentBase,AActor,0,Engine)
    virtual UObject* GetUObjectInterfaceInterface_NavigationHandle(){return this;}
	virtual UBOOL	CanCoverSlip(ACoverLink* Link, INT SlotIdx)	{ return FALSE; }

	/**
	 * returns the offset from the edge move point this entity should move toward (e.g. how high off the ground we should move to)
	 * @param Edge - the edge we're moving to
	 * @return - the offset to use
	 */
	virtual FVector GetEdgeZAdjust(FNavMeshEdgeBase* Edge)
	{
		return FVector(0.f,0.f,1.f);		
	}

	virtual void SetupPathfindingParams( FNavMeshPathParams& out_ParamCache );
	virtual void InitForPathfinding() {}
	virtual INT ExtraEdgeCostToAddWhenActive(FNavMeshEdgeBase* Edge) { return 0; }
};

class ACrowdPopulationManagerBase : public AActor
{
public:
    //## BEGIN PROPS CrowdPopulationManagerBase
    //## END PROPS CrowdPopulationManagerBase

    DECLARE_ABSTRACT_CLASS(ACrowdPopulationManagerBase,AActor,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(ACrowdPopulationManagerBase)
};

class APathTargetPoint : public AKeypoint
{
public:
    //## BEGIN PROPS PathTargetPoint
    //## END PROPS PathTargetPoint

    virtual UBOOL ShouldBeHiddenBySHOW_NavigationNodes();
    DECLARE_CLASS(APathTargetPoint,AKeypoint,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(APathTargetPoint)
};

struct NavMeshObstacle_eventGetObstacleBoudingShape_Parms
{
    TArray<FVector> Shape;
    UBOOL ReturnValue;
    NavMeshObstacle_eventGetObstacleBoudingShape_Parms(EEventParm)
    {
    }
};
class ANavMeshObstacle : public AActor, public IInterface_NavMeshPathObstacle
{
public:
    //## BEGIN PROPS NavMeshObstacle
    BITFIELD bEnabled:1;
    BITFIELD bPreserveInternalGeo:1;
    SCRIPT_ALIGN;
    //## END PROPS NavMeshObstacle

    virtual void RegisterObstacle();
    virtual void UnRegisterObstacle();
    DECLARE_FUNCTION(execRegisterObstacle)
    {
        P_FINISH;
        this->RegisterObstacle();
    }
    DECLARE_FUNCTION(execUnRegisterObstacle)
    {
        P_FINISH;
        this->UnRegisterObstacle();
    }
    UBOOL eventGetObstacleBoudingShape(TArray<FVector>& Shape)
    {
        NavMeshObstacle_eventGetObstacleBoudingShape_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.Shape=Shape;
        ProcessEvent(FindFunctionChecked(ENGINE_GetObstacleBoudingShape),&Parms);
        Shape=Parms.Shape;
        return Parms.ReturnValue;
    }
    DECLARE_CLASS(ANavMeshObstacle,AActor,0,Engine)
    virtual UObject* GetUObjectInterfaceInterface_NavMeshPathObstacle(){return this;}
	/**
	 * this function should populate out_polyshape with a list of verts which describe this object's 
	 * convex bounding shape
	 * @param out_PolyShape - output array which holds the vertex buffer for this obstacle's bounding polyshape
	 * @return TRUE if this object should block things right now (FALSE means this obstacle shouldn't affect the mesh)
	 */
	virtual UBOOL GetBoundingShape(TArray<FVector>& out_PolyShape,INT ShapeIdx);

	/**
	 * when TRUE polys internal to this obstacle will be preserved, but still split. (useful for things like cost volumes that 
	 * need to adjust cost but not completely destroy parts of the mesh
	 * @return TRUE if polys should be preserved internal to this obstacle
	 */
	virtual UBOOL PreserveInternalPolys() { return bPreserveInternalGeo; }

	/**
	 * For debugging.  Verifies that this pathobject is still alive and well and not orphaned or deleted
	 * @return - TRUE If this path object is in good working order
	 */
	virtual UBOOL VerifyObstacle()
	{
		return !IsPendingKill();
	}

};

class APylonSeed : public AActor, public IInterface_NavMeshPathObject
{
public:
    //## BEGIN PROPS PylonSeed
    //## END PROPS PylonSeed

    DECLARE_CLASS(APylonSeed,AActor,0,Engine)
    virtual UObject* GetUObjectInterfaceInterface_NavMeshPathObject(){return this;}
	virtual UBOOL Supports( const FNavMeshPathParams& PathParams,
							FNavMeshPolyBase* CurPoly,
							FNavMeshPathObjectEdge* Edge,
							FNavMeshEdgeBase* PredecessorEdge)
	{
		return FALSE;
	}

	virtual void AddAuxSeedPoints( APylon* Py )
	{
		if (Py != NULL && Py->IsPtWithinExpansionBounds(Location,50.f))
		{
			Py->NextPassSeedList.AddItem(Location);
		}
	}
};

class UCoverGroupRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS CoverGroupRenderingComponent
    //## END PROPS CoverGroupRenderingComponent

    DECLARE_CLASS(UCoverGroupRenderingComponent,UPrimitiveComponent,0,Engine)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
	virtual UBOOL ShouldRecreateProxyOnUpdateTransform() const;
};

struct FCoverMeshes
{
    class UStaticMesh* Base;
    class UStaticMesh* LeanLeft;
    class UStaticMesh* LeanRight;
    class UStaticMesh* LeanLeftPref;
    class UStaticMesh* LeanRightPref;
    class UStaticMesh* Climb;
    class UStaticMesh* Mantle;
    class UStaticMesh* SlipLeft;
    class UStaticMesh* SlipRight;
    class UStaticMesh* SwatLeft;
    class UStaticMesh* SwatRight;
    class UStaticMesh* PopUp;
    class UStaticMesh* PlayerOnly;

    /** Constructors */
    FCoverMeshes() {}
    FCoverMeshes(EEventParm)
    {
        appMemzero(this, sizeof(FCoverMeshes));
    }
};

class UCoverMeshComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS CoverMeshComponent
    TArrayNoInit<struct FCoverMeshes> Meshes;
    FVector LocationOffset;
    class UStaticMesh* AutoAdjustOn;
    class UStaticMesh* AutoAdjustOff;
    class UStaticMesh* Disabled;
    BITFIELD bShowWhenNotSelected:1;
    SCRIPT_ALIGN;
    //## END PROPS CoverMeshComponent

    DECLARE_CLASS(UCoverMeshComponent,UStaticMeshComponent,0,Engine)
	void UpdateBounds();
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual UBOOL ShouldRecreateProxyOnUpdateTransform() const;
	virtual void UpdateMeshes() {};
};

class UNavMeshRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS NavMeshRenderingComponent
    //## END PROPS NavMeshRenderingComponent

    DECLARE_CLASS(UNavMeshRenderingComponent,UPrimitiveComponent,0,Engine)
	/**
	 * Creates a new scene proxy for the path rendering component.
	 * @return	Pointer to the FNavMeshRenderingSceneProxy
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	virtual void UpdateBounds();
};

class UPathRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS PathRenderingComponent
    //## END PROPS PathRenderingComponent

    DECLARE_CLASS(UPathRenderingComponent,UPrimitiveComponent,0,Engine)
	/**
	 * Creates a new scene proxy for the path rendering component.
	 * @return	Pointer to the FPathRenderingSceneProxy
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	virtual void UpdateBounds();
};

class URouteRenderingComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS RouteRenderingComponent
    //## END PROPS RouteRenderingComponent

    DECLARE_CLASS(URouteRenderingComponent,UPrimitiveComponent,0,Engine)
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
	virtual void UpdateBounds();
};

struct AICommandBase_eventGetUtility_Parms
{
    class AAIController* InAI;
    INT ReturnValue;
    AICommandBase_eventGetUtility_Parms(EEventParm)
    {
    }
};
class UAICommandBase : public UObject
{
public:
    //## BEGIN PROPS AICommandBase
    //## END PROPS AICommandBase

    INT eventGetUtility(class AAIController* InAI)
    {
        AICommandBase_eventGetUtility_Parms Parms(EC_EventParm);
        Parms.ReturnValue=0;
        Parms.InAI=InAI;
        ProcessEvent(FindFunctionChecked(ENGINE_GetUtility),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UAICommandBase,UObject,0,Engine)
    DECLARE_WITHIN(AAIController)
    NO_DEFAULT_CONSTRUCTOR(UAICommandBase)
};

class UAutoNavMeshPathObstacleUnregister : public UObject
{
public:
    //## BEGIN PROPS AutoNavMeshPathObstacleUnregister
    TScriptInterface<class IInterface_NavMeshPathObstacle> PathObstacleRef;
    //## END PROPS AutoNavMeshPathObstacleUnregister

    DECLARE_CLASS(UAutoNavMeshPathObstacleUnregister,UObject,0,Engine)
	virtual void BeginDestroy()
	{
		Super::BeginDestroy();
		if( PathObstacleRef.GetInterface() != NULL )
		{
			PathObstacleRef->UnregisterObstacleWithNavMesh();
		}
	}
};

class UInterface_NavMeshPathSwitch : public UInterface_NavMeshPathObject
{
public:
    DECLARE_ABSTRACT_CLASS(UInterface_NavMeshPathSwitch,UInterface_NavMeshPathObject,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterface_NavMeshPathSwitch)
};

class IInterface_NavMeshPathSwitch : public IInterface_NavMeshPathObject
{
protected:
	virtual ~IInterface_NavMeshPathSwitch() {}
public:
	typedef UInterface_NavMeshPathSwitch UClassType;
	virtual UObject* GetUObjectInterfaceInterface_NavMeshPathSwitch()=0;
    virtual UBOOL eventAIActivateSwitch(class AAIController* AI)=0;
	// cost slightly more then normal edges so other edges are preferred unless this one is needed
	virtual INT CostFor( const FNavMeshPathParams& PathParams, const FVector& PreviousPoint, FVector& out_PathEdgePoint, FNavMeshPathObjectEdge* Edge, FNavMeshPolyBase* SourcePoly );

	// call the switch's support function 
	virtual UBOOL Supports( const FNavMeshPathParams& PathParams,
							struct FNavMeshPolyBase* CurPoly,
							struct FNavMeshPathObjectEdge* Edge,
							struct FNavMeshEdgeBase* PredecessorEdge);

	// if bot is in the same poly as the trigger, go to the trigger itself
	virtual UBOOL GetEdgeDestination( const FNavMeshPathParams& PathParams,
										FLOAT EntityRadius,
										const FVector& InfluencePosition,
										const FVector& EntityPosition,
										FVector& out_EdgeDest,
										struct FNavMeshPathObjectEdge* Edge,
										UNavigationHandle* Handle);

	// overidden to activate the switch when the bot needs to 
	virtual UBOOL PrepareMoveThru( class IInterface_NavigationHandle* Interface,
									FVector& out_MovePt,
									struct FNavMeshPathObjectEdge* Edge );

	/**
	 * called to allow this PO to draw custom stuff for edges linked to it
	 * @param DRSP          - the sceneproxy we're drawing for
	 * @param DrawOffset    - offset from the actual location we should be drawing 
	 * @param Edge          - the edge we're drawing
	 * @return - whether this PO is doing custom drawing for the passed edge (FALSE indicates the default edge drawing functionality should be used)
	 */
	virtual UBOOL DrawEdge( FDebugRenderSceneProxy* DRSP, FColor C, FVector DrawOffset, FNavMeshPathObjectEdge* Edge );

	/**
	 * called after edge creation is complete for each pylon to allow this PO to add edges for itself
	 * @param Py - the pylon which we are creating edges for
	 */
	virtual void CreateEdgesForPathObject( APylon* Py );

	// returns the spot that an AI should run to to operate this switch
	virtual FVector GetDestination(FLOAT EntityRadius){return FVector(0.f);}

	// returns TRUE if the passed bot is able to operate this switch
	virtual UBOOL CanBotUseThisSwitch(AAIController* AI){return TRUE;}

	// returns TRUE if this switch is 'open' in that the fence/gate it controls is pathable right now
	virtual UBOOL IsSwitchOpen(){return TRUE;}

	// returns TRUE if this switch is linked (e.g. opens) the passed switchable pylon
	virtual UBOOL IsLinkedTo(AAISwitchablePylon* Py){return FALSE;}

	virtual INT GetNumLinkedPylons() const{return 0;}
	virtual class AAISwitchablePylon* GetLinkedPylonAtIdx(INT Idx){return NULL;}
};

class UInterface_PylonGeometryProvider : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UInterface_PylonGeometryProvider,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterface_PylonGeometryProvider)
};

class IInterface_PylonGeometryProvider
{
protected:
	virtual ~IInterface_PylonGeometryProvider() {}
public:
	typedef UInterface_PylonGeometryProvider UClassType;
	virtual UObject* GetUObjectInterfaceInterface_PylonGeometryProvider()=0;
	/**
	 * Exports all path colliding geometry within pylon's bounds
	 * @param Pylon - bounding pylon
	 * @param Verts - list of exported vertices 
	 * @param Faces - list of exported triangles, 3 indices to Verts array for each item
	 */
	virtual void GetPathCollidingGeometry(APylon* Pylon, TArray<FVector>& Verts, TArray<INT>& Faces) {};
};

class UInterface_RVO : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UInterface_RVO,UInterface,0|CLASS_Interface,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterface_RVO)
};

class IInterface_RVO
{
protected:
	virtual ~IInterface_RVO() {}
public:
	typedef UInterface_RVO UClassType;
	virtual UObject* GetUObjectInterfaceInterface_RVO()=0;
	virtual FLOAT   GetAvoidRadius()=0;
	virtual INT     GetInfluencePriority()=0;
	virtual UBOOL   IsActiveObstacle()=0;
	virtual FColor  GetDebugAgentColor()=0;

	FORCEINLINE AActor* GetActor() 
	{ 
		return Cast<AActor>(GetUObjectInterfaceInterface_RVO()); 
	}
	FORCEINLINE FVector GetLocation() 
	{ 
		return GetActor()->Location;
	}
	FORCEINLINE FVector GetVelocity() 
	{ 
		return GetActor()->Velocity;
	}

	virtual void GetVelocityObstacleStats( TArray<FVelocityObstacleStat>& out_Array, AActor* RelActor );
};

#define UCONST_NumBreadCrumbs 10
#define UCONST_NUM_PATHFINDING_PARAMS 9
#define UCONST_LINECHECK_GRANULARITY 768.f

struct FPolySegmentSpan
{
    FNavMeshPolyBase* Poly;
    FVector P1;
    FVector P2;

		explicit FPolySegmentSpan( struct FNavMeshPolyBase* inPoly, FVector inP1, FVector inP2 )
		{
			Poly = inPoly;
			P1 = inP1;
			P2 = inP2;
		}
	
};

struct FPathStore
{
    TArrayNoInit<FNavMeshEdgeBase*> EdgeList;

		FORCEINLINE FNavMeshEdgeBase*& operator()( INT i )
		{
			return EdgeList(i);
		}

		FORCEINLINE INT Num()
		{
			return EdgeList.Num();
		}

		FNavMeshEdgeBase*& Last( INT c=0 )
		{
			return EdgeList.Last(c);
		}

		FNavMeshEdgeBase*& Top()
		{
			return Last();
		}
	
};

struct FNavMeshPathParams
{
    IInterface_NavigationHandle* Interface;
    BITFIELD bCanMantle:1;
    BITFIELD bNeedsMantleValidityTest:1;
    BITFIELD bAbleToSearch:1;
    SCRIPT_ALIGN;
    FVector SearchExtent;
    FLOAT SearchLaneMultiplier;
    FVector SearchStart;
    FLOAT MaxDropHeight;
    FLOAT MinWalkableZ;
    FLOAT MaxHoverDistance;

    /** Constructors */
    FNavMeshPathParams() {}
    FNavMeshPathParams(EEventParm)
    {
        appMemzero(this, sizeof(FNavMeshPathParams));
    }
};

class UNavigationHandle : public UObject
{
public:
    //## BEGIN PROPS NavigationHandle
    class APylon* AnchorPylon;
    FNavMeshPolyBase* AnchorPoly;
    struct FPathStore PathCache;
    FNavMeshPolyBase* BestUnfinishedPathPoint;
    FNavMeshEdgeBase* CurrentEdge;
    FNavMeshPolyBase* SubGoal_DestPoly;
    struct FBasedPosition FinalDestination;
    BITFIELD bSkipRouteCacheUpdates:1;
    BITFIELD bUseORforEvaluateGoal:1;
    BITFIELD bDebugConstraintsAndGoalEvals:1;
    BITFIELD bUltraVerbosePathDebugging:1;
    BITFIELD bVisualPathDebugging:1;
    BITFIELD bDebug_Breadcrumbs:1;
    class UNavMeshPathConstraint* PathConstraintList;
    class UNavMeshPathGoalEvaluator* PathGoalList;
    struct FNavMeshPathParams CachedPathParams;
    BYTE LastPathError;
    FLOAT LastPathFailTime;
    FVector Breadcrumbs[10];
    INT BreadCrumbMostRecentIdx;
    FLOAT BreadCrumbDistanceInterval;
    //## END PROPS NavigationHandle

    virtual void CopyPathStoreToPathCache(const struct FPathStore& InStore);
    virtual void UpdateBreadCrumbs(FVector InLocation);
    virtual UBOOL GetNextBreadCrumb(FVector& out_BreadCrumbLoc);
    virtual void ClearConstraints();
    virtual void AddPathConstraint(class UNavMeshPathConstraint* Constraint);
    virtual void AddGoalEvaluator(class UNavMeshPathGoalEvaluator* Evaluator);
    virtual class APylon* BuildFromPylonAToPylonB(class APylon* A,class APylon* B);
    virtual UBOOL DoesPylonAHaveAPathToPylonB(class APylon* A,class APylon* B);
    virtual UBOOL PathCache_Empty();
    virtual FVector PathCache_GetGoalPoint();
    virtual UBOOL PathCache_RemoveIndex(INT InIdx,INT Count=1);
    virtual FVector GetBestUnfinishedPathPoint() const;
    virtual UBOOL FindPylon();
    class APylon* GetPylonFromPos(FVector Position);
    virtual UBOOL GetNextMoveLocation(FVector& out_MoveDest,FLOAT ArrivalDistance);
    virtual UBOOL SetFinalDestination(FVector FinalDest);
    virtual UBOOL ComputeValidFinalDestination(FVector& out_ComputedPosition);
    virtual UBOOL FindPath(class AActor** out_DestActor=NULL,INT* out_DestItem=NULL);
    virtual UBOOL SuggestMovePreparation(FVector& MovePt,class AController* C);
    UBOOL ObstacleLineCheck(FVector Start,FVector End,FVector Extent,FVector* out_HitLoc=NULL,FVector* out_HitNorm=NULL);
    UBOOL ObstaclePointCheck(FVector Pt,FVector Extent);
    virtual UBOOL LineCheck(FVector Start,FVector End,FVector Extent,FVector* out_HitLocation=NULL,FVector* out_HitNormal=NULL);
    virtual UBOOL PointCheck(FVector Pt,FVector Extent);
    virtual UBOOL PointReachable(FVector Point,FVector OverrideStartPoint=FVector(EC_EventParm),UBOOL bAllowHitsInEndCollisionBox=TRUE);
    virtual UBOOL ActorReachable(class AActor* A);
    virtual void DrawPathCache(FVector DrawOffset=FVector(EC_EventParm),UBOOL bPersistent=FALSE,FColor DrawColor=FColor(EC_EventParm));
    virtual void PrintPathCacheDebugText();
    virtual FString GetCurrentEdgeDebugText();
    virtual void ClearCurrentEdge();
    virtual BYTE GetCurrentEdgeType();
    void GetAllPolyCentersWithinBounds(FVector pos,FVector Extent,TArray<FVector>& out_PolyCtrs);
    void GetValidPositionsForBox(FVector pos,FLOAT Radius,FVector Extent,UBOOL bMustBeReachableFromStartPos,TArray<FVector>& out_ValidPositions,INT MaxPositions=-1,FLOAT MinRadius=0,FVector ValidBoxAroundStartPos=FVector(0.000000,0.000000,0.000000));
    virtual void LimitPathCacheDistance(FLOAT MaxDist);
    virtual UBOOL IsAnchorInescapable();
    virtual FVector GetFirstMoveLocation();
    virtual FLOAT CalculatePathDistance(FVector FinalDest=FVector(EC_EventParm));
    virtual void CopyMovePointsFromPathCache(FVector FinalDest,TArray<FVector>& out_MovePoints);
    FVector MoveToDesiredHeightAboveMesh(FVector Point,FLOAT Height);
    UBOOL PopulatePathfindingParamCache();
    UBOOL GetAllCoverSlotsInRadius(FVector FromLoc,FLOAT Radius,TArray<struct FCoverInfo>& out_CoverList);
    UBOOL GetValidatedAnchorPosition(FVector& out_NewAnchorLoc,FVector OverrideStartLoc=FVector(EC_EventParm));
    UBOOL StaticGetValidatedAnchorPosition(FVector& out_NewAnchorLoc,FVector StartCheckBaseLocation,FVector Extent);
    DECLARE_FUNCTION(execCopyPathStoreToPathCache)
    {
        P_GET_STRUCT_REF(struct FPathStore,InStore);
        P_FINISH;
        this->CopyPathStoreToPathCache(InStore);
    }
    DECLARE_FUNCTION(execUpdateBreadCrumbs)
    {
        P_GET_STRUCT(FVector,InLocation);
        P_FINISH;
        this->UpdateBreadCrumbs(InLocation);
    }
    DECLARE_FUNCTION(execGetNextBreadCrumb)
    {
        P_GET_STRUCT_REF(FVector,out_BreadCrumbLoc);
        P_FINISH;
        *(UBOOL*)Result=this->GetNextBreadCrumb(out_BreadCrumbLoc);
    }
    DECLARE_FUNCTION(execClearConstraints)
    {
        P_FINISH;
        this->ClearConstraints();
    }
    DECLARE_FUNCTION(execAddPathConstraint)
    {
        P_GET_OBJECT(UNavMeshPathConstraint,Constraint);
        P_FINISH;
        this->AddPathConstraint(Constraint);
    }
    DECLARE_FUNCTION(execAddGoalEvaluator)
    {
        P_GET_OBJECT(UNavMeshPathGoalEvaluator,Evaluator);
        P_FINISH;
        this->AddGoalEvaluator(Evaluator);
    }
    DECLARE_FUNCTION(execBuildFromPylonAToPylonB)
    {
        P_GET_OBJECT(APylon,A);
        P_GET_OBJECT(APylon,B);
        P_FINISH;
        *(class APylon**)Result=this->BuildFromPylonAToPylonB(A,B);
    }
    DECLARE_FUNCTION(execDoesPylonAHaveAPathToPylonB)
    {
        P_GET_OBJECT(APylon,A);
        P_GET_OBJECT(APylon,B);
        P_FINISH;
        *(UBOOL*)Result=this->DoesPylonAHaveAPathToPylonB(A,B);
    }
    DECLARE_FUNCTION(execPathCache_Empty)
    {
        P_FINISH;
        *(UBOOL*)Result=this->PathCache_Empty();
    }
    DECLARE_FUNCTION(execPathCache_GetGoalPoint)
    {
        P_FINISH;
        *(FVector*)Result=this->PathCache_GetGoalPoint();
    }
    DECLARE_FUNCTION(execPathCache_RemoveIndex)
    {
        P_GET_INT(InIdx);
        P_GET_INT_OPTX(Count,1);
        P_FINISH;
        *(UBOOL*)Result=this->PathCache_RemoveIndex(InIdx,Count);
    }
    DECLARE_FUNCTION(execGetBestUnfinishedPathPoint)
    {
        P_FINISH;
        *(FVector*)Result=this->GetBestUnfinishedPathPoint();
    }
    DECLARE_FUNCTION(execFindPylon)
    {
        P_FINISH;
        *(UBOOL*)Result=this->FindPylon();
    }
    DECLARE_FUNCTION(execGetPylonFromPos)
    {
        P_GET_STRUCT(FVector,Position);
        P_FINISH;
        *(class APylon**)Result=this->GetPylonFromPos(Position);
    }
    DECLARE_FUNCTION(execGetNextMoveLocation)
    {
        P_GET_STRUCT_REF(FVector,out_MoveDest);
        P_GET_FLOAT(ArrivalDistance);
        P_FINISH;
        *(UBOOL*)Result=this->GetNextMoveLocation(out_MoveDest,ArrivalDistance);
    }
    DECLARE_FUNCTION(execSetFinalDestination)
    {
        P_GET_STRUCT(FVector,FinalDest);
        P_FINISH;
        *(UBOOL*)Result=this->SetFinalDestination(FinalDest);
    }
    DECLARE_FUNCTION(execComputeValidFinalDestination)
    {
        P_GET_STRUCT_REF(FVector,out_ComputedPosition);
        P_FINISH;
        *(UBOOL*)Result=this->ComputeValidFinalDestination(out_ComputedPosition);
    }
    DECLARE_FUNCTION(execFindPath)
    {
        P_GET_OBJECT_OPTX_REF(AActor,out_DestActor,NULL);
        P_GET_INT_OPTX_REF(out_DestItem,0);
        P_FINISH;
        *(UBOOL*)Result=this->FindPath(pout_DestActor ? &out_DestActor : NULL,pout_DestItem ? &out_DestItem : NULL);
    }
    DECLARE_FUNCTION(execSuggestMovePreparation)
    {
        P_GET_STRUCT_REF(FVector,MovePt);
        P_GET_OBJECT(AController,C);
        P_FINISH;
        *(UBOOL*)Result=this->SuggestMovePreparation(MovePt,C);
    }
    DECLARE_FUNCTION(execObstacleLineCheck)
    {
        P_GET_STRUCT(FVector,Start);
        P_GET_STRUCT(FVector,End);
        P_GET_STRUCT(FVector,Extent);
        P_GET_STRUCT_OPTX_REF(FVector,out_HitLoc,FVector(EC_EventParm));
        P_GET_STRUCT_OPTX_REF(FVector,out_HitNorm,FVector(EC_EventParm));
        P_FINISH;
        *(UBOOL*)Result=this->ObstacleLineCheck(Start,End,Extent,pout_HitLoc ? &out_HitLoc : NULL,pout_HitNorm ? &out_HitNorm : NULL);
    }
    DECLARE_FUNCTION(execObstaclePointCheck)
    {
        P_GET_STRUCT(FVector,Pt);
        P_GET_STRUCT(FVector,Extent);
        P_FINISH;
        *(UBOOL*)Result=this->ObstaclePointCheck(Pt,Extent);
    }
    DECLARE_FUNCTION(execLineCheck)
    {
        P_GET_STRUCT(FVector,Start);
        P_GET_STRUCT(FVector,End);
        P_GET_STRUCT(FVector,Extent);
        P_GET_STRUCT_OPTX_REF(FVector,out_HitLocation,FVector(EC_EventParm));
        P_GET_STRUCT_OPTX_REF(FVector,out_HitNormal,FVector(EC_EventParm));
        P_FINISH;
        *(UBOOL*)Result=this->LineCheck(Start,End,Extent,pout_HitLocation ? &out_HitLocation : NULL,pout_HitNormal ? &out_HitNormal : NULL);
    }
    DECLARE_FUNCTION(execPointCheck)
    {
        P_GET_STRUCT(FVector,Pt);
        P_GET_STRUCT(FVector,Extent);
        P_FINISH;
        *(UBOOL*)Result=this->PointCheck(Pt,Extent);
    }
    DECLARE_FUNCTION(execPointReachable)
    {
        P_GET_STRUCT(FVector,Point);
        P_GET_STRUCT_OPTX(FVector,OverrideStartPoint,FVector(EC_EventParm));
        P_GET_UBOOL_OPTX(bAllowHitsInEndCollisionBox,TRUE);
        P_FINISH;
        *(UBOOL*)Result=this->PointReachable(Point,OverrideStartPoint,bAllowHitsInEndCollisionBox);
    }
    DECLARE_FUNCTION(execActorReachable)
    {
        P_GET_OBJECT(AActor,A);
        P_FINISH;
        *(UBOOL*)Result=this->ActorReachable(A);
    }
    DECLARE_FUNCTION(execDrawPathCache)
    {
        P_GET_STRUCT_OPTX(FVector,DrawOffset,FVector(EC_EventParm));
        P_GET_UBOOL_OPTX(bPersistent,FALSE);
        P_GET_STRUCT_OPTX(FColor,DrawColor,FColor(EC_EventParm));
        P_FINISH;
        this->DrawPathCache(DrawOffset,bPersistent,DrawColor);
    }
    DECLARE_FUNCTION(execPrintPathCacheDebugText)
    {
        P_FINISH;
        this->PrintPathCacheDebugText();
    }
    DECLARE_FUNCTION(execGetCurrentEdgeDebugText)
    {
        P_FINISH;
        *(FString*)Result=this->GetCurrentEdgeDebugText();
    }
    DECLARE_FUNCTION(execClearCurrentEdge)
    {
        P_FINISH;
        this->ClearCurrentEdge();
    }
    DECLARE_FUNCTION(execGetCurrentEdgeType)
    {
        P_FINISH;
        *(BYTE*)Result=this->GetCurrentEdgeType();
    }
    DECLARE_FUNCTION(execGetAllPolyCentersWithinBounds)
    {
        P_GET_STRUCT(FVector,pos);
        P_GET_STRUCT(FVector,Extent);
        P_GET_TARRAY_REF(FVector,out_PolyCtrs);
        P_FINISH;
        this->GetAllPolyCentersWithinBounds(pos,Extent,out_PolyCtrs);
    }
    DECLARE_FUNCTION(execGetValidPositionsForBox)
    {
        P_GET_STRUCT(FVector,pos);
        P_GET_FLOAT(Radius);
        P_GET_STRUCT(FVector,Extent);
        P_GET_UBOOL(bMustBeReachableFromStartPos);
        P_GET_TARRAY_REF(FVector,out_ValidPositions);
        P_GET_INT_OPTX(MaxPositions,-1);
        P_GET_FLOAT_OPTX(MinRadius,0);
        P_GET_STRUCT_OPTX(FVector,ValidBoxAroundStartPos,FVector(0.000000,0.000000,0.000000));
        P_FINISH;
        this->GetValidPositionsForBox(pos,Radius,Extent,bMustBeReachableFromStartPos,out_ValidPositions,MaxPositions,MinRadius,ValidBoxAroundStartPos);
    }
    DECLARE_FUNCTION(execLimitPathCacheDistance)
    {
        P_GET_FLOAT(MaxDist);
        P_FINISH;
        this->LimitPathCacheDistance(MaxDist);
    }
    DECLARE_FUNCTION(execIsAnchorInescapable)
    {
        P_FINISH;
        *(UBOOL*)Result=this->IsAnchorInescapable();
    }
    DECLARE_FUNCTION(execGetFirstMoveLocation)
    {
        P_FINISH;
        *(FVector*)Result=this->GetFirstMoveLocation();
    }
    DECLARE_FUNCTION(execCalculatePathDistance)
    {
        P_GET_STRUCT_OPTX(FVector,FinalDest,FVector(EC_EventParm));
        P_FINISH;
        *(FLOAT*)Result=this->CalculatePathDistance(FinalDest);
    }
    DECLARE_FUNCTION(execCopyMovePointsFromPathCache)
    {
        P_GET_STRUCT(FVector,FinalDest);
        P_GET_TARRAY_REF(FVector,out_MovePoints);
        P_FINISH;
        this->CopyMovePointsFromPathCache(FinalDest,out_MovePoints);
    }
    DECLARE_FUNCTION(execMoveToDesiredHeightAboveMesh)
    {
        P_GET_STRUCT(FVector,Point);
        P_GET_FLOAT(Height);
        P_FINISH;
        *(FVector*)Result=this->MoveToDesiredHeightAboveMesh(Point,Height);
    }
    DECLARE_FUNCTION(execPopulatePathfindingParamCache)
    {
        P_FINISH;
        *(UBOOL*)Result=this->PopulatePathfindingParamCache();
    }
    DECLARE_FUNCTION(execGetAllCoverSlotsInRadius)
    {
        P_GET_STRUCT(FVector,FromLoc);
        P_GET_FLOAT(Radius);
        P_GET_TARRAY_REF(struct FCoverInfo,out_CoverList);
        P_FINISH;
        *(UBOOL*)Result=this->GetAllCoverSlotsInRadius(FromLoc,Radius,out_CoverList);
    }
    DECLARE_FUNCTION(execGetValidatedAnchorPosition)
    {
        P_GET_STRUCT_REF(FVector,out_NewAnchorLoc);
        P_GET_STRUCT_OPTX(FVector,OverrideStartLoc,FVector(EC_EventParm));
        P_FINISH;
        *(UBOOL*)Result=this->GetValidatedAnchorPosition(out_NewAnchorLoc,OverrideStartLoc);
    }
    DECLARE_FUNCTION(execStaticGetValidatedAnchorPosition)
    {
        P_GET_STRUCT_REF(FVector,out_NewAnchorLoc);
        P_GET_STRUCT(FVector,StartCheckBaseLocation);
        P_GET_STRUCT(FVector,Extent);
        P_FINISH;
        *(UBOOL*)Result=this->StaticGetValidatedAnchorPosition(out_NewAnchorLoc,StartCheckBaseLocation,Extent);
    }
    DECLARE_CLASS(UNavigationHandle,UObject,0,Engine)
    DECLARE_WITHIN(AActor)
public:
	UNavigationHandle()
	{
		if(!IsTemplate())
		{
			FNavMeshWorld::RegisterActiveHandle(this);
		}
	}
	// use this in SetupPathingParams and pass the number of params you have populated to ensure when new properties
	// are added to the struct that you are setting them all
	#define VERIFY_NAVMESH_PARAMS(NUM) \
		typedef char ERROR_Missing_NavMesh_param_please_Set_all_Params[( NUM != UCONST_NUM_PATHFINDING_PARAMS ) ? 0 : 1];

	// returns TRUE if the pylon and poly associated with the interface's current location can be found
	static UBOOL GetPylonAndPolyFromActorPos( AActor* Actor, APylon*& out_Pylon, struct FNavMeshPolyBase*& out_Poly);



	/**
	 * GetPylonANdPolyFromPos
	 * - will search for the pylon and polygon that contain this point
	 * @param Pos - position to get pylon and poly from
	 * @param out_Pylon - output var for pylon this position is within
	 * @param out_Poly - output var for poly this position is within
	 * @param PylonsToConsider - only check these pylons (useful for perf)
	 * @return - TRUE if the pylon and poly were found succesfully
	 */
	static UBOOL GetPylonAndPolyFromPos(const FVector& Pos, FLOAT MinWalkableFloorZ, APylon*& out_Pylon, struct FNavMeshPolyBase*& out_Poly, TArray<APylon*>* PylonsToConsider=NULL);
	/**
	 * GetAllPylonsFromPos
	 * - will populate a list of all pylons which are valid (in terms of can a pawn walk from the possible pylon) for the given position
	 * @param Pos - position to test
	 * @param out_Pylons - list of pylons to be populated with results
	 * @param bWalkable - whether or not this pylon's polys need to be "walkable"  FALSE for looking for disconnected pylons
	 * @return TRUE if any pylons were found
	 */
	static UBOOL GetAllPylonsFromPos(const FVector& Pos, const FVector& Extent, TArray<APylon*>& out_Pylons, UBOOL bWalkable = TRUE );

	/**
	 * GetPylonAndPolyFromBox
	 * - will search for the pylon and polygon that contain this box
	 * @param Box - the box to use to find a poly for
	 * @param out_Pylon - output var for pylon this position is within
	 * @param out_Poly - output var for poly this position is within
	 * @return - TRUE if the pylon and poly were found succesfully
	 */
	static UBOOL GetPylonAndPolyFromBox(const FBox& Box, FLOAT MinWalkableZ, APylon*& out_Pylon, struct FNavMeshPolyBase*& out_Poly);


	/**
	 * GetAnchorPoly
	 * - will find a suitable anchor (start) poly for this handle
	 * @return - the suitable poly (if any)
	 */
	FNavMeshPolyBase* GetAnchorPoly();

	/**
	 * GetAllPolysFromPos
	 * will return all polys in any mesh which are within the passed extent
	 * @param Pos - Center of extent to check
	 * @param Extent - extent of box to check
	 * @param out_PolyList - output array of polys to check
	 * @param bIgnoreDynamic - if TRUE, dynamically created submeshes will be ignored
	 * @param bReturnBothDynamicAndStatic - if TRUE, BOTH dynamic and static polys will be returned.. using this is *DANGEROUS*! most of the time you should use dynamic polys if they exist
	 *                                      as they are the 'correct' representation of the mesh at that point
	 * @param PylonsToConsider - list of pylons to consider for this check, defauls to doing an octree check to determine this list
	 * @param TraceFlags - flags for trace dilineation
	 * @return TRUE if polys were found
	 */
	static UBOOL GetAllPolysFromPos( const FVector& Pos, const FVector& Extent, TArray<struct FNavMeshPolyBase*>& out_PolyList, UBOOL bIgnoreDynamic, UBOOL bReturnBothDynamicAndStatic=FALSE, TArray<APylon*>* PylonsToConsider=NULL, DWORD TraceFlags=0);

	/**
	 * GetAllObstaclePolysFromPos
	 * will return all obstacle polys in any mesh which are within the passed extent
	 * @param Pos - Center of extent to check
	 * @param Extent - extent of box to check
	 * @param out_PolyList - output array of polys to check
	 * @param PylonsToCheck - OPTIONAL param indicating the lsit of pylons we should check instead of hitting the pylon octree
	 * @param bSkipDynamicObstacleMesh - OPTIONAL param, when true only static obstacle mesh polys will be returned
	 * @param TraceFlags - flags for trace dilineation
	 * @return TRUE if polys were found
	 */
												 
	static void GetAllObstaclePolysFromPos( const FVector& Pos,
											const FVector& Extent,
											TArray<struct FNavMeshPolyBase*>& out_PolyList,
											const TArray<APylon*>* PylonsToCheck=NULL,
											UBOOL bSkipDynamicObstacleMesh=FALSE, 
											DWORD TraceFlags=0);

	// returns TRUE if the AABB provided intersects a loaded portion of the mesh
	static UBOOL BoxIntersectsMesh( const FVector& Center, const FVector& Extent, APylon*& out_Pylon, struct FNavMeshPolyBase*& out_Poly, DWORD TraceFlags=0);

	/**
	 * returns TRUE if the poly described by the passed list of vectors intersects a loaded portion of the mesh
	 * @param Poly - vertexlist representing the poly we want to query against the mesh
	 * @param out_Pylon - pylon we collided with
	 * @param out_Poly - poly we collided with
	 * @arapm ExclusionPolys - optional list of polys we want to exclude from the search
	 * @param bIgnoreImportedMeshes - when TRUE meshes which unwalkable surfaces will be ignored for overlap testing
	 * @param IgnorePylons - optional pylons to ignore collisions from
	 * @return TRUE if poly intersects
	 */
	static UBOOL PolyIntersectsMesh( TArray<FVector>& Poly, APylon*& out_Pylon, struct FNavMeshPolyBase*& out_Poly, TArray<FNavMeshPolyBase*>* ExclusionPolys=NULL, UBOOL bIgnoreImportedMeshes=FALSE, TArray<APylon*>* IgnorePylons=NULL, DWORD TraceFlags=0);

	// queries the pylon octree and returns a list of pylons that intersect the given AABB
	static void GetIntersectingPylons(const FVector& Loc, const FVector& Extent, TArray<APylon*>& out_Pylons,class AActor* SrcActor=NULL);

	/**
	 * Given a line segment, walks along the segment returning all polys that it crosses as entry and exit points of that segment
	 * (will find spans from any navmesh in the world)
	 * @param Start - Start point of span to check
	 * @param End - end point of span
	 * @Param out_Spans - out array of spans found and the polys they link to
	 */
	static void GetPolySegmentSpanList( FVector& Start, FVector& End, TArray<struct FPolySegmentSpan>& out_Spans );

	/**
	 *  static function that will do an obstacle line check against any pylon's meshes colliding with the line passed
	 *  @param InOuter - The Outer which owns this NavHandle.  Can be used for debugging
	 *  @param Hit - Hitresult struct for line check
	 *  @param Start - start of line check
	 *  @param End - end of line check
	 *  @param Extent - extent of box to sweep
	 *  @param bIgnoreNormalMesh - OPTIONAL - default:FALSE - when TRUE no checks against the walkable mesh will be performed
	 *  @param out_HitPoly - optional output param stuffed with the poly we collided with (if any)
	 *  @param PylonsToCheck - OPTIONAL, if present only these pylons' meshes will be linecheck'd
	 *  @param TraceFlags - bitfield to control tracing options
	 *  @return TRUE if nothing hit
	 */
	static UBOOL StaticObstacleLineCheck( const UObject* const InOuter,
												 FCheckResult& Hit,
												 FVector Start,
												 FVector End,
												 FVector Extent,
												 UBOOL bIgnoreNormalMesh=FALSE,
												 FNavMeshPolyBase** out_HitPoly=NULL,
												 const TArray<APylon*>* PylonsToCheck=NULL,
												 DWORD TraceFlags=0);

	/**
	 * static function that will do a point check agains the obstacle mesh
	 * @param Hit - hitresult struct for point check
	 * @param Pt - centroid of extent box to point check
	 * @param Extent - extent of box to point check
	 * @param out_HitPoly - optional output param stuffed with the poly we collided with (if any)
	 * @param PylonsToCheck - OPTIONAL, if present only these pylons' meshes will be linecheck'd
	 * @param bSkipPointInMeshCheck - OPTIONAL, if TRUE ONLY a pointcheck against the obstacle mesh will be done, no verification that the point is on the mesh somewhere will be done (be careful with this one!)
	 * @return TRUE if nothing hit
	 */
	static UBOOL StaticObstaclePointCheck(FCheckResult& Hit,FVector Pt,FVector Extent, FNavMeshPolyBase** out_HitPoly=NULL, const TArray<APylon*>* PylonsToCheck=NULL, UBOOL bSkipPointInMeshCheck=FALSE, DWORD TraceFlags=0);

    /**
	 *  static function that will do a line check against any pylon's (walkable) meshes colliding with the line passed
	 *  @param Hit - Hitresult struct for line check
	 *  @param Start - start of line check
	 *  @param End - end of line check
	 *  @param Extent - extent of box to sweep
	 *  @param out_HitPoly - OPTIONAL, output param for hit poly
	 *  @param PylonsToCheck - OPTIONAL, if present only these pylons' meshes will be linecheck'd
	 *  @param TraceFlags - bitfield to control tracing options
	 *  @return TRUE if nothing hit
	 */
	static UBOOL StaticLineCheck(FCheckResult& Hit, FVector Start,FVector End,FVector Extent, FNavMeshPolyBase** out_HitPoly=NULL, const TArray<APylon*>* PylonsToCheck=NULL, DWORD TraceFlags=0);

	/**
	 * static function that will do a point check agains the walkable
	 * @param Hit - hitresult struct for point check
	 * @param Pt - centroid of extent box to point check
	 * @param Extent - extent of box to point check
	 * @param out_HitPoly - OPTIONAL, poly the pointcheck hit
	 * @param PylonsToCheck - OPTIONAL, if present only these pylons' meshes will be linecheck'd
	 * @return TRUE of nothing hit
	 */
	static UBOOL StaticPointCheck(FCheckResult& Hit,FVector Pt,FVector Extent, FNavMeshPolyBase** out_HitPoly=NULL, const TArray<APylon*>* PylonsToCheck=NULL, DWORD TraceFlags=0);

	static APylon* StaticGetPylonFromPos( FVector Position );

	UBOOL PathCache_Empty( FPathStore* PCache );
	UBOOL PathCache_AddEdge( FNavMeshEdgeBase* Edge, FPathStore* PCache = NULL  );
	UBOOL PathCache_InsertEdge( FNavMeshEdgeBase* Edge, int Idx=0, FPathStore* PCache = NULL  );
	UBOOL PathCache_RemoveEdge( FNavMeshEdgeBase* Edge, FPathStore* PCache = NULL  );
	UBOOL PathCache_RemoveIndex( int InIdx, int Count, FPathStore* PCache );
	FVector PathCache_GetGoalPoint( FPathStore* PCache );

	// Pathing functions

	/**
	 * internal function which does the heavy lifting for A* searches (typically called from FindPath()
	 * @param out_DestActor - output param goal evals can set if a particular actor was the result of the search
	 * @param out_DestItem - output param goal evans can set if they need an index into something (e.g. cover slot)
	 * @return - TRUE If search found a goal
	 */
	virtual UBOOL GeneratePath( class AActor** out_DestActor, INT* out_DestItem );
	

	/** 
	 *  Adds successor edges from the given poly to the A* search
	 *  @param CurPoly - poly to add sucessor edges for
	 *  @param PathParams - path params being used to search currently
	 *  @param PredecessorEdge - edge we got to this poly from
	 *  @param PathSessionID - SessionID for this pathfind
	 *  @param OpenList - first edge on the open list
	 */
	void AddSuccessorEdgesForPoly(FNavMeshPolyBase* CurPoly,
								const FNavMeshPathParams& PathParams,
								FNavMeshEdgeBase* PredecessorEdge,
								INT PathSessionID,
								PathOpenList& OpenList,
								INT OverrideVisitedCost=-1,
								INT OverrideHeuristicCost=-1);

	/**
	 * finds the best node in the list, and pulls it out and returns it
	 * (assumes list is sorted)
	 * @param OpenList - list to find best node from
	 * @return the best node in the list 
	 */
	PathCardinalType PopBestNode( PathOpenList& OpenList );

	/**
	 * InsertSorted
	 * inserts the passed node into the passed list at the proper spot to maintain sort order
	 * @param NodeForInsertion - node to insert into the list
	 * @param OpenList - list ot insert into
	 * @return TRUE if succesful
	 */
	UBOOL InsertSorted( PathCardinalType NodeForInsertion, PathOpenList& OpenList );
	UBOOL AddNodeToOpen( PathOpenList& OpenList,
						PathCardinalType NodeToAdd,
						INT EdgeCost,
						INT HeuristicCost,
						PathCardinalType Predecessor,
						const FVector& PrevPos,
						FNavMeshPolyBase* DestinationPolyForEdge);
	void RemoveNodeFromOpen( PathCardinalType NodeToRemove, PathOpenList& OpenList );

	/** 
	 * will loop through all constraints in the constraint list and let them have their say on the current cost of the edge being considered
	 * @param Edge - the edge being considered
	 * @param SrcPoly - the poly we're coming from 
	 * @param DestPoly - the poly we're going to!
	 * @param EdgeCost - output param with current edge cost, and should be updated cost after this function is called
	 * @param HeuristicCost - output param with current heuristiccost, and should be updated heuristic cost (h) after this function is called
	 * @param EdgePoint - the point on the edge being used for cost calculations ( a good place to do heuristic weighting )
	 * @return TRUE if this edge is fit at all, FALSE if it should be skipped
	 */
	UBOOL ApplyConstraints( FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge, FNavMeshPolyBase* SrcPoly, FNavMeshPolyBase* DestPoly, INT& EdgeCost, INT& HeuristicCost, const FVector& EdgePoint );

	/**
	 * EvaluateGoal handles composition of goal evaluators, and will loop through the goaleval list
	 * calling EvaluateGoal on each one to determine if the possibleGoal is the node we're looking for
	 * @param PossibleGoal - the goal to be evaluated!
	 * @param out_GeneratedGoal - the poly that we have chosen as our successful goal (if any)
	 *                            @NOTE: this will be NULL'd if the collective goals say no to PossibleGOal
	 * @return TRUE if PossibleGoal is a valid node to stop on (search stops once this happens)
	 */
	UBOOL EvaluateGoal(  PathCardinalType PossibleGoal, PathCardinalType& out_GeneratedGoal );

	void ClearCrossLevelRefs(ULevel* Level);

	/**
	 * will clear all references to any navmeshes
	 */
	void ClearAllMeshRefs();

	/**
	 * PostEdgeCleanup
	 * this function is called after an edge has been cleaned up, but before it has been deleted. Whatever triggerd
	 * the edge deletion is finished, so it's safe to call other code that might affect the mesh
	 * @param Edge - the edge that is being cleaned up
	 */
	void PostEdgeCleanup(FNavMeshEdgeBase* Edge);

	// UObject Interface - overidden to clear pathcache on destruction
	virtual void BeginDestroy();

	/**
	 * will operate on the pathcache to generate a set of points to run through.. this is based on the edges in the path
	 * and a 'stringpull' method applied to the edges to find the best route through the edges
	 * @param Interface - the interface of the entity we're computing for
	 * @param PathIdx   - the index of the edge we are computing
	 * @param out_EdgePos - the output of the computation
	 * @param ArrivalDist - the radius around points which the entity will consider itself arrived (used to offset points to make sure the bot moves far enough forward)
	 * @param bConstrainedToCurrentEdge - skip compensating if the edge requires special movement, rely solely upon GetEdgeDestination()
	 * @param out_EdgePoints - optional pointer to an array to fill with all the computed edge movement points
	 */
	void ComputeOptimalEdgePosition(INT PathIdx, FVector& out_EdgePos, FLOAT ArrivalDistance, UBOOL bConstrainedToCurrentEdge = FALSE, TArray<FVector>* out_EdgePoints=NULL);

	/**
	 * This function will generate a move point which will get the bot into the next polygon
	 * by compensating for early-arrival if needed
	 * @param PathIdx - the index of the pathedge position we're trying to resolve (usually 0)
	 * @param out_movePosition - the position we determined to be best to move to (should be set with the current desired location to move to)
	 * @param NextMovePoitn    - the next move point in the path
	 * @param HandleExtent     - the extent of the handle we're resolving for
	 * @param CurHandlePos     - the current world position of the handle we're resolving for
	 * @param ArrivalDistance  - how close to a point we have ot be before moveto() will return
	 */
	void CompensateForEarlyArrivals(INT PathIdx, FVector& out_MovePosition, const FVector& NextMovePoint, const FVector& CurHandlePos, FLOAT ArrivalDistance);

	/**
	 * This function is called from GetNextMoveLocation when it is detected that the entity is not within its path
	 * and it tries to recover from this happening
	 * @param Interface - the handle interface that's walking this path
	 * @param SearchStart - the location of the entity searching (saves on interface vf calls)
	 * @param Extent	  - extent of the entity searching (saves on interface vf calls)
	 * @param ArrivalDistance - how clsoe to a point we have to get before moveto() will return
	 * @param out_Dest		- out_param dictating what our destination should be
	 * @return				- whether we were succesful in finding a valid point to move to
	 */
	UBOOL HandleNotOnPath(FLOAT ArrivalDistance, FVector& out_Dest );

	/**
	 * This function is called to give the Handle a chance to handled the adjustment instead of the controller fallback.
	 * @param HitNoraml - Normal of the wall at point of collision
	 * @param HitActor - Actor that we hit
	 * @return - TRUE if we handled the adjustment, FALSE means allow Outer (usually the AIController)
	 */
	UBOOL HandleWallAdjust( FVector HitNormal, AActor* HitActor );

	/**
	 * This function is called after an adjust to the wall is complete (usually from execPollMoveTo/ward)
	 * @return - TRUE if we handled the adjustment and no other move should occur, FALSE means allow regular movement to continue
	 */
	UBOOL HandleFinishedAdjustMove();

	/**
	 * This function is called by APawn::ReachedDestination and is used to coordinate when to stop moving to a point during
	 * path following (e.g. once we are inside the next poly, stop moving rather than trying to hit an exact point)
	 * @param Destination - destination we're trying to move to
	 * @param out_bReached - whether or not we have reached this destination
	 * @param HandleOuterActor - the actor which implements the navhandle interface for this test
	 * @param ArrivalTreshold  - the radius within which code elsewhere is going to be doing arrival checks, so we can match in this function without breaking parity
	 * @return - returns TRUE If this function was able to determien if we've arrived (FALSE means keep checking elsewhere)
	 */
	UBOOL ReachedDestination(const FVector& Destination, AActor* HandleOuterActor, FLOAT ArrivalThreshold, UBOOL& out_bReached);

	// don't let navmeshes whose edges we are reffing be deleted before we are
	void AddReferencedObjects( TArray<UObject*>& ObjectArray );
	void Serialize( FArchive& Ar );

	/**
	 * do an octree check and return all pylons whose bounds overlap the passed center/extent
	 * @param Ctr - center of box to check for overlap
	 * @param Extent - extent of box to check for overlap
	 * @param out_OverlappingPylons - out param stuffed with pylons
	 */
	static void GetAllOverlappingPylonsFromBox(const FVector& Ctr, const FVector& Extent, TArray<APylon*>& out_OverlappingPylons);

	/**
	 * called from PointReachable, and is recursive to split the cast into several that conform to the mesh
	 *  @param InOuter - The Outer which owns this NavHandle.  Can be used for debugging
	 *  @param Hit - Hitresult struct for line check
	 *  @param Start - start of line check
	 *  @param End - end of line check
	 *  @param Extent - extent of box to sweep
	 *  @param bIgnoreNormalMesh - OPTIONAL - default:FALSE - when TRUE no checks against the walkable mesh will be performed
	 *  @param out_HitPoly - optional output param stuffed with the poly we collided with (if any)
	 *  @param bComparePolyNormalZs - optional bool dictating whether this function should return a collision when any two polys found along
	 *                               the way have very different Normal.Z values
	 *  @param TraceFlags - bitfield to control tracing options
	 *  @return TRUE of nothing hit
	 */
	static UBOOL PointReachableLineCheck( const UObject* const InOuter,
								  FCheckResult& Hit,
								  FVector Start,
								  FVector End,
								  FVector Extent,
								  UBOOL bIgnoreNormalMesh=FALSE,
								  FNavMeshPolyBase** out_HitPoly=NULL,
								  UBOOL bComparePolyNormalZs=FALSE,
								  DWORD TraceFlags=0,
								  UINT StackDepth=0);
	/**
	 * called when a path is searched for and not found
	 * sets the lastpatherror and saves off the time of the failure
	 * @param ErrorType - the type of path error that just occurred 
	 */
	void SetPathError(EPathFindingError ErrorType);

	struct FFitNessFuncParams
	{
		FFitNessFuncParams( UNavigationHandle* InAskingHandle,
			const FVector& InStartPt,
			const FVector& InExtent,
			const FVector& InPoint,
			FNavMeshPolyBase* InPolyContainingPoint,
			const TArray<APylon*>* InPylonsWeCareAbout)
			:
		AskingHandle(InAskingHandle),
		StartPt(InStartPt),
		Extent(InExtent),
		Point(InPoint),
		PolyContainingPoint(InPolyContainingPoint),
		PylonsWeCareAbout(InPylonsWeCareAbout){}

		UNavigationHandle* AskingHandle;
		FVector StartPt;
		FVector Extent;
		FVector Point;
		FNavMeshPolyBase* PolyContainingPoint;
		const TArray<APylon*>* PylonsWeCareAbout;
	};
	// typedef for getvalidpositionsforbox acceptability function pointer
	typedef UBOOL (*ValidBoxPositionFunc)(const FFitNessFuncParams& Params);

	/**
	 * will return a list of valid spots on the mesh which fit the passed extent and are within radius to Pos
	 * @param Pos - Center of bounds to check for polys
	 * @param Radius - radius from Pos to find valid positions within
	 * @param Extent - Extent of entity we're finding a spot for
	 * @param bMustBeReachableFromStartPos - if TRUE, only positions which are directly reachable from the starting position will be returned
	 * @param ValidPositions - out var of valid positions for the passed entity size
	 * @param MaxPositions - the maximum positions needed (e.g. the search for valid positions will stop after this many have been found)
	 * @param MinRadius    - minimum distance from center position to potential spots (default 0)
	 * @param ValidBoxAroundStartPos - when bMustBeReachableFromStartPos is TRUE, all hits that are within this AABB of the start pos will be considered valid
	 * @param ValidBoxPositionFunc - function pointer which can be supplied to filter out potential points from the result list
	 */
	void GetValidPositionsForBoxEx(FVector pos,
		FLOAT Radius,
		FVector Extent,
		UBOOL bMustBeReachableFromStartPos,
		TArray<FVector>& out_ValidPositions,
		INT MaxPositions=-1,
		FLOAT MinRadius=0,
		FVector ValidBoxAroundStartPos=FVector(0.000000,0.000000,0.000000),
		ValidBoxPositionFunc FitnessFunction=NULL);

	// macros to support debuglog, should call these instead of debuglog directly so that it gets compiled out in release builds
	#if !DO_AI_LOGGING
	#define NAVHANDLE_DEBUG_LOG(TXT){}
	#else
	#define NAVHANDLE_DEBUG_LOG(TXT){\
		if(RUNTIME_DO_AI_LOGGING)\
		{\
			IInterface_NavigationHandle* Interface = InterfaceCast<IInterface_NavigationHandle>(GetOuter());\
			if(Interface != NULL)\
			{\
				Interface->DebugLogInternal(TXT);\
			}\
		}\
	}
	#endif
};

struct NavMeshGoal_Filter_eventGetDumpString_Parms
{
    FString ReturnValue;
    NavMeshGoal_Filter_eventGetDumpString_Parms(EEventParm)
    {
    }
};
class UNavMeshGoal_Filter : public UObject
{
public:
    //## BEGIN PROPS NavMeshGoal_Filter
    BITFIELD bShowDebug:1;
    INT NumNodesThrownOut;
    INT NumNodesProcessed;
    //## END PROPS NavMeshGoal_Filter

    FString eventGetDumpString()
    {
        NavMeshGoal_Filter_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UNavMeshGoal_Filter,UObject,0,Engine)
	/**
	 * Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'
	 * @param PossibleGoal - the chosen (cheapest) successor from the open list
	 * @param PathParams   - the cached pathfinding params for the pathing entity
	 * @return - TRUE indicates according to this filter's criteria this goal is valid
	 */
	virtual UBOOL IsValidFinalGoal( PathCardinalType PossibleGoal,
								const FNavMeshPathParams& PathParams){return FALSE;}

	/**
	 * Called on each filter in the GenericFilterContainer to verify that a particular node is valid to be added
	 * as a seed poly (default is to just call IsValidFinalGoal)
 	 * @param PossibleGoal - the chosen (cheapest) successor from the open list
	 * @param PathParams   - the cached pathfinding params for the pathing entity
	 * @return - TRUE indicates according to this filter's criteria this goal is valid
	 */
	virtual UBOOL IsValidSeed( FNavMeshPolyBase* PossibleGoal,
								const FNavMeshPathParams& PathParams){return TRUE;}
	 
};

class UNavMeshGoalFilter_MinPathDistance : public UNavMeshGoal_Filter
{
public:
    //## BEGIN PROPS NavMeshGoalFilter_MinPathDistance
    INT MinDistancePathShouldBe;
    //## END PROPS NavMeshGoalFilter_MinPathDistance

    DECLARE_CLASS(UNavMeshGoalFilter_MinPathDistance,UNavMeshGoal_Filter,0,Engine)
	// Interface
		/**
	 * Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'
	 * @param PossibleGoal - the chosen (cheapest) successor from the open list
	 * @param PathParams   - the cached pathfinding params for the pathing entity
	 * @return - TRUE indicates according to this filter's criteria this goal is valid
	 */
	virtual UBOOL IsValidFinalGoal( PathCardinalType PossibleGoal,
								const FNavMeshPathParams& PathParams);
};

class UNavMeshGoalFilter_NotNearOtherAI : public UNavMeshGoal_Filter
{
public:
    //## BEGIN PROPS NavMeshGoalFilter_NotNearOtherAI
    FLOAT DistanceToCheck;
    //## END PROPS NavMeshGoalFilter_NotNearOtherAI

    DECLARE_CLASS(UNavMeshGoalFilter_NotNearOtherAI,UNavMeshGoal_Filter,0,Engine)
	// Interface
		/**
	 * Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'
	 * @param PossibleGoal - the chosen (cheapest) successor from the open list
	 * @param PathParams   - the cached pathfinding params for the pathing entity
	 * @return - TRUE indicates according to this filter's criteria this goal is valid
	 */
	virtual UBOOL IsValidFinalGoal( PathCardinalType PossibleGoal,
								const FNavMeshPathParams& PathParams);
};

class UNavMeshGoalFilter_OutOfViewFrom : public UNavMeshGoal_Filter
{
public:
    //## BEGIN PROPS NavMeshGoalFilter_OutOfViewFrom
    FNavMeshPolyBase* GoalPoly;
    FVector OutOfViewLocation;
    //## END PROPS NavMeshGoalFilter_OutOfViewFrom

    DECLARE_CLASS(UNavMeshGoalFilter_OutOfViewFrom,UNavMeshGoal_Filter,0,Engine)
	// Interface
		/**
	 * Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'
	 * @param PossibleGoal - the chosen (cheapest) successor from the open list
	 * @param PathParams   - the cached pathfinding params for the pathing entity
	 * @return - TRUE indicates according to this filter's criteria this goal is valid
	 */
	virtual UBOOL IsValidFinalGoal( PathCardinalType PossibleGoal,
								const FNavMeshPathParams& PathParams);
};

class UNavMeshGoalFilter_OutSideOfDotProductWedge : public UNavMeshGoal_Filter
{
public:
    //## BEGIN PROPS NavMeshGoalFilter_OutSideOfDotProductWedge
    FVector Location;
    FVector Rotation;
    FLOAT Epsilon;
    //## END PROPS NavMeshGoalFilter_OutSideOfDotProductWedge

    DECLARE_CLASS(UNavMeshGoalFilter_OutSideOfDotProductWedge,UNavMeshGoal_Filter,0,Engine)
	// Interface
	/**
	 * Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'
	 * @param PossibleGoal - the chosen (cheapest) successor from the open list
	 * @param PathParams   - the cached pathfinding params for the pathing entity
	 * @return - TRUE indicates according to this filter's criteria this goal is valid
	 */
	virtual UBOOL IsValidFinalGoal( PathCardinalType PossibleGoal,
								const FNavMeshPathParams& PathParams);
};

class UNavMeshGoalFilter_PolyEncompassesAI : public UNavMeshGoal_Filter
{
public:
    //## BEGIN PROPS NavMeshGoalFilter_PolyEncompassesAI
    FVector OverrideExtentToCheck;
    //## END PROPS NavMeshGoalFilter_PolyEncompassesAI

    DECLARE_CLASS(UNavMeshGoalFilter_PolyEncompassesAI,UNavMeshGoal_Filter,0,Engine)
	// Interface
		/**
	 * Called on each Goal_Filter that is in the list of a generic filter container to determine a goal's fitness for being 'the one'
	 * @param PossibleGoal - the chosen (cheapest) successor from the open list
	 * @param PathParams   - the cached pathfinding params for the pathing entity
	 * @return - TRUE indicates according to this filter's criteria this goal is valid
	 */
	virtual UBOOL IsValidFinalGoal( PathCardinalType PossibleGoal,
								const FNavMeshPathParams& PathParams);
};

struct NavMeshPathConstraint_eventGetDumpString_Parms
{
    FString ReturnValue;
    NavMeshPathConstraint_eventGetDumpString_Parms(EEventParm)
    {
    }
};
struct NavMeshPathConstraint_eventRecycle_Parms
{
    NavMeshPathConstraint_eventRecycle_Parms(EEventParm)
    {
    }
};
class UNavMeshPathConstraint : public UObject
{
public:
    //## BEGIN PROPS NavMeshPathConstraint
    class UNavMeshPathConstraint* NextConstraint;
    INT NumNodesProcessed;
    INT NumThrownOutNodes;
    FLOAT AddedDirectCost;
    FLOAT AddedHeuristicCost;
    //## END PROPS NavMeshPathConstraint

    FString eventGetDumpString()
    {
        NavMeshPathConstraint_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    void eventRecycle()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Recycle),NULL);
    }
    DECLARE_CLASS(UNavMeshPathConstraint,UObject,0,Engine)
	/**
	 * EvaluatePath - this function is called for every A* successor edge.  This gives constraints a chance
	 * to both modify the heuristic cost (h), the computed actual cost (g), as well as deny use of this edge altogether
	 * @param Edge - the successor candidate edge
	 * @param PredecessorEdge - Edge we traversed from to reach `Edge` 
	 * @param SrcPoly - the poly we are expanding from (e.g. the poly from which we want to traverse the Edge)
	 * @param DestPoly - The poly we're trying to traverse to (from SrcPoly)
	 * @param PathParams - the cached pathing parameters of the pathing entity 
	 * @param out_PathCost - the computed path cost of this edge (the current value is supplied as input, and can be modified in this function) 
	 *                       (this constitutes G of the pathfinding heuristic function F=G+H)
	 * @param out_HeuristicCost - the heuristic cost to be applied to this edge (the current heuristic is supplied as input, and can be modified in this function)
	 *                          (this constitutes H of the pathfindign heuristic function F=G+H)
	 * @param EdgePoint - the point on the edge that was used for cost calculations, useful starting point if computing distance to something
	 * @return - TRUE if this edge is a valid successor candidate and should be added to the open list, FALSE if it should be thrown out
	 */
	virtual UBOOL EvaluatePath( FNavMeshEdgeBase* Edge,
								FNavMeshEdgeBase* PredecessorEdge,
								FNavMeshPolyBase* SrcPoly,
								FNavMeshPolyBase* DestPoly,
								const FNavMeshPathParams& PathParams,								
								INT& out_PathCost, INT& out_HeuristicCost,
								const FVector& EdgePoint );
};

class UNavMeshPath_AlongLine : public UNavMeshPathConstraint
{
public:
    //## BEGIN PROPS NavMeshPath_AlongLine
    FVector Direction;
    //## END PROPS NavMeshPath_AlongLine

    DECLARE_CLASS(UNavMeshPath_AlongLine,UNavMeshPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge, FNavMeshPolyBase* SrcPoly, FNavMeshPolyBase* DestPoly, const FNavMeshPathParams& PathParams, INT& out_PathCost, INT& out_HeuristicCost, const FVector& EdgePoint );
};

class UNavMeshPath_EnforceTwoWayEdges : public UNavMeshPathConstraint
{
public:
    //## BEGIN PROPS NavMeshPath_EnforceTwoWayEdges
    //## END PROPS NavMeshPath_EnforceTwoWayEdges

    DECLARE_CLASS(UNavMeshPath_EnforceTwoWayEdges,UNavMeshPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge, FNavMeshPolyBase* SrcPoly, FNavMeshPolyBase* DestPoly, const FNavMeshPathParams& PathParams, INT& out_PathCost, INT& out_HeuristicCost, const FVector& EdgePoint );
};

class UNavMeshPath_MinDistBetweenSpecsOfType : public UNavMeshPathConstraint
{
public:
    //## BEGIN PROPS NavMeshPath_MinDistBetweenSpecsOfType
    FLOAT MinDistBetweenEdgeTypes;
    FVector InitLocation;
    BYTE EdgeType;
    FLOAT Penalty;
    //## END PROPS NavMeshPath_MinDistBetweenSpecsOfType

    DECLARE_CLASS(UNavMeshPath_MinDistBetweenSpecsOfType,UNavMeshPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge, FNavMeshPolyBase* SrcPoly, FNavMeshPolyBase* DestPoly, const FNavMeshPathParams& PathParams, INT& out_PathCost, INT& out_HeuristicCost, const FVector& EdgePoint );
	UBOOL IsWithinMinDistOfEdgeInPath(FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge);
};

class UNavMeshPath_SameCoverLink : public UNavMeshPathConstraint
{
public:
    //## BEGIN PROPS NavMeshPath_SameCoverLink
    class ACoverLink* TestLink;
    //## END PROPS NavMeshPath_SameCoverLink

    DECLARE_CLASS(UNavMeshPath_SameCoverLink,UNavMeshPathConstraint,0,Engine)
	virtual UBOOL EvaluatePath( FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge, FNavMeshPolyBase* SrcPoly, FNavMeshPolyBase* DestPoly,
					const FNavMeshPathParams& PathParams, INT& out_PathCost, INT& out_HeuristicCost, const FVector& EdgePoint )
	{
		for (INT i = 0; i < DestPoly->PolyCover.Num(); i++)
		{
			if (*DestPoly->PolyCover(i) == TestLink)
			{
				return TRUE;
			}
		}

		return FALSE;
	}
};

class UNavMeshPath_Toward : public UNavMeshPathConstraint
{
public:
    //## BEGIN PROPS NavMeshPath_Toward
    BITFIELD bBiasAgainstHighLevelPath:1;
    FLOAT OutOfHighLevelPathBias;
    class AActor* GoalActor;
    FVector GoalPoint;
    //## END PROPS NavMeshPath_Toward

    DECLARE_CLASS(UNavMeshPath_Toward,UNavMeshPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge, FNavMeshPolyBase* SrcPoly, FNavMeshPolyBase* DestPoly, const FNavMeshPathParams& PathParams, INT& out_PathCost, INT& out_HeuristicCost, const FVector& EdgePoint );
};

class UNavMeshPath_WithinDistanceEnvelope : public UNavMeshPathConstraint
{
public:
    //## BEGIN PROPS NavMeshPath_WithinDistanceEnvelope
    FLOAT MaxDistance;
    FLOAT MinDistance;
    BITFIELD bSoft:1;
    BITFIELD bOnlyThrowOutNodesThatLeaveEnvelope:1;
    FLOAT SoftStartPenalty;
    FVector EnvelopeTestPoint;
    //## END PROPS NavMeshPath_WithinDistanceEnvelope

    DECLARE_CLASS(UNavMeshPath_WithinDistanceEnvelope,UNavMeshPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge, FNavMeshPolyBase* SrcPoly, FNavMeshPolyBase* DestPoly, const FNavMeshPathParams& PathParams, INT& out_PathCost, INT& out_HeuristicCost, const FVector& EdgePoint );
};

class UNavMeshPath_WithinTraversalDist : public UNavMeshPathConstraint
{
public:
    //## BEGIN PROPS NavMeshPath_WithinTraversalDist
    FLOAT MaxTraversalDist;
    BITFIELD bSoft:1;
    FLOAT SoftStartPenalty;
    //## END PROPS NavMeshPath_WithinTraversalDist

    DECLARE_CLASS(UNavMeshPath_WithinTraversalDist,UNavMeshPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( FNavMeshEdgeBase* Edge, FNavMeshEdgeBase* PredecessorEdge, FNavMeshPolyBase* SrcPoly, FNavMeshPolyBase* DestPoly, const FNavMeshPathParams& PathParams, INT& out_PathCost, INT& out_HeuristicCost, const FVector& EdgePoint );
};

struct FBiasedGoalActor
{
    class AActor* Goal;
    INT ExtraCost;

    /** Constructors */
    FBiasedGoalActor() {}
    FBiasedGoalActor(EEventParm)
    {
        appMemzero(this, sizeof(FBiasedGoalActor));
    }
};

struct NavMeshPathGoalEvaluator_eventGetDumpString_Parms
{
    FString ReturnValue;
    NavMeshPathGoalEvaluator_eventGetDumpString_Parms(EEventParm)
    {
    }
};
struct NavMeshPathGoalEvaluator_eventRecycle_Parms
{
    NavMeshPathGoalEvaluator_eventRecycle_Parms(EEventParm)
    {
    }
};
class UNavMeshPathGoalEvaluator : public UObject
{
public:
    //## BEGIN PROPS NavMeshPathGoalEvaluator
    class UNavMeshPathGoalEvaluator* NextEvaluator;
    INT MaxPathVisits;
    BITFIELD bAlwaysCallEvaluateGoal:1;
    BITFIELD bDoPartialAStar:1;
    INT NumNodesThrownOut;
    INT NumNodesProcessed;
    INT MaxOpenListSize;
    //## END PROPS NavMeshPathGoalEvaluator

    FString eventGetDumpString()
    {
        NavMeshPathGoalEvaluator_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    void eventRecycle()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Recycle),NULL);
    }
    DECLARE_CLASS(UNavMeshPathGoalEvaluator,UObject,0,Engine)
	// public Interface
	/**
	 * adds initial nodes to the working set.  For basic searches this is just the start node.
	 * @param OpenList		- Pointer to the start of the open list
	 * @param AnchorPoly    - the anchor poly (poly the entity that's searching is in)
	 * @param PathSessionID - unique ID fo this particular path search (used for cheap clearing of path info)
	 * @param PathParams    - the cached pathfinding parameters for this path search
	 * @return - whether or not we were successful in seeding the search
	 */
	virtual UBOOL SeedWorkingSet( PathOpenList& OpenList,
								FNavMeshPolyBase* AnchorPoly,
								DWORD PathSessionID,
								UNavigationHandle* Handle,
								const FNavMeshPathParams& PathParams);

	/** 
	 * sets up internal vars for path searching, and will early out if something fails
	 * @param Handle - handle we're initializing for
	 * @param PathParams - pathfinding parameter packet
	 * @return - whether or not we should early out form this search
	 */
	virtual UBOOL InitializeSearch( UNavigationHandle* Handle,
									const FNavMeshPathParams& PathParams );
	
	/**
	 * Called each time a node is popped off the working set to determine
	 * whether or not we should finish the search (e.g. did we find the node we're looking for)
	 * @param PossibleGoal - the chosen (cheapest) successor from the open list
	 * @param PathParams   - the cached pathfinding params for the pathing entity
	 * @param out_GenGoal  - the node we should consider the 'goal'.  (Normally PossibleGOal when this returns true, but doesn't have to be)
	 * @return - TRUE indicates we have found the node we're looking for and we should stop the search
	 */
	virtual UBOOL EvaluateGoal( PathCardinalType PossibleGoal,
								const FNavMeshPathParams& PathParams,
								PathCardinalType& out_GenGoal );
	
	/**
	 * after the search is over this is called to allow the goal evaluator to determine the final result from the search.
	 * this is useful if your search is gathering lots of nodes and you need to pick the most fit after your search is complete
	 * @param out_GenGoal - the edge that got us to our final goal
	 * @param out_DestACtor - custom user usable actor output pointer
	 * @param out_DestItem  - custom user usable integter output 
	 * @return - if no final goal could be determined this should return false inidcating failure
	 */
	virtual UBOOL DetermineFinalGoal( PathCardinalType& out_GenGoal, class AActor** out_DestActor, INT* out_DestItem );
	
	/**
	 * called when we have hit our upper bound for path iterations, allows 
	 * evaluators to handle this case specifically to their needs
	 * @param BestGuess - last visited edge from open list which is our best guess 
	 * @param out_GenGoal - current generated goal
	 */
	virtual void  NotifyExceededMaxPathVisits( PathCardinalType BestGuess, PathCardinalType& out_GenGoal );

	/**
	 * walks the previousPath chain back and saves out edges into the handle's pathcache for that handle to follow
	 * @param StartingPoly - the Polygon we are walking backwards toward
	 * @param GoalPoly     - the polygon to begin walking backwards from
	 * @param Handle	   - the handle to save the path out to 
	 * @param GoalEdge     - the edge that lead us to the goal poly
	 */
	virtual void SaveResultingPath( FNavMeshPolyBase* StartingPoly, FNavMeshPolyBase* GoalPoly, UNavigationHandle* Handle, PathCardinalType GoalEdge );

	/** 
	 *  Allows any pathobjects in the path to modify the final path after it has been generated
	 *  @param Handle - the navigation handle we're pathfinding for
	 *  @return - TRUE if a path object modified the path
	 */
	virtual UBOOL DoPathObjectPathMods( UNavigationHandle* Handle );
};

class UNavMeshGoal_At : public UNavMeshPathGoalEvaluator
{
public:
    //## BEGIN PROPS NavMeshGoal_At
    FVector Goal;
    FLOAT GoalDist;
    BITFIELD bKeepPartial:1;
    BITFIELD bWeightPartialByDist:1;
    BITFIELD bGoalInSamePolyAsAnchor:1;
    FLOAT PartialDistSq;
    FNavMeshPolyBase* GoalPoly;
    FNavMeshEdgeBase* PartialGoal;
    //## END PROPS NavMeshGoal_At

    virtual void RecycleNative();
    DECLARE_FUNCTION(execRecycleNative)
    {
        P_FINISH;
        this->RecycleNative();
    }
    DECLARE_CLASS(UNavMeshGoal_At,UNavMeshPathGoalEvaluator,0,Engine)
	// Interface
	virtual UBOOL InitializeSearch( UNavigationHandle* Handle, const FNavMeshPathParams& PathParams);
	virtual UBOOL EvaluateGoal( PathCardinalType PossibleGoal, const FNavMeshPathParams& PathParams, PathCardinalType& out_GenGoal );
	virtual void  NotifyExceededMaxPathVisits( PathCardinalType BestGuess, PathCardinalType& out_GenGoal );
	virtual UBOOL DetermineFinalGoal( PathCardinalType& out_GenGoal, class AActor** out_DestActor, INT* out_DestItem );
	virtual UBOOL SeedWorkingSet( PathOpenList& OpenList,
								FNavMeshPolyBase* AnchorPoly,
								DWORD PathSessionID,
								UNavigationHandle* Handle,
								const FNavMeshPathParams& PathParams);

};

class UNavMeshGoal_ClosestActorInList : public UNavMeshPathGoalEvaluator
{
public:
    //## BEGIN PROPS NavMeshGoal_ClosestActorInList
    TArrayNoInit<struct FBiasedGoalActor> GoalList;
    TMultiMap<FNavMeshPolyBase*,AActor*> PolyToGoalActorMap;
    FNavMeshPolyBase* CachedAnchorPoly;
    //## END PROPS NavMeshGoal_ClosestActorInList

    virtual void RecycleInternal();
    DECLARE_FUNCTION(execRecycleInternal)
    {
        P_FINISH;
        this->RecycleInternal();
    }
    DECLARE_CLASS(UNavMeshGoal_ClosestActorInList,UNavMeshPathGoalEvaluator,0,Engine)

	// ++ NavMeshPathGoalEvaluator Interface ++
	// overidden to add the polys all our goal points are in to the working set instead of just the anchor
	virtual UBOOL SeedWorkingSet( PathOpenList& OpenList, FNavMeshPolyBase* AnchorPoly, DWORD PathSessionID,UNavigationHandle* Handle, const FNavMeshPathParams& PathParams );
	virtual UBOOL InitializeSearch( UNavigationHandle* Handle, const FNavMeshPathParams& PathParams );
	// stop when we reach the anchor
	virtual UBOOL EvaluateGoal( PathCardinalType PossibleGoal, const FNavMeshPathParams& PathParams, PathCardinalType& out_GenGoal );;
	// determine which goal actor we pathed to first (which was closest)
	virtual UBOOL DetermineFinalGoal( PathCardinalType& out_GenGoal, class AActor** out_DestActor, INT* out_DestItem );
	// overidden to save the path in forward order since we're pathing backwards
	/**
	 * walks the previousPath chain back and saves out edges into the handle's pathcache for that handle to follow
	 * @param StartingPoly - the Polygon we are walking backwards toward
	 * @param GoalPoly     - the polygon to begin walking backwards from
	 * @param Handle	   - the handle to save the path out to 
	 * @param GoalEdge     - the edge that lead us to the goal poly
	 */
	virtual void SaveResultingPath( FNavMeshPolyBase* StartingPoly, FNavMeshPolyBase* GoalPoly, UNavigationHandle* Handle, FNavMeshEdgeBase* GoalEdge );
};

class UNavMeshGoal_GenericFilterContainer : public UNavMeshPathGoalEvaluator
{
public:
    //## BEGIN PROPS NavMeshGoal_GenericFilterContainer
    TArrayNoInit<class UNavMeshGoal_Filter*> GoalFilters;
    FNavMeshEdgeBase* SuccessfulGoal;
    class UNavigationHandle* MyNavigationHandle;
    TArrayNoInit<FVector> SeedLocations;
    //## END PROPS NavMeshGoal_GenericFilterContainer

    virtual FVector GetGoalPoint();
    DECLARE_FUNCTION(execGetGoalPoint)
    {
        P_FINISH;
        *(FVector*)Result=this->GetGoalPoint();
    }
    DECLARE_CLASS(UNavMeshGoal_GenericFilterContainer,UNavMeshPathGoalEvaluator,0,Engine)
	// NavMeshPathGoalEvaluator Interface
	virtual UBOOL EvaluateGoal( PathCardinalType PossibleGoal, const FNavMeshPathParams& PathParams, PathCardinalType& out_GenGoal );
	
	/**
	 * this will ask each filter in this guy's list if the passed poly is a viable seed to get added at start time
	 * @param PossibleSeed - the seed to check viability for
	 * @param PathParams - params for entity searching
	 */
	virtual UBOOL IsValidSeed( FNavMeshPolyBase* PossibleSeed, const FNavMeshPathParams& PathParams );

	/** 
	 * sets up internal vars for path searching, and will early out if something fails
	 * @param Handle - handle we're initializing for
	 * @param PathParams - pathfinding parameter packet
	 * @return - whether or not we should early out form this search
	 */
	virtual UBOOL InitializeSearch( UNavigationHandle* Handle,
									const FNavMeshPathParams& PathParams );



	/**
	 * called when we have hit our upper bound for path iterations, allows 
	 * evaluators to handle this case specifically to their needs
	 * @param BestGuess - last visited edge from open list which is our best guess 
	 * @param out_GenGoal - current generated goal
	 */
	virtual void NotifyExceededMaxPathVisits( PathCardinalType BestGuess, PathCardinalType& out_GenGoal );


	/**
	 * adds initial nodes to the working set.  For basic searches this is just the start node.
	 * @param OpenList		- Pointer to the start of the open list
	 * @param AnchorPoly    - the anchor poly (poly the entity that's searching is in)
	 * @param PathSessionID - unique ID fo this particular path search (used for cheap clearing of path info)
	 * @param PathParams    - the cached pathfinding parameters for this path search
	 * @return - whether or not we were successful in seeding the search
	 */
	virtual UBOOL SeedWorkingSet( PathOpenList& OpenList,
								FNavMeshPolyBase* AnchorPoly,
								DWORD PathSessionID,
								UNavigationHandle* Handle,
								const FNavMeshPathParams& PathParams);



};

class UNavMeshGoal_Null : public UNavMeshPathGoalEvaluator
{
public:
    //## BEGIN PROPS NavMeshGoal_Null
    FNavMeshEdgeBase* PartialGoal;
    //## END PROPS NavMeshGoal_Null

    virtual void RecycleNative();
    DECLARE_FUNCTION(execRecycleNative)
    {
        P_FINISH;
        this->RecycleNative();
    }
    DECLARE_CLASS(UNavMeshGoal_Null,UNavMeshPathGoalEvaluator,0,Engine)
	// Interface
	virtual UBOOL EvaluateGoal( PathCardinalType PossibleGoal, const FNavMeshPathParams& PathParams, PathCardinalType& out_GenGoal );
	virtual void  NotifyExceededMaxPathVisits( PathCardinalType BestGuess, PathCardinalType& out_GenGoal ) {/*don't care about best guess.. just ignore this*/}
	virtual UBOOL DetermineFinalGoal( PathCardinalType& out_GenGoal, class AActor** out_DestActor, INT* out_DestItem );

};

class UNavMeshGoal_PolyEncompassesAI : public UNavMeshPathGoalEvaluator
{
public:
    //## BEGIN PROPS NavMeshGoal_PolyEncompassesAI
    FVector OverrideExtentToCheck;
    //## END PROPS NavMeshGoal_PolyEncompassesAI

    DECLARE_CLASS(UNavMeshGoal_PolyEncompassesAI,UNavMeshPathGoalEvaluator,0,Engine)
	// Interface
	virtual UBOOL EvaluateGoal( PathCardinalType PossibleGoal, const FNavMeshPathParams& PathParams, PathCardinalType& out_GenGoal );	
};

class UNavMeshGoal_Random : public UNavMeshPathGoalEvaluator
{
public:
    //## BEGIN PROPS NavMeshGoal_Random
    INT MinDist;
    FLOAT BestRating;
    FNavMeshEdgeBase* PartialGoal;
    //## END PROPS NavMeshGoal_Random

    virtual void RecycleNative();
    DECLARE_FUNCTION(execRecycleNative)
    {
        P_FINISH;
        this->RecycleNative();
    }
    DECLARE_CLASS(UNavMeshGoal_Random,UNavMeshPathGoalEvaluator,0,Engine)
	// Interface
	virtual UBOOL EvaluateGoal( PathCardinalType PossibleGoal, const FNavMeshPathParams& PathParams, PathCardinalType& out_GenGoal );
	virtual void  NotifyExceededMaxPathVisits(PathCardinalType BestGuess, PathCardinalType& out_GenGoal) {/*don't care about best guess.. just ignore this*/}
	virtual UBOOL DetermineFinalGoal(PathCardinalType& out_GenGoal, class AActor** out_DestActor, INT* out_DestItem);

};

class UNavMeshGoal_WithinDistanceEnvelope : public UNavMeshPathGoalEvaluator
{
public:
    //## BEGIN PROPS NavMeshGoal_WithinDistanceEnvelope
    FLOAT MaxDistance;
    FLOAT MinDistance;
    FLOAT MinTraversalDist;
    FVector EnvelopeTestPoint;
    //## END PROPS NavMeshGoal_WithinDistanceEnvelope

    DECLARE_CLASS(UNavMeshGoal_WithinDistanceEnvelope,UNavMeshPathGoalEvaluator,0,Engine)
	// Interface
	virtual UBOOL EvaluateGoal( PathCardinalType PossibleGoal, const FNavMeshPathParams& PathParams, PathCardinalType& out_GenGoal );
};

struct PathConstraint_eventGetDumpString_Parms
{
    FString ReturnValue;
    PathConstraint_eventGetDumpString_Parms(EEventParm)
    {
    }
};
struct PathConstraint_eventRecycle_Parms
{
    PathConstraint_eventRecycle_Parms(EEventParm)
    {
    }
};
class UPathConstraint : public UObject
{
public:
    //## BEGIN PROPS PathConstraint
    INT CacheIdx;
    class UPathConstraint* NextConstraint;
    //## END PROPS PathConstraint

    FString eventGetDumpString()
    {
        PathConstraint_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    void eventRecycle()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Recycle),NULL);
    }
    DECLARE_CLASS(UPathConstraint,UObject,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_AlongLine : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_AlongLine
    FVector Direction;
    //## END PROPS Path_AlongLine

    DECLARE_CLASS(UPath_AlongLine,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_AvoidInEscapableNodes : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_AvoidInEscapableNodes
    INT Radius;
    INT Height;
    INT MaxFallSpeed;
    INT MoveFlags;
    //## END PROPS Path_AvoidInEscapableNodes

    virtual void CachePawnReacFlags(class APawn* P);
    DECLARE_FUNCTION(execCachePawnReacFlags)
    {
        P_GET_OBJECT(APawn,P);
        P_FINISH;
        this->CachePawnReacFlags(P);
    }
    DECLARE_CLASS(UPath_AvoidInEscapableNodes,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_MinDistBetweenSpecsOfType : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_MinDistBetweenSpecsOfType
    FLOAT MinDistBetweenSpecTypes;
    FVector InitLocation;
    class UClass* ReachSpecClass;
    //## END PROPS Path_MinDistBetweenSpecsOfType

    DECLARE_CLASS(UPath_MinDistBetweenSpecsOfType,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
	UBOOL IsNodeWithinMinDistOfSpecInPath(ANavigationPoint* Node);
};

class UPath_TowardGoal : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_TowardGoal
    class AActor* GoalActor;
    //## END PROPS Path_TowardGoal

    DECLARE_CLASS(UPath_TowardGoal,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_TowardPoint : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_TowardPoint
    FVector GoalPoint;
    //## END PROPS Path_TowardPoint

    DECLARE_CLASS(UPath_TowardPoint,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_WithinDistanceEnvelope : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_WithinDistanceEnvelope
    FLOAT MaxDistance;
    FLOAT MinDistance;
    BITFIELD bSoft:1;
    BITFIELD bOnlyThrowOutNodesThatLeaveEnvelope:1;
    FLOAT SoftStartPenalty;
    FVector EnvelopeTestPoint;
    //## END PROPS Path_WithinDistanceEnvelope

    DECLARE_CLASS(UPath_WithinDistanceEnvelope,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

class UPath_WithinTraversalDist : public UPathConstraint
{
public:
    //## BEGIN PROPS Path_WithinTraversalDist
    FLOAT MaxTraversalDist;
    BITFIELD bSoft:1;
    FLOAT SoftStartPenalty;
    //## END PROPS Path_WithinTraversalDist

    DECLARE_CLASS(UPath_WithinTraversalDist,UPathConstraint,0,Engine)
	// Interface
	virtual UBOOL EvaluatePath( UReachSpec* Spec, APawn* Pawn, INT& out_PathCost, INT& out_HeuristicCost );
};

struct PathGoalEvaluator_eventGetDumpString_Parms
{
    FString ReturnValue;
    PathGoalEvaluator_eventGetDumpString_Parms(EEventParm)
    {
    }
};
struct PathGoalEvaluator_eventRecycle_Parms
{
    PathGoalEvaluator_eventRecycle_Parms(EEventParm)
    {
    }
};
class UPathGoalEvaluator : public UObject
{
public:
    //## BEGIN PROPS PathGoalEvaluator
    class UPathGoalEvaluator* NextEvaluator;
    class ANavigationPoint* GeneratedGoal;
    INT MaxPathVisits;
    INT CacheIdx;
    //## END PROPS PathGoalEvaluator

    FString eventGetDumpString()
    {
        PathGoalEvaluator_eventGetDumpString_Parms Parms(EC_EventParm);
        ProcessEvent(FindFunctionChecked(ENGINE_GetDumpString),&Parms);
        return Parms.ReturnValue;
    }
    void eventRecycle()
    {
        ProcessEvent(FindFunctionChecked(ENGINE_Recycle),NULL);
    }
    DECLARE_CLASS(UPathGoalEvaluator,UObject,0,Engine)
	// Interface
	virtual UBOOL InitialAbortCheck( ANavigationPoint* Start, APawn* Pawn );
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual UBOOL DetermineFinalGoal( ANavigationPoint*& out_GoalNav );
	virtual void  NotifyExceededMaxPathVisits( ANavigationPoint* BestGuess );
};

class UGoal_AtActor : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_AtActor
    class AActor* GoalActor;
    FLOAT GoalDist;
    BITFIELD bKeepPartial:1;
    SCRIPT_ALIGN;
    //## END PROPS Goal_AtActor

    DECLARE_CLASS(UGoal_AtActor,UPathGoalEvaluator,0,Engine)
	// Interface
	virtual UBOOL InitialAbortCheck( ANavigationPoint* Start, APawn* Pawn );
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual void  NotifyExceededMaxPathVisits( ANavigationPoint* BestGuess );
};

class UGoal_Null : public UPathGoalEvaluator
{
public:
    //## BEGIN PROPS Goal_Null
    //## END PROPS Goal_Null

    DECLARE_CLASS(UGoal_Null,UPathGoalEvaluator,0,Engine)
	// Interface
	virtual UBOOL EvaluateGoal(ANavigationPoint*& PossibleGoal, APawn* Pawn);
	virtual void NotifyExceededMaxPathVisits( ANavigationPoint* BestGuess ){/*don't care about best guess.. just ignore this*/}
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_AI_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(AEnvironmentVolume,-1,execSetSplitNavMesh);
AUTOGENERATE_FUNCTION(APathTargetPoint,-1,execShouldBeHiddenBySHOW_NavigationNodes);
AUTOGENERATE_FUNCTION(ANavMeshObstacle,-1,execUnRegisterObstacle);
AUTOGENERATE_FUNCTION(ANavMeshObstacle,-1,execRegisterObstacle);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execStaticGetValidatedAnchorPosition);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetValidatedAnchorPosition);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetAllCoverSlotsInRadius);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execPopulatePathfindingParamCache);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execMoveToDesiredHeightAboveMesh);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execCopyMovePointsFromPathCache);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execCalculatePathDistance);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetFirstMoveLocation);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execIsAnchorInescapable);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execLimitPathCacheDistance);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetValidPositionsForBox);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetAllPolyCentersWithinBounds);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetCurrentEdgeType);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execClearCurrentEdge);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetCurrentEdgeDebugText);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execPrintPathCacheDebugText);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execDrawPathCache);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execActorReachable);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execPointReachable);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execPointCheck);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execLineCheck);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execObstaclePointCheck);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execObstacleLineCheck);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execSuggestMovePreparation);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execFindPath);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execComputeValidFinalDestination);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execSetFinalDestination);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetNextMoveLocation);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetPylonFromPos);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execFindPylon);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetBestUnfinishedPathPoint);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execPathCache_RemoveIndex);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execPathCache_GetGoalPoint);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execPathCache_Empty);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execDoesPylonAHaveAPathToPylonB);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execBuildFromPylonAToPylonB);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execAddGoalEvaluator);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execAddPathConstraint);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execClearConstraints);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execGetNextBreadCrumb);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execUpdateBreadCrumbs);
AUTOGENERATE_FUNCTION(UNavigationHandle,-1,execCopyPathStoreToPathCache);
AUTOGENERATE_FUNCTION(UNavMeshGoal_At,-1,execRecycleNative);
AUTOGENERATE_FUNCTION(UNavMeshGoal_ClosestActorInList,-1,execRecycleInternal);
AUTOGENERATE_FUNCTION(UNavMeshGoal_GenericFilterContainer,-1,execGetGoalPoint);
AUTOGENERATE_FUNCTION(UNavMeshGoal_Null,-1,execRecycleNative);
AUTOGENERATE_FUNCTION(UNavMeshGoal_Random,-1,execRecycleNative);
AUTOGENERATE_FUNCTION(UPath_AvoidInEscapableNodes,-1,execCachePawnReacFlags);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_AI_NATIVE_DEFS
#define ENGINE_AI_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_AI \
	AEnvironmentVolume::StaticClass(); \
	GNativeLookupFuncs.Set(FName("EnvironmentVolume"), GEngineAEnvironmentVolumeNatives); \
	ATestSplittingVolume::StaticClass(); \
	AAIController::StaticClass(); \
	ACrowdAgentBase::StaticClass(); \
	ACrowdPopulationManagerBase::StaticClass(); \
	APathTargetPoint::StaticClass(); \
	GNativeLookupFuncs.Set(FName("PathTargetPoint"), GEngineAPathTargetPointNatives); \
	ANavMeshObstacle::StaticClass(); \
	GNativeLookupFuncs.Set(FName("NavMeshObstacle"), GEngineANavMeshObstacleNatives); \
	APylonSeed::StaticClass(); \
	UCoverGroupRenderingComponent::StaticClass(); \
	UCoverMeshComponent::StaticClass(); \
	UNavMeshRenderingComponent::StaticClass(); \
	UPathRenderingComponent::StaticClass(); \
	URouteRenderingComponent::StaticClass(); \
	UAICommandBase::StaticClass(); \
	UAutoNavMeshPathObstacleUnregister::StaticClass(); \
	UInterface_NavMeshPathObject::StaticClass(); \
	UInterface_NavMeshPathSwitch::StaticClass(); \
	UInterface_NavMeshPathObstacle::StaticClass(); \
	UInterface_PylonGeometryProvider::StaticClass(); \
	UInterface_RVO::StaticClass(); \
	UNavigationHandle::StaticClass(); \
	GNativeLookupFuncs.Set(FName("NavigationHandle"), GEngineUNavigationHandleNatives); \
	UNavMeshGoal_Filter::StaticClass(); \
	UNavMeshGoalFilter_MinPathDistance::StaticClass(); \
	UNavMeshGoalFilter_NotNearOtherAI::StaticClass(); \
	UNavMeshGoalFilter_OutOfViewFrom::StaticClass(); \
	UNavMeshGoalFilter_OutSideOfDotProductWedge::StaticClass(); \
	UNavMeshGoalFilter_PolyEncompassesAI::StaticClass(); \
	UNavMeshPathConstraint::StaticClass(); \
	UNavMeshPath_AlongLine::StaticClass(); \
	UNavMeshPath_EnforceTwoWayEdges::StaticClass(); \
	UNavMeshPath_MinDistBetweenSpecsOfType::StaticClass(); \
	UNavMeshPath_SameCoverLink::StaticClass(); \
	UNavMeshPath_Toward::StaticClass(); \
	UNavMeshPath_WithinDistanceEnvelope::StaticClass(); \
	UNavMeshPath_WithinTraversalDist::StaticClass(); \
	UNavMeshPathGoalEvaluator::StaticClass(); \
	UNavMeshGoal_At::StaticClass(); \
	GNativeLookupFuncs.Set(FName("NavMeshGoal_At"), GEngineUNavMeshGoal_AtNatives); \
	UNavMeshGoal_ClosestActorInList::StaticClass(); \
	GNativeLookupFuncs.Set(FName("NavMeshGoal_ClosestActorInList"), GEngineUNavMeshGoal_ClosestActorInListNatives); \
	UNavMeshGoal_GenericFilterContainer::StaticClass(); \
	GNativeLookupFuncs.Set(FName("NavMeshGoal_GenericFilterContainer"), GEngineUNavMeshGoal_GenericFilterContainerNatives); \
	UNavMeshGoal_Null::StaticClass(); \
	GNativeLookupFuncs.Set(FName("NavMeshGoal_Null"), GEngineUNavMeshGoal_NullNatives); \
	UNavMeshGoal_PolyEncompassesAI::StaticClass(); \
	UNavMeshGoal_Random::StaticClass(); \
	GNativeLookupFuncs.Set(FName("NavMeshGoal_Random"), GEngineUNavMeshGoal_RandomNatives); \
	UNavMeshGoal_WithinDistanceEnvelope::StaticClass(); \
	UPathConstraint::StaticClass(); \
	UPath_AlongLine::StaticClass(); \
	UPath_AvoidInEscapableNodes::StaticClass(); \
	GNativeLookupFuncs.Set(FName("Path_AvoidInEscapableNodes"), GEngineUPath_AvoidInEscapableNodesNatives); \
	UPath_MinDistBetweenSpecsOfType::StaticClass(); \
	UPath_TowardGoal::StaticClass(); \
	UPath_TowardPoint::StaticClass(); \
	UPath_WithinDistanceEnvelope::StaticClass(); \
	UPath_WithinTraversalDist::StaticClass(); \
	UPathGoalEvaluator::StaticClass(); \
	UGoal_AtActor::StaticClass(); \
	UGoal_Null::StaticClass(); \

#endif // ENGINE_AI_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GEngineAEnvironmentVolumeNatives[] = 
{ 
	MAP_NATIVE(AEnvironmentVolume, execSetSplitNavMesh)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineAPathTargetPointNatives[] = 
{ 
	MAP_NATIVE(APathTargetPoint, execShouldBeHiddenBySHOW_NavigationNodes)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineANavMeshObstacleNatives[] = 
{ 
	MAP_NATIVE(ANavMeshObstacle, execUnRegisterObstacle)
	MAP_NATIVE(ANavMeshObstacle, execRegisterObstacle)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUNavigationHandleNatives[] = 
{ 
	MAP_NATIVE(UNavigationHandle, execStaticGetValidatedAnchorPosition)
	MAP_NATIVE(UNavigationHandle, execGetValidatedAnchorPosition)
	MAP_NATIVE(UNavigationHandle, execGetAllCoverSlotsInRadius)
	MAP_NATIVE(UNavigationHandle, execPopulatePathfindingParamCache)
	MAP_NATIVE(UNavigationHandle, execMoveToDesiredHeightAboveMesh)
	MAP_NATIVE(UNavigationHandle, execCopyMovePointsFromPathCache)
	MAP_NATIVE(UNavigationHandle, execCalculatePathDistance)
	MAP_NATIVE(UNavigationHandle, execGetFirstMoveLocation)
	MAP_NATIVE(UNavigationHandle, execIsAnchorInescapable)
	MAP_NATIVE(UNavigationHandle, execLimitPathCacheDistance)
	MAP_NATIVE(UNavigationHandle, execGetValidPositionsForBox)
	MAP_NATIVE(UNavigationHandle, execGetAllPolyCentersWithinBounds)
	MAP_NATIVE(UNavigationHandle, execGetCurrentEdgeType)
	MAP_NATIVE(UNavigationHandle, execClearCurrentEdge)
	MAP_NATIVE(UNavigationHandle, execGetCurrentEdgeDebugText)
	MAP_NATIVE(UNavigationHandle, execPrintPathCacheDebugText)
	MAP_NATIVE(UNavigationHandle, execDrawPathCache)
	MAP_NATIVE(UNavigationHandle, execActorReachable)
	MAP_NATIVE(UNavigationHandle, execPointReachable)
	MAP_NATIVE(UNavigationHandle, execPointCheck)
	MAP_NATIVE(UNavigationHandle, execLineCheck)
	MAP_NATIVE(UNavigationHandle, execObstaclePointCheck)
	MAP_NATIVE(UNavigationHandle, execObstacleLineCheck)
	MAP_NATIVE(UNavigationHandle, execSuggestMovePreparation)
	MAP_NATIVE(UNavigationHandle, execFindPath)
	MAP_NATIVE(UNavigationHandle, execComputeValidFinalDestination)
	MAP_NATIVE(UNavigationHandle, execSetFinalDestination)
	MAP_NATIVE(UNavigationHandle, execGetNextMoveLocation)
	MAP_NATIVE(UNavigationHandle, execGetPylonFromPos)
	MAP_NATIVE(UNavigationHandle, execFindPylon)
	MAP_NATIVE(UNavigationHandle, execGetBestUnfinishedPathPoint)
	MAP_NATIVE(UNavigationHandle, execPathCache_RemoveIndex)
	MAP_NATIVE(UNavigationHandle, execPathCache_GetGoalPoint)
	MAP_NATIVE(UNavigationHandle, execPathCache_Empty)
	MAP_NATIVE(UNavigationHandle, execDoesPylonAHaveAPathToPylonB)
	MAP_NATIVE(UNavigationHandle, execBuildFromPylonAToPylonB)
	MAP_NATIVE(UNavigationHandle, execAddGoalEvaluator)
	MAP_NATIVE(UNavigationHandle, execAddPathConstraint)
	MAP_NATIVE(UNavigationHandle, execClearConstraints)
	MAP_NATIVE(UNavigationHandle, execGetNextBreadCrumb)
	MAP_NATIVE(UNavigationHandle, execUpdateBreadCrumbs)
	MAP_NATIVE(UNavigationHandle, execCopyPathStoreToPathCache)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUNavMeshGoal_AtNatives[] = 
{ 
	MAP_NATIVE(UNavMeshGoal_At, execRecycleNative)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUNavMeshGoal_ClosestActorInListNatives[] = 
{ 
	MAP_NATIVE(UNavMeshGoal_ClosestActorInList, execRecycleInternal)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUNavMeshGoal_GenericFilterContainerNatives[] = 
{ 
	MAP_NATIVE(UNavMeshGoal_GenericFilterContainer, execGetGoalPoint)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUNavMeshGoal_NullNatives[] = 
{ 
	MAP_NATIVE(UNavMeshGoal_Null, execRecycleNative)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUNavMeshGoal_RandomNatives[] = 
{ 
	MAP_NATIVE(UNavMeshGoal_Random, execRecycleNative)
	{NULL, NULL}
};

FNativeFunctionLookup GEngineUPath_AvoidInEscapableNodesNatives[] = 
{ 
	MAP_NATIVE(UPath_AvoidInEscapableNodes, execCachePawnReacFlags)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_SIZE_NODIE(AEnvironmentVolume)
VERIFY_CLASS_SIZE_NODIE(ATestSplittingVolume)
VERIFY_CLASS_OFFSET_NODIE(AAIController,AIController,Skill)
VERIFY_CLASS_OFFSET_NODIE(AAIController,AIController,ScriptedFocus)
VERIFY_CLASS_SIZE_NODIE(AAIController)
VERIFY_CLASS_SIZE_NODIE(ACrowdAgentBase)
VERIFY_CLASS_SIZE_NODIE(ACrowdPopulationManagerBase)
VERIFY_CLASS_SIZE_NODIE(APathTargetPoint)
VERIFY_CLASS_SIZE_NODIE(ANavMeshObstacle)
VERIFY_CLASS_SIZE_NODIE(APylonSeed)
VERIFY_CLASS_SIZE_NODIE(UCoverGroupRenderingComponent)
VERIFY_CLASS_OFFSET_NODIE(UCoverMeshComponent,CoverMeshComponent,Meshes)
VERIFY_CLASS_OFFSET_NODIE(UCoverMeshComponent,CoverMeshComponent,Disabled)
VERIFY_CLASS_SIZE_NODIE(UCoverMeshComponent)
VERIFY_CLASS_SIZE_NODIE(UNavMeshRenderingComponent)
VERIFY_CLASS_SIZE_NODIE(UPathRenderingComponent)
VERIFY_CLASS_SIZE_NODIE(URouteRenderingComponent)
VERIFY_CLASS_SIZE_NODIE(UAICommandBase)
VERIFY_CLASS_OFFSET_NODIE(UAutoNavMeshPathObstacleUnregister,AutoNavMeshPathObstacleUnregister,PathObstacleRef)
VERIFY_CLASS_SIZE_NODIE(UAutoNavMeshPathObstacleUnregister)
VERIFY_CLASS_SIZE_NODIE(UInterface_NavMeshPathObject)
VERIFY_CLASS_SIZE_NODIE(UInterface_NavMeshPathSwitch)
VERIFY_CLASS_SIZE_NODIE(UInterface_NavMeshPathObstacle)
VERIFY_CLASS_SIZE_NODIE(UInterface_PylonGeometryProvider)
VERIFY_CLASS_SIZE_NODIE(UInterface_RVO)
VERIFY_CLASS_OFFSET_NODIE(UNavigationHandle,NavigationHandle,AnchorPylon)
VERIFY_CLASS_OFFSET_NODIE(UNavigationHandle,NavigationHandle,BreadCrumbDistanceInterval)
VERIFY_CLASS_SIZE_NODIE(UNavigationHandle)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_Filter,NavMeshGoal_Filter,NumNodesThrownOut)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_Filter,NavMeshGoal_Filter,NumNodesProcessed)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoal_Filter)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoalFilter_MinPathDistance,NavMeshGoalFilter_MinPathDistance,MinDistancePathShouldBe)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoalFilter_MinPathDistance)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoalFilter_NotNearOtherAI,NavMeshGoalFilter_NotNearOtherAI,DistanceToCheck)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoalFilter_NotNearOtherAI)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoalFilter_OutOfViewFrom,NavMeshGoalFilter_OutOfViewFrom,GoalPoly)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoalFilter_OutOfViewFrom,NavMeshGoalFilter_OutOfViewFrom,OutOfViewLocation)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoalFilter_OutOfViewFrom)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoalFilter_OutSideOfDotProductWedge,NavMeshGoalFilter_OutSideOfDotProductWedge,Location)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoalFilter_OutSideOfDotProductWedge,NavMeshGoalFilter_OutSideOfDotProductWedge,Epsilon)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoalFilter_OutSideOfDotProductWedge)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoalFilter_PolyEncompassesAI,NavMeshGoalFilter_PolyEncompassesAI,OverrideExtentToCheck)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoalFilter_PolyEncompassesAI)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPathConstraint,NavMeshPathConstraint,NextConstraint)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPathConstraint,NavMeshPathConstraint,AddedHeuristicCost)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPathConstraint)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_AlongLine,NavMeshPath_AlongLine,Direction)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPath_AlongLine)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPath_EnforceTwoWayEdges)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_MinDistBetweenSpecsOfType,NavMeshPath_MinDistBetweenSpecsOfType,MinDistBetweenEdgeTypes)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_MinDistBetweenSpecsOfType,NavMeshPath_MinDistBetweenSpecsOfType,Penalty)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPath_MinDistBetweenSpecsOfType)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_SameCoverLink,NavMeshPath_SameCoverLink,TestLink)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPath_SameCoverLink)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_Toward,NavMeshPath_Toward,OutOfHighLevelPathBias)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_Toward,NavMeshPath_Toward,GoalPoint)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPath_Toward)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_WithinDistanceEnvelope,NavMeshPath_WithinDistanceEnvelope,MaxDistance)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_WithinDistanceEnvelope,NavMeshPath_WithinDistanceEnvelope,EnvelopeTestPoint)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPath_WithinDistanceEnvelope)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_WithinTraversalDist,NavMeshPath_WithinTraversalDist,MaxTraversalDist)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPath_WithinTraversalDist,NavMeshPath_WithinTraversalDist,SoftStartPenalty)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPath_WithinTraversalDist)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPathGoalEvaluator,NavMeshPathGoalEvaluator,NextEvaluator)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshPathGoalEvaluator,NavMeshPathGoalEvaluator,MaxOpenListSize)
VERIFY_CLASS_SIZE_NODIE(UNavMeshPathGoalEvaluator)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_At,NavMeshGoal_At,Goal)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_At,NavMeshGoal_At,PartialGoal)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoal_At)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_ClosestActorInList,NavMeshGoal_ClosestActorInList,GoalList)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_ClosestActorInList,NavMeshGoal_ClosestActorInList,CachedAnchorPoly)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoal_ClosestActorInList)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_GenericFilterContainer,NavMeshGoal_GenericFilterContainer,GoalFilters)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_GenericFilterContainer,NavMeshGoal_GenericFilterContainer,SeedLocations)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoal_GenericFilterContainer)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_Null,NavMeshGoal_Null,PartialGoal)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoal_Null)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_PolyEncompassesAI,NavMeshGoal_PolyEncompassesAI,OverrideExtentToCheck)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoal_PolyEncompassesAI)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_Random,NavMeshGoal_Random,MinDist)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_Random,NavMeshGoal_Random,PartialGoal)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoal_Random)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_WithinDistanceEnvelope,NavMeshGoal_WithinDistanceEnvelope,MaxDistance)
VERIFY_CLASS_OFFSET_NODIE(UNavMeshGoal_WithinDistanceEnvelope,NavMeshGoal_WithinDistanceEnvelope,EnvelopeTestPoint)
VERIFY_CLASS_SIZE_NODIE(UNavMeshGoal_WithinDistanceEnvelope)
VERIFY_CLASS_OFFSET_NODIE(UPathConstraint,PathConstraint,CacheIdx)
VERIFY_CLASS_OFFSET_NODIE(UPathConstraint,PathConstraint,NextConstraint)
VERIFY_CLASS_SIZE_NODIE(UPathConstraint)
VERIFY_CLASS_OFFSET_NODIE(UPath_AlongLine,Path_AlongLine,Direction)
VERIFY_CLASS_SIZE_NODIE(UPath_AlongLine)
VERIFY_CLASS_OFFSET_NODIE(UPath_AvoidInEscapableNodes,Path_AvoidInEscapableNodes,Radius)
VERIFY_CLASS_OFFSET_NODIE(UPath_AvoidInEscapableNodes,Path_AvoidInEscapableNodes,MoveFlags)
VERIFY_CLASS_SIZE_NODIE(UPath_AvoidInEscapableNodes)
VERIFY_CLASS_OFFSET_NODIE(UPath_MinDistBetweenSpecsOfType,Path_MinDistBetweenSpecsOfType,MinDistBetweenSpecTypes)
VERIFY_CLASS_OFFSET_NODIE(UPath_MinDistBetweenSpecsOfType,Path_MinDistBetweenSpecsOfType,ReachSpecClass)
VERIFY_CLASS_SIZE_NODIE(UPath_MinDistBetweenSpecsOfType)
VERIFY_CLASS_OFFSET_NODIE(UPath_TowardGoal,Path_TowardGoal,GoalActor)
VERIFY_CLASS_SIZE_NODIE(UPath_TowardGoal)
VERIFY_CLASS_OFFSET_NODIE(UPath_TowardPoint,Path_TowardPoint,GoalPoint)
VERIFY_CLASS_SIZE_NODIE(UPath_TowardPoint)
VERIFY_CLASS_OFFSET_NODIE(UPath_WithinDistanceEnvelope,Path_WithinDistanceEnvelope,MaxDistance)
VERIFY_CLASS_OFFSET_NODIE(UPath_WithinDistanceEnvelope,Path_WithinDistanceEnvelope,EnvelopeTestPoint)
VERIFY_CLASS_SIZE_NODIE(UPath_WithinDistanceEnvelope)
VERIFY_CLASS_OFFSET_NODIE(UPath_WithinTraversalDist,Path_WithinTraversalDist,MaxTraversalDist)
VERIFY_CLASS_OFFSET_NODIE(UPath_WithinTraversalDist,Path_WithinTraversalDist,SoftStartPenalty)
VERIFY_CLASS_SIZE_NODIE(UPath_WithinTraversalDist)
VERIFY_CLASS_OFFSET_NODIE(UPathGoalEvaluator,PathGoalEvaluator,NextEvaluator)
VERIFY_CLASS_OFFSET_NODIE(UPathGoalEvaluator,PathGoalEvaluator,CacheIdx)
VERIFY_CLASS_SIZE_NODIE(UPathGoalEvaluator)
VERIFY_CLASS_OFFSET_NODIE(UGoal_AtActor,Goal_AtActor,GoalActor)
VERIFY_CLASS_OFFSET_NODIE(UGoal_AtActor,Goal_AtActor,GoalDist)
VERIFY_CLASS_SIZE_NODIE(UGoal_AtActor)
VERIFY_CLASS_SIZE_NODIE(UGoal_Null)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
