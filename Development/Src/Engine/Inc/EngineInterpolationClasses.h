/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "EngineNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_ENGINE_INTERPOLATION_ENUMS
#define INCLUDED_ENGINE_INTERPOLATION_ENUMS 1

enum EInterpTrackMoveRotMode
{
    IMR_Keyframed           =0,
    IMR_LookAtGroup         =1,
    IMR_Ignore              =2,
    IMR_MAX                 =3,
};
#define FOREACH_ENUM_EINTERPTRACKMOVEROTMODE(op) \
    op(IMR_Keyframed) \
    op(IMR_LookAtGroup) \
    op(IMR_Ignore) 
enum EInterpTrackMoveFrame
{
    IMF_World               =0,
    IMF_RelativeToInitial   =1,
    IMF_MAX                 =2,
};
#define FOREACH_ENUM_EINTERPTRACKMOVEFRAME(op) \
    op(IMF_World) \
    op(IMF_RelativeToInitial) 
enum EInterpMoveAxis
{
    AXIS_TranslationX       =0,
    AXIS_TranslationY       =1,
    AXIS_TranslationZ       =2,
    AXIS_RotationX          =3,
    AXIS_RotationY          =4,
    AXIS_RotationZ          =5,
    AXIS_MAX                =6,
};
#define FOREACH_ENUM_EINTERPMOVEAXIS(op) \
    op(AXIS_TranslationX) \
    op(AXIS_TranslationY) \
    op(AXIS_TranslationZ) \
    op(AXIS_RotationX) \
    op(AXIS_RotationY) \
    op(AXIS_RotationZ) 
enum EHeadTrackingAction
{
    EHTA_DisableHeadTracking=0,
    EHTA_EnableHeadTracking =1,
    EHTA_MAX                =2,
};
#define FOREACH_ENUM_EHEADTRACKINGACTION(op) \
    op(EHTA_DisableHeadTracking) \
    op(EHTA_EnableHeadTracking) 
enum ETrackToggleAction
{
    ETTA_Off                =0,
    ETTA_On                 =1,
    ETTA_Toggle             =2,
    ETTA_Trigger            =3,
    ETTA_MAX                =4,
};
#define FOREACH_ENUM_ETRACKTOGGLEACTION(op) \
    op(ETTA_Off) \
    op(ETTA_On) \
    op(ETTA_Toggle) \
    op(ETTA_Trigger) 
enum EVisibilityTrackCondition
{
    EVTC_Always             =0,
    EVTC_GoreEnabled        =1,
    EVTC_GoreDisabled       =2,
    EVTC_MAX                =3,
};
#define FOREACH_ENUM_EVISIBILITYTRACKCONDITION(op) \
    op(EVTC_Always) \
    op(EVTC_GoreEnabled) \
    op(EVTC_GoreDisabled) 
enum EVisibilityTrackAction
{
    EVTA_Hide               =0,
    EVTA_Show               =1,
    EVTA_Toggle             =2,
    EVTA_MAX                =3,
};
#define FOREACH_ENUM_EVISIBILITYTRACKACTION(op) \
    op(EVTA_Hide) \
    op(EVTA_Show) \
    op(EVTA_Toggle) 

#endif // !INCLUDED_ENGINE_INTERPOLATION_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_ENGINE_INTERPOLATION_CLASSES
#define INCLUDED_ENGINE_INTERPOLATION_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UInterpFilter : public UObject
{
public:
    //## BEGIN PROPS InterpFilter
    FStringNoInit Caption;
    //## END PROPS InterpFilter

    DECLARE_CLASS(UInterpFilter,UObject,0,Engine)
	/** 
	 * Given a interpdata object, updates visibility of groups and tracks based on the filter settings
	 *
	 * @param InData			Data to filter.
	 */
	virtual void FilterData(class USeqAct_Interp* InData);
};

class UInterpFilter_Classes : public UInterpFilter
{
public:
    //## BEGIN PROPS InterpFilter_Classes
#if WITH_EDITORONLY_DATA
    class UClass* ClassToFilterBy;
    TArrayNoInit<class UClass*> TrackClasses;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS InterpFilter_Classes

    DECLARE_CLASS(UInterpFilter_Classes,UInterpFilter,0,Engine)
	/** 
	 * Given a interpdata object, updates visibility of groups and tracks based on the filter settings
	 *
	 * @param InData			Data to filter.
	 */
	virtual void FilterData(class USeqAct_Interp* InData);
};

class UInterpFilter_Custom : public UInterpFilter
{
public:
    //## BEGIN PROPS InterpFilter_Custom
#if WITH_EDITORONLY_DATA
    TArrayNoInit<class UInterpGroup*> GroupsToInclude;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS InterpFilter_Custom

    DECLARE_CLASS(UInterpFilter_Custom,UInterpFilter,0,Engine)
	/** 
	 * Given a interpdata object, updates visibility of groups and tracks based on the filter settings
	 *
	 * @param InData			Data to filter.
	 */
	virtual void FilterData(class USeqAct_Interp* InData);
};

class UInterpGroup : public UObject, public FInterpEdInputInterface
{
public:
    //## BEGIN PROPS InterpGroup
    TArrayNoInit<class UInterpTrack*> InterpTracks;
    FName GroupName;
    FColor GroupColor;
    TArrayNoInit<class UAnimSet*> GroupAnimSets;
    BITFIELD bCollapsed:1;
    BITFIELD bVisible:1;
    BITFIELD bIsFolder:1;
    BITFIELD bIsParented:1;
    BITFIELD bIsSelected:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpGroup

    DECLARE_CLASS(UInterpGroup,UObject,0,Engine)
	// UObject interface
	virtual void PostLoad();

	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// UInterpGroup interface

	/** Iterate over all InterpTracks in this InterpGroup, doing any actions to bring the state to the specified time. */
	virtual void UpdateGroup(FLOAT NewPosition, class UInterpGroupInst* GrInst, UBOOL bPreview, UBOOL bJump);

	/** Ensure this group name is unique within this InterpData (its Outer). */
	void EnsureUniqueName();

	/** 
	 *	Find all the tracks in this group of a specific class.
	 *	Tracks are in the output array in the order they appear in the group.
	 */
	void FindTracksByClass(UClass* TrackClass, TArray<class UInterpTrack*>& OutputTracks);

	/** Returns whether this Group contains at least one AnimControl track. */
	UBOOL HasAnimControlTrack() const;

	/** Returns whether this Group contains a movement track. */
	UBOOL HasMoveTrack() const;

	/** Iterate over AnimControl tracks in this Group, build the anim blend info structures, and pass to the Actor via (Preview)SetAnimWeights. */
	void UpdateAnimWeights(FLOAT NewPosition, class UInterpGroupInst* GrInst, UBOOL bPreview, UBOOL bJump);

	/** Util for determining how many AnimControl tracks within this group are using the Slot with the supplied name. */
	INT GetAnimTracksUsingSlot(FName InSlotName);
};

class UInterpGroupAI : public UInterpGroup
{
public:
    //## BEGIN PROPS InterpGroupAI
#if WITH_EDITORONLY_DATA
    class UClass* PreviewPawnClass;
#endif // WITH_EDITORONLY_DATA
    FName StageMarkGroup;
    BITFIELD SnapToRootBoneLocationWhenFinished:1;
    BITFIELD bNoEncroachmentCheck:1;
    BITFIELD bDisableWorldCollision:1;
    BITFIELD bIgnoreLegacyHeightAdjust:1;
    BITFIELD bRecreatePreviewPawn:1;
    BITFIELD bRefreshStageMarkGroup:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpGroupAI

    DECLARE_CLASS(UInterpGroupAI,UInterpGroup,0,Engine)
	// Post edit
	// Need to refresh skelmesh if that changes
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// UInterpGroup interface
	virtual void UpdateGroup(FLOAT NewPosition, class UInterpGroupInst* GrInst, UBOOL bPreview, UBOOL bJump);
};

struct FCameraPreviewInfo
{
    class UClass* PawnClass;
    TArrayNoInit<class UAnimSet*> PreviewAnimSets;
    FName AnimSeqName;
    FVector Location;
    FRotator Rotation;
    class APawn* PawnInst;

    /** Constructors */
    FCameraPreviewInfo() {}
    FCameraPreviewInfo(EEventParm)
    {
        appMemzero(this, sizeof(FCameraPreviewInfo));
    }
};

class UInterpGroupCamera : public UInterpGroup
{
public:
    //## BEGIN PROPS InterpGroupCamera
    class UCameraAnim* CameraAnimInst;
#if WITH_EDITORONLY_DATA
    struct FCameraPreviewInfo Target;
#endif // WITH_EDITORONLY_DATA
    FLOAT CompressTolerance;
    //## END PROPS InterpGroupCamera

    DECLARE_CLASS(UInterpGroupCamera,UInterpGroup,0,Engine)
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class UInterpGroupDirector : public UInterpGroup
{
public:
    //## BEGIN PROPS InterpGroupDirector
    //## END PROPS InterpGroupDirector

    DECLARE_CLASS(UInterpGroupDirector,UInterpGroup,0,Engine)
	// UInterpGroup interface
	virtual void UpdateGroup(FLOAT NewPosition, class UInterpGroupInst* GrInst, UBOOL bPreview, UBOOL bJump);

	// UInterpGroupDirector interface
	class UInterpTrackDirector* GetDirectorTrack();
	class UInterpTrackFade* GetFadeTrack();
	class UInterpTrackSlomo* GetSlomoTrack();
	class UInterpTrackColorScale* GetColorScaleTrack();
	class UInterpTrackAudioMaster* GetAudioMasterTrack();
};

class UInterpGroupInst : public UObject
{
public:
    //## BEGIN PROPS InterpGroupInst
    class UInterpGroup* Group;
    class AActor* GroupActor;
    TArrayNoInit<class UInterpTrackInst*> TrackInst;
    FPostProcessSettings* CachedCamOverridePostProcess;
    //## END PROPS InterpGroupInst

    DECLARE_CLASS(UInterpGroupInst,UObject,0,Engine)
	/** 
	 *	Returns the Actor that this GroupInstance is working on. 
	 *	Should use this instead of just referencing GroupActor, as it check bDeleteMe for you.
	 */
	virtual AActor* GetGroupActor();

	/** Called before Interp editing to save original state of Actor. @see UInterpTrackInst::SaveActorState */
	virtual void SaveGroupActorState();

	/** Called after Interp editing to put object back to its original state. @see UInterpTrackInst::RestoreActorState */
	virtual void RestoreGroupActorState();

	/**  
	 * Returns if this group contains this Actor
	 */
	virtual UBOOL HasActor(AActor * InActor)
	{
		return (GetGroupActor() == InActor);
	};

	/** 
	 *	Initialse this Group instance. Called from USeqAct_Interp::InitInterp before doing any interpolation.
	 *	Save the Actor for the group and creates any needed InterpTrackInsts
	 */
	virtual void InitGroupInst(UInterpGroup* InGroup, AActor* InGroupActor);

	/** 
	 *	Called when done with interpolation sequence. Cleans up InterpTrackInsts etc. 
	 *	Do not do anything further with the Interpolation after this.
	 */
	virtual void TermGroupInst(UBOOL bDeleteTrackInst);

	/** Force any actors attached to this group's actor to update their position using their relative location/rotation. */
	void UpdateAttachedActors();

	/** Caches or Restores the PPS at the Start/End of the matinee sequence */
	UBOOL HasPPS( void );
	void CreatePPS( void );
	void CachePPS( const FPostProcessSettings& PPSettings );
	void RestorePPS( FPostProcessSettings& PPSettings );
	void DestroyPPS( void );
	void FreePPS( void );
};

class UInterpGroupInstAI : public UInterpGroupInst
{
public:
    //## BEGIN PROPS InterpGroupInstAI
    class UInterpGroupAI* AIGroup;
    BYTE SavedPhysics;
    SCRIPT_ALIGN;
    BITFIELD bSavedNoEncroachCheck:1;
    BITFIELD bSavedCollideActors:1;
    BITFIELD bSavedBlockActors:1;
#if WITH_EDITORONLY_DATA
    class APawn* PreviewPawn;
#endif // WITH_EDITORONLY_DATA
    class AActor* StageMarkActor;
    //## END PROPS InterpGroupInstAI

    DECLARE_CLASS(UInterpGroupInstAI,UInterpGroupInst,0,Engine)
	/** 
	 *	Returns the Actor that this GroupInstance is working on. 
	 *	Should use this instead of just referencing GroupActor, as it check bDeleteMe for you.
	 */
	virtual AActor* GetGroupActor();

	virtual UBOOL HasActor(AActor * InActor);

	/** 
	 *	Initialze this Group instance. Called from USeqAct_Interp::InitInterp before doing any interpolation.
	 *	Save the Actor for the group and creates any needed InterpTrackInsts
	 */
	virtual void InitGroupInst( UInterpGroup* InGroup, AActor* InGroupActor );

	/** 
	 *	Initialze this Group instance from Seq Variable
	 */
	void UpdatePreviewPawnFromSeqVarCharacter( UInterpGroup* InGroup, const USeqVar_Character* InGroupObject );

	/**
	 * Create Preview Pawn/Destroy Preview Pawn
	 */ 
	void CreatePreviewPawn();
	void DestroyPreviewPawn();

	/**
	 * Get Stage Mark Actor ground position & rotation
	 */
	FVector     GetStageMarkPosition(FRotator* Rotation = NULL);
	
	/** 
	 *  Update Stage Mark Group Actor
	 */ 
	void UpdateStageMarkGroupActor(USeqAct_Interp * Seq);


	/** 
	 *	Called when done with interpolation sequence. Cleans up InterpTrackInsts etc. 
	 *	Do not do anything further with the Interpolation after this.
	 */
	virtual void TermGroupInst(UBOOL bDeleteTrackInst);

	/** 
	 *  Update Physics state if it includes Movement Track 
	 *  Or terminate if bInit = FALSE
	 */ 
	void UpdatePhysics(UBOOL bInit);
};

class UInterpGroupInstCamera : public UInterpGroupInst
{
public:
    //## BEGIN PROPS InterpGroupInstCamera
    //## END PROPS InterpGroupInstCamera

    DECLARE_CLASS(UInterpGroupInstCamera,UInterpGroupInst,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterpGroupInstCamera)
};

class UInterpGroupInstDirector : public UInterpGroupInst
{
public:
    //## BEGIN PROPS InterpGroupInstDirector
    //## END PROPS InterpGroupInstDirector

    DECLARE_CLASS(UInterpGroupInstDirector,UInterpGroupInst,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterpGroupInstDirector)
};

struct FBoolTrackKey
{
    FLOAT Time;
    BITFIELD Value:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FBoolTrackKey() {}
    FBoolTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FBoolTrackKey));
    }
};

class UInterpTrackBoolProp : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackBoolProp
    TArrayNoInit<struct FBoolTrackKey> BoolTrack;
    FName PropertyName;
    //## END PROPS InterpTrackBoolProp

    DECLARE_CLASS(UInterpTrackBoolProp,UInterpTrack,0,Engine)
	/** Returns the property name */
	virtual UBOOL GetPropertyName( FName& PropertyNameOut ) const { PropertyNameOut = PropertyName; return TRUE; }

	/**
	 * @return  The number of keyframes currently in this track.
	 */
	virtual INT GetNumKeyframes() const;

	/**
	 * Gathers the range that spans all keyframes.
	 * 
	 * @param   StartTime   [out] The time of the first keyframe on this track.
	 * @param   EndTime     [out] The time of the last keyframe on this track. 
	 */
	virtual void GetTimeRange( FLOAT& StartTime, FLOAT& EndTime ) const;
	
	/**
	 * @return	The ending time of the track. 
	 */
	virtual FLOAT GetTrackEndTime() const;

	/**
	 * @param   KeyIndex    The index of the key to retrieve the time in the track's key array. 
	 * 
	 * @return  The time of the given key in the track on the timeline. 
	 */
	virtual FLOAT GetKeyframeTime( INT KeyIndex ) const;

	/**
	 * Changes the time of the given key with the new given time.
	 * 
	 * @param   KeyIndex        The index key to change in the track's key array.
	 * @param   NewKeyTime      The new time for the given key in the timeline.
	 * @param   bUpdateOrder    When TRUE, moves the key to be in chronological order in the array. 
	 * 
	 * @return  The new index for the given key. 
	 */
	virtual INT SetKeyframeTime( INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder = TRUE );

	/**
	 * Removes the given key from the array of keys in the track.
	 * 
	 * @param   KeyIndex    The index of the key to remove in this track's array of keys. 
	 */
	virtual void RemoveKeyframe( INT KeyIndex );

	/**
	 * Duplicates the given key.
	 * 
	 * @param   KeyIndex    The index of the key to duplicate in this track's array of keys.
	 * @param   NewKeyTime  The time to assign to the duplicated key.
	 * 
	 * @return  The new index for the given key.
	 */
	virtual INT DuplicateKeyframe( INT KeyIndex, FLOAT NewKeyTime );

	/**
	 * Gets the position of the closest key with snapping incorporated.
	 * 
	 * @param   InPosition  The current position in the timeline.
	 * @param   IgnoreKeys  The set of keys to ignore when searching for the closest key.
	 * @param   OutPosition The position of the closest key with respect to snapping and ignoring the given set of keys.
	 * 
	 * @return  TRUE if a keyframe was found; FALSE if no keyframe was found. 
	 */
	virtual UBOOL GetClosestSnapPosition( FLOAT InPosition, TArray<INT>& IgnoreKeys, FLOAT& OutPosition );

	/**
	 * Adds a keyframe at the given time to the track.
	 * 
	 * @param	Time			The time to place the key in the track timeline.
	 * @param	TrackInst		The instance of this track. 
	 * @param	InitInterpMode	The interp mode of the newly-added keyframe.
	 */
	virtual INT AddKeyframe( FLOAT Time, UInterpTrackInst* TrackInst, EInterpCurveMode InitInterpMode );

	/**
	 * Changes the value of an existing keyframe.
	 *
	 * @param	KeyIndex	The index of the key to update in the track's key array. 
	 * @param	TrackInst	The instance of this track to update. 
	 */
	virtual void UpdateKeyframe( INT KeyIndex, UInterpTrackInst* TrackInst );

	/**
	 * Updates the instance of this track based on the new position. This is for editor preview.
	 *
	 * @param	NewPosition	The position of the track in the timeline. 
	 * @param	TrackInst	The instance of this track to update. 
	 */
	virtual void PreviewUpdateTrack( FLOAT NewPosition, UInterpTrackInst* TrackInst );

	/** 
	 * Updates the instance of this track based on the new position. This is called in the game, when USeqAct_Interp is ticked.
	 *
	 * @param	NewPosition	The position of the track in the timeline. 
	 * @param	TrackInst	The instance of this track to update. 
	 * @param	bJump		Indicates if this is a sudden jump instead of a smooth move to the new position.
	 */
	virtual void UpdateTrack( FLOAT NewPosition, UInterpTrackInst* TrackInst, UBOOL bJump );

	/** 
	 * @return  TRUE if this track type works with static actors; FALSE, otherwise.
	 */
	virtual UBOOL AllowStaticActors() { return TRUE; }
	
	/** 
	 * Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	 * 
	 * @return	String name of the helper class.
	 */
	virtual const FString GetEdHelperClassName() const;

	/** 
	 * @return	The icon to draw for this track in Matinee. 
	 */
	virtual class UMaterial* GetTrackIcon() const;
};

struct FDirectorTrackCut
{
    FLOAT Time;
    FLOAT TransitionTime;
    FName TargetCamGroup;
    INT ShotNumber;

    /** Constructors */
    FDirectorTrackCut() {}
    FDirectorTrackCut(EEventParm)
    {
        appMemzero(this, sizeof(FDirectorTrackCut));
    }
};

class UInterpTrackDirector : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackDirector
    TArrayNoInit<struct FDirectorTrackCut> CutTrack;
    BITFIELD bSimulateCameraCutsOnClients:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackDirector

    DECLARE_CLASS(UInterpTrackDirector,UInterpTrack,0,Engine)
    // UObject interface
	virtual void PostLoad();

	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT GetKeyframeIndex( FLOAT KeyTime ) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;
	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );

	// InterpTrackDirector interface
	FName GetViewedGroupName(FLOAT CurrentTime, FLOAT& CutTime, FLOAT& CutTransitionTime);
	const FString GetViewedCameraShotName(FLOAT CurrentTime) const;
	
	const INT GenerateCameraShotNumber(INT KeyIndex) const;
	const FString GetFormattedCameraShotName(INT KeyIndex) const;
	void DisplayShotNamesInHUD(UInterpGroupInst* GrInst, APlayerController* PC, FLOAT Time);
};

struct FEventTrackKey
{
    FLOAT Time;
    FName EventName;

    /** Constructors */
    FEventTrackKey() {}
    FEventTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FEventTrackKey));
    }
};

class UInterpTrackEvent : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackEvent
    TArrayNoInit<struct FEventTrackKey> EventTrack;
    BITFIELD bFireEventsWhenForwards:1;
    BITFIELD bFireEventsWhenBackwards:1;
    BITFIELD bFireEventsWhenJumpingForwards:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackEvent

    DECLARE_CLASS(UInterpTrackEvent,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );
};

struct FFaceFXTrackKey
{
    FLOAT StartTime;
    FStringNoInit FaceFXGroupName;
    FStringNoInit FaceFXSeqName;

    /** Constructors */
    FFaceFXTrackKey() {}
    FFaceFXTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FFaceFXTrackKey));
    }
};

struct FFaceFXSoundCueKey
{
    class USoundCue* FaceFXSoundCue;

    /** Constructors */
    FFaceFXSoundCueKey() {}
    FFaceFXSoundCueKey(EEventParm)
    {
        appMemzero(this, sizeof(FFaceFXSoundCueKey));
    }
};

class UInterpTrackFaceFX : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackFaceFX
    TArrayNoInit<class UFaceFXAnimSet*> FaceFXAnimSets;
    TArrayNoInit<struct FFaceFXTrackKey> FaceFXSeqs;
    class UFaceFXAsset* CachedActorFXAsset;
    TArrayNoInit<struct FFaceFXSoundCueKey> FaceFXSoundCueKeys;
    //## END PROPS InterpTrackFaceFX

    DECLARE_CLASS(UInterpTrackFaceFX,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	//virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);
	//virtual FColor GetKeyframeColor(INT KeyIndex) const;

	virtual void PreviewUpdateTrack(FLOAT NewPosition, class UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void PreviewStopPlayback(class UInterpTrackInst* TrInst);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;
	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );
	
	// InterpTrackFaceFX interface
	void GetSeqInfoForTime( FLOAT InTime, FString& OutGroupName, FString& OutSeqName, FLOAT& OutPosition, FLOAT& OutSeqStart, USoundCue*& OutSoundCue );

	/** Updates references to sound cues for all of this track's FaceFX animation keys.  Should be called at
		load time in the editor as well as whenever the track's data is changed. */
	void UpdateFaceFXSoundCueReferences( class UFaceFXAsset* FaceFXAsset );
};

class UInterpTrackFloatBase : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackFloatBase
    FInterpCurveFloat FloatTrack;
    FLOAT CurveTension;
    //## END PROPS InterpTrackFloatBase

    DECLARE_ABSTRACT_CLASS(UInterpTrackFloatBase,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);
	virtual FColor GetKeyframeColor(INT KeyIndex) const;

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();
};

struct FAnimControlTrackKey
{
    FLOAT StartTime;
    FName AnimSeqName;
    FLOAT AnimStartOffset;
    FLOAT AnimEndOffset;
    FLOAT AnimPlayRate;
    BITFIELD bLooping:1;
    BITFIELD bReverse:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FAnimControlTrackKey() {}
    FAnimControlTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FAnimControlTrackKey));
    }
};

class UInterpTrackAnimControl : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackAnimControl
    TArrayNoInit<class UAnimSet*> AnimSets;
    FName SlotName;
    TArrayNoInit<struct FAnimControlTrackKey> AnimSeqs;
    BITFIELD bEnableRootMotion:1;
    BITFIELD bSkipAnimNotifiers:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackAnimControl

    DECLARE_CLASS(UInterpTrackAnimControl,UInterpTrackFloatBase,0,Engine)
	// UObject interface
	virtual void PostLoad();

	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);
	virtual FColor GetKeyframeColor(INT KeyIndex) const;

	virtual void PreviewUpdateTrack(FLOAT NewPosition, class UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** 
	 * Calculates the reversed time for a sequence key, if the key has bReverse set.
	 *
	 * @param SeqKey		Key that is reveresed and we are trying to find a position for.
	 * @param Seq			Anim sequence the key represents.  If NULL, the function will lookup the sequence.
	 * @param InPosition	Timeline position that we are currently at.
	 *
	 * @return Returns the position in the specified seq key. 
	 */
	FLOAT ConditionallyReversePosition(FAnimControlTrackKey &SeqKey, UAnimSequence* Seq, FLOAT InPosition);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;
	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );
	
	// InterpTrackAnimControl interface
	class UAnimSequence* FindAnimSequenceFromName(FName InName);
	const class UAnimSequence* FindAnimSequenceFromName(FName InName) const;
	/** Get Animation for the given Time 
	 *  @return TRUE if it needs the animation to advance timer (from Previous to Current Time for Root Motion
	 */
	UBOOL GetAnimForTime(FLOAT InTime, FName& OutAnimSeqName, FLOAT& OutPosition, UBOOL& bOutLooping);
	FLOAT GetWeightForTime(FLOAT InTime);
	INT SplitKeyAtPosition(FLOAT InPosition);

	/**
	 * Crops the key at the position specified, by deleting the area of the key before or after the position.
	 *
	 * @param InPosition				Position to use as a crop point.
	 * @param bCutAreaBeforePosition	Whether we should delete the area of the key before the position specified or after.
	 *
	 * @return Returns the index of the key that was cropped.
	 */
	INT CropKeyAtPosition(FLOAT InPosition, UBOOL bCutAreaBeforePosition);

	// FInterpEdInputInterface

	/**
	 * Lets the interface object know that we are beginning a drag operation.
	 */
	virtual void BeginDrag(FInterpEdInputData &InputData);

	/**
	 * Lets the interface object know that we are ending a drag operation.
	 */
	virtual void EndDrag(FInterpEdInputData &InputData);

	/**
	 * @return Returns the mouse cursor to display when this input interface is moused over.
	 */
	EMouseCursor GetMouseCursor(FInterpEdInputData &InputData);

	/**
	 * Called when an object is dragged.
	 */
	void ObjectDragged(FInterpEdInputData& InputData);

	/** Calculate the index of this Track within its Slot (for when multiple tracks are using same slot). */
	INT CalcChannelIndex();
};

class UInterpTrackFade : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackFade
    BITFIELD bPersistFade:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackFade

    DECLARE_CLASS(UInterpTrackFade,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	virtual class UMaterial* GetTrackIcon() const;

	// InterpTrackFade interface
	FLOAT GetFadeAmountAtTime(FLOAT Time);
};

class UInterpTrackFloatMaterialParam : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackFloatMaterialParam
    TArrayNoInit<struct FMaterialReferenceList> Materials;
    class UMaterialInterface* Material_DEPRECATED;
    FName ParamName;
    BITFIELD bNeedsMaterialRefsUpdate:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackFloatMaterialParam

    DECLARE_CLASS(UInterpTrackFloatMaterialParam,UInterpTrackFloatBase,0,Engine)
	virtual void PreSave();
	virtual void PostLoad();
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostDuplicate();

	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	//virtual class UMaterial* GetTrackIcon() const;
};

class UInterpTrackFloatParticleParam : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackFloatParticleParam
    FName ParamName;
    //## END PROPS InterpTrackFloatParticleParam

    DECLARE_CLASS(UInterpTrackFloatParticleParam,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	//virtual class UMaterial* GetTrackIcon() const;
};

class UInterpTrackFloatProp : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackFloatProp
    FName PropertyName;
    //## END PROPS InterpTrackFloatProp

    DECLARE_CLASS(UInterpTrackFloatProp,UInterpTrackFloatBase,0,Engine)
	/** Returns the property name */
	virtual UBOOL GetPropertyName( FName& PropertyNameOut ) const { PropertyNameOut = PropertyName; return TRUE; }

	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;

	/** 
	 * Reduce Keys within Tolerance
	 *
	 * @param bIntervalStart	start of the key to reduce
	 * @param bIntervalEnd		end of the key to reduce
	 * @param Tolerance			tolerance
	 */
	virtual void ReduceKeys( FLOAT IntervalStart, FLOAT IntervalEnd, FLOAT Tolerance );
};

class UInterpTrackMorphWeight : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackMorphWeight
    FName MorphNodeName;
    //## END PROPS InterpTrackMorphWeight

    DECLARE_CLASS(UInterpTrackMorphWeight,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
};

struct FInterpLookupPoint
{
    FName GroupName;
    FLOAT Time;

    /** Constructors */
    FInterpLookupPoint() {}
    FInterpLookupPoint(EEventParm)
    {
        appMemzero(this, sizeof(FInterpLookupPoint));
    }
};

struct FInterpLookupTrack
{
    TArrayNoInit<struct FInterpLookupPoint> Points;

		/** Add a new keypoint to the LookupTrack.  Returns the index of the new key.*/
		INT AddPoint( const FLOAT InTime, FName &InGroupName )
		{
			INT PointIdx=0; 
			
			for( PointIdx=0; PointIdx<Points.Num() && Points(PointIdx).Time < InTime; PointIdx++);
			
			Points.Insert(PointIdx);
			Points(PointIdx).Time = InTime;
			Points(PointIdx).GroupName = InGroupName;

			return PointIdx;
		}

		/** Move a keypoint to a new In value. This may change the index of the keypoint, so the new key index is returned. */
		INT MovePoint( INT PointIndex, FLOAT NewTime )
		{
			if( PointIndex < 0 || PointIndex >= Points.Num() )
			{
				return PointIndex;
			}

			FName GroupName = Points(PointIndex).GroupName;

			Points.Remove(PointIndex);

			const INT NewPointIndex = AddPoint( NewTime, GroupName );

			return NewPointIndex;
		}
	
};

class UInterpTrackMove : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackMove
    FInterpCurveVector PosTrack;
    FInterpCurveVector EulerTrack;
    struct FInterpLookupTrack LookupTrack;
    FName LookAtGroupName;
    FLOAT LinCurveTension;
    FLOAT AngCurveTension;
    BITFIELD bUseQuatInterpolation:1;
    BITFIELD bShowArrowAtKeys:1;
    BITFIELD bDisableMovement:1;
    BITFIELD bShowTranslationOnCurveEd:1;
    BITFIELD bShowRotationOnCurveEd:1;
    BITFIELD bHide3DTrack:1;
    BITFIELD bUseRawActorTMforRelativeToInitial:1;
    SCRIPT_ALIGN;
    BYTE MoveFrame;
    BYTE RotMode;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackMove

    DECLARE_CLASS(UInterpTrackMove,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostEditImport();

	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	
	/**
     * Adds a keyframe to a child track 
	 *
	 * @param ChildTrack		The child track where the keyframe should be added
	 * @param Time				What time the keyframe is located at
	 * @param TrackInst			The track instance of the parent track(this track)
	 * @param InitInterpMode	The initial interp mode for the keyframe?	 
	 */
	virtual INT AddChildKeyframe(class UInterpTrack* ChildTrack, FLOAT Time, UInterpTrackInst* TrackInst, EInterpCurveMode InitInterpMode);

	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);

	/**
     * Updates a child track keyframe
	 *
	 * @param ChildTrack		The child track with keyframe to update
	 * @param KeyIndex			The index of the key to be updated
	 * @param TrackInst			The track instance of the parent track(this track)
	 */
	virtual void UpdateChildKeyframe( class UInterpTrack* ChildTrack, INT KeyIndex, UInterpTrackInst* TrackInst );

	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void ConditionalPreviewUpdateTrack(FLOAT NewPosition, class UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);

	virtual class UMaterial* GetTrackIcon() const;
	virtual FColor GetKeyframeColor(INT KeyIndex) const;
	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );
	virtual void Render3DTrack(UInterpTrackInst* TrInst, const FSceneView* View, FPrimitiveDrawInterface* PDI, INT TrackIndex, const FColor& TrackColor, TArray<class FInterpEdSelKey>& SelectedKeys);
	virtual void SetTrackToSensibleDefault();

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();


	// InterpTrackMove interface
	virtual FName GetLookupKeyGroupName(INT KeyIndex);
	virtual void SetLookupKeyGroupName(INT KeyIndex, const FName &NewGroupName);
	virtual void ClearLookupKeyGroupName(INT KeyIndex);

	/**
	 * Replacement for the PosTrack eval function that uses GetKeyframePosition.  This is so we can replace keyframes that get their information from other tracks.
	 *
	 * @param TrInst	TrackInst to use for looking up groups.
	 * @param Time		Time to evaluate position at.
	 * @return			Final position at the specified time.
	 */
	FVector EvalPositionAtTime(UInterpTrackInst* TrInst, FLOAT Time);

	/**
	 * Replacement for the EulerTrack eval function that uses GetKeyframeRotation.  This is so we can replace keyframes that get their information from other tracks.
	 *
	 * @param TrInst	TrackInst to use for looking up groups.
	 * @param Time		Time to evaluate rotation at.
	 * @return			Final rotation at the specified time.
	 */
	FVector EvalRotationAtTime(UInterpTrackInst* TrInst, FLOAT Time);

	/**
	 * Gets the position of a keyframe given its key index.  Also optionally retrieves the Arrive and Leave tangents for the key.
	 * This function respects the LookupTrack.
	 *
	 * @param TrInst			TrackInst to use for lookup track positions.
	 * @param KeyIndex			Index of the keyframe to get the position of.
	 * @param OutTime           Final time of the keyframe.
	 * @param OutPos			Final position of the keyframe.
	 * @param OutArriveTangent	Pointer to a vector to store the arrive tangent in, can be NULL.
	 * @param OutLeaveTangent	Pointer to a vector to store the leave tangent in, can be NULL.
	 */
	void GetKeyframePosition(UInterpTrackInst* TrInst, INT KeyIndex, FLOAT& OutTime, FVector &OutPos, FVector *OutArriveTangent, FVector *OutLeaveTangent);

	/**
	 * Gets the rotation of a keyframe given its key index.  Also optionally retrieves the Arrive and Leave tangents for the key.
	 * This function respects the LookupTrack.
	 *
	 * @param TrInst			TrackInst to use for lookup track rotations.
	 * @param KeyIndex			Index of the keyframe to get the rotation of.
	 * @param OutTime           Final time of the keyframe.
	 * @param OutRot			Final rotation of the keyframe.
	 * @param OutArriveTangent	Pointer to a vector to store the arrive tangent in, can be NULL.
	 * @param OutLeaveTangent	Pointer to a vector to store the leave tangent in, can be NULL.
	 */
	void GetKeyframeRotation(UInterpTrackInst* TrInst, INT KeyIndex, FLOAT& OutTime, FVector &OutRot, FVector *OutArriveTangent, FVector *OutLeaveTangent);

    /**
     * Computes the world space coordinates for a key; handles keys that use IMF_RelativeToInitial, basing, etc.
     *
     * @param MoveTrackInst		An instance of this movement track
     * @param RelativeSpacePos	Key position value from curve
     * @param RelativeSpaceRot	Key rotation value from curve
     * @param OutPos			Output world space position
     * @param OutRot			Output world space rotation
     */
    void ComputeWorldSpaceKeyTransform( UInterpTrackInstMove* MoveTrackInst,
                                        const FVector& RelativeSpacePos,
								        const FRotator& RelativeSpaceRot,
								        FVector& OutPos,
                                        FRotator& OutRot );
													      
	virtual void GetKeyTransformAtTime(UInterpTrackInst* TrInst, FLOAT Time, FVector& OutPos, FRotator& OutRot);
	virtual UBOOL GetLocationAtTime(UInterpTrackInst* TrInst, FLOAT Time, FVector& OutPos, FRotator& OutRot);
	virtual FMatrix GetMoveRefFrame(UInterpTrackInstMove* MoveTrackInst);
	/** 
	 * Find Best Matching Time From Position
	 * This function simply try to find Time from input Position using simple Lerp
	 * 
	 * @param : Pos  - input position
	 * @param : StartKeyIndex - optional
	 *
	 * @return : Interp Time
	 */
	FLOAT FindBestMatchingTimefromPosition(UInterpTrackInst* TrInst, const FVector& Pos, INT StartKeyIndex=0, EAxis WeightAxis = AXIS_XY);

	INT CalcSubIndex(UBOOL bPos, INT InIndex) const;

	/**
     * Creates and adds subtracks to this track
	 *
	 * @param bCopy	If subtracks are being added as a result of a copy
	 */
	virtual void CreateSubTracks( UBOOL bCopy );

	/**
	 * Splits this movment track in to seperate tracks for translation and rotation
	 */
	void SplitTranslationAndRotation();

	/** 
	 * Reduce Keys within Tolerance
	 *
	 * @param bIntervalStart	start of the key to reduce
	 * @param bIntervalEnd		end of the key to reduce
	 * @param Tolerance			tolerance
	 */
	virtual void ReduceKeys( FLOAT IntervalStart, FLOAT IntervalEnd, FLOAT Tolerance );
};

class UInterpTrackMoveAxis : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackMoveAxis
    BYTE MoveAxis;
    SCRIPT_ALIGN;
    struct FInterpLookupTrack LookupTrack;
    //## END PROPS InterpTrackMoveAxis

    DECLARE_CLASS(UInterpTrackMoveAxis,UInterpTrackFloatBase,0,Engine)
	virtual INT GetKeyframeIndex( FLOAT KeyTime ) const;
	virtual INT AddKeyframe( FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode );
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual INT SetKeyframeTime( INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder );
	virtual void RemoveKeyframe( INT KeyIndex );
	virtual INT DuplicateKeyframe( INT KeyIndex, FLOAT NewKeyTime );
	FName GetLookupKeyGroupName( INT KeyIndex );
	void SetLookupKeyGroupName( INT KeyIndex, const FName& NewGroupName );
	void ClearLookupKeyGroupName( INT KeyIndex );
	
	// FCurveEdInterface interface
	virtual FColor GetSubCurveButtonColor( INT SubCurveIndex, UBOOL bIsSubCurveHidden ) const;
	virtual INT CreateNewKey( FLOAT KeyIn );
	virtual void DeleteKey( INT KeyIndex );
	virtual INT SetKeyIn( INT KeyIndex, FLOAT NewInVal );

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	void GetKeyframeValue( UInterpTrackInst* TrInst, INT KeyIndex, FLOAT& OutTime, FLOAT &OutValue, FLOAT* OutArriveTangent, FLOAT* OutLeaveTangent );
	FLOAT EvalValueAtTime( UInterpTrackInst* TrInst, FLOAT Time );

	virtual class UMaterial* GetTrackIcon() const;

	/** 
	 * Reduce Keys within Tolerance
	 *
	 * @param bIntervalStart	start of the key to reduce
	 * @param bIntervalEnd		end of the key to reduce
	 * @param Tolerance			tolerance
	 */
	virtual void ReduceKeys( FLOAT IntervalStart, FLOAT IntervalEnd, FLOAT Tolerance );
};

class UInterpTrackSkelControlScale : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackSkelControlScale
    FName SkelControlName;
    //## END PROPS InterpTrackSkelControlScale

    DECLARE_CLASS(UInterpTrackSkelControlScale,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
};

class UInterpTrackSkelControlStrength : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackSkelControlStrength
    FName SkelControlName;
    //## END PROPS InterpTrackSkelControlStrength

    DECLARE_CLASS(UInterpTrackSkelControlStrength,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
};

class UInterpTrackSlomo : public UInterpTrackFloatBase
{
public:
    //## BEGIN PROPS InterpTrackSlomo
    //## END PROPS InterpTrackSlomo

    DECLARE_CLASS(UInterpTrackSlomo,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void SetTrackToSensibleDefault();

	virtual class UMaterial* GetTrackIcon() const;

	// InterpTrackSlomo interface
	FLOAT GetSlomoFactorAtTime(FLOAT Time);
};

struct FHeadTrackingKey
{
    FLOAT Time;
    BYTE Action;
    SCRIPT_ALIGN;

    /** Constructors */
    FHeadTrackingKey() {}
    FHeadTrackingKey(EEventParm)
    {
        appMemzero(this, sizeof(FHeadTrackingKey));
    }
};

class UInterpTrackHeadTracking : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackHeadTracking
    TArrayNoInit<struct FHeadTrackingKey> HeadTrackingTrack;
    TArrayNoInit<FName> TrackControllerName;
    FLOAT LookAtActorRadius;
    BITFIELD bDisableBeyondLimit:1;
    BITFIELD bLookAtPawns:1;
    FLOAT MaxLookAtTime;
    FLOAT MinLookAtTime;
    FLOAT MaxInterestTime;
    TArrayNoInit<class UClass*> ActorClassesToLookAt;
    TArrayNoInit<FName> TargetBoneNames;
    //## END PROPS InterpTrackHeadTracking

    DECLARE_CLASS(UInterpTrackHeadTracking,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );

private:
	/** Update Actor List for look at candidate **/
	void    UpdateHeadTracking(AActor* Actor, UInterpTrackInst* TrInst, FLOAT DeltaTime);
};

class UInterpTrackLinearColorBase : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackLinearColorBase
    FInterpCurveLinearColor LinearColorTrack;
    FLOAT CurveTension;
    //## END PROPS InterpTrackLinearColorBase

    DECLARE_ABSTRACT_CLASS(UInterpTrackLinearColorBase,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	void Serialize(FArchive& Ar)
	{
		Super::Serialize(Ar);
	}

	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const; 
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual FColor GetKeyframeColor(INT KeyIndex) const;

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();
};

class UInterpTrackLinearColorProp : public UInterpTrackLinearColorBase
{
public:
    //## BEGIN PROPS InterpTrackLinearColorProp
    FName PropertyName;
    //## END PROPS InterpTrackLinearColorProp

    DECLARE_CLASS(UInterpTrackLinearColorProp,UInterpTrackLinearColorBase,0,Engine)
	/** Returns the property name */
	virtual UBOOL GetPropertyName( FName& PropertyNameOut ) const { PropertyNameOut = PropertyName; return TRUE; }

	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	 *
	 * @return	String name of the helper class.
	 */
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;
};

struct FNotifyTrackKey
{
    FLOAT Time;
    class UAnimNotify* Notify;

    /** Constructors */
    FNotifyTrackKey() {}
    FNotifyTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FNotifyTrackKey));
    }
};

class UInterpTrackNotify : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackNotify
    class UAnimNodeSequence* Node;
    FName ParentNodeName;
    class UAnimSequence* OuterSequence;
    class UAnimSet* OuterSet;
    TArrayNoInit<struct FNotifyTrackKey> NotifyTrack;
    //## END PROPS InterpTrackNotify

    DECLARE_CLASS(UInterpTrackNotify,UInterpTrack,0,Engine)
	// UObject interface
	//virtual void PostLoad();

	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);
	//virtual FColor GetKeyframeColor(INT KeyIndex) const;

	virtual void PreviewUpdateTrack(FLOAT NewPosition, class UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;
	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );
};

struct FParticleReplayTrackKey
{
    FLOAT Time;
    FLOAT Duration;
    INT ClipIDNumber;

    /** Constructors */
    FParticleReplayTrackKey() {}
    FParticleReplayTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FParticleReplayTrackKey));
    }
};

class UInterpTrackParticleReplay : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackParticleReplay
    TArrayNoInit<struct FParticleReplayTrackKey> TrackKeys;
    BITFIELD bIsCapturingReplay:1;
#if WITH_EDITORONLY_DATA
    FLOAT FixedTimeStep;
#else
    SCRIPT_ALIGN;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS InterpTrackParticleReplay

    DECLARE_CLASS(UInterpTrackParticleReplay,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	/**
	 * Lets the interface object know that we are beginning a drag operation.
	 */
	virtual void BeginDrag(FInterpEdInputData &InputData);

	/**
	 * Lets the interface object know that we are ending a drag operation.
	 */
	virtual void EndDrag(FInterpEdInputData &InputData);

	/**
	 * @return Returns the mouse cursor to display when this input interface is moused over.
	 */
	EMouseCursor GetMouseCursor(FInterpEdInputData &InputData);

	/**
	 * Called when an object is dragged.
	 */
	void ObjectDragged(FInterpEdInputData& InputData);

	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );
};

struct FToggleTrackKey
{
    FLOAT Time;
    BYTE ToggleAction;
    SCRIPT_ALIGN;

    /** Constructors */
    FToggleTrackKey() {}
    FToggleTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FToggleTrackKey));
    }
};

class UInterpTrackToggle : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackToggle
    TArrayNoInit<struct FToggleTrackKey> ToggleTrack;
    BITFIELD bActivateSystemEachUpdate:1;
    BITFIELD bActivateWithJustAttachedFlag:1;
    BITFIELD bFireEventsWhenForwards:1;
    BITFIELD bFireEventsWhenBackwards:1;
    BITFIELD bFireEventsWhenJumpingForwards:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackToggle

    DECLARE_CLASS(UInterpTrackToggle,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );
};

class UInterpTrackVectorBase : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackVectorBase
    FInterpCurveVector VectorTrack;
    FLOAT CurveTension;
    //## END PROPS InterpTrackVectorBase

    DECLARE_ABSTRACT_CLASS(UInterpTrackVectorBase,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual FColor GetKeyframeColor(INT KeyIndex) const;

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves() const;

	/**
	 * Provides the color for the sub-curve button that is present on the curve tab.
	 *
	 * @param	SubCurveIndex		The index of the sub-curve. Cannot be negative nor greater or equal to the number of sub-curves.
	 * @param	bIsSubCurveHidden	Is the curve hidden?
	 * @return						The color associated to the given sub-curve index.
	 */
	virtual FColor	GetSubCurveButtonColor(INT SubCurveIndex, UBOOL bIsSubCurveHidden) const;

	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);

	/**
	 * Provides the color for the given key at the given sub-curve.
	 *
	 * @param		SubIndex	The index of the sub-curve
	 * @param		KeyIndex	The index of the key in the sub-curve
	 * @param[in]	CurveColor	The color of the curve
	 * @return					The color that is associated the given key at the given sub-curve
	 */
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);

	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);

	/** Returns TRUE if this curve uses legacy tangent/interp algorithms and may be 'upgraded' */
	virtual UBOOL	UsingLegacyInterpMethod() const;

	/** 'Upgrades' this curve to use the latest tangent/interp algorithms (usually, will 'bake' key tangents.) */
	virtual void	UpgradeInterpMethod();
};

class UInterpTrackAudioMaster : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackAudioMaster
    //## END PROPS InterpTrackAudioMaster

    DECLARE_CLASS(UInterpTrackAudioMaster,UInterpTrackVectorBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void SetTrackToSensibleDefault();

	/** Return the sound volume scale for the specified time */
	FLOAT GetVolumeScaleForTime( FLOAT Time ) const;

	/** Return the sound pitch scale for the specified time */
	FLOAT GetPitchScaleForTime( FLOAT Time ) const;

	virtual class UMaterial* GetTrackIcon() const;
};

class UInterpTrackColorProp : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackColorProp
    FName PropertyName;
    //## END PROPS InterpTrackColorProp

    DECLARE_CLASS(UInterpTrackColorProp,UInterpTrackVectorBase,0,Engine)
	/** Returns the property name */
	virtual UBOOL GetPropertyName( FName& PropertyNameOut ) const { PropertyNameOut = PropertyName; return TRUE; }

	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;
};

class UInterpTrackColorScale : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackColorScale
    //## END PROPS InterpTrackColorScale

    DECLARE_CLASS(UInterpTrackColorScale,UInterpTrackVectorBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void SetTrackToSensibleDefault();

	virtual class UMaterial* GetTrackIcon() const;

	// InterpTrackColorScale interface
	FVector GetColorScaleAtTime(FLOAT Time);
};

struct FSoundTrackKey
{
    FLOAT Time;
    FLOAT Volume;
    FLOAT Pitch;
    class USoundCue* Sound;

    /** Constructors */
    FSoundTrackKey() {}
    FSoundTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FSoundTrackKey));
    }
};

class UInterpTrackSound : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackSound
    TArrayNoInit<struct FSoundTrackKey> Sounds;
    BITFIELD bPlayOnReverse:1;
    BITFIELD bContinueSoundOnMatineeEnd:1;
    BITFIELD bSuppressSubtitles:1;
    BITFIELD bTreatAsDialogue:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackSound

    DECLARE_CLASS(UInterpTrackSound,UInterpTrackVectorBase,0,Engine)
	virtual void PostLoad();

	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	virtual void PreviewStopPlayback(class UInterpTrackInst* TrInst);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;
	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	// InterpTrackSound interface
	/**
	 * Returns the key at the specified position in the track.
	 */
	struct FSoundTrackKey& GetSoundTrackKeyAtPosition(FLOAT InPosition);

	virtual void SetTrackToSensibleDefault();
};

class UInterpTrackVectorMaterialParam : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackVectorMaterialParam
    TArrayNoInit<struct FMaterialReferenceList> Materials;
    class UMaterialInterface* Material_DEPRECATED;
    FName ParamName;
    BITFIELD bNeedsMaterialRefsUpdate:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackVectorMaterialParam

    DECLARE_CLASS(UInterpTrackVectorMaterialParam,UInterpTrackVectorBase,0,Engine)
	virtual void PreSave();
	virtual void PostLoad();
	virtual void PreEditChange(UProperty* PropertyThatWillChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostDuplicate();

	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	//virtual class UMaterial* GetTrackIcon() const;
};

class UInterpTrackVectorProp : public UInterpTrackVectorBase
{
public:
    //## BEGIN PROPS InterpTrackVectorProp
    FName PropertyName;
    //## END PROPS InterpTrackVectorProp

    DECLARE_CLASS(UInterpTrackVectorProp,UInterpTrackVectorBase,0,Engine)
	/** Returns the property name */
	virtual UBOOL GetPropertyName( FName& PropertyNameOut ) const { PropertyNameOut = PropertyName; return TRUE; }

	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);
	
	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;
};

struct FVisibilityTrackKey
{
    FLOAT Time;
    BYTE Action;
    BYTE ActiveCondition;
    SCRIPT_ALIGN;

    /** Constructors */
    FVisibilityTrackKey() {}
    FVisibilityTrackKey(EEventParm)
    {
        appMemzero(this, sizeof(FVisibilityTrackKey));
    }
};

class UInterpTrackVisibility : public UInterpTrack
{
public:
    //## BEGIN PROPS InterpTrackVisibility
    TArrayNoInit<struct FVisibilityTrackKey> VisibilityTrack;
    BITFIELD bFireEventsWhenForwards:1;
    BITFIELD bFireEventsWhenBackwards:1;
    BITFIELD bFireEventsWhenJumpingForwards:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackVisibility

    DECLARE_CLASS(UInterpTrackVisibility,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes() const;
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime) const;
	virtual FLOAT GetTrackEndTime() const;
	virtual FLOAT GetKeyframeTime(INT KeyIndex) const;
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst, EInterpCurveMode InitInterpMode);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);
	virtual UBOOL GetClosestSnapPosition(FLOAT InPosition, TArray<INT> &IgnoreKeys, FLOAT& OutPosition);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump);

	/** Get the name of the class used to help out when adding tracks, keys, etc. in UnrealEd.
	* @return	String name of the helper class.*/
	virtual const FString	GetEdHelperClassName() const;

	virtual class UMaterial* GetTrackIcon() const;

	/** Whether or not this track is allowed to be used on static actors. */
	virtual UBOOL AllowStaticActors() { return TRUE; }

	virtual void DrawTrack( FCanvas* Canvas, UInterpGroup* Group, const FInterpTrackDrawParams& Params );
};

class UInterpTrackInst : public UObject
{
public:
    //## BEGIN PROPS InterpTrackInst
    //## END PROPS InterpTrackInst

    DECLARE_CLASS(UInterpTrackInst,UObject,0,Engine)
	/** 
	 *	Return the Actor associated with this instance of a Group. 
	 *	Note that all Groups have at least 1 instance, even if no Actor variable is attached, so this may return NULL. 
	 */
	AActor* GetGroupActor();

	/** Called before Interp editing to put object back to its original state. */
	virtual void SaveActorState(UInterpTrack* Track) {}

	/** Restore the saved state of this Actor. */
	virtual void RestoreActorState(UInterpTrack* Track) {}

	/** Initialise this Track instance. Called in-game before doing any interpolation. */
	virtual void InitTrackInst(UInterpTrack* Track);

	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst(UInterpTrack* Track) {}
};

class UInterpTrackInstAnimControl : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstAnimControl
    FLOAT LastUpdatePosition;
#if WITH_EDITORONLY_DATA
    FVector InitPosition;
    FRotator InitRotation;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS InterpTrackInstAnimControl

    DECLARE_CLASS(UInterpTrackInstAnimControl,UInterpTrackInst,0,Engine)
	/** Initialise this Track instance. Called in-game before doing any interpolation. */
	virtual void InitTrackInst(UInterpTrack* Track);

	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstAudioMaster : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstAudioMaster
    //## END PROPS InterpTrackInstAudioMaster

    DECLARE_CLASS(UInterpTrackInstAudioMaster,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstColorScale : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstColorScale
    //## END PROPS InterpTrackInstColorScale

    DECLARE_CLASS(UInterpTrackInstColorScale,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstDirector : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstDirector
    class AActor* OldViewTarget;
    struct FRenderingPerformanceOverrides OldRenderingOverrides;
    //## END PROPS InterpTrackInstDirector

    DECLARE_CLASS(UInterpTrackInstDirector,UInterpTrackInst,0,Engine)
	/** Initialise this Track instance. Called in-game before doing any interpolation. */
	virtual void InitTrackInst(UInterpTrack* Track);
	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstEvent : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstEvent
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstEvent

    DECLARE_CLASS(UInterpTrackInstEvent,UInterpTrackInst,0,Engine)
	/** 
	 * This will initialise LastUpdatePosition to whatever position the SeqAct_Interp is in, 
	 * so we don't play a bunch of events straight away! 
	 */
	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstFaceFX : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstFaceFX
    BITFIELD bFirstUpdate:1;
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstFaceFX

    DECLARE_CLASS(UInterpTrackInstFaceFX,UInterpTrackInst,0,Engine)
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstFade : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstFade
    //## END PROPS InterpTrackInstFade

    DECLARE_CLASS(UInterpTrackInstFade,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void TermTrackInst(UInterpTrack* Track);
};

struct FFloatMaterialParamMICData
{
    TArrayNoInit<class UMaterialInstanceConstant*> MICs;
    TArrayNoInit<FLOAT> MICResetFloats;

    /** Constructors */
    FFloatMaterialParamMICData() {}
    FFloatMaterialParamMICData(EEventParm)
    {
        appMemzero(this, sizeof(FFloatMaterialParamMICData));
    }
};

class UInterpTrackInstFloatMaterialParam : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstFloatMaterialParam
    TArrayNoInit<struct FFloatMaterialParamMICData> MICInfos;
    class UInterpTrackFloatMaterialParam* InstancedTrack;
    //## END PROPS InterpTrackInstFloatMaterialParam

    DECLARE_CLASS(UInterpTrackInstFloatMaterialParam,UInterpTrackInst,0,Engine)
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstFloatParticleParam : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstFloatParticleParam
    FLOAT ResetFloat;
    //## END PROPS InterpTrackInstFloatParticleParam

    DECLARE_CLASS(UInterpTrackInstFloatParticleParam,UInterpTrackInst,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstHeadTracking : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstHeadTracking
    BYTE Action;
    TMap< class AActor*,struct FActorToLookAt* > CurrentActorMap;
    class USkeletalMeshComponent* Mesh;
    TArrayNoInit<class USkelControlLookAt*> TrackControls;
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstHeadTracking

    DECLARE_CLASS(UInterpTrackInstHeadTracking,UInterpTrackInst,0,Engine)
	/** 
	 */
	virtual void InitTrackInst(UInterpTrack* Track);

	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst(UInterpTrack* Track);

	/** Make sure CurrentActorMap is referenced */
	void AddReferencedObjects( TArray<UObject*>& ObjectArray );
};

class UInterpTrackInstMorphWeight : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstMorphWeight
    //## END PROPS InterpTrackInstMorphWeight

    DECLARE_CLASS(UInterpTrackInstMorphWeight,UInterpTrackInst,0,Engine)
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstMove : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstMove
    FVector ResetLocation;
    FRotator ResetRotation;
    FMatrix InitialTM;
    FQuat InitialQuat;
    //## END PROPS InterpTrackInstMove

    DECLARE_CLASS(UInterpTrackInstMove,UInterpTrackInst,0,Engine)
	/** Will save the current position of the Actor as the 'initial position', used if MoveFrame == IMF_RelativeToInitial. */
	virtual void InitTrackInst(UInterpTrack* Track);

	/** Initialise InitialTMand InitialQuat. */
	void CalcInitialTransform(UInterpTrack* Track, UBOOL bZeroFromHere);
};

class UInterpTrackInstNotify : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstNotify
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstNotify

    DECLARE_CLASS(UInterpTrackInstNotify,UInterpTrackInst,0,Engine)
	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstParticleReplay : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstParticleReplay
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstParticleReplay

    DECLARE_CLASS(UInterpTrackInstParticleReplay,UInterpTrackInst,0,Engine)
	/** Initialise this Track instance. Called in-game before doing any interpolation. */
	virtual void InitTrackInst(UInterpTrack* Track);

	/** Restore the saved state of this Actor. */
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstProperty : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstProperty
    class UFunction* PropertyUpdateCallback;
    class UObject* PropertyOuterObjectInst;
    //## END PROPS InterpTrackInstProperty

    DECLARE_CLASS(UInterpTrackInstProperty,UInterpTrackInst,0,Engine)
	/**
	 * Retrieves the update callback from the interp property's metadata and stores it.
	 *
	 * @param InActor			Actor we are operating on.
	 * @param TrackProperty		Property we are interpolating.
	 */
	void SetupPropertyUpdateCallback(AActor* InActor, const FName& TrackPropertyName);

	/** 
	 * Tries to call the property update callback.
	 *
	 * @return TRUE if the callback existed and was called, FALSE otherwise.
	 */
	UBOOL CallPropertyUpdateCallback();

	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstBoolProp : public UInterpTrackInstProperty
{
public:
    //## BEGIN PROPS InterpTrackInstBoolProp
    FPointer BoolProp;
    INT BitMask;
    BITFIELD ResetBool:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackInstBoolProp

    DECLARE_CLASS(UInterpTrackInstBoolProp,UInterpTrackInstProperty,0,Engine)
	/** 
	 * Initialize the track instance.
	 *
	 * @param	Track	The track associated to this instance.
	 */
	virtual void InitTrackInst( UInterpTrack* Track );

	/** 
	 * Save any variables from the actor that will be modified by this instance.
	 *
	 * @param	Track	The track associated to this instance.
	 */
	virtual void SaveActorState( UInterpTrack* Track );
	
	/** 
	 * Restores any variables modified on the actor by this instance.
	 *
	 * @param	Track	The track associated to this instance.
	 */
	virtual void RestoreActorState( UInterpTrack* Track );
};

class UInterpTrackInstColorProp : public UInterpTrackInstProperty
{
public:
    //## BEGIN PROPS InterpTrackInstColorProp
    FPointer ColorProp;
    FColor ResetColor;
    //## END PROPS InterpTrackInstColorProp

    DECLARE_CLASS(UInterpTrackInstColorProp,UInterpTrackInstProperty,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);

	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstFloatProp : public UInterpTrackInstProperty
{
public:
    //## BEGIN PROPS InterpTrackInstFloatProp
    FPointer FloatProp;
    FLOAT ResetFloat;
    FPointer DistributionProp;
    //## END PROPS InterpTrackInstFloatProp

    DECLARE_CLASS(UInterpTrackInstFloatProp,UInterpTrackInstProperty,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);

	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstLinearColorProp : public UInterpTrackInstProperty
{
public:
    //## BEGIN PROPS InterpTrackInstLinearColorProp
    FPointer ColorProp;
    FLinearColor ResetColor;
    //## END PROPS InterpTrackInstLinearColorProp

    DECLARE_CLASS(UInterpTrackInstLinearColorProp,UInterpTrackInstProperty,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);

	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstVectorProp : public UInterpTrackInstProperty
{
public:
    //## BEGIN PROPS InterpTrackInstVectorProp
    FPointer VectorProp;
    FVector ResetVector;
    //## END PROPS InterpTrackInstVectorProp

    DECLARE_CLASS(UInterpTrackInstVectorProp,UInterpTrackInstProperty,0,Engine)
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);

	virtual void InitTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstSkelControlScale : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstSkelControlScale
    //## END PROPS InterpTrackInstSkelControlScale

    DECLARE_CLASS(UInterpTrackInstSkelControlScale,UInterpTrackInst,0,Engine)
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstSkelControlStrength : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstSkelControlStrength
    BITFIELD bSavedControlledByAnimMetaData:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackInstSkelControlStrength

    DECLARE_CLASS(UInterpTrackInstSkelControlStrength,UInterpTrackInst,0,Engine)
	virtual void RestoreActorState(UInterpTrack* Track);

	/** Initialise this Track instance. Called in-game before doing any interpolation. */
	virtual void InitTrackInst(UInterpTrack* Track);

	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstSlomo : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstSlomo
    FLOAT OldTimeDilation;
    //## END PROPS InterpTrackInstSlomo

    DECLARE_CLASS(UInterpTrackInstSlomo,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);

	/** @return whether the slomo track's effects should actually be applied. We want to only do this once for the server
	 * and not at all for the clients regardless of the number of instances created for the various players
	 * to avoid collisions and replication issues
	 */
	UBOOL ShouldBeApplied();
};

class UInterpTrackInstSound : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstSound
    FLOAT LastUpdatePosition;
    class UAudioComponent* PlayAudioComp;
    //## END PROPS InterpTrackInstSound

    DECLARE_CLASS(UInterpTrackInstSound,UInterpTrackInst,0,Engine)
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);
};

class UInterpTrackInstToggle : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstToggle
    BYTE Action;
    FLOAT LastUpdatePosition;
    BITFIELD bSavedActiveState:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpTrackInstToggle

    DECLARE_CLASS(UInterpTrackInstToggle,UInterpTrackInst,0,Engine)
	/** 
	 */
	virtual void InitTrackInst(UInterpTrack* Track);

	/** Called before Interp editing to put object back to its original state. */
	virtual void SaveActorState(UInterpTrack* Track);

	/** Restore the saved state of this Actor. */
	virtual void RestoreActorState(UInterpTrack* Track);
};

struct FVectorMaterialParamMICData
{
    TArrayNoInit<class UMaterialInstanceConstant*> MICs;
    TArrayNoInit<FVector> MICResetVectors;

    /** Constructors */
    FVectorMaterialParamMICData() {}
    FVectorMaterialParamMICData(EEventParm)
    {
        appMemzero(this, sizeof(FVectorMaterialParamMICData));
    }
};

class UInterpTrackInstVectorMaterialParam : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstVectorMaterialParam
    TArrayNoInit<struct FVectorMaterialParamMICData> MICInfos;
    class UInterpTrackVectorMaterialParam* InstancedTrack;
    //## END PROPS InterpTrackInstVectorMaterialParam

    DECLARE_CLASS(UInterpTrackInstVectorMaterialParam,UInterpTrackInst,0,Engine)
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst(UInterpTrack* Track);
	virtual void SaveActorState(UInterpTrack* Track);
	virtual void RestoreActorState(UInterpTrack* Track);
};

class UInterpTrackInstVisibility : public UInterpTrackInst
{
public:
    //## BEGIN PROPS InterpTrackInstVisibility
    BYTE Action;
    FLOAT LastUpdatePosition;
    //## END PROPS InterpTrackInstVisibility

    DECLARE_CLASS(UInterpTrackInstVisibility,UInterpTrackInst,0,Engine)
	/** 
	 */
	virtual void InitTrackInst(UInterpTrack* Track);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_ENGINE_INTERPOLATION_CLASSES
#endif // !NAMES_ONLY


#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef ENGINE_INTERPOLATION_NATIVE_DEFS
#define ENGINE_INTERPOLATION_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_ENGINE_INTERPOLATION \
	UInterpFilter::StaticClass(); \
	UInterpFilter_Classes::StaticClass(); \
	UInterpFilter_Custom::StaticClass(); \
	UInterpGroup::StaticClass(); \
	UInterpGroupAI::StaticClass(); \
	UInterpGroupCamera::StaticClass(); \
	UInterpGroupDirector::StaticClass(); \
	UInterpGroupInst::StaticClass(); \
	UInterpGroupInstAI::StaticClass(); \
	UInterpGroupInstCamera::StaticClass(); \
	UInterpGroupInstDirector::StaticClass(); \
	UInterpTrackBoolProp::StaticClass(); \
	UInterpTrackDirector::StaticClass(); \
	UInterpTrackEvent::StaticClass(); \
	UInterpTrackFaceFX::StaticClass(); \
	UInterpTrackFloatBase::StaticClass(); \
	UInterpTrackAnimControl::StaticClass(); \
	UInterpTrackFade::StaticClass(); \
	UInterpTrackFloatMaterialParam::StaticClass(); \
	UInterpTrackFloatParticleParam::StaticClass(); \
	UInterpTrackFloatProp::StaticClass(); \
	UInterpTrackMorphWeight::StaticClass(); \
	UInterpTrackMoveAxis::StaticClass(); \
	UInterpTrackSkelControlScale::StaticClass(); \
	UInterpTrackSkelControlStrength::StaticClass(); \
	UInterpTrackSlomo::StaticClass(); \
	UInterpTrackHeadTracking::StaticClass(); \
	UInterpTrackLinearColorBase::StaticClass(); \
	UInterpTrackLinearColorProp::StaticClass(); \
	UInterpTrackMove::StaticClass(); \
	UInterpTrackNotify::StaticClass(); \
	UInterpTrackParticleReplay::StaticClass(); \
	UInterpTrackToggle::StaticClass(); \
	UInterpTrackVectorBase::StaticClass(); \
	UInterpTrackAudioMaster::StaticClass(); \
	UInterpTrackColorProp::StaticClass(); \
	UInterpTrackColorScale::StaticClass(); \
	UInterpTrackSound::StaticClass(); \
	UInterpTrackVectorMaterialParam::StaticClass(); \
	UInterpTrackVectorProp::StaticClass(); \
	UInterpTrackVisibility::StaticClass(); \
	UInterpTrackInst::StaticClass(); \
	UInterpTrackInstAnimControl::StaticClass(); \
	UInterpTrackInstAudioMaster::StaticClass(); \
	UInterpTrackInstColorScale::StaticClass(); \
	UInterpTrackInstDirector::StaticClass(); \
	UInterpTrackInstEvent::StaticClass(); \
	UInterpTrackInstFaceFX::StaticClass(); \
	UInterpTrackInstFade::StaticClass(); \
	UInterpTrackInstFloatMaterialParam::StaticClass(); \
	UInterpTrackInstFloatParticleParam::StaticClass(); \
	UInterpTrackInstHeadTracking::StaticClass(); \
	UInterpTrackInstMorphWeight::StaticClass(); \
	UInterpTrackInstMove::StaticClass(); \
	UInterpTrackInstNotify::StaticClass(); \
	UInterpTrackInstParticleReplay::StaticClass(); \
	UInterpTrackInstProperty::StaticClass(); \
	UInterpTrackInstBoolProp::StaticClass(); \
	UInterpTrackInstColorProp::StaticClass(); \
	UInterpTrackInstFloatProp::StaticClass(); \
	UInterpTrackInstLinearColorProp::StaticClass(); \
	UInterpTrackInstVectorProp::StaticClass(); \
	UInterpTrackInstSkelControlScale::StaticClass(); \
	UInterpTrackInstSkelControlStrength::StaticClass(); \
	UInterpTrackInstSlomo::StaticClass(); \
	UInterpTrackInstSound::StaticClass(); \
	UInterpTrackInstToggle::StaticClass(); \
	UInterpTrackInstVectorMaterialParam::StaticClass(); \
	UInterpTrackInstVisibility::StaticClass(); \

#endif // ENGINE_INTERPOLATION_NATIVE_DEFS

#ifdef NATIVES_ONLY
#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UInterpFilter,InterpFilter,Caption)
VERIFY_CLASS_SIZE_NODIE(UInterpFilter)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInterpFilter_Classes,InterpFilter_Classes,ClassToFilterBy)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInterpFilter_Classes,InterpFilter_Classes,TrackClasses)
#endif
VERIFY_CLASS_SIZE_NODIE(UInterpFilter_Classes)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInterpFilter_Custom,InterpFilter_Custom,GroupsToInclude)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInterpFilter_Custom,InterpFilter_Custom,GroupsToInclude)
#endif
VERIFY_CLASS_SIZE_NODIE(UInterpFilter_Custom)
VERIFY_CLASS_OFFSET_NODIE(UInterpGroup,InterpGroup,InterpTracks)
VERIFY_CLASS_OFFSET_NODIE(UInterpGroup,InterpGroup,GroupAnimSets)
VERIFY_CLASS_SIZE_NODIE(UInterpGroup)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInterpGroupAI,InterpGroupAI,PreviewPawnClass)
#else
VERIFY_CLASS_OFFSET_NODIE(UInterpGroupAI,InterpGroupAI,StageMarkGroup)
#endif
VERIFY_CLASS_OFFSET_NODIE(UInterpGroupAI,InterpGroupAI,StageMarkGroup)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupAI)
VERIFY_CLASS_OFFSET_NODIE(UInterpGroupCamera,InterpGroupCamera,CameraAnimInst)
VERIFY_CLASS_OFFSET_NODIE(UInterpGroupCamera,InterpGroupCamera,CompressTolerance)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupCamera)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupDirector)
VERIFY_CLASS_OFFSET_NODIE(UInterpGroupInst,InterpGroupInst,Group)
VERIFY_CLASS_OFFSET_NODIE(UInterpGroupInst,InterpGroupInst,CachedCamOverridePostProcess)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupInst)
VERIFY_CLASS_OFFSET_NODIE(UInterpGroupInstAI,InterpGroupInstAI,AIGroup)
VERIFY_CLASS_OFFSET_NODIE(UInterpGroupInstAI,InterpGroupInstAI,StageMarkActor)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupInstAI)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupInstCamera)
VERIFY_CLASS_SIZE_NODIE(UInterpGroupInstDirector)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackBoolProp,InterpTrackBoolProp,BoolTrack)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackBoolProp,InterpTrackBoolProp,PropertyName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackBoolProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackDirector,InterpTrackDirector,CutTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackDirector)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackEvent,InterpTrackEvent,EventTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackEvent)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackFaceFX,InterpTrackFaceFX,FaceFXAnimSets)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackFaceFX,InterpTrackFaceFX,FaceFXSoundCueKeys)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFaceFX)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackFloatBase,InterpTrackFloatBase,FloatTrack)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackFloatBase,InterpTrackFloatBase,CurveTension)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatBase)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackAnimControl,InterpTrackAnimControl,AnimSets)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackAnimControl,InterpTrackAnimControl,AnimSeqs)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackAnimControl)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFade)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackFloatMaterialParam,InterpTrackFloatMaterialParam,Materials)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackFloatMaterialParam,InterpTrackFloatMaterialParam,ParamName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatMaterialParam)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackFloatParticleParam,InterpTrackFloatParticleParam,ParamName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatParticleParam)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackFloatProp,InterpTrackFloatProp,PropertyName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackMorphWeight,InterpTrackMorphWeight,MorphNodeName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackMorphWeight)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackMoveAxis,InterpTrackMoveAxis,MoveAxis)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackMoveAxis,InterpTrackMoveAxis,LookupTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackMoveAxis)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackSkelControlScale,InterpTrackSkelControlScale,SkelControlName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSkelControlScale)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackSkelControlStrength,InterpTrackSkelControlStrength,SkelControlName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSkelControlStrength)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSlomo)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackHeadTracking,InterpTrackHeadTracking,HeadTrackingTrack)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackHeadTracking,InterpTrackHeadTracking,TargetBoneNames)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackHeadTracking)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackLinearColorBase,InterpTrackLinearColorBase,LinearColorTrack)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackLinearColorBase,InterpTrackLinearColorBase,CurveTension)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackLinearColorBase)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackLinearColorProp,InterpTrackLinearColorProp,PropertyName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackLinearColorProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackMove,InterpTrackMove,PosTrack)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackMove,InterpTrackMove,RotMode)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackMove)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackNotify,InterpTrackNotify,Node)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackNotify,InterpTrackNotify,NotifyTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackNotify)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackParticleReplay,InterpTrackParticleReplay,TrackKeys)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackParticleReplay,InterpTrackParticleReplay,FixedTimeStep)
#endif
VERIFY_CLASS_SIZE_NODIE(UInterpTrackParticleReplay)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackToggle,InterpTrackToggle,ToggleTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackToggle)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackVectorBase,InterpTrackVectorBase,VectorTrack)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackVectorBase,InterpTrackVectorBase,CurveTension)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVectorBase)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackAudioMaster)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackColorProp,InterpTrackColorProp,PropertyName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackColorProp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackColorScale)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackSound,InterpTrackSound,Sounds)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSound)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackVectorMaterialParam,InterpTrackVectorMaterialParam,Materials)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackVectorMaterialParam,InterpTrackVectorMaterialParam,ParamName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVectorMaterialParam)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackVectorProp,InterpTrackVectorProp,PropertyName)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVectorProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackVisibility,InterpTrackVisibility,VisibilityTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVisibility)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInst)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstAnimControl,InterpTrackInstAnimControl,LastUpdatePosition)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstAnimControl,InterpTrackInstAnimControl,InitRotation)
#endif
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstAnimControl)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstAudioMaster)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstColorScale)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstDirector,InterpTrackInstDirector,OldViewTarget)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstDirector,InterpTrackInstDirector,OldRenderingOverrides)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstDirector)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstEvent,InterpTrackInstEvent,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstEvent)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstFaceFX,InterpTrackInstFaceFX,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFaceFX)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFade)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstFloatMaterialParam,InterpTrackInstFloatMaterialParam,MICInfos)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstFloatMaterialParam,InterpTrackInstFloatMaterialParam,InstancedTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFloatMaterialParam)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstFloatParticleParam,InterpTrackInstFloatParticleParam,ResetFloat)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFloatParticleParam)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstHeadTracking,InterpTrackInstHeadTracking,Action)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstHeadTracking,InterpTrackInstHeadTracking,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstHeadTracking)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstMorphWeight)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstMove,InterpTrackInstMove,ResetLocation)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstMove,InterpTrackInstMove,InitialQuat)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstMove)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstNotify,InterpTrackInstNotify,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstNotify)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstParticleReplay,InterpTrackInstParticleReplay,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstParticleReplay)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstProperty,InterpTrackInstProperty,PropertyUpdateCallback)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstProperty,InterpTrackInstProperty,PropertyOuterObjectInst)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstProperty)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstBoolProp,InterpTrackInstBoolProp,BoolProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstBoolProp,InterpTrackInstBoolProp,BitMask)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstBoolProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstColorProp,InterpTrackInstColorProp,ColorProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstColorProp,InterpTrackInstColorProp,ResetColor)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstColorProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstFloatProp,InterpTrackInstFloatProp,FloatProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstFloatProp,InterpTrackInstFloatProp,DistributionProp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstFloatProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstLinearColorProp,InterpTrackInstLinearColorProp,ColorProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstLinearColorProp,InterpTrackInstLinearColorProp,ResetColor)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstLinearColorProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstVectorProp,InterpTrackInstVectorProp,VectorProp)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstVectorProp,InterpTrackInstVectorProp,ResetVector)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstVectorProp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstSkelControlScale)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstSkelControlStrength)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstSlomo,InterpTrackInstSlomo,OldTimeDilation)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstSlomo)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstSound,InterpTrackInstSound,LastUpdatePosition)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstSound,InterpTrackInstSound,PlayAudioComp)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstSound)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstToggle,InterpTrackInstToggle,Action)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstToggle,InterpTrackInstToggle,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstToggle)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstVectorMaterialParam,InterpTrackInstVectorMaterialParam,MICInfos)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstVectorMaterialParam,InterpTrackInstVectorMaterialParam,InstancedTrack)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstVectorMaterialParam)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstVisibility,InterpTrackInstVisibility,Action)
VERIFY_CLASS_OFFSET_NODIE(UInterpTrackInstVisibility,InterpTrackInstVisibility,LastUpdatePosition)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackInstVisibility)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
