/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif


#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern FName ENGINE_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY


class UInterpGroup : public UObject
{
public:
    TArrayNoInit<class UInterpTrack*> InterpTracks;
    FName GroupName;
    FColor GroupColor;
    BITFIELD bCollapsed:1 GCC_PACK(PROPERTY_ALIGNMENT);
    DECLARE_CLASS(UInterpGroup,UObject,0,Engine)
	// UInterpGroup interface

	/** Iterate over all InterpTracks in this InterpGroup, doing any actions to bring the state to the specified time. */
	virtual void UpdateGroup(FLOAT NewPosition, class UInterpGroupInst* GrInst, UBOOL bPreview=false, UBOOL bJump=false);

	/** Ensure this group name is unique within this InterpData (its Outer). */
	void EnsureUniqueName();

	void FindTracksByClass(UClass* TrackClass, TArray<class UInterpTrack*>& OutputTracks);
};


class UInterpGroupDirector : public UInterpGroup
{
public:
    DECLARE_CLASS(UInterpGroupDirector,UInterpGroup,0,Engine)
	// UInterpGroup interface
	virtual void UpdateGroup(FLOAT NewPosition, class UInterpGroupInst* GrInst, UBOOL bPreview=false);

	// UInterpGroupDirector interface
	class UInterpTrackDirector* GetDirectorTrack();
	class UInterpTrackFade* GetFadeTrack();
	class UInterpTrackSlomo* GetSlomoTrack();
};


class UInterpGroupInst : public UObject
{
public:
    class UInterpGroup* Group;
    class AActor* GroupActor;
    TArrayNoInit<class UInterpTrackInst*> TrackInst;
    DECLARE_CLASS(UInterpGroupInst,UObject,0,Engine)
	/** 
	 *	Returns the Actor that this GroupInstance is working on. 
	 *	Should use this instead of just referencing GroupActor, as it check bDeleteMe for you.
	 */
	AActor* GetGroupActor();

	/** Called before Interp editing to save original state of Actor. @see UInterpTrackInst::SaveActorState */
	virtual void SaveGroupActorState();

	/** Called after Interp editing to put object back to its original state. @see UInterpTrackInst::RestoreActorState */
	virtual void RestoreGroupActorState();

	/** 
	 *	Initialse this Group instance. Called from USeqAct_Interp::InitInterp before doing any interpolation.
	 *	Save the Actor for the group and creates any needed InterpTrackInsts
	 */
	virtual void InitGroupInst(UInterpGroup* InGroup, AActor* InGroupActor);

	/** 
	 *	Called when done with interpolation sequence. Cleans up InterpTrackInsts etc. 
	 *	Do not do anything further with the Interpolation after this.
	 */
	virtual void TermGroupInst();
};


class UInterpGroupInstDirector : public UInterpGroupInst
{
public:
    DECLARE_CLASS(UInterpGroupInstDirector,UInterpGroupInst,0,Engine)
    NO_DEFAULT_CONSTRUCTOR(UInterpGroupInstDirector)
};

struct FDirectorTrackCut
{
    FLOAT Time;
    FName TargetCamGroup;
};


class UInterpTrackDirector : public UInterpTrack
{
public:
    TArrayNoInit<FDirectorTrackCut> CutTrack;
    DECLARE_CLASS(UInterpTrackDirector,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);

	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump=false);

	virtual void DrawTrack(FRenderInterface* RI, INT TrackIndex, INT TrackWidth, INT TrackHeight, FLOAT StartTime, FLOAT PixelsPerSec, TArray<class FInterpEdSelKey>& SelectedKeys);

	// InterpTrackDirector interface
	FName GetViewedGroupName(FLOAT CurrentTime);
};

struct FEventTrackKey
{
    FLOAT Time;
    FName EventName;
};


class UInterpTrackEvent : public UInterpTrack
{
public:
    TArrayNoInit<FEventTrackKey> EventTrack;
    BITFIELD bFireEventsWhenForwards:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bFireEventsWhenBackwards:1;
    DECLARE_CLASS(UInterpTrackEvent,UInterpTrack,0,Engine)
	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);

	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump=false);

	virtual void DrawTrack(FRenderInterface* RI, INT TrackIndex, INT TrackWidth, INT TrackHeight, FLOAT StartTime, FLOAT PixelsPerSec, TArray<class FInterpEdSelKey>& SelectedKeys);
};


class UInterpTrackFloatBase : public UInterpTrack
{
public:
    FInterpCurveFloat FloatTrack;
    FLOAT CurveTension;
    DECLARE_CLASS(UInterpTrackFloatBase,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);

	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);

	virtual FColor GetKeyframeColor(INT KeyIndex);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);
};


class UInterpTrackFade : public UInterpTrackFloatBase
{
public:
    DECLARE_CLASS(UInterpTrackFade,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump=false);

	// InterpTrackFade interface
	FLOAT GetFadeAmountAtTime(FLOAT Time);
};


class UInterpTrackFloatProp : public UInterpTrackFloatBase
{
public:
    FName PropertyName;
    DECLARE_CLASS(UInterpTrackFloatProp,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump=false);
};


class UInterpTrackSlomo : public UInterpTrackFloatBase
{
public:
    DECLARE_CLASS(UInterpTrackSlomo,UInterpTrackFloatBase,0,Engine)
	// InterpTrack interface
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);
	virtual void UpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst, UBOOL bJump=false);
	virtual void SetTrackToSensibleDefault();

	// InterpTrackSlomo interface
	FLOAT GetSlomoFactorAtTime(FLOAT Time);
};

enum EInterpTrackMoveRotMode
{
    IMR_Keyframed           =0,
    IMR_LookAtGroup         =1,
    IMR_MAX                 =2,
};
enum EInterpTrackMoveFrame
{
    IMF_World               =0,
    IMF_RelativeToInitial   =1,
    IMF_MAX                 =2,
};

class UInterpTrackMove : public UInterpTrack
{
public:
    FInterpCurveVector PosTrack;
    FInterpCurveQuat RotTrack;
    FInterpCurveVector EulerTrack;
    FName LookAtGroupName;
    FLOAT LinCurveTension;
    FLOAT AngCurveTension;
    BITFIELD bUseQuatInterpolation:1 GCC_PACK(PROPERTY_ALIGNMENT);
    BITFIELD bShowArrowAtKeys:1;
    BITFIELD bDisableMovement:1;
    BITFIELD bShowTranslationOnCurveEd:1;
    BITFIELD bShowRotationOnCurveEd:1;
    BYTE MoveFrame GCC_PACK(PROPERTY_ALIGNMENT);
    BYTE RotMode;
    DECLARE_CLASS(UInterpTrackMove,UInterpTrack,0,Engine)
	// UObject interface
	virtual void PostEditChange(UProperty* PropertyThatChanged);
	virtual void PostLoad();

	// InterpTrack interface
	virtual INT GetNumKeyframes();
	virtual void GetTimeRange(FLOAT& StartTime, FLOAT& EndTime);
	virtual FLOAT GetKeyframeTime(INT KeyIndex);
	virtual INT AddKeyframe(FLOAT Time, UInterpTrackInst* TrInst);
	virtual void UpdateKeyframe(INT KeyIndex, UInterpTrackInst* TrInst);
	virtual INT SetKeyframeTime(INT KeyIndex, FLOAT NewKeyTime, UBOOL bUpdateOrder=true);
	virtual void RemoveKeyframe(INT KeyIndex);
	virtual INT DuplicateKeyframe(INT KeyIndex, FLOAT NewKeyTime);

	virtual void PreviewUpdateTrack(FLOAT NewPosition, UInterpTrackInst* TrInst);

	virtual FColor GetKeyframeColor(INT KeyIndex);
	virtual void Render3DTrack(UInterpTrackInst* TrInst, const FSceneContext& Context, FPrimitiveRenderInterface* PRI, INT TrackIndex, const FColor& TrackColor, TArray<class FInterpEdSelKey>& SelectedKeys);

	// FCurveEdInterface interface
	virtual INT		GetNumKeys();
	virtual INT		GetNumSubCurves();
	virtual FLOAT	GetKeyIn(INT KeyIndex);
	virtual FLOAT	GetKeyOut(INT SubIndex, INT KeyIndex);
	virtual void	GetInRange(FLOAT& MinIn, FLOAT& MaxIn);
	virtual void	GetOutRange(FLOAT& MinOut, FLOAT& MaxOut);
	virtual FColor	GetKeyColor(INT SubIndex, INT KeyIndex, const FColor& CurveColor);
	virtual BYTE	GetKeyInterpMode(INT KeyIndex);
	virtual void	GetTangents(INT SubIndex, INT KeyIndex, FLOAT& ArriveTangent, FLOAT& LeaveTangent);
	virtual FLOAT	EvalSub(INT SubIndex, FLOAT InVal);

	virtual INT		CreateNewKey(FLOAT KeyIn);
	virtual void	DeleteKey(INT KeyIndex);

	virtual INT		SetKeyIn(INT KeyIndex, FLOAT NewInVal);
	virtual void	SetKeyOut(INT SubIndex, INT KeyIndex, FLOAT NewOutVal);
	virtual void	SetKeyInterpMode(INT KeyIndex, EInterpCurveMode NewMode);
	virtual void	SetTangents(INT SubIndex, INT KeyIndex, FLOAT ArriveTangent, FLOAT LeaveTangent);


	// InterpTrackMove interface
	FMatrix GetKeyTransformAtTime(class UInterpTrackInstMove* MoveTrackInst, FLOAT Time);
	void GetLocationAtTime(UInterpTrackInst* TrInst, FLOAT Time, FVector& OutPos, FRotator& OutRot);
	FMatrix GetMoveRefFrame(UInterpTrackInstMove* MoveTrackInst);

	INT CalcSubIndex(UBOOL bPos, INT Index);
};


class UInterpTrackInst : public UObject
{
public:
    DECLARE_CLASS(UInterpTrackInst,UObject,0,Engine)
	/** 
	 *	Return the Actor associated with this instance of a Group. 
	 *	Note that all Groups have at least 1 instance, even if no Actor variable is attached, so this may return NULL. 
	 */
	AActor* GetGroupActor();

	/** Called before Interp editing to put object back to its original state. */
	virtual void SaveActorState() {}

	/** Restore the saved state of this Actor. */
	virtual void RestoreActorState() {}

	/** Initialise this Track instance. Called in-game before doing any interpolation. */
	virtual void InitTrackInst(UInterpTrack* Track) {}

	/** Called when interpolation is done. Should not do anything else with this TrackInst after this. */
	virtual void TermTrackInst() {}
};


class UInterpTrackInstDirector : public UInterpTrackInst
{
public:
    class AActor* OldViewTarget;
    DECLARE_CLASS(UInterpTrackInstDirector,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void TermTrackInst();
};


class UInterpTrackInstEvent : public UInterpTrackInst
{
public:
    FLOAT LastUpdatePosition;
    DECLARE_CLASS(UInterpTrackInstEvent,UInterpTrackInst,0,Engine)
	/** 
	 * This will initialise LastUpdatePosition to whatever position the SeqAct_Interp is in, 
	 * so we don't play a bunch of events straight away! 
	 */
	virtual void InitTrackInst(UInterpTrack* Track);
};


class UInterpTrackInstFade : public UInterpTrackInst
{
public:
    DECLARE_CLASS(UInterpTrackInstFade,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void TermTrackInst();
};


class UInterpTrackInstFloatProp : public UInterpTrackInst
{
public:
    Fpointer FloatProp;
    FLOAT ResetFloat;
    DECLARE_CLASS(UInterpTrackInstFloatProp,UInterpTrackInst,0,Engine)
	virtual void SaveActorState();
	virtual void RestoreActorState();

	virtual void InitTrackInst(UInterpTrack* Track);
};


class UInterpTrackInstMove : public UInterpTrackInst
{
public:
    FVector ResetLocation;
    FRotator ResetRotation;
    FMatrix InitialTM;
    FQuat InitialQuat;
    DECLARE_CLASS(UInterpTrackInstMove,UInterpTrackInst,0,Engine)
	virtual void SaveActorState();
	virtual void RestoreActorState();

	/** Will save the current position of the Actor as the 'initial position', used if MoveFrame == IMF_RelativeToInitial. */
	virtual void InitTrackInst(UInterpTrack* Track);
};


class UInterpTrackInstSlomo : public UInterpTrackInst
{
public:
    FLOAT OldTimeDilation;
    DECLARE_CLASS(UInterpTrackInstSlomo,UInterpTrackInst,0,Engine)
	// InterpTrackInst interface
	virtual void SaveActorState();
	virtual void RestoreActorState();
	virtual void InitTrackInst(UInterpTrack* Track);
	virtual void TermTrackInst();
};

#endif


#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif

