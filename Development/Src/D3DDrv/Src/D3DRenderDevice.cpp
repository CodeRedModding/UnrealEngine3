/*=============================================================================
	D3DRenderDevice.cpp: Unreal Direct3D render device implementation.
	Copyright 2004 Epic Games, Inc. All Rights Reserved.

	Revision history:
		* Created by Andrew Scheidecker
=============================================================================*/

#include "D3DDrv.h"

IMPLEMENT_CLASS(UD3DRenderDevice);

//
//	FD3DCycleCounterSection::~FD3DCycleCounterSection
//

FD3DCycleCounterSection::~FD3DCycleCounterSection()
{
	DWORD	RenderEndCycles = appCycles();
	if(GD3DRenderDevice->AccurateStats)
		GD3DRenderInterface.Wait();
	Counter.Value.RenderCycles += RenderEndCycles - StartCycles;
	Counter.Value.WaitCycles += appCycles() - RenderEndCycles;
}

//
//	FD3DViewport::FD3DViewport
//

FD3DViewport::FD3DViewport(FChildViewport* InViewport,UINT InSizeX,UINT InSizeY):
	Viewport(InViewport),
	SizeX(InSizeX),
	SizeY(InSizeY)
{
}

//
//	UD3DRenderDevice::UD3DRenderDevice
//

UD3DRenderDevice::UD3DRenderDevice():
	ResourceSets(),
	Resources(this),
	MeshLightShaders(this),
	MeshShaders(this),
	EmissiveTileShaders(this,0),
	EmissiveTileHitProxyShaders(this,1),
	BlurShaders(this),
	MiscResources(this),
	SpriteShader(this),
	SpriteHitProxyShader(this),
	AccumulateImageShader(this),
	BlendImageShader(this),
	FinishImageShader(this),
	FogShader(this),
	ShadowVolumeShader(this),
	ExposureShader(this),
	FillShader(this),
	CopyShader(this),
	CopyFillShader(this),
	OcclusionQueryShader(this),
	TileShader(this),
	TileHitProxyShader(this),
	SolidTileShader(this),
	SolidTileHitProxyShader(this),
	DynamicIndexBuffer16(NULL),
	DynamicIndexBuffer32(NULL),
	BufferSizeX(0),
	BufferSizeY(0),
	BlurBufferSizeX(0),
	BlurBufferSizeY(0),
	CachedShadowBufferSize(0),
	DeviceLost(0),
	DeviceFullscreen(0),
	DeviceSizeX(0),
	DeviceSizeY(0)
{
	GD3DRenderDevice = this;

	// Initialize mapping of Unreal engine formats to platform specific tokens.
	// @warning: make sure to update XeTools.cpp when updating the below!
	GPixelFormats[ PF_Unknown		].PlatformFormat	= D3DFMT_UNKNOWN;
	GPixelFormats[ PF_A32B32G32R32F	].PlatformFormat	= D3DFMT_UNKNOWN;	// Not supported for rendering.
	GPixelFormats[ PF_A8R8G8B8		].PlatformFormat	= D3DFMT_A8R8G8B8;
#ifndef XBOX
	GPixelFormats[ PF_G8			].PlatformFormat	= D3DFMT_L8;
#else
	GPixelFormats[ PF_G8			].PlatformFormat	= D3DFMT_LIN_L8;	// @todo xenon: linear as generated by code
#endif
	GPixelFormats[ PF_G16			].PlatformFormat	= D3DFMT_UNKNOWN;	// Not supported for rendering.
	GPixelFormats[ PF_DXT1			].PlatformFormat	= D3DFMT_DXT1;
	GPixelFormats[ PF_DXT3			].PlatformFormat	= D3DFMT_DXT3;
	GPixelFormats[ PF_DXT5			].PlatformFormat	= D3DFMT_DXT5;
	GPixelFormats[ PF_UYVY			].PlatformFormat	= D3DFMT_UYVY;

	D3DTempDefinitions = new TArray<FD3DDefinition>;
}

//
//	UD3DRenderDevice::StaticConstructor
//

void UD3DRenderDevice::StaticConstructor()
{
	new(GetClass(),TEXT("UseTrilinear"),				RF_Public)UBoolProperty	( CPP_PROPERTY( UseTrilinear				), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("UseRefDevice"),				RF_Public)UBoolProperty	( CPP_PROPERTY( UseRefDevice				), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("DisableFPBlending"),			RF_Public)UBoolProperty	( CPP_PROPERTY( DisableFPBlending			), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("DisableFPTranslucency"),		RF_Public)UBoolProperty	( CPP_PROPERTY( DisableFPTranslucency		), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("DisableFPFiltering"),			RF_Public)UBoolProperty	( CPP_PROPERTY( DisableFPFiltering			), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("DisablePrecaching"),			RF_Public)UBoolProperty	( CPP_PROPERTY( DisablePrecaching			), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("DisableHWShadowMaps"),			RF_Public)UBoolProperty ( CPP_PROPERTY( DisableHWShadowMaps			), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("DisableShaderModel3"),			RF_Public)UBoolProperty	( CPP_PROPERTY( DisableShaderModel3			), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("DisableMultiLightPath"),		RF_Public)UBoolProperty	( CPP_PROPERTY( DisableMultiLightPath		), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("EnableOcclusionQuery"),		RF_Public)UBoolProperty	( CPP_PROPERTY( EnableOcclusionQuery		), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("LevelOfAnisotropy"),			RF_Public)UIntProperty  ( CPP_PROPERTY( LevelOfAnisotropy			), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("AccurateStats"),				RF_Public)UBoolProperty	( CPP_PROPERTY( AccurateStats				), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("MaxTextureSize"),				RF_Public)UIntProperty  ( CPP_PROPERTY( MaxTextureSize				), TEXT("Options"), CPF_Config );
	new(GetClass(),TEXT("MaxTranslucencyLayers"),		RF_Public)UIntProperty	( CPP_PROPERTY( MaxTranslucencyLayers		), TEXT("Options"), CPF_Config );

	new(GetClass(),TEXT("UseStaticLighting"),			RF_Public)UBoolProperty ( CPP_PROPERTY( UseStaticLighting			), TEXT("Options"),	CPF_Config);
	new(GetClass(),TEXT("MinShadowResolution"),			RF_Public)UIntProperty  ( CPP_PROPERTY( MinShadowResolution			), TEXT("Options"),	CPF_Config);
	new(GetClass(),TEXT("MaxShadowResolution"),			RF_Public)UIntProperty  ( CPP_PROPERTY( MaxShadowResolution			), TEXT("Options"),	CPF_Config);
	new(GetClass(),TEXT("ShadowResolutionScale"),		RF_Public)UFloatProperty( CPP_PROPERTY( ShadowResolutionScale		), TEXT("Options"),	CPF_Config);

	new(GetClass(),TEXT("UsePostProcessEffects"),		RF_Public)UBoolProperty ( CPP_PROPERTY( UsePostProcessEffects		), TEXT("Options"),	CPF_Config);
	new(GetClass(),TEXT("BlurBufferResolutionDivisor"),	RF_Public)UIntProperty  ( CPP_PROPERTY( BlurBufferResolutionDivisor	), TEXT("Options"),	CPF_Config);
	new(GetClass(),TEXT("BlurAttenuation"),				RF_Public)UFloatProperty( CPP_PROPERTY( BlurAttenuation				), TEXT("Options"),	CPF_Config);
	new(GetClass(),TEXT("BlurAlpha"),					RF_Public)UFloatProperty( CPP_PROPERTY( BlurAlpha					), TEXT("Options"),	CPF_Config);

	new(GetClass(),TEXT("ShaderPath"),					RF_Public)UStrProperty	( CPP_PROPERTY( ShaderPath					), TEXT("Options"),	CPF_Config);
}

//
//	UD3DRenderDevice::SerializeCompiledShaders
//

void UD3DRenderDevice::SerializeCompiledShaders(FArchive& Ar)
{
	UINT	SavedVersion = GEngineVersion;
	Ar << SavedVersion;

	if(!Ar.IsLoading() || SavedVersion == GEngineVersion) // Don't load shaders that were compiled in an old version of the engine.
		Ar << CompiledShaders << CompiledShaderMap << CompiledMeshShaders << CompiledMeshLightShaders << CompiledEmissiveTileShaders << CompiledEmissiveTileHitProxyShaders;

	if(Ar.IsLoading())
	{
		VertexShaders.Empty();
		VertexShaders.AddZeroed(CompiledShaders.Num());
		PixelShaders.Empty(CompiledShaders.Num());
		PixelShaders.AddZeroed(CompiledShaders.Num());
	}
}

//
//	UD3DRenderDevice::Init
//

void UD3DRenderDevice::Init()
{
	// Create the Direct3D object.
	Direct3D = Direct3DCreate9(D3D_SDK_VERSION);
	if(!Direct3D)
		appErrorf(NAME_FriendlyError, TEXT("Please install DirectX 9.0c or later (see Release Notes for instructions on how to obtain it)"));

	// Load the compiled shader cache.
	FArchive* CompiledShaderCacheFile = GFileManager->CreateFileReader( *(FString(appBaseDir()) * ShaderPath * TEXT("D3DShaderCache")) );
	if(CompiledShaderCacheFile)
	{
		SerializeCompiledShaders(*CompiledShaderCacheFile);
		delete CompiledShaderCacheFile;
	}

	// Register the resource client.
	GResourceManager->RegisterClient(this);
}

//
//	UD3DRenderDevice::Destroy
//

void UD3DRenderDevice::Destroy()
{
	// Deregister the resource client.

	GResourceManager->DeregisterClient(this);

	GDirect3DDevice	= NULL;
	Direct3D		= NULL;

	// Save the shader cache.

	FArchive* CompiledShaderCacheFile = GFileManager->CreateFileWriter( *(FString(appBaseDir()) * ShaderPath * TEXT("D3DShaderCache")) );
	if(CompiledShaderCacheFile)
	{
		SerializeCompiledShaders(*CompiledShaderCacheFile);
		delete CompiledShaderCacheFile;
	}
	else
	{
		warnf(
			NAME_UserPrompt,
			TEXT("%s cannot be written.  Some shaders may be recompiled next time they are loaded, causing increased level load times."),
			*(FString(appBaseDir()) * ShaderPath * TEXT("D3DShaderCache"))
			);
	}

	delete D3DTempDefinitions;
	D3DTempDefinitions = NULL;

	Super::Destroy();
}

//
//	UD3DRenderDevice::PostEditChange
//

void UD3DRenderDevice::PostEditChange(UProperty* PropertyThatChanged)
{
	Super::PostEditChange(PropertyThatChanged);
	UpdateRenderOptions();
}

//
//	UD3DRenderDevice::Serialize
//

void UD3DRenderDevice::Serialize(FArchive& Ar)
{
	Super::Serialize(Ar);
	if(!Ar.IsLoading() && !Ar.IsSaving())
	{
		// Make sure objects referenced by hit proxies aren't garbage collected.
		for(INT ProxyIndex = 0;ProxyIndex < HitProxies.Num();ProxyIndex++)
			if(HitProxies(ProxyIndex))
				HitProxies(ProxyIndex)->Serialize(Ar);
	}
}

//
//	FD3DSortedResource
//

struct FD3DSortedResource
{
	FString	Description;
	UINT	Size;

	FD3DSortedResource(const TCHAR* InDescription):
		Description(InDescription),
		Size(0)
	{}
};

IMPLEMENT_COMPARE_CONSTREF( FD3DSortedResource, D3DRenderDevice, { return B.Size - A.Size; } )

//
//	UD3DRenderDevice::Exec
//

UBOOL UD3DRenderDevice::Exec(const TCHAR* Cmd,FOutputDevice& Ar)
{
	if(ParseCommand(&Cmd,TEXT("AccurateStats")))
	{
		AccurateStats = !AccurateStats;
		return 1;
	}
	else if(ParseCommand(&Cmd,TEXT("DumpRenderTargets")))
	{
		DumpRenderTargets = 1;
		return 1;
	}
	else if(ParseCommand(&Cmd,TEXT("DumpHitProxies")))
	{
		DumpHitProxies = 1;
		return 1;
	}
	else if(ParseCommand(&Cmd,TEXT("ResourceMemoryUsage")))
	{
		TArray<FD3DSortedResource>	SortedResources;
		UINT						TotalSize = GetBufferMemorySize();

		(new(SortedResources) FD3DSortedResource(TEXT("Rendering buffers")))->Size = GetBufferMemorySize();

		for(UINT SetIndex = 0;SetIndex < (UINT)ResourceSets.Num();SetIndex++)
		{
			for(FD3DResource* Resource = GD3DRenderDevice->ResourceSets(SetIndex)->FirstResource;Resource;Resource = Resource->NextResource)
			{
				FD3DSortedResource*	SortedResource = NULL;
				for(UINT OtherResourceIndex = 0;OtherResourceIndex < (UINT)SortedResources.Num();OtherResourceIndex++)
				{
					if(SortedResources(OtherResourceIndex).Description == Resource->Description)
					{
						SortedResource = &SortedResources(OtherResourceIndex);
						break;
					}
				}
				if(!SortedResource)
					SortedResource = new(SortedResources) FD3DSortedResource(*Resource->Description);
				SortedResource->Size += Resource->GetSize();
				TotalSize += Resource->GetSize();
			}
		}
		Sort<USE_COMPARE_CONSTREF(FD3DSortedResource,D3DRenderDevice)>(&SortedResources(0),SortedResources.Num());

		for(UINT ResourceIndex = 0;ResourceIndex < (UINT)SortedResources.Num();ResourceIndex++)
			if(SortedResources(ResourceIndex).Description.Len())
				Ar.Logf(TEXT("%u KB: %s"),SortedResources(ResourceIndex).Size / 1024,*SortedResources(ResourceIndex).Description);

		GLog->Logf(TEXT("%u resources consuming %uMB of video memory"),SortedResources.Num(),TotalSize / 1024 / 1024);
		return 1;
	}
	else if(ParseCommand(&Cmd,TEXT("DumpResources")))
	{
		UINT	NumResources = 0,
				NumBytes = 0;
		for(UINT SetIndex = 0;SetIndex < (UINT)ResourceSets.Num();SetIndex++)
		{
			for(FD3DResource* Resource = GD3DRenderDevice->ResourceSets(SetIndex)->FirstResource;Resource;Resource = Resource->NextResource)
			{
				Resource->Dump(*GLog);
				NumBytes += Resource->GetSize();
				NumResources++;
			}
		}
		GLog->Logf(TEXT("%u resources consuming %uKB of video memory"),NumResources,NumBytes / 1024);
		return 1;
	}
	else if(ParseCommand(&Cmd,TEXT("RecompileShaders")))
	{
		CompiledMeshLightShaders.Empty();
		CompiledMeshShaders.Empty();
		CompiledEmissiveTileShaders.Empty();
		CompiledShaders.Empty();
		CompiledShaderMap.Empty();
		VertexShaders.Empty();
		PixelShaders.Empty();
		Flush();
		return 1;
	}
	else if(ParseCommand(&Cmd,TEXT("DumpShaders")))
	{
		for(UINT SetIndex = 0;SetIndex < (UINT)ResourceSets.Num();SetIndex++)
			for(FD3DResource* Resource = GD3DRenderDevice->ResourceSets(SetIndex)->FirstResource;Resource;Resource = Resource->NextResource)
				Resource->DumpShader();
		return 1;
	}
	else
		return 0;
}

//
//	UD3DRenderDevice::Precache
//

void UD3DRenderDevice::Precache(FD3DViewport* Viewport)
{
	if(!DisablePrecaching)
	{
		DOUBLE	StartTime = appSeconds();
		Viewport->Viewport->ViewportClient->Precache(Viewport->Viewport,this);
		DOUBLE	EndTime = appSeconds();

		UINT	NumBytes = 0;
		for(UINT SetIndex = 0;SetIndex < (UINT)ResourceSets.Num();SetIndex++)
			for(FD3DResource* Resource = GD3DRenderDevice->ResourceSets(SetIndex)->FirstResource;Resource;Resource = Resource->NextResource)
				NumBytes += Resource->GetSize();

		//debugf(TEXT("Precaching %uMB took %.2f seconds"),NumBytes / 1024 / 1024,EndTime - StartTime);
	}
}

//
//	UD3DRenderDevice::CacheBuffers
//

void UD3DRenderDevice::CacheBuffers(UINT MinSizeX,UINT MinSizeY)
{
	// Check if any buffers need to be reallocated.

	UBOOL	ReallocateBuffers = 0;

	if(BufferSizeX < MinSizeX || BufferSizeY < MinSizeY)
		ReallocateBuffers = 1;

	if(CachedShadowBufferSize != MaxShadowResolution)
		ReallocateBuffers = 1;

	if((UseHWShadowMaps && !HWShadowDepthBufferTexture) || (!UseHWShadowMaps && HWShadowDepthBufferTexture))
		ReallocateBuffers = 1;

	if(!ManualExposureRenderTarget)
		ReallocateBuffers = 1;

	CachedBlurBufferDivisor = (UINT)Clamp<INT>(BlurBufferResolutionDivisor,1,4);

	if(BlurBufferSizeX < (MinSizeX / CachedBlurBufferDivisor) + 2 || BlurBufferSizeY < (MinSizeY / CachedBlurBufferDivisor) + 2)
		ReallocateBuffers = 1;

	if(ReallocateBuffers)
	{
		MinSizeX = Max(MinSizeX,BufferSizeX);
		MinSizeY = Max(MinSizeY,BufferSizeY);

		// Release all resources.
		Flush();

		// Allocate buffers.
		AllocateBuffers(MinSizeX,MinSizeY);

		// Allow viewport client to precache resources it will use for rendering.
		Precache(GD3DRenderInterface.CurrentViewport);
	}
}

//
//	UD3DRenderDevice::AllocateBuffers
//

void UD3DRenderDevice::AllocateBuffers(UINT MinSizeX, UINT MinSizeY)
{
	if(MinSizeX && MinSizeY)
	{
		// Create the lighting buffers.
#ifndef XBOX
		LightingRenderTargets[0]	= new FD3DRenderTarget( MinSizeX, MinSizeY, Supports16bitRT ? D3DFMT_A16B16G16R16F : D3DFMT_A32B32G32R32F, TEXT("Lighting0") );
		LightingRenderTargets[1]	= new FD3DRenderTarget( MinSizeX, MinSizeY, Supports16bitRT ? D3DFMT_A16B16G16R16F : D3DFMT_A32B32G32R32F, TEXT("Lighting1") );
#else
		LightingRenderTarget		= new FD3DRenderTarget( MinSizeX, MinSizeY, D3DFMT_A16B16G16R16F, TEXT("Lighting") );
#endif

		// Create the light render target.
		LightRenderTarget			= new FD3DRenderTarget( MinSizeX, MinSizeY, D3DFMT_A8R8G8B8, TEXT("Light") );
	}

	BufferSizeX = MinSizeX;
	BufferSizeY = MinSizeY;

	// Create the shadow depth buffer render target.

	HRESULT Result;
	if(UseHWShadowMaps)
	{
		Result = GDirect3DDevice->CreateTexture(
			MaxShadowResolution,
			MaxShadowResolution,
			1,
			D3DUSAGE_DEPTHSTENCIL,
			D3DFMT_D24X8,
			D3DPOOL_DEFAULT,
			&HWShadowDepthBufferTexture.Handle,
			NULL
			);
		if (FAILED(Result))
			appErrorf(TEXT("Creation of HW shadow depth buffer failed: %s"),*D3DError(Result));

		TD3DRef<IDirect3DSurface9> ShadowDepthBufferSurface;
		Result = HWShadowDepthBufferTexture->GetSurfaceLevel(0, &ShadowDepthBufferSurface.Handle);
		if (FAILED(Result))
			appErrorf(TEXT("GetSurfaceLevel failed on HW shadowmap: %s"), *D3DError(Result));

		ShadowDepthBuffer = new FD3DDepthStencilSurface( ShadowDepthBufferSurface );
	}
	else
	{
		ShadowDepthBuffer = new FD3DDepthStencilSurface( MaxShadowResolution, MaxShadowResolution, D3DFMT_D24X8, TEXT("ShadowDepthZ") );
	}

	ShadowDepthRenderTarget = new FD3DRenderTarget( MaxShadowResolution, MaxShadowResolution, UseHWShadowMaps ? D3DFMT_A8R8G8B8 : D3DFMT_R32F, TEXT("ShadowDepthRT") );

	CachedShadowBufferSize = MaxShadowResolution;

	// Create the manual exposure render target.

	ManualExposureRenderTarget = new FD3DRenderTarget( 1, 1, D3DFMT_R32F, TEXT("ManualExposure") );

	// Create the blur buffers.

	CachedBlurBufferDivisor = (UINT)Clamp<INT>(BlurBufferResolutionDivisor,1,4);
	BlurBufferSizeX = MinSizeX / CachedBlurBufferDivisor + 2;
	BlurBufferSizeY = MinSizeY / CachedBlurBufferDivisor + 2;

	for(UINT BufferIndex = 0;BufferIndex < ARRAY_COUNT(BlurRenderTargets);BufferIndex++)
		BlurRenderTargets[BufferIndex] = new FD3DRenderTarget( BlurBufferSizeX, BlurBufferSizeY, Supports16bitRT ? D3DFMT_A16B16G16R16F : D3DFMT_A32B32G32R32F, *FString::Printf(TEXT("Blur%i"),BufferIndex) );
}

//
//	UD3DRenderDevice::GetBufferMemorySize
//

UINT UD3DRenderDevice::GetBufferMemorySize()
{
	// Count the bytes used by the rendering buffers.

	UINT	Size = 0;
	Size += BufferSizeX * BufferSizeY * 4;									// Back buffer.
	Size += BufferSizeX * BufferSizeY * 4;									// Depth buffer.
	Size += BufferSizeX * BufferSizeY * (Supports16bitRT ? 8 : 16) * 2;			// Lighting buffers.
	Size += BlurBufferSizeX * BlurBufferSizeY * (Supports16bitRT ? 8 : 16) * 3;	// Blur buffers.
	Size += MaxShadowResolution * MaxShadowResolution * 4;					// Shadow depth buffer.
	Size += MaxShadowResolution * MaxShadowResolution * 4;					// Shadow depth texture.
	Size += BufferSizeX * BufferSizeY * 4;									// Light buffer.
	return Size;
}

//
//	UD3DRenderDevice::GetShaderCodeIndex
//

INT UD3DRenderDevice::GetShaderCodeIndex(void* CodeBuffer,UINT CodeSize)
{
	FD3DCompiledShaderCode	Code;
	appMemcpy(&Code.Code(Code.Code.Add(CodeSize / sizeof(DWORD))),CodeBuffer,CodeSize);

	INT*	CachedCodeIndex = CompiledShaderMap.Find(Code);

	if(CachedCodeIndex)
		return *CachedCodeIndex;

	// Count the number of shader instructions.
	TD3DRef<ID3DXBuffer> DisassemblyBuffer;
	D3DXDisassembleShader((DWORD*)CodeBuffer,0,NULL,&DisassemblyBuffer.Handle);
	Parse(ANSI_TO_TCHAR((ANSICHAR*)DisassemblyBuffer->GetBufferPointer()),TEXT("// approximately "),(DWORD&)Code.NumInstructions);

	INT	CodeIndex = CompiledShaders.Num();
	new(CompiledShaders) FD3DCompiledShaderCode(Code);
	VertexShaders.AddZeroed();
	PixelShaders.AddZeroed();
	CompiledShaderMap.Set(Code,CodeIndex);

	return CodeIndex;
}

//
//	UD3DRenderDevice::SetVertexShader
//

void UD3DRenderDevice::SetVertexShader(const TD3DRef<IDirect3DVertexShader9>& VertexShader)
{
	if(CurrentVertexShader != VertexShader)
	{
		GDirect3DDevice->SetVertexShader(VertexShader);
		CurrentVertexShader = VertexShader;
	}
}

//
//	UD3DRenderDevice::SetPixelShader
//

void UD3DRenderDevice::SetPixelShader(const TD3DRef<IDirect3DPixelShader9>& PixelShader)
{
	if(CurrentPixelShader != PixelShader)
	{
		GDirect3DDevice->SetPixelShader(PixelShader);
		CurrentPixelShader = PixelShader;
	}
}

//
//	UD3DRenderDevice::GetShaderSource
//

FString UD3DRenderDevice::GetShaderSource(const TCHAR* Filename)
{
	FString*	SourceString = ShaderFileCache.Find(Filename);

	if(!SourceString)
	{
		// Load the specified file from the System/Shaders directory.

		FString	FileContents;

		if( !appLoadFileToString(FileContents,*(FString(appBaseDir()) * ShaderPath * TEXT("HLSL") * FString(Filename)) ) )
			appErrorf(TEXT("Couldn't load HLSL shader header \'%s\'"),Filename);

		ShaderFileCache.Set(Filename,*FileContents);

		return FileContents;
	}
	else
		return *SourceString;
}

//
//	UD3DRenderDevice::UpdateRenderOptions
//

void UD3DRenderDevice::UpdateRenderOptions()
{
	UseFPBlending = !DisableFPBlending && SupportsFPBlending;
	UseFPTranslucency = !DisableFPTranslucency && UseFPBlending;
	UseFPFiltering = !DisableFPFiltering && SupportsFPFiltering;
	UseHWShadowMaps = !DisableHWShadowMaps && SupportsHWShadowMaps;
	UseShaderModel3 = !DisableShaderModel3 && SupportsShaderModel3;
	UseMultiLightPath = !DisableMultiLightPath && SupportsMultiLightPath;
}

//
//	UD3DRenderDevice::CleanupDevice
//

void UD3DRenderDevice::CleanupDevice()
{
	Flush();
	EventQuery = NULL;
	BackBuffer = NULL;
	DepthBuffer = NULL;
	HitProxyBuffer = NULL;
}

//
//	UD3DRenderDevice::InitDevice
//

void UD3DRenderDevice::InitDevice()
{
	HRESULT	Result;

	// If no viewports are open, clean up the existing device and return.

	if(!Viewports.Num())
	{
		if(GDirect3DDevice)
		{
			CleanupDevice();
			GDirect3DDevice = NULL;
		}
		return;
	}

	// Find the maximum viewport dimensions and any fullscreen viewports.

	FD3DViewport*	NewFullscreenViewport = NULL;
	UINT			MaxViewportSizeX = 0,
					MaxViewportSizeY = 0,
					MaxHitViewportSizeX = 0,
					MaxHitViewportSizeY = 0;

	for(INT ViewportIndex = 0;ViewportIndex < Viewports.Num();ViewportIndex++)
	{
		FD3DViewport*	D3DViewport = Viewports(ViewportIndex);

		MaxViewportSizeX = Max(MaxViewportSizeX,D3DViewport->SizeX);
		MaxViewportSizeY = Max(MaxViewportSizeY,D3DViewport->SizeY);

		if(D3DViewport->Viewport->ViewportClient && D3DViewport->Viewport->ViewportClient->RequiresHitProxyStorage())
		{
			MaxHitViewportSizeX = Max(MaxHitViewportSizeX,D3DViewport->SizeX);
			MaxHitViewportSizeY = Max(MaxHitViewportSizeY,D3DViewport->SizeY);
		}

		if(D3DViewport->Viewport->IsFullscreen())
		{
			check(!NewFullscreenViewport);
			NewFullscreenViewport = D3DViewport;
		}
	}

	// Check to see if GDirect3DDevice needs to be recreated.

	UINT	NewDeviceSizeX		= NewFullscreenViewport ? NewFullscreenViewport->SizeX : MaxViewportSizeX,
			NewDeviceSizeY		= NewFullscreenViewport ? NewFullscreenViewport->SizeY : MaxViewportSizeY;
	HWND	NewDeviceWindow		= NewFullscreenViewport ? (HWND)NewFullscreenViewport->Viewport->GetWindow() : (HWND)Viewports(0)->Viewport->GetWindow();
	UBOOL	NewDeviceFullscreen = NewFullscreenViewport != NULL,
			RecreateDevice		= 0;

	if(!GDirect3DDevice || DeviceLost)
		RecreateDevice = 1;

	if(NewDeviceFullscreen != DeviceFullscreen)
		RecreateDevice = 1;

	if(NewDeviceFullscreen)
	{
		if(DeviceSizeX != NewDeviceSizeX || DeviceSizeY != NewDeviceSizeY)
			RecreateDevice = 1;
	}
	else
	{
		if(DeviceSizeX < NewDeviceSizeX || DeviceSizeY < NewDeviceSizeY)
			RecreateDevice = 1;

		if(HitProxyBufferSizeX < MaxHitViewportSizeX || HitProxyBufferSizeY < MaxHitViewportSizeY)
			RecreateDevice = 1;
	}

	if(DeviceWindow != NewDeviceWindow)
	{
		// If the device window changes, we need to completely destroy and recreate the device.
#ifdef XBOX
		appErrorf(TEXT("!!XENON: the device window should never change on Xenon"));
#endif
		Flush();
		EventQuery		= NULL;
		BackBuffer		= NULL;
		DepthBuffer		= NULL;
		HitProxyBuffer	= NULL;
		GDirect3DDevice	= NULL;
		RecreateDevice	= 1;
	}

	if(RecreateDevice)
	{
#ifndef XBOX
		// Setup the present parameters.

		D3DPRESENT_PARAMETERS PresentParameters;
		
		appMemzero(&PresentParameters,sizeof(PresentParameters));
		PresentParameters.BackBufferCount			= 1;
		PresentParameters.BackBufferFormat			= D3DFMT_A8R8G8B8;
		PresentParameters.BackBufferWidth			= NewDeviceSizeX;
		PresentParameters.BackBufferHeight			= NewDeviceSizeY;
		PresentParameters.SwapEffect				= NewDeviceFullscreen ? D3DSWAPEFFECT_DISCARD : D3DSWAPEFFECT_COPY;
		PresentParameters.Flags						= D3DPRESENTFLAG_LOCKABLE_BACKBUFFER;
		PresentParameters.EnableAutoDepthStencil	= TRUE;
		PresentParameters.AutoDepthStencilFormat	= D3DFMT_D24S8;
		PresentParameters.Windowed					= !NewDeviceFullscreen;
		PresentParameters.PresentationInterval		= D3DPRESENT_INTERVAL_IMMEDIATE;
		PresentParameters.hDeviceWindow				= NewDeviceWindow;

		if( GDirect3DDevice )
		{
			// Simple reset the device with the new present parameters.

			CleanupDevice();

			do 
			{
				if( FAILED(Result=GDirect3DDevice->Reset(&PresentParameters) ) )
				{
					// Sleep for a second before trying again if we couldn't reset the device as the most likely
					// cause is the device not being ready/ lost which can e.g. occur if a screen saver with "lock"
					// kicks in.
					appSleep(1.0);
				}
			} 
			while( FAILED(Result) );
		}
		else
		{
			// Create a new device.

			AdapterNumber	            = D3DADAPTER_DEFAULT;
			D3DDEVTYPE	DeviceType		= D3DDEVTYPE_HAL;
			if( UseRefDevice )
				DeviceType = D3DDEVTYPE_REF;

            D3DADAPTER_IDENTIFIER9  identifier;
            Direct3D->GetAdapterIdentifier( Direct3D->GetAdapterCount() - 1, 0, &identifier );
            if ( strstr( identifier.Description, "PerfHUD" ) != NULL )
            {
                AdapterNumber = Direct3D->GetAdapterCount() - 1;
                DeviceType    = D3DDEVTYPE_REF;
            }

			// Get information about the device being used.

			Result = Direct3D->GetDeviceCaps(AdapterNumber,DeviceType,&DeviceCaps);
			if(FAILED(Result))
				appErrorf(TEXT("Could not get device caps: %s"),*D3DError(Result));

			D3DADAPTER_IDENTIFIER9	AdapterIdentifier;

			Result = Direct3D->GetAdapterIdentifier(AdapterNumber,0,&AdapterIdentifier);
			if(FAILED(Result))
				appErrorf(TEXT("Could not get adapter identifier: %s"),*D3DError(Result));

			debugf(
				TEXT("D3DDrv adapter: Product=%u Version=%u SubVersion=%u Build=%u \'%s\'"),
				HIWORD(AdapterIdentifier.DriverVersion.HighPart),
				LOWORD(AdapterIdentifier.DriverVersion.HighPart),
				HIWORD(AdapterIdentifier.DriverVersion.LowPart),
				LOWORD(AdapterIdentifier.DriverVersion.LowPart),
				ANSI_TO_TCHAR(AdapterIdentifier.Description)
				);

			// Check for ps_2_0 support.

			if((DeviceCaps.PixelShaderVersion & 0xff00) < 0x0200)
				appErrorf(TEXT("Device does not support pixel shaders 2.0 or greater.  PixelShaderVersion=%08x"),DeviceCaps.PixelShaderVersion);

			// Check for required format support.

			D3DDISPLAYMODE	CurrentDisplayMode;
			Result = Direct3D->GetAdapterDisplayMode(AdapterNumber,&CurrentDisplayMode);
			if(FAILED(Result))
				appErrorf(TEXT("Failed to get current adapter display mode."));

			// Determine the supported lighting buffer formats.

			if(FAILED(Direct3D->CheckDeviceFormat(
						AdapterNumber,
						DeviceType,
						CurrentDisplayMode.Format,
						D3DUSAGE_RENDERTARGET,
						D3DRTYPE_TEXTURE,
						D3DFMT_A16B16G16R16F
						)))
				Supports16bitRT = 0;
			else
				Supports16bitRT = 1;

			if(FAILED(Direct3D->CheckDeviceFormat(
						AdapterNumber,
						DeviceType,
						CurrentDisplayMode.Format,
						D3DUSAGE_RENDERTARGET,
						D3DRTYPE_TEXTURE,
						D3DFMT_A32B32G32R32F
						)))
				appErrorf(TEXT("Device does not support 4 component FP render target format."));

			debugf(TEXT("Lighting buffer format: %s"),Supports16bitRT ? TEXT("D3DFMT_A16B16G16R16F") : TEXT("D3DFMT_A32B32G32R32F"));

			// Determine whether alpha blending with a floating point framebuffer is supported.

			SupportsFPBlending = SUCCEEDED(
				Direct3D->CheckDeviceFormat(
					AdapterNumber,
					DeviceType,
					CurrentDisplayMode.Format,
					D3DUSAGE_RENDERTARGET | D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING,
					D3DRTYPE_TEXTURE,
					Supports16bitRT ? D3DFMT_A16B16G16R16F : D3DFMT_A32B32G32R32F
					)
				);

			if(SupportsFPBlending)
				debugf(TEXT("Lighting buffer supports framebuffer blending"));

			// Determine whether hardware shadow mapping is supported.

			SupportsHWShadowMaps = SUCCEEDED(
				Direct3D->CheckDeviceFormat(
					AdapterNumber,
					DeviceType,
					CurrentDisplayMode.Format,
					D3DUSAGE_DEPTHSTENCIL,
					D3DRTYPE_TEXTURE,
					D3DFMT_D24X8)) && SUCCEEDED(
				Direct3D->CheckDeviceFormat(
					AdapterNumber,
					DeviceType,
					CurrentDisplayMode.Format,
					D3DUSAGE_DEPTHSTENCIL,
					D3DRTYPE_TEXTURE,
					D3DFMT_D24S8)) && SUCCEEDED(
				Direct3D->CheckDeviceFormat(
					AdapterNumber,
					DeviceType,
					CurrentDisplayMode.Format,
					D3DUSAGE_DEPTHSTENCIL,
					D3DRTYPE_TEXTURE,
					D3DFMT_D16));

			if(SupportsHWShadowMaps)
				debugf(TEXT("Device supports HW shadow maps"));

			// Determine whether filtering of floating point textures is supported.

			SupportsFPFiltering = SUCCEEDED(
				Direct3D->CheckDeviceFormat(
					AdapterNumber,
					DeviceType,
					CurrentDisplayMode.Format,
					D3DUSAGE_RENDERTARGET | D3DUSAGE_QUERY_FILTER,
					D3DRTYPE_TEXTURE,
					Supports16bitRT ? D3DFMT_A16B16G16R16F : D3DFMT_A32B32G32R32F
					)
				);

			if(SupportsFPFiltering)
				debugf(TEXT("Device supports fp filtering"));

			// Verify that the device supports the required single component 32-bit floating pointer render target format.

			if(FAILED(Direct3D->CheckDeviceFormat(
						AdapterNumber,
						DeviceType,
						CurrentDisplayMode.Format,
						D3DUSAGE_RENDERTARGET,
						D3DRTYPE_TEXTURE,
						D3DFMT_R32F
						)))
				appErrorf(TEXT("Device does not support 1x32 FP render target format."));

			// Determine whether ps_2_b is supported.

			SupportsMultiLightPath = DeviceCaps.PixelShaderVersion > 0x0200;

			// Determine whether ps_3_0 is supported.

			SupportsShaderModel3 = (DeviceCaps.PixelShaderVersion & 0xff00) >= 0x0300;
			check((DeviceCaps.VertexShaderVersion & 0xff00) >= 0x0300 || !SupportsShaderModel3);

			// Query for YUV texture format support.

			if( SUCCEEDED(Direct3D->CheckDeviceFormat( AdapterNumber, DeviceType, CurrentDisplayMode.Format, D3DUSAGE_DYNAMIC, D3DRTYPE_TEXTURE, D3DFMT_UYVY	) ) )
			{
				// Query for SRGB read support (gamma correction on texture sampling) for YUV texture format. E.g. not supported on Radeon 9800.
				if( FAILED(Direct3D->CheckDeviceFormat( AdapterNumber, DeviceType, CurrentDisplayMode.Format, D3DUSAGE_QUERY_SRGBREAD, D3DRTYPE_TEXTURE, D3DFMT_UYVY	) ) )
				{
					GPixelFormats[PF_UYVY].PlatformFlags |= D3DPF_REQUIRES_GAMMA_CORRECTION;
				}
				else
				{
					GPixelFormats[PF_UYVY].PlatformFlags &= ~ D3DPF_REQUIRES_GAMMA_CORRECTION;
				}
			}
			else
			{
				GPixelFormats[PF_UYVY].Supported = 0;
			}
	
			// Try creating a new Direct3D device till it either succeeds or fails with an error code != D3DERR_DEVICELOST.
			
			while( 1 )
			{
				DWORD CreationFlags = D3DCREATE_HARDWARE_VERTEXPROCESSING | D3DCREATE_FPU_PRESERVE /*| D3DCREATE_MULTITHREADED*/;
				if( GEngine->UseStreaming )
				{
					// Driver management of video memory currently is FAR from being optimal for streaming!
					CreationFlags |= D3DCREATE_DISABLE_DRIVER_MANAGEMENT;
				}

				Result = Direct3D->CreateDevice(
					AdapterNumber == INDEX_NONE ? D3DADAPTER_DEFAULT : AdapterNumber,
					DeviceType,
					NewDeviceWindow,
					CreationFlags,
					&PresentParameters,
					&GDirect3DDevice.Handle
					);

				if( Result != D3DERR_DEVICELOST )
					break;

				appSleep( 0.5f );
			}

			if(FAILED(Result))
				appErrorf(TEXT("CreateDevice failed: %s"),*D3DError(Result));

			UpdateRenderOptions();
		}

		// Create an event query for syncronization with the GPU.

		Result = GDirect3DDevice->CreateQuery(D3DQUERYTYPE_EVENT,&EventQuery.Handle);
		if(FAILED(Result))
			appErrorf(TEXT("CreateQuery failed: %s"),*D3DError(Result));

		// Create a hit proxy buffer.

		if(MaxHitViewportSizeX && MaxHitViewportSizeY)
		{
			Result = GDirect3DDevice->CreateRenderTarget(
				MaxHitViewportSizeX,
				MaxHitViewportSizeY,
				D3DFMT_A8R8G8B8,
				D3DMULTISAMPLE_NONE,
				0,
				TRUE,
				&HitProxyBuffer.Handle,
				NULL
				);
			if(FAILED(Result))
				appErrorf(TEXT("Failed to create hit proxy buffer: %s"),*D3DError(Result));
		}
#else
		// Xenon compatibility settings.

		SupportsFPBlending		= 0;
		SupportsFPFiltering		= 0;
		SupportsHWShadowMaps	= 0;
		SupportsShaderModel3	= 0;
		SupportsMultiLightPath	= 0;
		Supports16bitRT			= 1;

		UpdateRenderOptions();
#endif

		HitProxyBufferSizeX = MaxHitViewportSizeX;
		HitProxyBufferSizeY = MaxHitViewportSizeY;

		// Get pointers to the device's back buffer and depth buffer.

		Result = GDirect3DDevice->GetBackBuffer(0,0,D3DBACKBUFFER_TYPE_MONO,&BackBuffer.Handle);
		if(FAILED(Result))
			appErrorf(TEXT("GetBackBuffer failed: %s"),*D3DError(Result));

		Result = GDirect3DDevice->GetDepthStencilSurface(&DepthBuffer.Handle);
		if(FAILED(Result))
			appErrorf(TEXT("GetDepthStencilSurface failed: %s"),*D3DError(Result));

		// Update saved device settings.

		FullscreenViewport	= NewFullscreenViewport;
		DeviceSizeX			= NewDeviceSizeX;
		DeviceSizeY			= NewDeviceSizeY;
		DeviceWindow		= NewDeviceWindow;
		DeviceFullscreen	= NewDeviceFullscreen;
		DeviceLost			= 0;
	}
}

//
//	UD3DRenderDevice::CheckDeviceLost
//

UBOOL UD3DRenderDevice::CheckDeviceLost()
{
#ifndef XBOX
	HRESULT	Result;
	if( DeviceLost )
	{
		Result = GDirect3DDevice->TestCooperativeLevel();
		if( FAILED(Result) )
		{
			// D3DERR_DEVICELOST is returned if the device was lost, but exclusive mode isn't available again yet.
			// D3DERR_DEVICENOTRESET is returned if the device was lost, but can be reset.
			// TestCooperativeLevel will fail if window does not have focus.
			if( Result == D3DERR_DEVICENOTRESET )
			{
				InitDevice();
				return 1;
			}
			else
				return 0;
		}
	}
#endif

	return 1;
}

//
//	UD3DRenderDevice::CreateViewport
//

void UD3DRenderDevice::CreateViewport(FChildViewport* Viewport)
{
	Viewports.AddItem(new FD3DViewport(Viewport,Viewport->GetSizeX(),Viewport->GetSizeY()));
	InitDevice();
}

//
//	UD3DRenderDevice::ResizeViewport
//

void UD3DRenderDevice::ResizeViewport(FChildViewport* Viewport)
{
	DestroyViewport(Viewport);
	CreateViewport(Viewport);
	InitDevice();
}

//
//	UD3DRenderDevice::DestroyViewport
//

void UD3DRenderDevice::DestroyViewport(FChildViewport* Viewport)
{
	INT	ViewportIndex = GetViewportIndex(Viewport);
	check(ViewportIndex != INDEX_NONE);

	if(FullscreenViewport == Viewports(ViewportIndex))
		FullscreenViewport = NULL;

	delete Viewports(ViewportIndex);
	Viewports.Remove(ViewportIndex);

	InvalidateHitProxies(Viewport);

	InitDevice();
}

//
//	UD3DRenderDevice::Flush
//

void UD3DRenderDevice::Flush()
{
	// Ensure that all D3D resources currently locked by the streaming code are unlocked.
	GStreamingManager->Flush( TRUE );

	InvalidateHitProxyCache();

	// Free the render targets.

#ifndef XBOX
	delete LightingRenderTargets[0];
	delete LightingRenderTargets[1];
	LightingRenderTargets[0]		= NULL;
	LightingRenderTargets[1]		= NULL;
#else
	delete LightingRenderTarget;
	LightingRenderTarget			= NULL;
#endif
	delete BlurRenderTargets[0];
	delete BlurRenderTargets[1];
	delete LightRenderTarget;
	delete ManualExposureRenderTarget;
	delete ShadowDepthRenderTarget;
	delete ShadowDepthBuffer;

	BlurRenderTargets[0]			= NULL;
	BlurRenderTargets[1]			= NULL;
	LightRenderTarget				= NULL;
	ManualExposureRenderTarget		= NULL;
	ShadowDepthRenderTarget			= NULL;
	ShadowDepthBuffer				= NULL;

	HWShadowDepthBufferTexture		= NULL;
	ShadowDepthBuffer				= NULL;
	BufferSizeX						= 0;
	BufferSizeY						= 0;
	BlurBufferSizeX					= 0;
	BlurBufferSizeY					= 0;
	CachedShadowBufferSize			= 0;
	CachedBlurBufferDivisor			= 0;

	// Disassociate cached resources from their sources and free the unreferenced resources.

	for(UINT SetIndex = 0;SetIndex < (UINT)ResourceSets.Num();SetIndex++)
		ResourceSets(SetIndex)->Flush();

	if(DynamicIndexBuffer16)
	{
		delete DynamicIndexBuffer16;
		DynamicIndexBuffer16 = NULL;
	}

	if(DynamicIndexBuffer32)
	{
		delete DynamicIndexBuffer32;
		DynamicIndexBuffer32 = NULL;
	}

	ShaderFileCache.Empty();

	USE_OWN_ALLOCATOR;
	if( GDirect3DDevice )
	{
		// This avoids later calls to SetVertexDeclaration releasing a vertex declaration which was allocated with our memory manager.
		GDirect3DDevice->SetFVF( D3DFVF_XYZ );
	}
	CachedVertexDeclarations.Empty();
	CanvasVertexDeclaration = NULL;

	for(UINT ShaderIndex = 0;ShaderIndex < (UINT)CompiledShaders.Num();ShaderIndex++)
	{
		PixelShaders(ShaderIndex) = NULL;
		VertexShaders(ShaderIndex) = NULL;
	}
	USE_DEFAULT_ALLOCATOR;
}

//
//	UD3DRenderDevice::DrawViewport
//

void UD3DRenderDevice::DrawViewport(FChildViewport* Viewport,UBOOL Synchronous)
{
	INT	ViewportIndex = GetViewportIndex(Viewport);
	check(ViewportIndex != INDEX_NONE);

	if(!CheckDeviceLost() || (FullscreenViewport && Viewports(ViewportIndex) != FullscreenViewport))
		return;

	GD3DRenderInterface.BeginScene(Viewports(ViewportIndex),0);
	if(Viewport->ViewportClient)
		Viewport->ViewportClient->Draw(Viewport,&GD3DRenderInterface);
	GD3DRenderInterface.EndScene(Synchronous);
}

//
//	UD3DRenderDevice::GetHitProxyMap
//

void UD3DRenderDevice::GetHitProxyMap(FChildViewport* Viewport,UINT MinX,UINT MinY,UINT MaxX,UINT MaxY,TArray<HHitProxy*>& OutMap)
{
	check(Viewport->ViewportClient && Viewport->ViewportClient->RequiresHitProxyStorage());

	INT	ViewportIndex = GetViewportIndex(Viewport);
	check(ViewportIndex != INDEX_NONE);
	FD3DViewport*	D3DViewport = Viewports(ViewportIndex);

	MinX = Clamp<UINT>(MinX, 0, D3DViewport->SizeX-1);
	MinY = Clamp<UINT>(MinY, 0, D3DViewport->SizeY-1);
	MaxX = Clamp<UINT>(MaxX, 0, D3DViewport->SizeX-1);
	MaxY = Clamp<UINT>(MaxY, 0, D3DViewport->SizeY-1);

	UINT	SizeX = MaxX - MinX + 1,
			SizeY = MaxY - MinY + 1;

	OutMap.Empty(SizeX * SizeY);
	OutMap.AddZeroed(SizeX * SizeY);

	if(!CheckDeviceLost() || (FullscreenViewport && Viewports(ViewportIndex) != FullscreenViewport))
		return;

	if(CachedHitProxyViewport != Viewport)
	{
		// Cache the hit proxy used by each pixel in the viewport.

		InvalidateHitProxyCache();

		GD3DRenderInterface.BeginScene(D3DViewport,1);
		if(Viewport->ViewportClient)
			Viewport->ViewportClient->Draw(Viewport,&GD3DRenderInterface);
		GD3DRenderInterface.EndScene(0);

		CachedHitProxyViewport = Viewport;
	}

	if(DumpHitProxies)
	{
		// Dump the entire hit proxy buffer to a file.

		SaveRenderTarget(HitProxyBuffer,TEXT("HitProxies"));
		DumpHitProxies = 0;
	}

	// Read back the hit proxy buffer from (MinX,MinY) to (MaxX,MaxY)

	D3DLOCKED_RECT	LockedRect;
	RECT			HitRect;
	HitRect.left = MinX;
	HitRect.top = MinY;
	HitRect.right = MaxX + 1;
	HitRect.bottom = MaxY + 1;
	HRESULT	Result = HitProxyBuffer->LockRect(&LockedRect,&HitRect,D3DLOCK_READONLY);
	if(FAILED(Result))
		appErrorf(TEXT("Failed to lock hit proxy buffer: %s"),*D3DError(Result));

	for(UINT Y = MinY;Y <= MaxY;Y++)
	{
		DWORD*	SrcPtr = (DWORD*)((BYTE*)LockedRect.pBits + (Y - MinY) * LockedRect.Pitch);
		for(UINT X = MinX;X <= MaxX;X++)
		{
			DWORD	HitProxyIndex = *SrcPtr++ & 0x00ffffff;
			if(HitProxyIndex < (DWORD)HitProxies.Num())
				OutMap(((Y - MinY) * SizeX) + X - MinX) = HitProxies(HitProxyIndex);
		}
	}

	HitProxyBuffer->UnlockRect();
}

//
//	UD3DRenderDevice::InvalidateHitProxyCache
//

void UD3DRenderDevice::InvalidateHitProxyCache()
{
	for(INT ProxyIndex = 0;ProxyIndex < HitProxies.Num();ProxyIndex++)
		delete HitProxies(ProxyIndex);
	HitProxies.Empty(1);
	CachedHitProxyViewport = NULL;
	HitProxies.AddItem(NULL);
}

//
//	UD3DRenderDevice::InvalidateHitProxies
//

void UD3DRenderDevice::InvalidateHitProxies(FChildViewport* Viewport)
{
	if(Viewport == CachedHitProxyViewport)
		InvalidateHitProxyCache();
}
