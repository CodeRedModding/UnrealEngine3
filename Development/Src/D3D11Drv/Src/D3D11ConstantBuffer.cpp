/*=============================================================================
	D3D11ConstantBuffer.cpp: D3D Constant buffer RHI implementation.
	Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
=============================================================================*/

#include "D3D11DrvPrivate.h"

// SHANOND: Looks like UpdateSubresource is going to be the way to update these CBs.
//			The driver writers are trying to optimize for UpdateSubresource and this
//			will also avoid any driver renaming issues we may hit with map_discard.

#define MAX_POOL_BUFFERS 1 // use update subresource and plop it into the command stream

// Need to update BONE_CONSTANT_BUFFER_SIZE if MAX_GPUSKIN_BONES changes
checkAtCompileTime(MAX_GPUSKIN_BONES == 75, ERROR_BONE_CBUFFER_NEEDS_UPDATING);

/** Sizes of constant buffers defined in ED3D11ShaderOffsetBuffer. */
const UINT GConstantBufferSizes[MAX_CONSTANT_BUFFER_SLOTS] = 
{
	// CBs must be a multiple of 16
	Align(MAX_GLOBAL_CONSTANT_BUFFER_SIZE, 16),
	Align(sizeof(FVertexShaderOffsetConstantBufferContents), 16),
	Align(sizeof(FPixelShaderOffsetConstantBufferContents), 16),
	Align(BONE_CONSTANT_BUFFER_SIZE, 16),
	Align(sizeof(FHullShaderOffsetConstantBufferContents), 16),
	Align(sizeof(FDomainShaderOffsetConstantBufferContents), 16),
	Align(MAX_IR_CONSTANT_BUFFER_SIZE, 16),
	Align(MAX_IR_CONSTANT_BUFFER_SIZE, 16)
};

FD3D11ConstantBuffer::FD3D11ConstantBuffer(FD3D11DynamicRHI* InD3DRHI,UINT InSize,UINT SubBuffers) : 
	D3DRHI(InD3DRHI),
	MaxSize(InSize),
	IsDirty(FALSE),
	ShadowData(NULL),
	Buffers(NULL),
	CurrentSubBuffer(0),
	NumSubBuffers(SubBuffers),
	CurrentUpdateSize(0),
	TotalUpdateSize(0)
{
	InitResource();
}

FD3D11ConstantBuffer::~FD3D11ConstantBuffer()
{
	ReleaseResource();
}

/**
* Creates a constant buffer on the device
*/
void FD3D11ConstantBuffer::InitDynamicRHI()
{
	TRefCountPtr<ID3D11Buffer> CBuffer = NULL;
	D3D11_BUFFER_DESC BufferDesc;
	// Verify constant buffer ByteWidth requirements
	check(MaxSize <= D3D11_REQ_CONSTANT_BUFFER_ELEMENT_COUNT && (MaxSize % 16) == 0);
	BufferDesc.ByteWidth = MaxSize;
	
	BufferDesc.Usage = D3D11_USAGE_DEFAULT;
	BufferDesc.CPUAccessFlags = 0;
	BufferDesc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	BufferDesc.MiscFlags = 0;

	Buffers = new TRefCountPtr<ID3D11Buffer>[NumSubBuffers];
	CurrentSubBuffer = 0;
	for(UINT s = 0;s < NumSubBuffers;s++)
	{
		VERIFYD3D11RESULT(D3DRHI->GetDevice()->CreateBuffer(&BufferDesc, NULL, Buffers[s].GetInitReference()));
		BufferDesc.ByteWidth = Align(BufferDesc.ByteWidth / 2, 16);
	}

	ShadowData = new BYTE[MaxSize];
	appMemzero(ShadowData,MaxSize);
}

void FD3D11ConstantBuffer::ReleaseDynamicRHI()
{
	if(ShadowData)
	{
		delete [] ShadowData;
	}

	if(Buffers)
	{
		for(UINT s = 0;s < NumSubBuffers;s++)
		{
			delete Buffers[s];
		}
	}
}

/**
* Updates a variable in the constant buffer.
* @param Data - The data to copy into the constant buffer
* @param Offset - The offset in the constant buffer to place the data at
* @param Size - The size of the data being copied
*/
void FD3D11ConstantBuffer::UpdateConstant(const BYTE* Data, WORD Offset, WORD InSize)
{
	IsDirty = TRUE;
	appMemcpy(ShadowData+Offset, Data, InSize);
	CurrentUpdateSize = Max( (UINT)(Offset + InSize), CurrentUpdateSize );
}

/**
* Unlocks the constant buffer so the data can be transmitted to the device
*/
UBOOL FD3D11ConstantBuffer::CommitConstantsToDevice( UBOOL bDiscardSharedConstants )
{
	if(IsDirty)
	{
		SCOPE_CYCLE_COUNTER(STAT_D3D11ConstantBufferUpdateTime);

		if ( bDiscardSharedConstants )
		{
			// If we're discarding shared constants, just use constants that have been updated since the last Commit.
			TotalUpdateSize = CurrentUpdateSize;
		}
		else
		{
			// If we're re-using shared constants, use all constants.
			TotalUpdateSize = Max( CurrentUpdateSize, TotalUpdateSize );
		}

		// This basically keeps track dynamically how much data has been updated every frame
		// and then divides up a "max" constant buffer size by halves down until it finds a large sections that more tightly covers
		// the amount updated, assuming that all data in a constant buffer is updated each draw call and contiguous.
		// This only used for the IndexSlot==0 constant buffer on the vertex shader.
		// Which will have an indeterminate number of constant values that are generated by material shaders.
		CurrentSubBuffer = 1;
		UINT BufferSize = MaxSize / 2;
		while ( BufferSize >= TotalUpdateSize && CurrentSubBuffer < NumSubBuffers )
		{
			CurrentSubBuffer++;
			BufferSize /= 2;
		}
		CurrentSubBuffer--;
		BufferSize *= 2;

		ID3D11Buffer* Buffer = Buffers[CurrentSubBuffer];
		D3DRHI->GetDeviceContext()->UpdateSubresource(Buffer,0,NULL,(void*)ShadowData,BufferSize,BufferSize);

		IsDirty = FALSE;
		CurrentUpdateSize = 0;

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

/**
* Get the current pool buffer
*/
ID3D11Buffer* FD3D11ConstantBuffer::GetConstantBuffer()
{
	return Buffers[CurrentSubBuffer];
}

void FD3D11DynamicRHI::InitConstantBuffers()
{
	// Allocate shader constant buffers.  All shader types can have access to all buffers.
	//  Index==0 is reserved for "custom" params, and the rest are reserved by the system for Common
	//	constants
	VSConstantBuffers.Empty(MAX_CONSTANT_BUFFER_SLOTS);
	PSConstantBuffers.Empty(MAX_CONSTANT_BUFFER_SLOTS);
	HSConstantBuffers.Empty(MAX_CONSTANT_BUFFER_SLOTS);
	DSConstantBuffers.Empty(MAX_CONSTANT_BUFFER_SLOTS);
	GSConstantBuffers.Empty(MAX_CONSTANT_BUFFER_SLOTS);
	CSConstantBuffers.Empty(MAX_CONSTANT_BUFFER_SLOTS);
	for(INT BufferIndex = 0;BufferIndex < MAX_CONSTANT_BUFFER_SLOTS;BufferIndex++)
	{
		UINT Size = GConstantBufferSizes[BufferIndex];
		UINT SubBuffers = 1;
		if(BufferIndex == GLOBAL_CONSTANT_BUFFER_INDEX)
		{
			SubBuffers = 5;
		}

		// Vertex shader can have subbuffers for index==0.  This is from Epic's original design for the auto-fit of size to
		//	reduce the update costs of the buffer.
		VSConstantBuffers.AddItem(new FD3D11ConstantBuffer(this,Size,SubBuffers));

		PSConstantBuffers.AddItem(new FD3D11ConstantBuffer(this,Size));
		HSConstantBuffers.AddItem(new FD3D11ConstantBuffer(this,Size));
		DSConstantBuffers.AddItem(new FD3D11ConstantBuffer(this,Size));
		GSConstantBuffers.AddItem(new FD3D11ConstantBuffer(this,Size));
		CSConstantBuffers.AddItem(new FD3D11ConstantBuffer(this,Size));
	}
}
