/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "UnrealEdNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_UNREALED_GAMESTATS_ENUMS
#define INCLUDED_UNREALED_GAMESTATS_ENUMS 1

enum GameStatsDateFilters
{
    GSDF_Today              =0,
    GSDF_Last3Days          =1,
    GSDF_LastWeek           =2,
    GSDF_MAX                =3,
};
#define FOREACH_ENUM_GAMESTATSDATEFILTERS(op) \
    op(GSDF_Today) \
    op(GSDF_Last3Days) \
    op(GSDF_LastWeek) 
enum EReportType
{
    RT_SingleSession        =0,
    RT_Game                 =1,
    RT_MAX                  =2,
};
#define FOREACH_ENUM_EREPORTTYPE(op) \
    op(RT_SingleSession) \
    op(RT_Game) 

#endif // !INCLUDED_UNREALED_GAMESTATS_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_UNREALED_GAMESTATS_CLASSES
#define INCLUDED_UNREALED_GAMESTATS_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

struct FSessionIndexPair
{
    FString SessionId;
    INT Index;

		FSessionIndexPair(EEventParm)
		{
			appMemzero(this, sizeof(FSessionIndexPair));
		}

		FSessionIndexPair(const FString& InSessionId, const INT InIndex) 
			: SessionId(InSessionId), Index(InIndex) {}
	
};

struct FGameStatsSearchQuery
{
    INT StartTime;
    INT EndTime;
    TArrayNoInit<FString> SessionIDs;
    TArrayNoInit<INT> EventIDs;
    TArrayNoInit<struct FSessionIndexPair> TeamIndices;
    TArrayNoInit<struct FSessionIndexPair> PlayerIndices;

		/** Constructors */
		FGameStatsSearchQuery() {}
		FGameStatsSearchQuery(EEventParm)
		{
			appMemzero(this, sizeof(FGameStatsSearchQuery));
		}

		enum SearchQueryTypes
		{
			ALL_PLAYERS =  INDEX_NONE,
			ALL_TEAMS =    INDEX_NONE,
			ALL_EVENTS =   INDEX_NONE,
		};
	
};

struct FGameSessionEntry
{
    TArray<INT> AllEvents;
    TArrayNoInit<INT> GameEvents;
    TMultiMap<INT, INT> EventsByPlayer;
    TMultiMap<INT, INT> EventsByRound;
    TMultiMap<INT, INT> EventsByType;
    TMultiMap<INT, INT> EventsByTeam;

		/** Constructors */
		FGameSessionEntry() {}
		FGameSessionEntry(EEventParm)
		{
			appMemzero(this, sizeof(FGameSessionEntry));
		}

		/* Clear out all contained data */
		void Empty()
		{
			AllEvents.Empty();
			GameEvents.Empty();
			EventsByPlayer.Empty();
			EventsByRound.Empty();
			EventsByType.Empty();
			EventsByTeam.Empty();
		}
	
};

struct FIGameStatEntry
{
    FString EventName;
    INT EventID;
    FLOAT EventTime;

		FIGameStatEntry() {}
		FIGameStatEntry(const struct FGameEventHeader& GameEvent);
		FIGameStatEntry(class FDataBaseRecordSet* RecordSet);

		/** 
		 * Every entry type must handle/accept the visitor interface 
		 * @param Visitor - Interface class wanting access to the entry
		 */
		virtual void Accept(class IGameStatsDatabaseVisitor* Visitor)
		{
			ensureMsg(0, TEXT("Game stats database entry type didn't implement Accept function!"));
		}
	
};

struct FGameStatsRecordSet
{
    TArray<INT> LocalRecordSet;
    TArray<FIGameStatEntry*> RemoteRecordSet;

		INT GetNumResults() { return LocalRecordSet.Num() + RemoteRecordSet.Num(); }
	
};

class UGameStatsDatabase : public UObject
{
public:
    //## BEGIN PROPS GameStatsDatabase
    TMultiMap<FString, FString> MapNameToFilenameMapping;
    TArrayNoInit<FIGameStatEntry*> AllEvents;
    TMap<FString, struct FGameSessionEntry> AllSessions;
    TMap<FString, FString> SessionFilenamesBySessionID;
    TMap<FString, struct FGameSessionInformation> SessionInfoBySessionID;
    TMap<FString, TArray<struct FPlayerInformation> > PlayerListBySessionID;
    TMap<FString, TArray<struct FTeamInformation> > TeamListBySessionID;
    TMap<FString, TArray<struct FGameplayEventMetaData> > SupportedEventsBySessionID;
    TMap<FString, TArray<struct FWeaponClassEventData> > WeaponClassesBySessionID;
    TMap<FString, TArray<struct FDamageClassEventData> > DamageClassesBySessionID;
    TMap<FString, TArray<struct FProjectileClassEventData> > ProjectileClassesBySessionID;
    TMap<FString, TArray<struct FPawnClassEventData> > PawnClassesBySessionID;
    TArrayNoInit<FString> AllGameTypes;
    struct FGameStatsRemoteDB* RemoteDB;
    FStringNoInit GameStatsFileReaderClassname;
    FStringNoInit GameStateClassname;
    //## END PROPS GameStatsDatabase

    virtual void Init(const FString& MapName,BYTE DateFilter);
    virtual void CacheLocalFilenames();
    virtual void GetGameTypes(TArray<FString>& GameTypes);
    virtual void GetSessionIDs(BYTE DateFilter,const FString& GameTypeFilter,TArray<FString>& SessionIDs);
    virtual UBOOL IsSessionIDLocal(const FString& SessionId);
    virtual void GetSessionInfoBySessionID(const FString& SessionId,struct FGameSessionInformation& OutSessionInfo);
    virtual void GetPlayersListBySessionID(const FString& SessionId,TArray<struct FPlayerInformation>& OutPlayerList);
    virtual void GetTeamListBySessionID(const FString& SessionId,TArray<struct FTeamInformation>& OutTeamList);
    virtual void GetEventsListBySessionID(const FString& SessionId,TArray<struct FGameplayEventMetaData>& OutGameplayEvents);
    virtual void GetWeaponListBySessionID(const FString& SessionId,TArray<struct FWeaponClassEventData>& OutWeaponList);
    virtual void GetDamageListBySessionID(const FString& SessionId,TArray<struct FDamageClassEventData>& OutDamageList);
    virtual void GetProjectileListBySessionID(const FString& SessionId,TArray<struct FProjectileClassEventData>& OutProjectileList);
    virtual void GetPawnListBySessionID(const FString& SessionId,TArray<struct FPawnClassEventData>& OutPawnList);
    virtual INT GetEventCountByType(const FString& SessionId,INT EventID);
    virtual void ClearDatabase();
    virtual UBOOL UploadSession(const FString& SessionId);
    DECLARE_FUNCTION(execInit)
    {
        P_GET_STR(MapName);
        P_GET_BYTE(DateFilter);
        P_FINISH;
        this->Init(MapName,DateFilter);
    }
    DECLARE_FUNCTION(execCacheLocalFilenames)
    {
        P_FINISH;
        this->CacheLocalFilenames();
    }
    DECLARE_FUNCTION(execGetGameTypes)
    {
        P_GET_TARRAY_REF(FString,GameTypes);
        P_FINISH;
        this->GetGameTypes(GameTypes);
    }
    DECLARE_FUNCTION(execGetSessionIDs)
    {
        P_GET_BYTE(DateFilter);
        P_GET_STR(GameTypeFilter);
        P_GET_TARRAY_REF(FString,SessionIDs);
        P_FINISH;
        this->GetSessionIDs(DateFilter,GameTypeFilter,SessionIDs);
    }
    DECLARE_FUNCTION(execIsSessionIDLocal)
    {
        P_GET_STR(SessionId);
        P_FINISH;
        *(UBOOL*)Result=this->IsSessionIDLocal(SessionId);
    }
    DECLARE_FUNCTION(execGetSessionInfoBySessionID)
    {
        P_GET_STR(SessionId);
        P_GET_STRUCT_INIT_REF(struct FGameSessionInformation,OutSessionInfo);
        P_FINISH;
        this->GetSessionInfoBySessionID(SessionId,OutSessionInfo);
    }
    DECLARE_FUNCTION(execGetPlayersListBySessionID)
    {
        P_GET_STR(SessionId);
        P_GET_TARRAY_REF(struct FPlayerInformation,OutPlayerList);
        P_FINISH;
        this->GetPlayersListBySessionID(SessionId,OutPlayerList);
    }
    DECLARE_FUNCTION(execGetTeamListBySessionID)
    {
        P_GET_STR(SessionId);
        P_GET_TARRAY_REF(struct FTeamInformation,OutTeamList);
        P_FINISH;
        this->GetTeamListBySessionID(SessionId,OutTeamList);
    }
    DECLARE_FUNCTION(execGetEventsListBySessionID)
    {
        P_GET_STR(SessionId);
        P_GET_TARRAY_REF(struct FGameplayEventMetaData,OutGameplayEvents);
        P_FINISH;
        this->GetEventsListBySessionID(SessionId,OutGameplayEvents);
    }
    DECLARE_FUNCTION(execGetWeaponListBySessionID)
    {
        P_GET_STR(SessionId);
        P_GET_TARRAY_REF(struct FWeaponClassEventData,OutWeaponList);
        P_FINISH;
        this->GetWeaponListBySessionID(SessionId,OutWeaponList);
    }
    DECLARE_FUNCTION(execGetDamageListBySessionID)
    {
        P_GET_STR(SessionId);
        P_GET_TARRAY_REF(struct FDamageClassEventData,OutDamageList);
        P_FINISH;
        this->GetDamageListBySessionID(SessionId,OutDamageList);
    }
    DECLARE_FUNCTION(execGetProjectileListBySessionID)
    {
        P_GET_STR(SessionId);
        P_GET_TARRAY_REF(struct FProjectileClassEventData,OutProjectileList);
        P_FINISH;
        this->GetProjectileListBySessionID(SessionId,OutProjectileList);
    }
    DECLARE_FUNCTION(execGetPawnListBySessionID)
    {
        P_GET_STR(SessionId);
        P_GET_TARRAY_REF(struct FPawnClassEventData,OutPawnList);
        P_FINISH;
        this->GetPawnListBySessionID(SessionId,OutPawnList);
    }
    DECLARE_FUNCTION(execGetEventCountByType)
    {
        P_GET_STR(SessionId);
        P_GET_INT(EventID);
        P_FINISH;
        *(INT*)Result=this->GetEventCountByType(SessionId,EventID);
    }
    DECLARE_FUNCTION(execClearDatabase)
    {
        P_FINISH;
        this->ClearDatabase();
    }
    DECLARE_FUNCTION(execUploadSession)
    {
        P_GET_STR(SessionId);
        P_FINISH;
        *(UBOOL*)Result=this->UploadSession(SessionId);
    }
    DECLARE_CLASS(UGameStatsDatabase,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

public:

	/** @return TRUE if this database is able to access a remote database */
	UBOOL HasRemoteConnection() { return RemoteDB != NULL; }

	/** 
	* Query this database
	* @param SearchQuery - the query to run on the database
	* @param Events - out array of indices of relevant events in the database
	* @return the number of results found for this query
	*/
	virtual INT QueryDatabase(const struct FGameStatsSearchQuery& Query, struct FGameStatsRecordSet& RecordSet);

	/**
	* Allows a visitor interface access to every database entry of interest
	* @param SessionID - session we're interested in
	* @param EventIndices - all events the visitor wants access to
	* @param Visitor - the visitor interface that will be accessing the data
	* @return TRUE if the visitor got what it needed from the visit, FALSE otherwise
	*/
	virtual UBOOL VisitEntries(const struct FGameStatsRecordSet& RecordSet, class IGameStatsDatabaseVisitor* Visitor);

	/**
	 *   Fill in database structures for a given sessionID if necessary
	 * @param SessionID - session to cache data for
	 */
	virtual void PopulateSessionData(const FString& SessionID);

protected:
	/*
	 * Get all events associated with a given session
	 * @param SessionID - session we're interested in
	 * @param Events - array of indices related to relevant session events
	 */
	virtual INT GetEventsBySessionID(const FString& SessionID, TArray<INT>& Events);

	/*
	 * Get all game events associated with a given session (neither player nor team)
	 * @param SessionID - session we're interested in
	 * @param Events - array of indices related to relevant game events
	 */
	virtual INT GetGameEventsBySession(const FString& SessionID, TArray<INT>& Events);

	/*
	 * Get all events associated with a given team
	 * @param SessionID - session we're interested in
	 * @param TeamIndex - the team to return the events for (INDEX_NONE is all teams)
	 * @param Events - array of indices related to relevant team events
	 */
	virtual INT GetEventsByTeam(const FString& SessionID, INT TeamIndex, TArray<INT>& Events);

	/*
	 * Get all events associated with a given player
	 * @param SessionID - session we're interested in
	 * @param PlayerIndex - the player to return the events for (INDEX_NONE is all players)
	 * @param Events - array of indices related to relevant player events
	 */
	virtual INT GetEventsByPlayer(const FString& SessionID, INT PlayerIndex, TArray<INT>& Events);

	/*
	 * Get all events associated with a given round
	 * @param SessionID - session we're interested in
	 * @param RoundNumber - the round to return events for  (INDEX_NONE is all rounds)
	 * @param Events - array of indices related to relevant round events
	 */
	virtual INT GetEventsByRound(const FString& SessionID, INT RoundNumber, TArray<INT>& Events);
	
	/*
	 * Get all events associated with a given event ID
	 * @param SessionID - session we're interested in
	 * @param EventID - the event of interest (INDEX_NONE is all events)
	 * @param Events - array of indices related to relevant events
	 */
	virtual INT GetEventsByID(const FString& SessionID, INT EventID, TArray<INT>& Events);

	/** Searches the stats directory for relevant data files and populates the database */
	virtual void LoadLocalData(const FString& MapName, GameStatsDateFilters DateFilter);

	/** Connects to the remote database and populates the db with data */
	virtual void LoadRemoteData(const FString& MapName, GameStatsDateFilters DateFilter);

	/** 
	 *   Open a game stats file for reading
	 * @param Filename - name of the file that will be open for serialization
	 * @return TRUE if successful, else FALSE
	 */
	virtual UBOOL OpenStatsFile(const FString& Filename);
};

class UGameStatsDatabaseVisitor : public UInterface
{
public:
    DECLARE_ABSTRACT_CLASS(UGameStatsDatabaseVisitor,UInterface,0|CLASS_Interface,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UGameStatsDatabaseVisitor)
};

class IGameStatsDatabaseVisitor
{
protected:
	virtual ~IGameStatsDatabaseVisitor() {}
public:
	typedef UGameStatsDatabaseVisitor UClassType;
	virtual UObject* GetUObjectInterfaceGameStatsDatabaseVisitor()=0;
	/** Called before the visiting begins */
	virtual void BeginVisiting() = 0;

	/** Called after the visiting is over */
	virtual UBOOL EndVisiting() = 0;

	/**
	 * Abstract functions that defines a visitor's behavior when given a GameStatEntry 
	 * There must be an entry for each possible concrete datatype stored in the database
	 * or else no visit action will occur.
	 */
	virtual void Visit(class GameStringEntry* Entry) = 0; 
	virtual void Visit(class GameIntEntry* Entry) = 0;
	virtual void Visit(class GameFloatEntry* Entry) = 0;
	virtual void Visit(class GamePositionEntry* Entry) = 0;
	virtual void Visit(class TeamIntEntry* Entry) = 0;
	virtual void Visit(class TeamStringEntry* Entry) = 0; 
	virtual void Visit(class TeamFloatEntry* Entry) = 0; 
	virtual void Visit(class PlayerStringEntry* Entry) = 0;
	virtual void Visit(class PlayerIntEntry* Entry) = 0; 
	virtual void Visit(class PlayerFloatEntry* Entry) = 0; 
	virtual void Visit(class PlayerLoginEntry* Entry) = 0;
	virtual void Visit(class PlayerSpawnEntry* Entry) = 0;
	virtual void Visit(class PlayerKillDeathEntry* Entry) = 0;
	virtual void Visit(class PlayerPlayerEntry * Entry) = 0;
	virtual void Visit(class WeaponEntry* Entry) = 0;
	virtual void Visit(class DamageEntry* Entry) = 0; 
	virtual void Visit(class ProjectileIntEntry* Entry) = 0;
	virtual void Visit(class GenericParamListEntry* Entry) = 0; 


	/** Forward declarations so that games can create game specific events that can be visited */
	virtual void Visit(class EntryEx1* Entry) = 0;
	virtual void Visit(class EntryEx2* Entry) = 0;
	virtual void Visit(class EntryEx3* Entry) = 0;
	virtual void Visit(class EntryEx4* Entry) = 0;
	virtual void Visit(class EntryEx5* Entry) = 0;
	virtual void Visit(class EntryEx6* Entry) = 0;
	virtual void Visit(class EntryEx7* Entry) = 0;
	virtual void Visit(class EntryEx8* Entry) = 0;
	virtual void Visit(class EntryEx9* Entry) = 0;
	virtual void Visit(class EntryEx10* Entry) = 0;
	virtual void Visit(class EntryEx11* Entry) = 0;
	virtual void Visit(class EntryEx12* Entry) = 0;
	virtual void Visit(class EntryEx13* Entry) = 0;
	virtual void Visit(class EntryEx14* Entry) = 0;
	virtual void Visit(class EntryEx15* Entry) = 0;
};

struct GameStatsFileReader_eventCleanup_Parms
{
    GameStatsFileReader_eventCleanup_Parms(EEventParm)
    {
    }
};
class UGameStatsFileReader : public UGameplayEventsHandler
{
public:
    //## BEGIN PROPS GameStatsFileReader
    class UGameStateObject* GameState;
    struct FGameSessionEntry SessionData;
    INT EventsOffset;
    TArrayNoInit<FIGameStatEntry*> AllEvents;
    //## END PROPS GameStatsFileReader

    virtual void Cleanup();
    DECLARE_FUNCTION(execCleanup)
    {
        P_FINISH;
        this->Cleanup();
    }
    void eventCleanup()
    {
        ProcessEvent(FindFunctionChecked(UNREALED_Cleanup),NULL);
    }
    DECLARE_CLASS(UGameStatsFileReader,UGameplayEventsHandler,0|CLASS_Config,UnrealEd)
public:
	/** 
	 * The function that does the actual handling of data (override with particular implementation) 
	 * @param GameEvent - header of the current game event from disk
	 * @param GameEventData - payload immediately following the header
	 */
	virtual void HandleEvent(struct FGameEventHeader& GameEvent, class IGameEvent* GameEventData);

	/*
	 *   Set the game state this handler will use
	 * @param InGameState - game state object to use
	 */
	virtual void SetGameState(class UGameStateObject* InGameState);

	/** 
	 * Adds a new event created to the array of all events in the file 
	 * @param NewEvent - new event to add
	 * @param TeamIndex - Team Index for team events (INDEX_NONE if not a team event)
	 * @param PlayerIndex - Player Index for player events (INDEX_NONE if not a player event)
	 * @param TargetIndex - Target Index for player events (INDEX_NONE if event has no target)
	 */
	void AddNewEvent(struct FIGameStatEntry* NewEvent, INT TeamIndex, INT PlayerIndex, INT TargetIndex);
};

struct FMetaKeyValuePair
{
    FString Tag;
    FString Key;
    FString Value;

		FMetaKeyValuePair()
		{}
		FMetaKeyValuePair(EEventParm)
		{
			appMemzero(this, sizeof(FMetaKeyValuePair));
		}
		FMetaKeyValuePair(const FString& InTag) : Tag(InTag) {}
	
};

struct FCategory
{
    FString Tag;
    FString Header;
    INT Id;
    TArray<struct FMetaKeyValuePair> KeyValuePairs;
    TArray<struct FCategory> SubCategories;

		FCategory()
		{}
		FCategory(EEventParm)
		{
			appMemzero(this, sizeof(FCategory));
		}
		FCategory(const FString& InTag, const FString& InHeader) : Tag(InTag), Header(InHeader), Id(INDEX_NONE) {}
	
};

struct FHeatmapQuery
{
    FStringNoInit HeatmapName;
    TArrayNoInit<INT> EventIDs;
    FStringNoInit ImageFilename;

    /** Constructors */
    FHeatmapQuery() {}
    FHeatmapQuery(EEventParm)
    {
        appMemzero(this, sizeof(FHeatmapQuery));
    }
};

class UGameStatsReport : public UObject
{
public:
    //## BEGIN PROPS GameStatsReport
    struct FGameSessionInformation SessionInfo;
    class UGameStateObject* GameState;
    class UGameplayEventsReader* StatsFileReader;
    class UGameStatsAggregator* Aggregator;
    TArrayNoInit<INT> HighlightEvents;
    TArrayNoInit<INT> GameStatsColumns;
    TArrayNoInit<INT> TeamStatsColumns;
    TArrayNoInit<INT> PlayerStatsColumns;
    TArrayNoInit<INT> WeaponStatsColumns;
    TArrayNoInit<INT> DamageStatsColumns;
    TArrayNoInit<INT> ProjectileStatsColumns;
    TArrayNoInit<INT> PawnStatsColumns;
    FStringNoInit ReportBaseURL;
    //## END PROPS GameStatsReport

    DECLARE_ABSTRACT_CLASS(UGameStatsReport,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/** Output the entire report in XML */
	virtual void WriteReport(FArchive& Ar);
	/** 
	 * Write the session header information to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WriteSessionHeader(FArchive& Ar, INT IndentCount);
	/** 
	 * Write the any image reference information to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WriteImageMetadata(FArchive& Ar, INT IndentCount);
	/** 
	 * Write the session metadata to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WriteMetadata(FArchive& Ar, INT IndentCount);
	/** 
	 * Write the game stats data to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WriteGameValues(FArchive& Ar, INT IndentCount);
	/** 
	 * Write the team stats data to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WriteTeamValues(FArchive& Ar, INT IndentCount);
	/** 
	 * Fill out the information for a single team
	 * @param Team - XML object to fill in with data
	 * @param TeamIndex - team currently being written out
	 */	
	virtual void WriteTeamValue(FCategory& Team, INT TeamIndex);
	/** 
	 * Write the player stats data to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WritePlayerValues(FArchive& Ar, INT IndentCount);
	/** 
	 * Fill out the information for a single player
	 * @param Player - XML object to fill in with data
	 * @param PlayerIndex - player currently being written out
	 */	
	virtual void WritePlayerValue(FCategory& Player, INT PlayerIndex);
	/** 
	 * Write the weapon stats data to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WriteWeaponValues(FArchive& Ar, INT IndentCount);
	/** 
	 * Write the damage stats data to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WriteDamageValues(FArchive& Ar, INT IndentCount);
	/** 
	 * Write the projectile stats data to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WriteProjectileValues(FArchive& Ar, INT IndentCount);
	/** 
	 * Write the pawn stats data to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WritePawnValues(FArchive& Ar, INT IndentCount);
	/** 
	 * Write anything game specific to XML 
	 * @param Ar - archive to write out
	 * @param IndentCount - number of tabs to indent this information
	 */	
	virtual void WriteGameSpecificValues(FArchive& Ar, INT IndentCount) {}

	/**
     * Get an URL related this report
     * @param ReportType - report type to generate 
     * @return URL passed to a browser to view the report 
	 */
	virtual FString GetReportURL(EReportType ReportType) { return TEXT(""); } 
	/** @return the location of the file generated */
	virtual FString GetReportFilename(const FString& FileExt);

	/** @return list of heatmap queries to run on the database for this report */
	virtual void GetHeatmapQueries(TArray<FHeatmapQuery>& HeatmapQueries);

	/*
	 *   Get all the event columns to be displayed in the whole report 
	 * @param EventColumns - structure to add columns to
	 */
	virtual void GetAllEventColumns(TArray<INT>& EventColumns);
	/*
	 *   Get all the weapon events for a given time period (uses WeaponStatsColumns)
	 * @param ParentCategory - XML container to fill with the data
	 * @param TimePeriod - TimePeriod (0 game, 1+ round)
	 * @param WeaponEvents - the aggregate events structure to get the data from
	 * @param StatsReader - the file reader containing the weapon metadata
	 */
	void GetWeaponValuesForTimePeriod(FCategory& ParentCategory, INT TimePeriod, const struct FWeaponEvents& WeaponEvents, const class UGameplayEventsReader* StatsReader);
	/*
	 *   Get all the damage events for a given time period (uses DamageStatsColumns)
	 * @param ParentCategory - XML container to fill with the data
	 * @param TimePeriod - TimePeriod (0 game, 1+ round)
	 * @param DamageEvents - the aggregate events structure to get the data from
	 * @param StatsReader - the file reader containing the damage metadata
	 */
	void GetDamageValuesForTimePeriod(FCategory& ParentCategory, INT TimePeriod, const struct FDamageEvents& DamageEvents, const class UGameplayEventsReader* StatsReader);
	/*
	 *   Get all the projectile events for a given time period (uses ProjectileStatsColumns)
	 * @param ParentCategory - XML container to fill with the data
	 * @param TimePeriod - TimePeriod (0 game, 1+ round)
	 * @param ProjectileEvents - the aggregate events structure to get the data from
	 * @param StatsReader - the file reader containing the projectile metadata
	 */
	void GetProjectileValuesForTimePeriod(FCategory& ParentCategory, INT TimePeriod, const struct FProjectileEvents& ProjectileEvents, const class UGameplayEventsReader* StatsReader);
	/*
	 *   Get all the pawn events for a given time period (uses PawnStatsColumns)
	 * @param ParentCategory - XML container to fill with the data
	 * @param TimePeriod - TimePeriod (0 game, 1+ round)
	 * @param PawnEvents - the aggregate events structure to get the data from
	 * @param StatsReader - the file reader containing the pawn metadata
	 */
	void GetPawnValuesForTimePeriod(FCategory& ParentCategory, INT TimePeriod, const struct FPawnEvents& PawnEvents, const class UGameplayEventsReader* StatsReader);

};

class UGameStatsVisitorImpl : public UObject, public IGameStatsDatabaseVisitor
{
public:
    //## BEGIN PROPS GameStatsVisitorImpl
    //## END PROPS GameStatsVisitorImpl

    DECLARE_ABSTRACT_CLASS(UGameStatsVisitorImpl,UObject,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    virtual UObject* GetUObjectInterfaceGameStatsDatabaseVisitor(){return this;}
	/** Called before the visiting begins */
	virtual void BeginVisiting() { /* Do nothing */ }

	/** Called after the visiting is over */
	virtual UBOOL EndVisiting() { return TRUE; }

	/**
	 * Abstract functions that defines a visitor's behavior when given a GameStatEntry 
	 * There must be an entry for each possible concrete datatype stored in the database
	 * or else no visit action will occur.
	 */
	virtual void Visit(class GameStringEntry* Entry) { /* Do nothing */ } 
	virtual void Visit(class GameIntEntry* Entry) { /* Do nothing */ }
	virtual void Visit(class GameFloatEntry* Entry) { /* Do nothing */ }
	virtual void Visit(class GamePositionEntry* Entry) { /* Do nothing */ }
	virtual void Visit(class TeamIntEntry* Entry) { /* Do nothing */ } 
	virtual void Visit(class TeamFloatEntry* Entry) { /* Do nothing */ } 
	virtual void Visit(class TeamStringEntry* Entry) { /* Do nothing */ } 
	virtual void Visit(class PlayerStringEntry* Entry) { /* Do nothing */ }
	virtual void Visit(class PlayerIntEntry* Entry) { /* Do nothing */ } 
	virtual void Visit(class PlayerFloatEntry* Entry) { /* Do nothing */ } 
	virtual void Visit(class PlayerLoginEntry* Entry) { /* Do nothing */ }
	virtual void Visit(class PlayerSpawnEntry* Entry) { /* Do nothing */ }
	virtual void Visit(class PlayerKillDeathEntry* Entry) { /* Do nothing */ }
	virtual void Visit(class PlayerPlayerEntry * Entry) { /* Do nothing */ }
	virtual void Visit(class WeaponEntry* Entry) { /* Do nothing */ }
	virtual void Visit(class DamageEntry* Entry) { /* Do nothing */ } 
	virtual void Visit(class ProjectileIntEntry* Entry) { /* Do nothing */ }
	virtual void Visit(class GenericParamListEntry* Entry){ /* Do SOMETHING! */ }


	/** Forward declarations so that games can create game specific events that can be visited */
	virtual void Visit(class EntryEx1* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx2* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx3* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx4* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx5* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx6* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx7* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx8* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx9* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx10* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx11* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx12* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx13* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx14* Entry) { /* Do nothing */ }
	virtual void Visit(class EntryEx15* Entry) { /* Do nothing */ }
};

class UGameStatsVisualizer : public UGameStatsVisitorImpl
{
public:
    //## BEGIN PROPS GameStatsVisualizer
    class WxGameStatsVisualizer* Parent;
    FStringNoInit FriendlyName;
    FStringNoInit OptionsDialogName;
    class WxVisualizerOptionsDialog* OptionsDialog;
    TArrayNoInit<INT> SupportedEvents;
    //## END PROPS GameStatsVisualizer

    DECLARE_ABSTRACT_CLASS(UGameStatsVisualizer,UGameStatsVisitorImpl,0|CLASS_Config,UnrealEd)
	/** Given a chance to initialize */
	virtual void Init() {}

	/** Reset the visualizer to initial state */
	virtual void Reset() {}

	/** Given a chance to cleanup on destruction */
	virtual void Cleanup() {}

	/** 
	 * Draw your stuff 
	 * @param View - the view being drawn in
	 * @param PDI - draw interface for primitives
	 * @param ViewportType - type of viewport being draw (perspective, ortho)
	 */
	virtual void Visualize(const FSceneView* View, class FPrimitiveDrawInterface* PDI, ELevelViewportType ViewportType) {}

	/** 
	 * Draw your stuff as a canvas overlay 
	 * @param ViewportClient - viewport client currently drawing
     * @param View - the view being drawn in
	 * @param Canvas - overlay canvas
	 * @param ViewportType - type of viewport being draw (perspective, ortho)
	 */
	virtual void VisualizeCanvas(FEditorLevelViewportClient* ViewportClient, const FSceneView* View, FCanvas* Canvas, ELevelViewportType ViewportType) {}

	/** Returns the number of data points the visualizer is actively working with */
	virtual INT GetVisualizationSetCount() const { return 0; }

	/** 
	 *	Retrieve some metadata about an event
	 * @param EventIndex - some visualizer relative index about the data to get metadata about
	 * @param MetadataString - return string containing information about the event requested
	 */
	virtual void GetMetadata(INT EventIndex, FString& MetadataString) {}

	/** 
	 * Called when a hitproxy belonging to this visualizer is triggered 
	 * @param HitProxy - hitproxy the editor says was triggered
	 */
	virtual void HandleHitProxy(struct HGameStatsHitProxy* HitProxy) {}

	/** Get the friendly name of the visualization type */
	virtual const FString& GetFriendlyName() { return FriendlyName; }

	/** 
	 * Associates this visualization with the given GUI parent that created it 
	 * @param InParent - Parent to associate with this visualizer
	 */
	virtual void SetParent(WxGameStatsVisualizer* InParent) { Parent = InParent; }

	/** 
	 * Returns a dialog box with options related to the visualizer
	 * @return NULL if no options for this visualizer, else pointer to dialog
	 */
	virtual class WxVisualizerOptionsDialog* GetOptionsDialog() { return NULL; }

	/**
	 * Invalidates all viewports for the specified location/rotation
	 *
	 * @param Location the location to invalidate
	 * @param Rotation the rotation to invalidate
	 */
	void InvalidateViewportsForEvent(const FVector& Location,const FRotator& Rotation);
};

struct FStatDrawingProperties
{
    INT EventID;
    FColor StatColor;
    FLOAT Size;
    FStringNoInit SpriteName;
    class UTexture2D* StatSprite;

    /** Constructors */
    FStatDrawingProperties() {}
    FStatDrawingProperties(EEventParm)
    {
        appMemzero(this, sizeof(FStatDrawingProperties));
    }
};

struct FBasicStatEntry
{
    INT EventID;
    FStringNoInit EventName;
    FLOAT EventTime;
    FVector Location;
    FRotator Rotation;

    /** Constructors */
    FBasicStatEntry() {}
    FBasicStatEntry(EEventParm)
    {
        appMemzero(this, sizeof(FBasicStatEntry));
    }
};

struct FPlayerEntry : public FBasicStatEntry
{
    INT PlayerIndex;
    FStringNoInit PlayerName;
    FStringNoInit WeaponName;

    /** Constructors */
    FPlayerEntry() {}
    FPlayerEntry(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerEntry));
    }
};

struct FPlayerPlayerEntry : public FBasicStatEntry
{
    INT Player1Index;
    FStringNoInit Player1Name;
    INT Player2Index;
    FStringNoInit Player2Name;
    FVector Player2Location;
    FRotator Rotation2;

    /** Constructors */
    FPlayerPlayerEntry() {}
    FPlayerPlayerEntry(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerPlayerEntry));
    }
};

struct FPlayerTargetEntry : public FBasicStatEntry
{
    FStringNoInit KillType;
    FStringNoInit DamageType;
    INT PlayerIndex;
    FStringNoInit PlayerName;
    INT TargetIndex;
    FStringNoInit TargetName;
    FVector TargetLocation;
    FRotator TargetRotation;

    /** Constructors */
    FPlayerTargetEntry() {}
    FPlayerTargetEntry(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerTargetEntry));
    }
};

class UBasicStatsVisualizer : public UGameStatsVisualizer
{
public:
    //## BEGIN PROPS BasicStatsVisualizer
    TArrayNoInit<struct FStatDrawingProperties> DrawingProperties;
    TArrayNoInit<struct FBasicStatEntry> BasicEntries;
    TArrayNoInit<struct FPlayerEntry> PlayerEntries;
    TArrayNoInit<struct FPlayerPlayerEntry> PlayerPlayerEntries;
    TArrayNoInit<struct FPlayerTargetEntry> PlayerTargetEntries;
    //## END PROPS BasicStatsVisualizer

    DECLARE_CLASS(UBasicStatsVisualizer,UGameStatsVisualizer,0|CLASS_Config,UnrealEd)
	/** Given a chance to initialize */
	virtual void Init();

	/** Reset the visualizer to initial state */
	virtual void Reset();

	/** 
	 * Visualizes all stats in a very basic way (sprite at a location with an orientation arrow typically)
	 * @param View - the view being drawn in
	 * @param PDI - draw interface for primitives
	 * @param ViewportType - type of viewport being draw (perspective, ortho)
	 */
	virtual void Visualize(const FSceneView* View, class FPrimitiveDrawInterface* PDI, ELevelViewportType ViewportType);

	/** 
	 * Draw your stuff as a canvas overlay 
	 * @param ViewportClient - viewport client currently drawing
     * @param View - the view being drawn in
	 * @param Canvas - overlay canvas
	 * @param ViewportType - type of viewport being draw (perspective, ortho)
	 */
	virtual void VisualizeCanvas(FEditorLevelViewportClient* ViewportClient, const FSceneView* View, FCanvas* Canvas, ELevelViewportType ViewportType);

	/** 
	 * Return the drawing properties defined for the given EventID 
	 * @param EventID - EventID to get the drawing property for
	 */
	const FStatDrawingProperties& GetDrawingProperties(int EventID);

	/** Called before any database entries are given to the visualizer */
	virtual void BeginVisiting();

	/** Called at the end of database entry traversal, returns success or failure */
	virtual UBOOL EndVisiting();

	/** Returns the number of data points the visualizer is actively working with */
	virtual INT GetVisualizationSetCount() const;

	/** 
	 *	Retrieve some metadata about an event
	 * @param EventIndex - some visualizer relative index about the data to get metadata about
	 * @param MetadataString - return string containing information about the event requested
	 */
	virtual void GetMetadata(INT EventIndex, FString& MetadataString);

	/** Called when a hitproxy belonging to this visualizer is triggered */
	virtual void HandleHitProxy(struct HGameStatsHitProxy* HitProxy);

	/** 
	  * Basic idea here is to just transfer/copy the stat information out of the database
	  * and into a form capable of displaying a sprite/arrow/color at a given position
	  */
	virtual void Visit(class GameStringEntry* Entry); 
	virtual void Visit(class GameIntEntry* Entry);
	virtual void Visit(class GamePositionEntry* Entry);
	virtual void Visit(class TeamIntEntry* Entry); 
	virtual void Visit(class PlayerStringEntry* Entry);
	virtual void Visit(class PlayerIntEntry* Entry); 
	virtual void Visit(class PlayerFloatEntry* Entry); 
	virtual void Visit(class PlayerLoginEntry* Entry);
	virtual void Visit(class PlayerSpawnEntry* Entry);
	virtual void Visit(class PlayerKillDeathEntry* Entry);
	virtual void Visit(class PlayerPlayerEntry * Entry);
	virtual void Visit(class WeaponEntry* Entry);
	virtual void Visit(class DamageEntry* Entry); 
	virtual void Visit(class ProjectileIntEntry* Entry);
};

struct FLine
{
    FVector LineStart;
    FVector LineEnd;
    FLinearColor LineColor;
    FLOAT Thickness;

    /** Constructors */
    FLine() {}
    FLine(EEventParm)
    {
        appMemzero(this, sizeof(FLine));
    }
};

struct FDrawBox
{
    FVector BoxLoc;
    FVector Extent;
    FColor BoxColor;

    /** Constructors */
    FDrawBox() {}
    FDrawBox(EEventParm)
    {
        appMemzero(this, sizeof(FDrawBox));
    }
};

struct FDrawAtom
{
    TArrayNoInit<struct FLine> Lines;
    TArrayNoInit<struct FDrawBox> Boxes;
    FStringNoInit ShortName;
    FStringNoInit LongName;
    class UTexture2D* Sprite;
    FVector Loc;
    FLinearColor Color;

    /** Constructors */
    FDrawAtom() {}
    FDrawAtom(EEventParm)
    {
        appMemzero(this, sizeof(FDrawAtom));
    }
};

class UGenericParamlistVisualizer : public UGameStatsVisualizer
{
public:
    //## BEGIN PROPS GenericParamlistVisualizer
    TArrayNoInit<struct FDrawAtom> DrawAtoms;
    class UTexture2D* DatumSprite;
    //## END PROPS GenericParamlistVisualizer

    DECLARE_CLASS(UGenericParamlistVisualizer,UGameStatsVisualizer,0|CLASS_Config,UnrealEd)
	/** Given a chance to initialize */
	virtual void Init();

	/** Reset the visualizer to initial state */
	virtual void Reset();

	/** 
	 * Draws all players with unique color within the given time period
	 * taking into account time/space jumps
	 * @param View - the view being drawn in
	 * @param PDI - draw interface for primitives
	 * @param ViewportType - type of viewport being draw (perspective, ortho)
	 */
	virtual void Visualize(const FSceneView* View, class FPrimitiveDrawInterface* PDI, ELevelViewportType ViewportType);

	/** Called before any database entries are given to the visualizer */
	virtual void BeginVisiting();

	/** Called at the end of database entry traversal, returns success or failure */
	virtual UBOOL EndVisiting();

	/** Returns the number of data points the visualizer is actively working with */
	virtual INT GetVisualizationSetCount() const;

	/** 
	 *	Retrieve some metadata about an event
	 * @param EventIndex - some visualizer relative index about the data to get metadata about
	 * @param MetadataString - return string containing information about the event requested
	 */
	virtual void GetMetadata(INT EventIndex, FString& MetadataString);


	/** Called when a hitproxy belonging to this visualizer is triggered */
	virtual void HandleHitProxy(struct HGameStatsHitProxy* HitProxy);

	virtual void Visit(class GenericParamListEntry* Entry); 
};

struct FHeatMapPosEntry
{
    FLOAT Time;
    FVector Position;
    FLOAT Strength;

    /** Constructors */
    FHeatMapPosEntry() {}
    FHeatMapPosEntry(EEventParm)
    {
        appMemzero(this, sizeof(FHeatMapPosEntry));
    }
};

class UHeatmapVisualizer : public UGameStatsVisualizer
{
public:
    //## BEGIN PROPS HeatmapVisualizer
    FVector WorldMinPos;
    FVector WorldMaxPos;
    INT TextureXSize;
    INT TextureYSize;
    INT CurrentMinDensity;
    INT CurrentMaxDensity;
    INT MinDensity;
    INT MaxDensity;
    INT HeatRadius;
    FLOAT NumUnrealUnitsPerPixel;
    class UMaterialInstanceConstant* HeatmapMaterial;
    class UTexture2D* OverlayTexture;
    TArrayNoInit<struct FHeatMapPosEntry> HeatmapPositions;
    TArrayNoInit<FLOAT> PositionGrid;
    //## END PROPS HeatmapVisualizer

    DECLARE_CLASS(UHeatmapVisualizer,UGameStatsVisualizer,0|CLASS_Config,UnrealEd)
	/** Given a chance to initialize */
	virtual void Init();

	/** Reset the visualizer to initial state */
	virtual void Reset();

	/** 
	 * Returns a dialog box with options related to the visualizer
	 * @return NULL if no options for this visualizer, else pointer to dialog
	 */
	virtual class WxVisualizerOptionsDialog* GetOptionsDialog();

	/** 
	 * Draws all players with unique color within the given time period
	 * taking into account time/space jumps
	 * @param View - the view being drawn in
	 * @param PDI - draw interface for primitives
	 * @param ViewportType - type of viewport being draw (perspective, ortho)
	 */
	virtual void Visualize(const FSceneView* View, class FPrimitiveDrawInterface* PDI, ELevelViewportType ViewportType);

	/** 
	 * Draw your stuff as a canvas overlay 
	 * @param View - the view being drawn in
	 * @param Canvas - overlay canvas
 	 * @param ViewportType - type of viewport being draw (perspective, ortho)
	 */
	virtual void VisualizeCanvas(FEditorLevelViewportClient* ViewportClient, const FSceneView* View, FCanvas* Canvas, ELevelViewportType ViewportType);

	/*
	 *   Actual DrawTile call to the canvas, using min/max screen values to properly position the texture
	 * @param Canvas - canvas to draw to
	 * @param MinScreen - WorldMin position of the heatmap, converted to screen space
	 * @param MaxScreen - WorldMax position of the heatmap, converted to screen space
	 */
	void VisualizeCanvas(FCanvas* Canvas, const FVector2D& MinScreen, const FVector2D& MaxScreen);

	/** Called before any database entries are given to the visualizer */
	virtual void BeginVisiting();

	/** Called at the end of database entry traversal, returns success or failure */
	virtual UBOOL EndVisiting();

	/** Returns the number of data points the visualizer is actively working with */
	virtual INT GetVisualizationSetCount() const;

	/** 
	 *	Retrieve some metadata about an event
	 * @param EventIndex - some visualizer relative index about the data to get metadata about
	 * @param MetadataString - return string containing information about the event requested
	 */
	virtual void GetMetadata(INT EventIndex, FString& MetadataString);

	/** Called when a hitproxy belonging to this visualizer is triggered */
	virtual void HandleHitProxy(struct HGameStatsHitProxy* HitProxy);

	/** Game locations during the game are stored as GamePositionEntries */
	virtual void Visit(class GamePositionEntry* Entry); 

	/** Player locations during the game are stored as PlayerIntEntries */
	virtual void Visit(class PlayerIntEntry* Entry); 

	/** Player kills during the game are stored as PlayerKillDeathEnties */
	virtual void Visit(class PlayerKillDeathEntry* Entry); 

	/** Player spawns during the game are stored as PlayerSpawnEntries */
	virtual void Visit(class PlayerSpawnEntry* Entry); 

	/** Projectile ints the game are stored as ProjectileIntEntries */
	virtual void Visit(class ProjectileIntEntry* Entry); 

	/** the goats are in the base, and they like to use generic param lists to specify heatmap targets as well */
	virtual void Visit(class GenericParamListEntry* Entry);

	/** adds a new point to the heatmap, and adjusts bounds for incoming position */
	virtual void AddNewPoint(const FVector& Pt, FLOAT Time, FLOAT Strength);
	/**
	 * Runs through the data and creates a heatmap texture, normalizing values
	 */
	virtual void CreateHeatmapTexture();
	/**
	 * Runs through the data and splats an attenuating set of values for each data point
	 */
	virtual void CreateHeatmapGrid();
	/*
	 * Scan the array of grid points and find the min/max grid values, or specify custom min/max values
	 * @param NewMinDensity - all values at or below this value get the lowest coloring
	 * @param NewMaxDensity - all values at or above this value get the highest coloring
	 */
	virtual void UpdateDensityMapping(INT NewMinDensity, INT NewMaxDensity);

	/**
	 * Called before destroying the object.  This is called immediately upon deciding to destroy the object, to allow the object to begin an
	 * asynchronous cleanup process.
	 */
	void BeginDestroy();
};

class UPerformanceVisualizer : public UHeatmapVisualizer
{
public:
    //## BEGIN PROPS PerformanceVisualizer
    TArrayNoInit<FLOAT> GridPositionMaxValues;
    TArrayNoInit<INT> GridPositionHitCounts;
    TArrayNoInit<FLOAT> GridPositionSums;
    //## END PROPS PerformanceVisualizer

    DECLARE_CLASS(UPerformanceVisualizer,UHeatmapVisualizer,0|CLASS_Config,UnrealEd)
	/** Reset the visualizer to initial state */
	virtual void Reset();

	/** Called before any database entries are given to the visualizer */
	virtual void BeginVisiting();

	/** Called at the end of database entry traversal, returns success or failure */
	virtual UBOOL EndVisiting();

	/** Game locations during the game are stored as GamePositionEntries */
	virtual void Visit(class GamePositionEntry* Entry); 

	/** Player locations during the game are stored as PlayerIntEntries */
	virtual void Visit(class PlayerIntEntry* Entry) { /** Do Nothing */ } 

	/** Player kills during the game are stored as PlayerKillDeathEnties */
	virtual void Visit(class PlayerKillDeathEntry* Entry) { /** Do Nothing */ } 

	/** Player spawns during the game are stored as PlayerSpawnEntries */
	virtual void Visit(class PlayerSpawnEntry* Entry) { /** Do Nothing */ } 

	/** the goats are in the base, and they like to use generic param lists to specify heatmap targets as well */
	virtual void Visit(class GenericParamListEntry* Entry) { /** Do Nothing */ }

	/**
	 * Runs through the data and splats an attenuating set of values for each data point
	 */
	virtual void CreateHeatmapGrid();
};

struct FPlayerMovementStatDrawingProperties
{
    FStringNoInit PawnClassName;
    FStringNoInit SpriteName;
    class UTexture2D* StatSprite;

    /** Constructors */
    FPlayerMovementStatDrawingProperties() {}
    FPlayerMovementStatDrawingProperties(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerMovementStatDrawingProperties));
    }
};

struct FPosEntry
{
    FLOAT Time;
    FVector Position;
    FRotator Rotation;

    /** Constructors */
    FPosEntry() {}
    FPosEntry(EEventParm)
    {
        appMemzero(this, sizeof(FPosEntry));
    }
};

struct FMovementSegment
{
    TArrayNoInit<struct FPosEntry> Positions;

    /** Constructors */
    FMovementSegment() {}
    FMovementSegment(EEventParm)
    {
        appMemzero(this, sizeof(FMovementSegment));
    }
};

struct FPlayerMovement
{
    INT PlayerIndex;
    FStringNoInit PlayerName;
    TArrayNoInit<struct FMovementSegment> Segments;
    class UTexture2D* StatSprite;
    TArrayNoInit<struct FPosEntry> TempPositions;

    /** Constructors */
    FPlayerMovement() {}
    FPlayerMovement(EEventParm)
    {
        appMemzero(this, sizeof(FPlayerMovement));
    }
};

class UPlayerMovementVisualizer : public UGameStatsVisualizer
{
public:
    //## BEGIN PROPS PlayerMovementVisualizer
    TArrayNoInit<struct FPlayerMovement> Players;
    TArrayNoInit<struct FPlayerMovementStatDrawingProperties> DrawingProperties;
    //## END PROPS PlayerMovementVisualizer

    DECLARE_CLASS(UPlayerMovementVisualizer,UGameStatsVisualizer,0|CLASS_Config,UnrealEd)
	/** Given a chance to initialize */
	virtual void Init();

	/** Reset the visualizer to initial state */
	virtual void Reset();

	/** 
	 * Draws all players with unique color within the given time period
	 * taking into account time/space jumps
	 * @param View - the view being drawn in
	 * @param PDI - draw interface for primitives
	 * @param ViewportType - type of viewport being draw (perspective, ortho)
	 */
	virtual void Visualize(const FSceneView* View, class FPrimitiveDrawInterface* PDI, ELevelViewportType ViewportType);

	/** Called before any database entries are given to the visualizer */
	virtual void BeginVisiting();

	/** Called at the end of database entry traversal, returns success or failure */
	virtual UBOOL EndVisiting();

	/** Returns the number of data points the visualizer is actively working with */
	virtual INT GetVisualizationSetCount() const;

	/** 
	 *	Retrieve some metadata about an event
	 * @param EventIndex - some visualizer relative index about the data to get metadata about
	 * @param MetadataString - return string containing information about the event requested
	 */
	virtual void GetMetadata(INT EventIndex, FString& MetadataString);

	/** 
	* Return the drawing properties defined for the given player 
	* @param PawnClassName - Name of the pawn spawned
	*/
	const FPlayerMovementStatDrawingProperties& GetDrawingProperties(const FString& PawnClassName);

	/** Called when a hitproxy belonging to this visualizer is triggered */
	virtual void HandleHitProxy(struct HGameStatsHitProxy* HitProxy);

	/** Player locations during the game are stored as PlayerIntEntries */
	virtual void Visit(class PlayerIntEntry* Entry); 

	/** Player spawns reveal the pawn class in use so we can choose a sprite */
	virtual void Visit(class PlayerSpawnEntry* Entry); 

	/** Create or find a given player entry by index */
	FPlayerMovement& CreateOrFindPlayerEntry(INT PlayerIndex, const FString& PlayerName);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_UNREALED_GAMESTATS_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execUploadSession);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execClearDatabase);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetEventCountByType);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetPawnListBySessionID);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetProjectileListBySessionID);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetDamageListBySessionID);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetWeaponListBySessionID);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetEventsListBySessionID);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetTeamListBySessionID);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetPlayersListBySessionID);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetSessionInfoBySessionID);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execIsSessionIDLocal);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetSessionIDs);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execGetGameTypes);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execCacheLocalFilenames);
AUTOGENERATE_FUNCTION(UGameStatsDatabase,-1,execInit);
AUTOGENERATE_FUNCTION(UGameStatsFileReader,-1,execCleanup);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UNREALED_GAMESTATS_NATIVE_DEFS
#define UNREALED_GAMESTATS_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_UNREALED_GAMESTATS \
	UGameStatsDatabase::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameStatsDatabase"), GUnrealEdUGameStatsDatabaseNatives); \
	UGameStatsDatabaseVisitor::StaticClass(); \
	UGameStatsFileReader::StaticClass(); \
	GNativeLookupFuncs.Set(FName("GameStatsFileReader"), GUnrealEdUGameStatsFileReaderNatives); \
	UGameStatsReport::StaticClass(); \
	UGameStatsVisitorImpl::StaticClass(); \
	UGameStatsVisualizer::StaticClass(); \
	UBasicStatsVisualizer::StaticClass(); \
	UGenericParamlistVisualizer::StaticClass(); \
	UHeatmapVisualizer::StaticClass(); \
	UPerformanceVisualizer::StaticClass(); \
	UPlayerMovementVisualizer::StaticClass(); \

#endif // UNREALED_GAMESTATS_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GUnrealEdUGameStatsDatabaseNatives[] = 
{ 
	MAP_NATIVE(UGameStatsDatabase, execUploadSession)
	MAP_NATIVE(UGameStatsDatabase, execClearDatabase)
	MAP_NATIVE(UGameStatsDatabase, execGetEventCountByType)
	MAP_NATIVE(UGameStatsDatabase, execGetPawnListBySessionID)
	MAP_NATIVE(UGameStatsDatabase, execGetProjectileListBySessionID)
	MAP_NATIVE(UGameStatsDatabase, execGetDamageListBySessionID)
	MAP_NATIVE(UGameStatsDatabase, execGetWeaponListBySessionID)
	MAP_NATIVE(UGameStatsDatabase, execGetEventsListBySessionID)
	MAP_NATIVE(UGameStatsDatabase, execGetTeamListBySessionID)
	MAP_NATIVE(UGameStatsDatabase, execGetPlayersListBySessionID)
	MAP_NATIVE(UGameStatsDatabase, execGetSessionInfoBySessionID)
	MAP_NATIVE(UGameStatsDatabase, execIsSessionIDLocal)
	MAP_NATIVE(UGameStatsDatabase, execGetSessionIDs)
	MAP_NATIVE(UGameStatsDatabase, execGetGameTypes)
	MAP_NATIVE(UGameStatsDatabase, execCacheLocalFilenames)
	MAP_NATIVE(UGameStatsDatabase, execInit)
	{NULL, NULL}
};

FNativeFunctionLookup GUnrealEdUGameStatsFileReaderNatives[] = 
{ 
	MAP_NATIVE(UGameStatsFileReader, execCleanup)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UGameStatsDatabase,GameStatsDatabase,MapNameToFilenameMapping)
VERIFY_CLASS_OFFSET_NODIE(UGameStatsDatabase,GameStatsDatabase,GameStateClassname)
VERIFY_CLASS_SIZE_NODIE(UGameStatsDatabase)
VERIFY_CLASS_SIZE_NODIE(UGameStatsDatabaseVisitor)
VERIFY_CLASS_OFFSET_NODIE(UGameStatsFileReader,GameStatsFileReader,GameState)
VERIFY_CLASS_OFFSET_NODIE(UGameStatsFileReader,GameStatsFileReader,AllEvents)
VERIFY_CLASS_SIZE_NODIE(UGameStatsFileReader)
VERIFY_CLASS_OFFSET_NODIE(UGameStatsReport,GameStatsReport,SessionInfo)
VERIFY_CLASS_OFFSET_NODIE(UGameStatsReport,GameStatsReport,ReportBaseURL)
VERIFY_CLASS_SIZE_NODIE(UGameStatsReport)
VERIFY_CLASS_SIZE_NODIE(UGameStatsVisitorImpl)
VERIFY_CLASS_OFFSET_NODIE(UGameStatsVisualizer,GameStatsVisualizer,Parent)
VERIFY_CLASS_OFFSET_NODIE(UGameStatsVisualizer,GameStatsVisualizer,SupportedEvents)
VERIFY_CLASS_SIZE_NODIE(UGameStatsVisualizer)
VERIFY_CLASS_OFFSET_NODIE(UBasicStatsVisualizer,BasicStatsVisualizer,DrawingProperties)
VERIFY_CLASS_OFFSET_NODIE(UBasicStatsVisualizer,BasicStatsVisualizer,PlayerTargetEntries)
VERIFY_CLASS_SIZE_NODIE(UBasicStatsVisualizer)
VERIFY_CLASS_OFFSET_NODIE(UGenericParamlistVisualizer,GenericParamlistVisualizer,DrawAtoms)
VERIFY_CLASS_OFFSET_NODIE(UGenericParamlistVisualizer,GenericParamlistVisualizer,DatumSprite)
VERIFY_CLASS_SIZE_NODIE(UGenericParamlistVisualizer)
VERIFY_CLASS_OFFSET_NODIE(UHeatmapVisualizer,HeatmapVisualizer,WorldMinPos)
VERIFY_CLASS_OFFSET_NODIE(UHeatmapVisualizer,HeatmapVisualizer,PositionGrid)
VERIFY_CLASS_SIZE_NODIE(UHeatmapVisualizer)
VERIFY_CLASS_OFFSET_NODIE(UPerformanceVisualizer,PerformanceVisualizer,GridPositionMaxValues)
VERIFY_CLASS_OFFSET_NODIE(UPerformanceVisualizer,PerformanceVisualizer,GridPositionSums)
VERIFY_CLASS_SIZE_NODIE(UPerformanceVisualizer)
VERIFY_CLASS_OFFSET_NODIE(UPlayerMovementVisualizer,PlayerMovementVisualizer,Players)
VERIFY_CLASS_OFFSET_NODIE(UPlayerMovementVisualizer,PlayerMovementVisualizer,DrawingProperties)
VERIFY_CLASS_SIZE_NODIE(UPlayerMovementVisualizer)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
