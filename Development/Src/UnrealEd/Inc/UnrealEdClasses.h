/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
    Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
===========================================================================*/
#if SUPPORTS_PRAGMA_PACK
#pragma pack (push,4)
#endif

#include "UnrealEdNames.h"

// Split enums from the rest of the header so they can be included earlier
// than the rest of the header file by including this file twice with different
// #define wrappers. See Engine.h and look at EngineClasses.h for an example.
#if !NO_ENUMS && !defined(NAMES_ONLY)

#ifndef INCLUDED_UNREALED_ENUMS
#define INCLUDED_UNREALED_ENUMS 1

enum WASDType
{
    WASD_Always             =0,
    WASD_RMBOnly            =1,
    WASD_Never              =2,
    WASD_MAX                =3,
};
#define FOREACH_ENUM_WASDTYPE(op) \
    op(WASD_Always) \
    op(WASD_RMBOnly) \
    op(WASD_Never) 
enum EFBXImportType
{
    FBXIT_StaticMesh        =0,
    FBXIT_SkeletalMesh      =1,
    FBXIT_MAX               =2,
};
#define FOREACH_ENUM_EFBXIMPORTTYPE(op) \
    op(FBXIT_StaticMesh) \
    op(FBXIT_SkeletalMesh) 
enum EThumbnailBackgroundType
{
    TBT_None                =0,
    TBT_DefaultBackground   =1,
    TBT_SolidBackground     =2,
    TBT_MAX                 =3,
};
#define FOREACH_ENUM_ETHUMBNAILBACKGROUNDTYPE(op) \
    op(TBT_None) \
    op(TBT_DefaultBackground) \
    op(TBT_SolidBackground) 
enum EThumbnailPrimType
{
    TPT_None                =0,
    TPT_Sphere              =1,
    TPT_Cube                =2,
    TPT_Plane               =3,
    TPT_Cylinder            =4,
    TPT_MAX                 =5,
};
#define FOREACH_ENUM_ETHUMBNAILPRIMTYPE(op) \
    op(TPT_None) \
    op(TPT_Sphere) \
    op(TPT_Cube) \
    op(TPT_Plane) \
    op(TPT_Cylinder) 

#endif // !INCLUDED_UNREALED_ENUMS
#endif // !NO_ENUMS

#if !ENUMS_ONLY

#ifndef NAMES_ONLY
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif


#ifndef NAMES_ONLY

#ifndef INCLUDED_UNREALED_CLASSES
#define INCLUDED_UNREALED_CLASSES 1
#define ENABLE_DECLARECLASS_MACRO 1
#include "UnObjBas.h"
#undef ENABLE_DECLARECLASS_MACRO

class UAnimNodeEditInfo : public UObject
{
public:
    //## BEGIN PROPS AnimNodeEditInfo
    class UClass* AnimNodeClass;
    //## END PROPS AnimNodeEditInfo

    DECLARE_ABSTRACT_CLASS(UAnimNodeEditInfo,UObject,0,UnrealEd)
	virtual void OnDoubleClickNode(UAnimNode* InNode, class WxAnimTreeEditor* InEditor) {}
	virtual void OnCloseAnimTreeEditor() {}
	virtual UBOOL ShouldDrawWidget() { return FALSE; }
	virtual UBOOL IsRotationWidget() { return TRUE; }
	virtual FMatrix GetWidgetTM() { return FMatrix::Identity; }
	virtual void HandleWidgetDrag(const FQuat& DeltaQuat, const FVector& DeltaTranslate) {}
	virtual void Draw3DInfo(const FSceneView* View, FPrimitiveDrawInterface* PDI) {}
};

class UAnimNodeEditInfo_AimOffset : public UAnimNodeEditInfo
{
public:
    //## BEGIN PROPS AnimNodeEditInfo_AimOffset
    class WxAnimAimOffsetEditor* EditWindow;
    class UAnimNodeAimOffset* EditNode;
    //## END PROPS AnimNodeEditInfo_AimOffset

    DECLARE_CLASS(UAnimNodeEditInfo_AimOffset,UAnimNodeEditInfo,0,UnrealEd)
	virtual void OnDoubleClickNode(UAnimNode* InNode, class WxAnimTreeEditor* InEditor);
	virtual void OnCloseAnimTreeEditor();
	virtual UBOOL ShouldDrawWidget();
	virtual UBOOL IsRotationWidget();
	virtual FMatrix GetWidgetTM();
	virtual void HandleWidgetDrag(const FQuat& DeltaQuat, const FVector& DeltaTranslate);
	virtual void Draw3DInfo(const FSceneView* View, FPrimitiveDrawInterface* PDI);
};

class UAnimTreeEdSkelComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS AnimTreeEdSkelComponent
    FPointer AnimTreeEdPtr;
    //## END PROPS AnimTreeEdSkelComponent

    DECLARE_CLASS(UAnimTreeEdSkelComponent,USkeletalMeshComponent,0|CLASS_Config,UnrealEd)
	// UPrimitiveComponent interface.
	virtual void Render(const FSceneView* View, class FPrimitiveDrawInterface* PDI);

	// USkeletalMeshComponent interface.
	virtual UBOOL LegLineCheck(const FVector& Start, const FVector& End, FVector& HitLocation, FVector& HitNormal, const FVector& Extent = FVector(0.f));
};

class UASVSkelComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS ASVSkelComponent
    FPointer AnimSetViewerPtr;
    BITFIELD bRenderRawSkeleton:1;
    BITFIELD bShowSoftBodyTetra:1;
    BITFIELD bDrawMesh:1;
    BITFIELD bDrawBoneInfluences:1;
    SCRIPT_ALIGN;
    FColor BoneColor;
    INT ColorRenderMode;
    TArrayNoInit<INT> BonesOfInterest;
    TArrayNoInit<class UMaterialInterface*> SkelMaterials;
    //## END PROPS ASVSkelComponent

    DECLARE_CLASS(UASVSkelComponent,USkeletalMeshComponent,0|CLASS_Transient|CLASS_Config,UnrealEd)
	// UPrimitiveComponent interface.
	virtual FPrimitiveSceneProxy* CreateSceneProxy();

    /**
     * Function that returns whether or not CPU skinning should be applied
     * Allows the editor to override the skinning state for editor tools
     */
	virtual UBOOL ShouldCPUSkin();

	/** 
	 * Function to operate on mesh object after its created, 
	 * but before it's attached.
	 * @param MeshObject - Mesh Object owned by this component
	 */
	virtual void PostInitMeshObject(class FSkeletalMeshObject* MeshObject);

	/**
	 * Update material information depending on color render mode 
	 * Refresh/replace materials 
	 */
	void ApplyColorRenderMode(INT InColorRenderMode);
};

struct FBrowserPaneInfo
{
    INT PaneID;
    FStringNoInit WxWindowClassName;
    FStringNoInit FriendlyName;
    BITFIELD bInitiallyHidden:1;
    INT CloneOfPaneID;
    INT CloneNumber;
    FPointer WxBrowserPtr;

    /** Constructors */
    FBrowserPaneInfo() {}
    FBrowserPaneInfo(EEventParm)
    {
        appMemzero(this, sizeof(FBrowserPaneInfo));
    }
};

class UBrowserManager : public UObject
{
public:
    //## BEGIN PROPS BrowserManager
    TArrayNoInit<struct FBrowserPaneInfo> BrowserPanes;
    BITFIELD bHasCreatedPanes:1;
    BITFIELD bHasStateBeenRestored:1;
    BITFIELD bIsBrowserLayoutChanging:1;
    INT LastSelectedPaneID;
    FPointer CreatedPanesPtr;
    FPointer DockingContainerPtr;
    FPointer FloatingWindowsArrayPtr;
    FPointer BrowserMenuPtr;
    //## END PROPS BrowserManager

    DECLARE_CLASS(UBrowserManager,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    #include "UBrowserManager.h"
};

struct BrushBuilder_eventBuild_Parms
{
    UBOOL ReturnValue;
    BrushBuilder_eventBuild_Parms(EEventParm)
    {
    }
};
class UBrushBuilder : public UObject
{
public:
    //## BEGIN PROPS BrushBuilder
    FStringNoInit BitmapFilename;
    FStringNoInit ToolTip;
    TArrayNoInit<FVector> Vertices;
    TArrayNoInit<FBuilderPoly> Polys;
    FName Group_DEPRECATED;
    FName Layer;
    BITFIELD MergeCoplanars:1;
    SCRIPT_ALIGN;
    //## END PROPS BrushBuilder

    virtual void BeginBrush(UBOOL InMergeCoplanars,FName InLayer);
    virtual UBOOL EndBrush();
    virtual INT GetVertexCount();
    virtual FVector GetVertex(INT I);
    virtual INT GetPolyCount();
    virtual UBOOL BadParameters(const FString& msg=TEXT(""));
    virtual INT Vertexv(FVector V);
    virtual INT Vertex3f(FLOAT X,FLOAT Y,FLOAT Z);
    virtual void Poly3i(INT Direction,INT I,INT J,INT K,FName ItemName=NAME_None,UBOOL bIsTwoSidedNonSolid=FALSE);
    virtual void Poly4i(INT Direction,INT I,INT J,INT K,INT L,FName ItemName=NAME_None,UBOOL bIsTwoSidedNonSolid=FALSE);
    virtual void PolyBegin(INT Direction,FName ItemName=NAME_None);
    virtual void Polyi(INT I);
    virtual void PolyEnd();
    DECLARE_FUNCTION(execBeginBrush)
    {
        P_GET_UBOOL(InMergeCoplanars);
        P_GET_NAME(InLayer);
        P_FINISH;
        this->BeginBrush(InMergeCoplanars,InLayer);
    }
    DECLARE_FUNCTION(execEndBrush)
    {
        P_FINISH;
        *(UBOOL*)Result=this->EndBrush();
    }
    DECLARE_FUNCTION(execGetVertexCount)
    {
        P_FINISH;
        *(INT*)Result=this->GetVertexCount();
    }
    DECLARE_FUNCTION(execGetVertex)
    {
        P_GET_INT(I);
        P_FINISH;
        *(FVector*)Result=this->GetVertex(I);
    }
    DECLARE_FUNCTION(execGetPolyCount)
    {
        P_FINISH;
        *(INT*)Result=this->GetPolyCount();
    }
    DECLARE_FUNCTION(execBadParameters)
    {
        P_GET_STR_OPTX(msg,TEXT(""));
        P_FINISH;
        *(UBOOL*)Result=this->BadParameters(msg);
    }
    DECLARE_FUNCTION(execVertexv)
    {
        P_GET_STRUCT(FVector,V);
        P_FINISH;
        *(INT*)Result=this->Vertexv(V);
    }
    DECLARE_FUNCTION(execVertex3f)
    {
        P_GET_FLOAT(X);
        P_GET_FLOAT(Y);
        P_GET_FLOAT(Z);
        P_FINISH;
        *(INT*)Result=this->Vertex3f(X,Y,Z);
    }
    DECLARE_FUNCTION(execPoly3i)
    {
        P_GET_INT(Direction);
        P_GET_INT(I);
        P_GET_INT(J);
        P_GET_INT(K);
        P_GET_NAME_OPTX(ItemName,NAME_None);
        P_GET_UBOOL_OPTX(bIsTwoSidedNonSolid,FALSE);
        P_FINISH;
        this->Poly3i(Direction,I,J,K,ItemName,bIsTwoSidedNonSolid);
    }
    DECLARE_FUNCTION(execPoly4i)
    {
        P_GET_INT(Direction);
        P_GET_INT(I);
        P_GET_INT(J);
        P_GET_INT(K);
        P_GET_INT(L);
        P_GET_NAME_OPTX(ItemName,NAME_None);
        P_GET_UBOOL_OPTX(bIsTwoSidedNonSolid,FALSE);
        P_FINISH;
        this->Poly4i(Direction,I,J,K,L,ItemName,bIsTwoSidedNonSolid);
    }
    DECLARE_FUNCTION(execPolyBegin)
    {
        P_GET_INT(Direction);
        P_GET_NAME_OPTX(ItemName,NAME_None);
        P_FINISH;
        this->PolyBegin(Direction,ItemName);
    }
    DECLARE_FUNCTION(execPolyi)
    {
        P_GET_INT(I);
        P_FINISH;
        this->Polyi(I);
    }
    DECLARE_FUNCTION(execPolyEnd)
    {
        P_FINISH;
        this->PolyEnd();
    }
    UBOOL eventBuild()
    {
        BrushBuilder_eventBuild_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        ProcessEvent(FindFunctionChecked(UNREALED_Build),&Parms);
        return Parms.ReturnValue;
    }
    DECLARE_ABSTRACT_CLASS(UBrushBuilder,UObject,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UBrushBuilder)
};

class UCubeBuilder : public UBrushBuilder
{
public:
    //## BEGIN PROPS CubeBuilder
    FLOAT X;
    FLOAT Y;
    FLOAT Z;
    FLOAT WallThickness;
    FName GroupName;
    BITFIELD Hollow:1;
    BITFIELD Tessellated:1;
    SCRIPT_ALIGN;
    //## END PROPS CubeBuilder

    DECLARE_CLASS(UCubeBuilder,UBrushBuilder,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCubeBuilder)
};

struct FModuleMenuMapper
{
    FStringNoInit ObjName;
    TArrayNoInit<FString> InvalidObjNames;

    /** Constructors */
    FModuleMenuMapper() {}
    FModuleMenuMapper(EEventParm)
    {
        appMemzero(this, sizeof(FModuleMenuMapper));
    }
};

class UCascadeConfiguration : public UObject
{
public:
    //## BEGIN PROPS CascadeConfiguration
    TArrayNoInit<struct FModuleMenuMapper> ModuleMenu_TypeDataToBaseModuleRejections;
    TArrayNoInit<struct FModuleMenuMapper> ModuleMenu_TypeDataToSpecificModuleRejections;
    TArrayNoInit<FString> ModuleMenu_ModuleRejections;
    //## END PROPS CascadeConfiguration

    DECLARE_CLASS(UCascadeConfiguration,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(UCascadeConfiguration)
};

class UCascadeOptions : public UObject
{
public:
    //## BEGIN PROPS CascadeOptions
    BITFIELD bShowModuleDump:1;
    BITFIELD bUseSubMenus:1;
    BITFIELD bUseSpaceBarReset:1;
    BITFIELD bUseSpaceBarResetInLevel:1;
    BITFIELD bShowGrid:1;
    BITFIELD bShowParticleCounts:1;
    BITFIELD bShowParticleEvents:1;
    BITFIELD bShowParticleTimes:1;
    BITFIELD bShowParticleDistance:1;
    BITFIELD bShowParticleMemory:1;
    BITFIELD bShowFloor:1;
    BITFIELD bUseSlimCascadeDraw:1;
    BITFIELD bCenterCascadeModuleText:1;
    SCRIPT_ALIGN;
    FColor BackgroundColor;
    FColor Empty_Background;
    FColor Emitter_Background;
    FColor Emitter_Unselected;
    FColor Emitter_Selected;
    FColor ModuleColor_General_Unselected;
    FColor ModuleColor_General_Selected;
    FColor ModuleColor_TypeData_Unselected;
    FColor ModuleColor_TypeData_Selected;
    FColor ModuleColor_Beam_Unselected;
    FColor ModuleColor_Beam_Selected;
    FColor ModuleColor_Trail_Unselected;
    FColor ModuleColor_Trail_Selected;
    FColor ModuleColor_Spawn_Unselected;
    FColor ModuleColor_Spawn_Selected;
    FColor ModuleColor_Required_Unselected;
    FColor ModuleColor_Required_Selected;
    FColor ModuleColor_Event_Unselected;
    FColor ModuleColor_Event_Selected;
    FColor GridColor_Hi;
    FColor GridColor_Low;
    FLOAT GridPerspectiveSize;
    FLOAT ParticleMemoryUpdateTime;
    FStringNoInit FloorMesh;
    FVector FloorPosition;
    FRotator FloorRotation;
    FLOAT FloorScale;
    FVector FloorScale3D;
    FStringNoInit PostProcessChainName;
    INT ShowPPFlags;
    INT SlimCascadeDrawHeight;
    INT Cascade_MouseMoveThreshold;
    TArrayNoInit<struct FModuleMenuMapper> ModuleMenu_TypeDataToBaseModuleRejections_DEPRECATED;
    TArrayNoInit<struct FModuleMenuMapper> ModuleMenu_TypeDataToSpecificModuleRejections_DEPRECATED;
    TArrayNoInit<FString> ModuleMenu_ModuleRejections_DEPRECATED;
    FLOAT MotionModeRadius;
    //## END PROPS CascadeOptions

    DECLARE_CLASS(UCascadeOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

    NO_DEFAULT_CONSTRUCTOR(UCascadeOptions)
};

class UCascadePreviewComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS CascadePreviewComponent
    class WxCascade* CascadePtr;
    //## END PROPS CascadePreviewComponent

    DECLARE_CLASS(UCascadePreviewComponent,UPrimitiveComponent,0,UnrealEd)
	virtual void Render(const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class UConvertMapToNavMesh : public UCommandlet
{
public:
    //## BEGIN PROPS ConvertMapToNavMesh
    //## END PROPS ConvertMapToNavMesh

    DECLARE_CLASS(UConvertMapToNavMesh,UCommandlet,0|CLASS_Transient,UnrealEd)
	virtual INT Main(const FString& Params);
};

class UCurveEdOptions : public UObject
{
public:
    //## BEGIN PROPS CurveEdOptions
    FLOAT MinViewRange;
    FLOAT MaxViewRange;
    FLinearColor BackgroundColor;
    FLinearColor LabelColor;
    FLinearColor SelectedLabelColor;
    FLinearColor GridColor;
    FLinearColor GridTextColor;
    FLinearColor LabelBlockBkgColor;
    FLinearColor SelectedKeyColor;
    //## END PROPS CurveEdOptions

    DECLARE_CLASS(UCurveEdOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

    NO_DEFAULT_CONSTRUCTOR(UCurveEdOptions)
};

struct CurveEdPresetBase_eventGenerateCurveData_Parms
{
    TArray<FLOAT> RequiredKeyInTimes;
    TArray<struct FPresetGeneratedPoint> GeneratedPoints;
    UBOOL ReturnValue;
    CurveEdPresetBase_eventGenerateCurveData_Parms(EEventParm)
    {
    }
};
struct CurveEdPresetBase_eventFetchRequiredKeyInTimes_Parms
{
    TArray<FLOAT> RequiredKeyInTimes;
    UBOOL ReturnValue;
    CurveEdPresetBase_eventFetchRequiredKeyInTimes_Parms(EEventParm)
    {
    }
};
struct CurveEdPresetBase_eventCheckAreSettingsValid_Parms
{
    UBOOL bIsSaving;
    UBOOL ReturnValue;
    CurveEdPresetBase_eventCheckAreSettingsValid_Parms(EEventParm)
    {
    }
};
struct CurveEdPresetBase_eventFetchDisplayName_Parms
{
    FString OutName;
    CurveEdPresetBase_eventFetchDisplayName_Parms(EEventParm)
    {
    }
};
class UCurveEdPresetBase : public UObject
{
public:
    //## BEGIN PROPS CurveEdPresetBase
    //## END PROPS CurveEdPresetBase

    UBOOL eventGenerateCurveData(TArray<FLOAT>& RequiredKeyInTimes,TArray<struct FPresetGeneratedPoint>& GeneratedPoints)
    {
        CurveEdPresetBase_eventGenerateCurveData_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.RequiredKeyInTimes=RequiredKeyInTimes;
        Parms.GeneratedPoints=GeneratedPoints;
        ProcessEvent(FindFunctionChecked(UNREALED_GenerateCurveData),&Parms);
        RequiredKeyInTimes=Parms.RequiredKeyInTimes;
        GeneratedPoints=Parms.GeneratedPoints;
        return Parms.ReturnValue;
    }
    UBOOL eventFetchRequiredKeyInTimes(TArray<FLOAT>& RequiredKeyInTimes)
    {
        CurveEdPresetBase_eventFetchRequiredKeyInTimes_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.RequiredKeyInTimes=RequiredKeyInTimes;
        ProcessEvent(FindFunctionChecked(UNREALED_FetchRequiredKeyInTimes),&Parms);
        RequiredKeyInTimes=Parms.RequiredKeyInTimes;
        return Parms.ReturnValue;
    }
    UBOOL eventCheckAreSettingsValid(UBOOL bIsSaving)
    {
        CurveEdPresetBase_eventCheckAreSettingsValid_Parms Parms(EC_EventParm);
        Parms.ReturnValue=FALSE;
        Parms.bIsSaving=bIsSaving ? FIRST_BITFIELD : FALSE;
        ProcessEvent(FindFunctionChecked(UNREALED_CheckAreSettingsValid),&Parms);
        return Parms.ReturnValue;
    }
    void eventFetchDisplayName(FString& OutName)
    {
        CurveEdPresetBase_eventFetchDisplayName_Parms Parms(EC_EventParm);
        Parms.OutName=OutName;
        ProcessEvent(FindFunctionChecked(UNREALED_FetchDisplayName),&Parms);
        OutName=Parms.OutName;
    }
    DECLARE_ABSTRACT_CLASS(UCurveEdPresetBase,UObject,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPresetBase)
};

class UCurveEdPreset_CosWave : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_CosWave
    FLOAT Frequency;
    FLOAT Scale;
    FLOAT Offset;
    //## END PROPS CurveEdPreset_CosWave

    DECLARE_CLASS(UCurveEdPreset_CosWave,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_CosWave)
};

class UCurveEdPreset_LinearDecay : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_LinearDecay
    FLOAT StartDecay;
    FLOAT StartValue;
    FLOAT EndDecay;
    FLOAT EndValue;
    //## END PROPS CurveEdPreset_LinearDecay

    DECLARE_CLASS(UCurveEdPreset_LinearDecay,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_LinearDecay)
};

class UCurveEdPreset_Nothing : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_Nothing
    //## END PROPS CurveEdPreset_Nothing

    DECLARE_CLASS(UCurveEdPreset_Nothing,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_Nothing)
};

class UCurveEdPreset_SineWave : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_SineWave
    FLOAT Frequency;
    FLOAT Scale;
    FLOAT Offset;
    //## END PROPS CurveEdPreset_SineWave

    DECLARE_CLASS(UCurveEdPreset_SineWave,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_SineWave)
};

class UCurveEdPreset_UserSet : public UCurveEdPresetBase
{
public:
    //## BEGIN PROPS CurveEdPreset_UserSet
    class UCurveEdPresetCurve* UserCurve;
    //## END PROPS CurveEdPreset_UserSet

    DECLARE_CLASS(UCurveEdPreset_UserSet,UCurveEdPresetBase,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UCurveEdPreset_UserSet)
};

struct FLightmassParameterValue
{
    BITFIELD bOverride:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FLightmassParameterValue() {}
    FLightmassParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassParameterValue));
    }
};

struct FLightmassBooleanParameterValue : public FLightmassParameterValue
{
    BITFIELD ParameterValue:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FLightmassBooleanParameterValue() {}
    FLightmassBooleanParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassBooleanParameterValue));
    }
};

struct FLightmassScalarParameterValue : public FLightmassParameterValue
{
    FLOAT ParameterValue;

    /** Constructors */
    FLightmassScalarParameterValue() {}
    FLightmassScalarParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassScalarParameterValue));
    }
};

struct FLightmassParameterizedMaterialSettings
{
    struct FLightmassBooleanParameterValue CastShadowAsMasked;
    struct FLightmassScalarParameterValue EmissiveBoost;
    struct FLightmassScalarParameterValue DiffuseBoost;
    struct FLightmassScalarParameterValue SpecularBoost;
    struct FLightmassScalarParameterValue ExportResolutionScale;
    struct FLightmassScalarParameterValue DistanceFieldPenumbraScale;

    /** Constructors */
    FLightmassParameterizedMaterialSettings() {}
    FLightmassParameterizedMaterialSettings(EEventParm)
    {
        appMemzero(this, sizeof(FLightmassParameterizedMaterialSettings));
    }
};

struct FPhysicalMaterialMaskSettings
{
    class UTexture2D* PhysMaterialMask;
    INT PhysMaterialMaskUVChannel;
    class UPhysicalMaterial* BlackPhysicalMaterial;
    class UPhysicalMaterial* WhitePhysicalMaterial;

    /** Constructors */
    FPhysicalMaterialMaskSettings() {}
    FPhysicalMaterialMaskSettings(EEventParm)
    {
        appMemzero(this, sizeof(FPhysicalMaterialMaskSettings));
    }
};

class UUnrealEdTypes : public UObject
{
public:
    //## BEGIN PROPS UnrealEdTypes
    //## END PROPS UnrealEdTypes

    DECLARE_ABSTRACT_CLASS(UUnrealEdTypes,UObject,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("UnrealEd");}

    NO_DEFAULT_CONSTRUCTOR(UUnrealEdTypes)
};

class UDEditorParameterValue : public UObject
{
public:
    //## BEGIN PROPS DEditorParameterValue
    BITFIELD bOverride:1;
    FName ParameterName;
    FGuid ExpressionId;
    //## END PROPS DEditorParameterValue

    DECLARE_CLASS(UDEditorParameterValue,UObject,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UDEditorParameterValue)
};

class UDEditorFontParameterValue : public UDEditorParameterValue
{
public:
    //## BEGIN PROPS DEditorFontParameterValue
    class UFont* FontValue;
    INT FontPage;
    //## END PROPS DEditorFontParameterValue

    DECLARE_CLASS(UDEditorFontParameterValue,UDEditorParameterValue,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UDEditorFontParameterValue)
};

class UDEditorScalarParameterValue : public UDEditorParameterValue
{
public:
    //## BEGIN PROPS DEditorScalarParameterValue
    FLOAT ParameterValue;
    //## END PROPS DEditorScalarParameterValue

    DECLARE_CLASS(UDEditorScalarParameterValue,UDEditorParameterValue,0,UnrealEd)

};

struct FDComponentMaskParameter
{
    BITFIELD R:1;
    BITFIELD G:1;
    BITFIELD B:1;
    BITFIELD A:1;
    SCRIPT_ALIGN;

	public:
	/** Constructor */
	FDComponentMaskParameter(UBOOL InR, UBOOL InG, UBOOL InB, UBOOL InA) :
		R(InR),
		G(InG),
		B(InB),
		A(InA)
	{
	};
	FDComponentMaskParameter(){};

};

class UDEditorStaticComponentMaskParameterValue : public UDEditorParameterValue
{
public:
    //## BEGIN PROPS DEditorStaticComponentMaskParameterValue
    struct FDComponentMaskParameter ParameterValue;
    //## END PROPS DEditorStaticComponentMaskParameterValue

    DECLARE_CLASS(UDEditorStaticComponentMaskParameterValue,UDEditorParameterValue,0,UnrealEd)
	/** Constructor */
	UDEditorStaticComponentMaskParameterValue(const FStaticComponentMaskParameter& InParameter) : ParameterValue(InParameter.R, InParameter.G, InParameter.B, InParameter.A)
	{
		//initialize base class members
		bOverride = InParameter.bOverride;
		ParameterName = InParameter.ParameterName;
		ExpressionId = InParameter.ExpressionGUID;
	}
	NO_DEFAULT_CONSTRUCTOR(UDEditorStaticComponentMaskParameterValue)

};

class UDEditorStaticSwitchParameterValue : public UDEditorParameterValue
{
public:
    //## BEGIN PROPS DEditorStaticSwitchParameterValue
    BITFIELD ParameterValue:1;
    SCRIPT_ALIGN;
    //## END PROPS DEditorStaticSwitchParameterValue

    DECLARE_CLASS(UDEditorStaticSwitchParameterValue,UDEditorParameterValue,0,UnrealEd)
	/** Constructor */
	UDEditorStaticSwitchParameterValue(const FStaticSwitchParameter& InParameter) : ParameterValue(InParameter.Value)
	{
		//initialize base class members
		bOverride = InParameter.bOverride;
		ParameterName = InParameter.ParameterName;
		ExpressionId = InParameter.ExpressionGUID;
	}
	NO_DEFAULT_CONSTRUCTOR(UDEditorStaticSwitchParameterValue)
};

class UDEditorTextureParameterValue : public UDEditorParameterValue
{
public:
    //## BEGIN PROPS DEditorTextureParameterValue
    class UTexture* ParameterValue;
    //## END PROPS DEditorTextureParameterValue

    DECLARE_CLASS(UDEditorTextureParameterValue,UDEditorParameterValue,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UDEditorTextureParameterValue)
};

class UDEditorVectorParameterValue : public UDEditorParameterValue
{
public:
    //## BEGIN PROPS DEditorVectorParameterValue
    FLinearColor ParameterValue;
    //## END PROPS DEditorVectorParameterValue

    DECLARE_CLASS(UDEditorVectorParameterValue,UDEditorParameterValue,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UDEditorVectorParameterValue)
};

class UEditorUserSettings : public UObject
{
public:
    //## BEGIN PROPS EditorUserSettings
    BITFIELD bAutoSaveEnable:1;
    BITFIELD bAutoSaveMaps:1;
    BITFIELD bAutoSaveContent:1;
    BITFIELD bAutoloadCheckedOutPackages:1;
    BITFIELD bSuppressFullyLoadPrompt:1;
    BITFIELD bAllowSelectTranslucent:1;
    BITFIELD bOnlyLoadVisibleLevelsInPIE:1;
    BITFIELD bStrictBoxSelection:1;
    BITFIELD bPromptForCheckoutOnPackageModification:1;
    BITFIELD bEnableRealTimeAudio:1;
    BITFIELD bUpdateActorsInGridLevelsImmediately:1;
    BITFIELD bAutoRestartReimportedFlashMovies:1;
    BITFIELD bAutoReimportTextures:1;
    BITFIELD bAutoReimportApexAssets:1;
    BITFIELD bAutoReimportAnimSets:1;
    BITFIELD bUseLinkedOrthographicViewports:1;
    BITFIELD bEnableShowFlagsShortcut:1;
    BITFIELD bStartInRealtimeMode:1;
    BITFIELD bLoadSimpleLevelAtStartup:1;
    BITFIELD bEnableViewportHoverFeedback:1;
    BITFIELD bEnableViewportCameraToUpdateFromPIV:1;
    BITFIELD bEmulateMobileFeatures:1;
    BITFIELD bAlwaysOptimizeContentForMobile:1;
    INT AutoSaveTimeMinutes;
    BYTE FlightCameraControlType;
    BYTE AspectRatioAxisConstraint;
    SCRIPT_ALIGN;
    FColor PreviewThumbnailBackgroundColor;
    FColor PreviewThumbnailTranslucentMaterialBackgroundColor;
    FLOAT EditorVolumeLevel;
    TArrayNoInit<FString> PackagesToSave;
    //## END PROPS EditorUserSettings

    DECLARE_CLASS(UEditorUserSettings,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

    NO_DEFAULT_CONSTRUCTOR(UEditorUserSettings)
};

class UEditorViewportInput : public UInput
{
public:
    //## BEGIN PROPS EditorViewportInput
    class UEditorEngine* Editor;
    //## END PROPS EditorViewportInput

    DECLARE_CLASS(UEditorViewportInput,UInput,0|CLASS_Transient|CLASS_Config,UnrealEd)
	virtual UBOOL Exec(const TCHAR* Cmd,FOutputDevice& Ar);
};

class UFaceFXStudioSkelComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS FaceFXStudioSkelComponent
    FPointer RenderWidgetUE3Ptr;
    //## END PROPS FaceFXStudioSkelComponent

    DECLARE_CLASS(UFaceFXStudioSkelComponent,USkeletalMeshComponent,0|CLASS_Config,UnrealEd)
	// UPrimitiveComponent interface.
	virtual FPrimitiveSceneProxy* CreateSceneProxy();
};

class UFbxImportUI : public UObject
{
public:
    //## BEGIN PROPS FbxImportUI
    BYTE MeshTypeToImport;
    SCRIPT_ALIGN;
    BITFIELD bOverrideFullName:1;
    BITFIELD bImportMeshLODs:1;
    BITFIELD bOverrideTangents:1;
    BITFIELD bImportMorphTargets:1;
    BITFIELD bImportAnimations:1;
    BITFIELD bImportRigidAnimation:1;
    BITFIELD bResampleAnimations:1;
    BITFIELD bUseT0AsRefPose:1;
    BITFIELD bSplitNonMatchingTriangles:1;
    BITFIELD bImportMeshesInBoneHierarchy:1;
    BITFIELD bCombineMeshes:1;
    BITFIELD bReplaceVertexColors:1;
    BITFIELD bExplicitNormals:1;
    BITFIELD bRemoveDegenerates:1;
    BITFIELD bOneConvexHullPerUCX:1;
    BITFIELD bImportMaterials:1;
    BITFIELD bImportTextures:1;
    BITFIELD bInvertNormalMaps:1;
    BITFIELD bAutoCreateGroups:1;
    SCRIPT_ALIGN;
    //## END PROPS FbxImportUI

    DECLARE_CLASS(UFbxImportUI,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

    NO_DEFAULT_CONSTRUCTOR(UFbxImportUI)
};

class UFindUnreferencedFunctionsCommandlet : public UCommandlet
{
public:
    //## BEGIN PROPS FindUnreferencedFunctionsCommandlet
    class UByteCodeSerializer* Serializer;
    //## END PROPS FindUnreferencedFunctionsCommandlet

    DECLARE_CLASS(UFindUnreferencedFunctionsCommandlet,UCommandlet,0|CLASS_Transient,UnrealEd)
	/**
	 * Find the original function declaration from an interface class implemented by FunctionOwnerClass.
	 *
	 * @param	FunctionOwnerClass	the class containing the function being looked up.
	 * @param	Function			the function being looked up
	 *
	 * @return	if Function is an implementation of a function declared in an interface class implemented by FunctionOwnerClass,
	 *			returns a pointer to the function from the interface class; NULL if Function isn't an implementation of an interface
	 *			function
	 */
	UFunction* GetInterfaceFunctionDeclaration( UClass* FunctionOwnerClass, UFunction* Function );

	/**
	 * Commandlet entry point
	 *
	 * @param	Params	the command line parameters that were passed in.
	 *
	 * @return	0 if the commandlet succeeded; otherwise, an error code defined by the commandlet.
	 */
	virtual INT Main(const FString& Params);
};

struct FObjectSupportedCommandType
{
    INT CommandID;
    INT ParentIndex;
    FString LocalizedName;
    BITFIELD bIsEnabled:1;
    SCRIPT_ALIGN;

		/** Constructor that initializes all elements */
		FObjectSupportedCommandType( INT InCommandID, const FString& InLocalizedName, UBOOL bInIsEnabled = TRUE, INT InParentIndex = -1 )
			: CommandID( InCommandID ),
			  LocalizedName( InLocalizedName ),
			  bIsEnabled( bInIsEnabled ),
			  ParentIndex( InParentIndex )
		{
		}
	
};

struct FGenericBrowserTypeInfo
{
    class UClass* Class;
    FColor BorderColor;
    QWORD RequiredFlags;
    class UGenericBrowserType* BrowserType;
    FPointer IsSupportedCallback;

	typedef UBOOL (*GenericBrowserSupportCallback)(UObject* Object);

	FGenericBrowserTypeInfo(
		UClass* InClass,
		const FColor& InBorderColor,
		QWORD InRequiredFlags = 0,
		UGenericBrowserType* InBrowserType = NULL,
		GenericBrowserSupportCallback InIsSupportedCallback = NULL
	)
	:	Class(InClass)
	,	RequiredFlags(InRequiredFlags)
	,	BorderColor(InBorderColor)
	,	BrowserType(InBrowserType)
	,	IsSupportedCallback(InIsSupportedCallback)
	{}

	UBOOL Supports( UObject* Object ) const
	{
		UBOOL bResult = FALSE;
		if ( Object->IsA(Class) )
		{
			bResult = TRUE;
			if ( RequiredFlags != 0 )
			{
				bResult = Object->HasAllFlags(RequiredFlags);
			}
			if( bResult && IsSupportedCallback )
			{
				GenericBrowserSupportCallback Callback = (GenericBrowserSupportCallback) IsSupportedCallback;
				bResult = Callback( Object );
			}
		}
		return bResult;
	}

	inline UBOOL operator==( const FGenericBrowserTypeInfo& Other ) const
	{
		return ( Class == Other.Class && RequiredFlags == Other.RequiredFlags );
	}

};

class UGenericBrowserType : public UObject
{
public:
    //## BEGIN PROPS GenericBrowserType
    FStringNoInit Description;
    TArrayNoInit<struct FGenericBrowserTypeInfo> SupportInfo;
    FColor BorderColor;
    //## END PROPS GenericBrowserType

    DECLARE_ABSTRACT_CLASS(UGenericBrowserType,UObject,0,UnrealEd)
	/**
	 * @return Returns the browser type description string.
	 */
	const FString& GetBrowserTypeDescription() const
	{
		return Description;
	}

	FColor GetBorderColor( UObject* InObject );

	/**
	 * Does any initial set up that the type requires.
	 */
	virtual void Init() 
	{
	}

	/**
	 * Clear out any old data before calling Init() again
	 */
	virtual void Clear();

	/**
	 * Checks to see if the specified class is handled by this type.
	 *
	 * @param	InObject	The object we need to check if we support
	 */
	UBOOL Supports( UObject* InObject ) const;

	/**
	 * Creates a context menu specific to the type of objects that are selected.
	 *
	 * @param	Selection	The selected object set.
	 */
	class WxMBGenericBrowserContextBase* GetContextMenu( USelection* Selection );

	/**
	 * Invokes the editor for an object.  The default behaviour is to
	 * open a property window for the object.  Dervied classes can override
	 * this with eg an editor which is specialized for the object's class.
	 *
	 * @param	InObject	The object to invoke the editor for.
	 */
	virtual UBOOL ShowObjectEditor( UObject* InObject )
	{
		return ShowObjectProperties( InObject );
	}

	/**
	 * Opens a property window for the specified object.  By default, GEditor's
	 * notify hook is used on the property window.  Derived classes can override
	 * this method in order to eg provide their own notify hook.
	 *
	 * @param	InObject	The object to invoke the property window for.
	 */
	virtual UBOOL ShowObjectProperties( UObject* InObject );

	/**
	 * Opens a property window for the specified objects.  By default, GEditor's
	 * notify hook is used on the property window.  Derived classes can override
	 * this method in order to eg provide their own notify hook.
	 *
	 * @param	InObjects	The objects to invoke the property window for.
	 */
	virtual UBOOL ShowObjectProperties( const TArray<UObject*>& InObjects );

	/**
	 * Invokes the editor for all selected objects.
	 */
	virtual UBOOL ShowObjectEditor();

	/**
	 * Displays the object properties window for all selected objects that this
	 * GenericBrowserType supports.
	 */
	UBOOL ShowObjectProperties();


	/**
	 * Static: Returns a list of standard context menu commands supported by the specified objects
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	static void QueryStandardSupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands );


	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	/**
	 * Returns the default command to be executed given the selected object.
	 *
	 * @param	InObject		The objects to query the default command for
	 *
	 * @return The ID of the default action command (i.e. command that happens on double click or enter).
	 */
	virtual INT QueryDefaultCommand( TArray<UObject*>& InObjects ) const;


	/**
	 * Invokes a custom menu item command for every selected object
	 * of a supported class.
	 *
	 * @param InCommand		The command to execute
	 */

	virtual void InvokeCustomCommand( INT InCommand );

	/**
	 * Invokes a custom menu item command.
	 *
	 * @param InCommand		The command to execute
	 * @param InObject		The object to invoke the command against
	 */

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects ) 
	{
	}

	/**
	 * Calls the virtual "DoubleClick" function for each object
	 * of a supported class.
	 */

	virtual void DoubleClick();

	/**
	 * Allows each type to handle double clicking as they see fit.
	 */

	virtual void DoubleClick( UObject* InObject );

	/**
	 * Retrieves a list of objects supported by this browser type which
	 * are currently selected in the generic browser.
	 */
	void GetSelectedObjects( TArray<UObject*>& Objects );

	/**
	 * Determines whether the specified package is allowed to be saved.
	 */
	virtual UBOOL IsSavePackageAllowed( UPackage* PackageToSave );

protected:
	/**
	 * Determines whether the specified package is allowed to be saved.
	 *
	 * @param	PackageToSave		the package that is about to be saved
	 * @param	StandaloneObjects	a list of objects from PackageToSave which were marked RF_Standalone
	 */
	virtual UBOOL IsSavePackageAllowed( UPackage* PackageToSave, TArray<UObject*>& StandaloneObjects ) 
	{ 
		return TRUE; 
	}


	/**
	 * Static: Returns true if any of the specified objects have already been cooked
	 */
	static UBOOL AnyObjectsAreCooked( USelection* InObjects );


public:
	/**
	 * Called when the user chooses to delete objects from the generic browser.  Gives the resource type the opportunity
	 * to perform any special logic prior to the delete.
	 *
	 * @param	ObjectToDelete	the object about to be deleted.
	 *
	 * @return	TRUE to allow the object to be deleted, FALSE to prevent the object from being deleted.
	 */
	virtual UBOOL NotifyPreDeleteObject( UObject* ObjectToDelete ) 
	{ 
		return TRUE; 
	}

	/**
	 * Called when the user chooses to delete objects from the generic browser, after the object has been checked for referencers.
	 * Gives the resource type the opportunity to perform any special logic after the delete.
	 *
	 * @param	ObjectToDelete		the object that was deleted.
	 * @param	bDeleteSuccessful	TRUE if the object wasn't referenced and was successfully marked for deletion.
	 */
	virtual void NotifyPostDeleteObject() 
	{
	}
};

class UGenericBrowserType_Animation : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Animation
    //## END PROPS GenericBrowserType_Animation

    DECLARE_CLASS(UGenericBrowserType_Animation,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
};

class UGenericBrowserType_AnimTree : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_AnimTree
    //## END PROPS GenericBrowserType_AnimTree

    DECLARE_CLASS(UGenericBrowserType_AnimTree,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
};

class UGenericBrowserType_ApexClothingAsset : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_ApexClothingAsset
    //## END PROPS GenericBrowserType_ApexClothingAsset

    DECLARE_CLASS(UGenericBrowserType_ApexClothingAsset,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_ApexDestructibleAsset : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_ApexDestructibleAsset
    //## END PROPS GenericBrowserType_ApexDestructibleAsset

    DECLARE_CLASS(UGenericBrowserType_ApexDestructibleAsset,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_ApexDestructibleDamageParameters : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_ApexDestructibleDamageParameters
    //## END PROPS GenericBrowserType_ApexDestructibleDamageParameters

    DECLARE_CLASS(UGenericBrowserType_ApexDestructibleDamageParameters,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor(UObject *InObject);
};

class UGenericBrowserType_ApexGenericAsset : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_ApexGenericAsset
    //## END PROPS GenericBrowserType_ApexGenericAsset

    DECLARE_CLASS(UGenericBrowserType_ApexGenericAsset,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
	virtual void InvokeCustomCommand( INT InCommand );
	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
	virtual void DoubleClick();
	virtual void DoubleClick( UObject* InObject );
	virtual INT QueryDefaultCommand( TArray<UObject*>& InObjects ) const;
	virtual UBOOL ShowObjectEditor( UObject* InObject);

};

class UGenericBrowserType_Archetype : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Archetype
    //## END PROPS GenericBrowserType_Archetype

    DECLARE_CLASS(UGenericBrowserType_Archetype,UGenericBrowserType,0,UnrealEd)
	virtual void Init();

	/**
	 * Determines whether the specified object is an archetype that should be handled by this generic browser type.
	 *
	 * @param	Object	a pointer to a object with the RF_ArchetypeObject flag
	 *
	 * @return	TRUE if this generic browser type supports to object specified.
	 */
	static UBOOL IsArchetypeSupported( UObject* Object );


	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	/**
	 * Returns the default command to be executed given the selected object.
	 *
	 * @param	InObject		The objects to query the default command for
	 *
	 * @return The ID of the default action command (i.e. command that happens on double click or enter).
	 */
	virtual INT QueryDefaultCommand( TArray<UObject*>& InObjects ) const;
};

class UGenericBrowserType_CameraAnim : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_CameraAnim
    //## END PROPS GenericBrowserType_CameraAnim

    DECLARE_CLASS(UGenericBrowserType_CameraAnim,UGenericBrowserType,0,UnrealEd)
	/**
	 * Initialize the supported classes for this browser type.
	 */
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
};

class UGenericBrowserType_CurveEdPresetCurve : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_CurveEdPresetCurve
    //## END PROPS GenericBrowserType_CurveEdPresetCurve

    DECLARE_CLASS(UGenericBrowserType_CurveEdPresetCurve,UGenericBrowserType,0,UnrealEd)
	/**
	 * Initialize the supported classes for this browser type.
	 */
	virtual void Init();
};

class UGenericBrowserType_Custom : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Custom
    //## END PROPS GenericBrowserType_Custom

    DECLARE_CLASS(UGenericBrowserType_Custom,UGenericBrowserType,0,UnrealEd)
	/**
	 * Invokes the editor for all selected objects.
	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 */
	virtual UBOOL ShowObjectEditor();

	/**
	 * Invokes the editor for an object.  The default behaviour is to
	 * open a property window for the object.  Dervied classes can override
	 * this with eg an editor which is specialized for the object's class.
	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 *
	 * @param	InObject	The object to invoke the editor for.
	 */
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Opens a property window for the specified object.  By default, GEditor's
	 * notify hook is used on the property window.  Derived classes can override
	 * this method in order to eg provide their own notify hook.
	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 *
	 * @param	InObject	The object to invoke the property window for.
	 */
	virtual UBOOL ShowObjectProperties( const TArray<UObject*>& InObjects );


	/**
	 * Invokes a custom menu item command for every selected object
	 * of a supported class.
	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 *
	 * @param InCommand		The command to execute
	 */
	virtual void InvokeCustomCommand( INT InCommand );

	/**
	 * Calls the virtual "DoubleClick" function for each object
	 * of a supported class.
 	 *
	 * This version loops through all of the supported classes for the custom type and
	 * calls the appropriate implementation of the function.
	 */
	virtual void DoubleClick();
};

class UGenericBrowserType_All : public UGenericBrowserType_Custom
{
public:
    //## BEGIN PROPS GenericBrowserType_All
    //## END PROPS GenericBrowserType_All

    DECLARE_CLASS(UGenericBrowserType_All,UGenericBrowserType_Custom,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_DecalMaterial : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_DecalMaterial
    //## END PROPS GenericBrowserType_DecalMaterial

    DECLARE_CLASS(UGenericBrowserType_DecalMaterial,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_FaceFXAnimSet : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_FaceFXAnimSet
    //## END PROPS GenericBrowserType_FaceFXAnimSet

    DECLARE_CLASS(UGenericBrowserType_FaceFXAnimSet,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects);
};

class UGenericBrowserType_FaceFXAsset : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_FaceFXAsset
    //## END PROPS GenericBrowserType_FaceFXAsset

    DECLARE_CLASS(UGenericBrowserType_FaceFXAsset,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual UBOOL ShowObjectProperties( UObject* InObject );
	virtual UBOOL ShowObjectProperties( const TArray<UObject*>& InObjects );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_Font : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Font
    //## END PROPS GenericBrowserType_Font

    DECLARE_CLASS(UGenericBrowserType_Font,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	/**
	 * Displays the font properties window for editing & importing/exporting of
	 * font pages
	 *
	 * @param InObject the object being edited
	 */
	virtual UBOOL ShowObjectEditor( UObject* InObject );


	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;


	/**
	 * Invokes a custom menu item command.
	 *
	 * @param InCommand		The command to execute
	 * @param InObject		The object to invoke the command against
	 */
	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_FractureMaterial : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_FractureMaterial
    //## END PROPS GenericBrowserType_FractureMaterial

    DECLARE_CLASS(UGenericBrowserType_FractureMaterial,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_InstancedFoliageSettings : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_InstancedFoliageSettings
    //## END PROPS GenericBrowserType_InstancedFoliageSettings

    DECLARE_CLASS(UGenericBrowserType_InstancedFoliageSettings,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_LandscapeLayer : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_LandscapeLayer
    //## END PROPS GenericBrowserType_LandscapeLayer

    DECLARE_CLASS(UGenericBrowserType_LandscapeLayer,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_LensFlare : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_LensFlare
    //## END PROPS GenericBrowserType_LensFlare

    DECLARE_CLASS(UGenericBrowserType_LensFlare,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
};

class UGenericBrowserType_Material : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Material
    //## END PROPS GenericBrowserType_Material

    DECLARE_CLASS(UGenericBrowserType_Material,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& Objects );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;


	/**
	* Callback to register whether or not the object should be displayed
	* @param InObject - object that will be displayed in the GB
	* @return TRUE if should be displayed
	*/ 
	static UBOOL ShouldDisplayCallback( UObject* InObject );
};

class UGenericBrowserType_MaterialFunction : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_MaterialFunction
    //## END PROPS GenericBrowserType_MaterialFunction

    DECLARE_CLASS(UGenericBrowserType_MaterialFunction,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& Objects );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;


	/**
	* Callback to register whether or not the object should be displayed
	* @param InObject - object that will be displayed in the GB
	* @return TRUE if should be displayed
	*/ 
	static UBOOL ShouldDisplayCallback( UObject* InObject );
};

class UGenericBrowserType_MaterialInstanceConstant : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_MaterialInstanceConstant
    //## END PROPS GenericBrowserType_MaterialInstanceConstant

    DECLARE_CLASS(UGenericBrowserType_MaterialInstanceConstant,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_MaterialInstanceTimeVarying : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_MaterialInstanceTimeVarying
    //## END PROPS GenericBrowserType_MaterialInstanceTimeVarying

    DECLARE_CLASS(UGenericBrowserType_MaterialInstanceTimeVarying,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_MorphTargetSet : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_MorphTargetSet
    //## END PROPS GenericBrowserType_MorphTargetSet

    DECLARE_CLASS(UGenericBrowserType_MorphTargetSet,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
};

class UGenericBrowserType_MorphWeightSequence : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_MorphWeightSequence
    //## END PROPS GenericBrowserType_MorphWeightSequence

    DECLARE_CLASS(UGenericBrowserType_MorphWeightSequence,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_ParticleSystem : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_ParticleSystem
    //## END PROPS GenericBrowserType_ParticleSystem

    DECLARE_CLASS(UGenericBrowserType_ParticleSystem,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_PhysicalMaterial : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_PhysicalMaterial
    //## END PROPS GenericBrowserType_PhysicalMaterial

    DECLARE_CLASS(UGenericBrowserType_PhysicalMaterial,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_PhysicsAsset : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_PhysicsAsset
    //## END PROPS GenericBrowserType_PhysicsAsset

    DECLARE_CLASS(UGenericBrowserType_PhysicsAsset,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
};

class UGenericBrowserType_PhysXParticleSystem : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_PhysXParticleSystem
    //## END PROPS GenericBrowserType_PhysXParticleSystem

    DECLARE_CLASS(UGenericBrowserType_PhysXParticleSystem,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor(UObject *InObject);
};

class UGenericBrowserType_PostProcess : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_PostProcess
    //## END PROPS GenericBrowserType_PostProcess

    DECLARE_CLASS(UGenericBrowserType_PostProcess,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
};

class UGenericBrowserType_Prefab : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Prefab
    //## END PROPS GenericBrowserType_Prefab

    DECLARE_CLASS(UGenericBrowserType_Prefab,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
};

class UGenericBrowserType_ProcBuildingRuleset : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_ProcBuildingRuleset
    //## END PROPS GenericBrowserType_ProcBuildingRuleset

    DECLARE_CLASS(UGenericBrowserType_ProcBuildingRuleset,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
};

class UGenericBrowserType_Sequence : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Sequence
    //## END PROPS GenericBrowserType_Sequence

    DECLARE_CLASS(UGenericBrowserType_Sequence,UGenericBrowserType,0,UnrealEd)
	virtual void Init();

	/**
	 * Determines whether the specified object is a USequence class that should be handled by this generic browser type.
	 *
	 * @param	Object	a pointer to a USequence object.
	 *
	 * @return	TRUE if this generic browser type supports to object specified.
	 */
	static UBOOL IsSequenceTypeSupported( UObject* Object );
};

class UGenericBrowserType_SkeletalMesh : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_SkeletalMesh
    //## END PROPS GenericBrowserType_SkeletalMesh

    DECLARE_CLASS(UGenericBrowserType_SkeletalMesh,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_Sounds : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Sounds
    //## END PROPS GenericBrowserType_Sounds

    DECLARE_CLASS(UGenericBrowserType_Sounds,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual INT QueryDefaultCommand( TArray<UObject*>& InObjects ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
	virtual void DoubleClick( UObject* InObject );

	void Play( USoundCue* InSound );
	void Play( USoundNode* InSound );
	bool IsPlaying( USoundCue* InSound );
	bool IsPlaying( USoundNode* InSound );
	void Stop();
};

class UGenericBrowserType_SoundClass : public UGenericBrowserType_Sounds
{
public:
    //## BEGIN PROPS GenericBrowserType_SoundClass
    //## END PROPS GenericBrowserType_SoundClass

    DECLARE_CLASS(UGenericBrowserType_SoundClass,UGenericBrowserType_Sounds,0,UnrealEd)
	virtual void Init();
	virtual UBOOL NotifyPreDeleteObject( UObject* ObjectToDelete );
	virtual void NotifyPostDeleteObject();
};

class UGenericBrowserType_SoundCue : public UGenericBrowserType_Sounds
{
public:
    //## BEGIN PROPS GenericBrowserType_SoundCue
    //## END PROPS GenericBrowserType_SoundCue

    DECLARE_CLASS(UGenericBrowserType_SoundCue,UGenericBrowserType_Sounds,0,UnrealEd)
	virtual void Init( void );
	
	/**
	 * Invokes a custom menu item command for every selected object
	 * of a supported class.
	 *
	 * @param InCommand		The command to execute
	 * @param InObjects		The objects to invoke the command against
	 */
	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects);
};

class UGenericBrowserType_SoundMode : public UGenericBrowserType_Sounds
{
public:
    //## BEGIN PROPS GenericBrowserType_SoundMode
    //## END PROPS GenericBrowserType_SoundMode

    DECLARE_CLASS(UGenericBrowserType_SoundMode,UGenericBrowserType_Sounds,0,UnrealEd)
	virtual void Init();
	virtual UBOOL NotifyPreDeleteObject( UObject* ObjectToDelete );
	virtual void NotifyPostDeleteObject();
};

class UGenericBrowserType_SoundWave : public UGenericBrowserType_Sounds
{
public:
    //## BEGIN PROPS GenericBrowserType_SoundWave
    //## END PROPS GenericBrowserType_SoundWave

    DECLARE_CLASS(UGenericBrowserType_SoundWave,UGenericBrowserType_Sounds,0,UnrealEd)
	virtual void Init( void );
		
	/**
	 * Invokes a custom menu item command for every selected object
	 * of a supported class.
	 *
	 * @param InCommand		The command to execute
	 * @param InObjects		The objects to invoke the command against
	 */
	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_SpeechRecognition : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_SpeechRecognition
    //## END PROPS GenericBrowserType_SpeechRecognition

    DECLARE_CLASS(UGenericBrowserType_SpeechRecognition,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_SpeedTree : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_SpeedTree
    //## END PROPS GenericBrowserType_SpeedTree

    DECLARE_CLASS(UGenericBrowserType_SpeedTree,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );
	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;
};

class UGenericBrowserType_StaticMesh : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_StaticMesh
    //## END PROPS GenericBrowserType_StaticMesh

    DECLARE_CLASS(UGenericBrowserType_StaticMesh,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_FracturedStaticMesh : public UGenericBrowserType_StaticMesh
{
public:
    //## BEGIN PROPS GenericBrowserType_FracturedStaticMesh
    //## END PROPS GenericBrowserType_FracturedStaticMesh

    DECLARE_CLASS(UGenericBrowserType_FracturedStaticMesh,UGenericBrowserType_StaticMesh,0,UnrealEd)
	virtual void Init();

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_TemplateMapMetadata : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_TemplateMapMetadata
    //## END PROPS GenericBrowserType_TemplateMapMetadata

    DECLARE_CLASS(UGenericBrowserType_TemplateMapMetadata,UGenericBrowserType,0,UnrealEd)
	/**
	 * Initialize the supported classes for this browser type.
	 */
	virtual void Init();
};

class UGenericBrowserType_TerrainLayer : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_TerrainLayer
    //## END PROPS GenericBrowserType_TerrainLayer

    DECLARE_CLASS(UGenericBrowserType_TerrainLayer,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_TerrainMaterial : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_TerrainMaterial
    //## END PROPS GenericBrowserType_TerrainMaterial

    DECLARE_CLASS(UGenericBrowserType_TerrainMaterial,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGenericBrowserType_Texture : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_Texture
    //## END PROPS GenericBrowserType_Texture

    DECLARE_CLASS(UGenericBrowserType_Texture,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
	virtual UBOOL ShowObjectEditor( UObject* InObject );

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );

	/**
	* Callback to register whether or not the object should be displayed
	* @param InObject - object that will be displayed in the GB
	* @return TRUE if should be displayed
	*/ 
	static UBOOL ShouldDisplayCallback( UObject* InObject );
};

class UGenericBrowserType_RenderTexture : public UGenericBrowserType_Texture
{
public:
    //## BEGIN PROPS GenericBrowserType_RenderTexture
    //## END PROPS GenericBrowserType_RenderTexture

    DECLARE_CLASS(UGenericBrowserType_RenderTexture,UGenericBrowserType_Texture,0,UnrealEd)
	virtual void Init();

	/**
	 * Returns a list of commands that this object supports (or the object type supports, if InObject is NULL)
	 *
	 * @param	InObjects		The objects to query commands for (if NULL, query commands for all objects of this type.)
	 * @param	OutCommands		The list of custom commands to support
	 */
	virtual void QuerySupportedCommands( class USelection* InObjects, TArray< FObjectSupportedCommandType >& OutCommands ) const;

	virtual void InvokeCustomCommand( INT InCommand, TArray<UObject*>& InObjects );
};

class UGenericBrowserType_TextureCube : public UGenericBrowserType_Texture
{
public:
    //## BEGIN PROPS GenericBrowserType_TextureCube
    //## END PROPS GenericBrowserType_TextureCube

    DECLARE_CLASS(UGenericBrowserType_TextureCube,UGenericBrowserType_Texture,0,UnrealEd)
	/** Initialize this generic browser type */
	virtual void Init();
};

class UGenericBrowserType_TextureMovie : public UGenericBrowserType
{
public:
    //## BEGIN PROPS GenericBrowserType_TextureMovie
    //## END PROPS GenericBrowserType_TextureMovie

    DECLARE_CLASS(UGenericBrowserType_TextureMovie,UGenericBrowserType,0,UnrealEd)
	virtual void Init();
};

class UGeomModifier : public UObject
{
public:
    //## BEGIN PROPS GeomModifier
    FStringNoInit Description;
    BITFIELD bPushButton:1;
    BITFIELD bInitialized:1;
    class UPolys* CachedPolys;
    //## END PROPS GeomModifier

    DECLARE_ABSTRACT_CLASS(UGeomModifier,UObject,0,UnrealEd)
	/**
	 * @return		The modifier's description string.
	 */
	const FString& GetModifierDescription() const;

	/**
	 * @return		TRUE if the key was handled by this editor mode tool.
	 */
	virtual UBOOL InputKey(struct FEditorLevelViewportClient* ViewportClient,FViewport* Viewport,FName Key,EInputEvent Event);

	/**
	 * @return		TRUE if the delta was handled by this editor mode tool.
	 */
	virtual UBOOL InputDelta(struct FEditorLevelViewportClient* InViewportClient,FViewport* InViewport,FVector& InDrag,FRotator& InRot,FVector& InScale);

	/*
	 * Drawing functions to allow modifiers to have better control over the screen.
	 */
	virtual void Render(const FSceneView* View,FViewport* Viewport,FPrimitiveDrawInterface* PDI);
	virtual void DrawHUD(FEditorLevelViewportClient* ViewportClient,FViewport* Viewport,const FSceneView* View,FCanvas* Canvas);

	/**
	 * Applies the modifier.  Does nothing if the editor is not in geometry mode.
	 *
	 * @return		TRUE if something happened.
	 */
 	UBOOL Apply();

	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

	/**
	 * Gives the individual modifiers a chance to do something the first time they are activated.
	 */
	virtual void Initialize();
	
	/**
	 * Starts the modification of geometry data.
	 */
	UBOOL StartModify();

	/**
	 * Ends the modification of geometry data.
	 */
	UBOOL EndModify();

	/**
	 * Handles the starting of transactions against the selected ABrushes.
	 */
	void StartTrans();
	
	/**
	 * Handles the stopping of transactions against the selected ABrushes.
	 */
	void EndTrans();

	virtual void Tick(FEditorLevelViewportClient* ViewportClient,FLOAT DeltaTime) {}

	/**
	 * Gives the modifier a chance to initialize it's internal state when activated.
	 */
	virtual void WasActivated() {}

	/**
	* Gives the modifier a chance to clean up when the user is switching away from it.
	*/
	virtual void WasDeactivated() {}
 	
 	/**
 	 * Stores the current state of the brush so that upon faulty operations, the
 	 * brush may be restored to its previous state
 	 */
 	 void CacheBrushState();
 	 
 	/**
 	 * Restores the brush to its cached state
 	 */
 	 void RestoreBrushState();
 	 
 	/**
	 * @return		TRUE if two edges in the shape overlap not at a vertex
	 */
	UBOOL DoEdgesOverlap();

protected:
	/**
	 * Interface for displaying error messages.
	 *
	 * @param	InErrorMsg		The error message to display.
	 */
	void GeomError(const FString& InErrorMsg);
	
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
};

class UGeomModifier_Edit : public UGeomModifier
{
public:
    //## BEGIN PROPS GeomModifier_Edit
    //## END PROPS GeomModifier_Edit

    DECLARE_CLASS(UGeomModifier_Edit,UGeomModifier,0,UnrealEd)
	/**
	 * @return		TRUE if the delta was handled by this editor mode tool.
	 */
	virtual UBOOL InputDelta(struct FEditorLevelViewportClient* InViewportClient,FViewport* InViewport,FVector& InDrag,FRotator& InRot,FVector& InScale);	
};

class UGeomModifier_Clip : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Clip
    BITFIELD bFlipNormal:1;
    BITFIELD bSplit:1;
    TArrayNoInit<FVector> ClipMarkers;
    FVector SnappedMouseWorldSpacePos;
    //## END PROPS GeomModifier_Clip

    DECLARE_CLASS(UGeomModifier_Clip,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

	/**
	 * @return		TRUE if the key was handled by this editor mode tool.
	 */
	virtual UBOOL InputKey(struct FEditorLevelViewportClient* ViewportClient,FViewport* Viewport,FName Key,EInputEvent Event);

	virtual void Render(const FSceneView* View,FViewport* Viewport,FPrimitiveDrawInterface* PDI);
	virtual void DrawHUD(FEditorLevelViewportClient* ViewportClient,FViewport* Viewport,const FSceneView* View,FCanvas* Canvas);

	virtual void Tick(FEditorLevelViewportClient* ViewportClient,FLOAT DeltaTime);

	/**
	 * Gives the modifier a chance to initialize it's internal state when activated.
	 */
	virtual void WasActivated();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();

private:
 	void ApplyClip( UBOOL InSplit, UBOOL InFlipNormal );
};

class UGeomModifier_Create : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Create
    //## END PROPS GeomModifier_Create

    DECLARE_CLASS(UGeomModifier_Create,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
};

class UGeomModifier_Delete : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Delete
    //## END PROPS GeomModifier_Delete

    DECLARE_CLASS(UGeomModifier_Delete,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
};

class UGeomModifier_Extrude : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Extrude
    INT Length;
    INT Segments;
    INT SaveCoordSystem;
    //## END PROPS GeomModifier_Extrude

    DECLARE_CLASS(UGeomModifier_Extrude,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

	/**
	 * Gives the individual modifiers a chance to do something the first time they are activated.
	 */
	virtual void Initialize();

	virtual void WasActivated();

	virtual void WasDeactivated();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();

 	
private:
 	void Apply(INT InLength, INT InSegments);
};

class UGeomModifier_Flip : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Flip
    //## END PROPS GeomModifier_Flip

    DECLARE_CLASS(UGeomModifier_Flip,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
};

class UGeomModifier_Lathe : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Lathe
    INT TotalSegments;
    INT Segments;
    BITFIELD AlignToSide:1;
    SCRIPT_ALIGN;
    BYTE Axis;
    SCRIPT_ALIGN;
    //## END PROPS GeomModifier_Lathe

    DECLARE_CLASS(UGeomModifier_Lathe,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

	/**
	 * Gives the individual modifiers a chance to do something the first time they are activated.
	 */
	virtual void Initialize();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
 	
private:
 	void Apply( INT InTotalSegments, INT InSegments, EAxis InAxis );
};

class UGeomModifier_Optimize : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Optimize
    //## END PROPS GeomModifier_Optimize

    DECLARE_CLASS(UGeomModifier_Optimize,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
};

class UGeomModifier_Pen : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Pen
    BITFIELD bAutoExtrude:1;
    BITFIELD bCreateConvexPolygons:1;
    BITFIELD bCreateBrushShape:1;
    INT ExtrudeDepth;
#if WITH_EDITORONLY_DATA
    FEditorLevelViewportClient* UsingViewportClient;
#endif // WITH_EDITORONLY_DATA
    TArrayNoInit<FVector> ShapeVertices;
    FVector MouseWorldSpacePos;
    //## END PROPS GeomModifier_Pen

    DECLARE_CLASS(UGeomModifier_Pen,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if the key was handled by this editor mode tool.
	 */
	virtual UBOOL InputKey(struct FEditorLevelViewportClient* ViewportClient,FViewport* Viewport,FName Key,EInputEvent Event);

	virtual void Render(const FSceneView* View,FViewport* Viewport,FPrimitiveDrawInterface* PDI);
	virtual void DrawHUD(FEditorLevelViewportClient* ViewportClient,FViewport* Viewport,const FSceneView* View,FCanvas* Canvas);

	virtual void Tick(FEditorLevelViewportClient* ViewportClient,FLOAT DeltaTime);

	/**
	 * Gives the modifier a chance to initialize it's internal state when activated.
	 */
	virtual void WasActivated();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
 	
private:
 	void Apply();
};

class UGeomModifier_Split : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Split
    //## END PROPS GeomModifier_Split

    DECLARE_CLASS(UGeomModifier_Split,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
};

class UGeomModifier_Triangulate : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Triangulate
    //## END PROPS GeomModifier_Triangulate

    DECLARE_CLASS(UGeomModifier_Triangulate,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
};

class UGeomModifier_Turn : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Turn
    //## END PROPS GeomModifier_Turn

    DECLARE_CLASS(UGeomModifier_Turn,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();

protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
};

class UGeomModifier_Weld : public UGeomModifier_Edit
{
public:
    //## BEGIN PROPS GeomModifier_Weld
    //## END PROPS GeomModifier_Weld

    DECLARE_CLASS(UGeomModifier_Weld,UGeomModifier_Edit,0,UnrealEd)
	/**
	 * @return		TRUE if this modifier will work on the currently selected sub objects.
	 */
	virtual UBOOL Supports();
	
protected:
	/**
	 * Implements the modifier application.
	 */
 	virtual UBOOL OnApply();
};

class AGroupActor : public AActor
{
public:
    //## BEGIN PROPS GroupActor
private:
    BITFIELD bLocked:1;
    BITFIELD bResetProxy:1;
    BITFIELD bRemergeProxy:1;
    SCRIPT_ALIGN;
#if WITH_EDITORONLY_DATA
    BYTE eMaterialType;
    BYTE eVertexColorMode;
    INT iOnScreenSize;
    INT iTextureSize;
    TArrayNoInit<class AActor*> GroupActors;
    TArrayNoInit<class AGroupActor*> SubGroups;
#else
    SCRIPT_ALIGN;
#endif // WITH_EDITORONLY_DATA
public:
    //## END PROPS GroupActor

    DECLARE_CLASS(AGroupActor,AActor,0,UnrealEd)
	virtual void Spawned();
	virtual void PostLoad();
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
	virtual void PostScriptDestroyed();
	virtual UBOOL Tick( FLOAT DeltaTime, enum ELevelTick TickType );
	virtual UBOOL IsSelected() const;

	/**
		Checks the group/proxy to make sure it doesn't conflict with other groups or is attempting anything invalid
	 */
	UBOOL ValidateGroup();
	void VerifyProxy( const UBOOL bSkipProxy, const UBOOL bSkipHidden );

	/**
	 * Apply given deltas to all actors and subgroups for this group.
	 * @param	Viewport		The viewport to draw to apply our deltas
	 * @param	InDrag			Delta Transition
	 * @param	InRot			Delta Rotation
	 * @param	InScale			Delta Scale
	 */
	void GroupApplyDelta(FEditorLevelViewportClient* Viewport, const FVector& InDrag, const FRotator& InRot, const FVector& InScale );

	/**
	 * Draw brackets around all selected groups
	 * @param	PDI				FPrimitiveDrawInterface used to draw lines in active viewports
	 * @param	Viewport		The viewport to draw brackets in.
	 * @param	bMustBeSelected	Flag to only draw currently selected groups. Defaults to TRUE.
	 */
	static void DrawBracketsForGroups( FPrimitiveDrawInterface* PDI, FViewport* Viewport, UBOOL bMustBeSelected=TRUE );

	/**
	 * Changes the given array to remove any existing subgroups
	 * @param	GroupArray	Array to remove subgroups from
	 */
	static void RemoveSubGroupsFromArray(TArray<AGroupActor*>& GroupArray);
	
	/**
	 * Returns the highest found root for the given actor or null if one is not found. Qualifications of root can be specified via optional parameters.
	 * @param	InActor			Actor to find a group root for.
	 * @param	bMustBeLocked	Flag designating to only return the topmost locked group.
	 * @param	bMustBeSelected	Flag designating to only return the topmost selected group.
	 * @return	The topmost group actor for this actor. Returns null if none exists using the given conditions.
	 */
	static AGroupActor* GetRootForActor(AActor* InActor, UBOOL bMustBeLocked=FALSE, UBOOL bMustBeSelected=FALSE);

	/**
	 * Returns the direct parent for the actor or null if one is not found.
	 * @param	InActor	Actor to find a group parent for.
	 * @return	The direct parent for the given actor. Returns null if no group has this actor as a child.
	 */
	static AGroupActor* GetParentForActor(AActor* InActor);

	/**
	 * Query to find how many active groups are currently in the editor.
	 * @param	bSelected	Flag to only return currently selected groups (defaults to FALSE).
	 * @param	bDeepSearch	Flag to do a deep search when checking group selections (defaults to TRUE).
	 * @return	Number of active groups currently in the editor.
	 */
	static const INT NumActiveGroups( UBOOL bSelected=FALSE, UBOOL bDeepSearch=TRUE );

	/**
	 * Get the selected group matching the supplied index
	 * @param iGroupIdx		Index of selected groups to gather the actors from.
	 * @param	bDeepSearch	Flag to do a deep search when checking group selections (defaults to TRUE).
	 * @return	Selected group actor, NULL if failed to find it
	 */
	static AGroupActor* GetSelectedGroup( INT iGroupIdx, UBOOL bDeepSearch=TRUE );

	/**
	 * Adds selected ungrouped actors to a selected group. Does nothing if more than one group is selected.
	 */
	static UBOOL AddSelectedActorsToSelectedGroup();

	/**
	 * Removes selected ungrouped actors from a selected group. Does nothing if more than one group is selected.
	 */
	static UBOOL RemoveSelectedActorsFromSelectedGroup();

	/**
	 * Report stats for selected group.
	 */
	static UBOOL ReportStatsForSelectedGroups();

	/**
	 * Report stats for selected actors.
	 */
	static UBOOL ReportStatsForSelectedActors();

	/**
	 * Locks the lowest selected groups in the current selection.
	 */
	static UBOOL LockSelectedGroups();

	/**
	 * Unlocks the highest locked parent groups for actors in the current selection.
	 */
	static UBOOL UnlockSelectedGroups();
	
	/**
	 * Toggle group mode
	 */
	static void ToggleGroupMode();

	/**
	 * Reselects any valid groups based on current editor selection
	 */
	static void SelectGroupsInSelection();
	
	/**
	 * Loops through the active groups and checks to see if any need remerging
	 */
	static void RemergeActiveGroups();

	/**
	 * Lock this group and all subgroups.
	 */
	void Lock();
	
	/**
	 * Unlock this group
	 */
	FORCEINLINE void Unlock()
	{
		bLocked = false;
	};
	
	/**
	 * @return	Group's locked state
	 */
	FORCEINLINE UBOOL IsLocked() const
	{
		return bLocked;
	};

	/**
	 * Indicate that this group needs it's proxy remerging
	 */
	FORCEINLINE void SetRemergeProxy(UBOOL bRemerge)
	{
		bRemergeProxy = bRemerge;
	};

	/**
	 * Get whether this group needs it's proxy remerging
	 */
	FORCEINLINE UBOOL GetRemergeProxy()
	{
		return bRemergeProxy;
	};

	/**
	 * Reset the params which constructed the proxy
	 */
	FORCEINLINE void ResetProxyParams()
	{
		eMaterialType = 255;
		eVertexColorMode = 255;
		iOnScreenSize = -1;
		iTextureSize = -1;
	};

	/**
	 * Set the params which constructed the proxy
	 */
	FORCEINLINE void SetProxyParams(BYTE eMaterialTypeIn, BYTE eVertexColorModeIn, INT iOnScreenSizeIn, INT iTextureSizeIn)
	{
		eMaterialType = eMaterialTypeIn;
		eVertexColorMode = eVertexColorModeIn;
		iOnScreenSize = iOnScreenSizeIn;
		iTextureSize = iTextureSizeIn;
	};

	/**
	 * Get the params which constructed the proxy
	 */
	FORCEINLINE UBOOL GetProxyParams(BYTE &eMaterialTypeOut, BYTE &eVertexColorModeOut, INT &iOnScreenSizeOut, INT &iTextureSizeOut)
	{
		eMaterialTypeOut = eMaterialType;
		eVertexColorModeOut = eVertexColorMode;
		iOnScreenSizeOut = iOnScreenSize;
		iTextureSizeOut = iTextureSize;
		return ( ( eMaterialTypeOut != 255 && eVertexColorModeOut != 255 && iOnScreenSizeOut != -1 && iTextureSizeOut != -1 ) ? TRUE : FALSE );
	};

	/**
	 * @param	InActor	Actor to add to this group
	 * @param	bInformProxy Should the proxy dialog be informed of this change (necessary to stop recursion)
	 */
	void Add(AActor& InActor, const UBOOL bInformProxy = TRUE, const UBOOL bMaintainProxy = FALSE);
	
	/**
	 * Removes the given actor from this group. If the group has no actors after this transaction, the group itself is removed.
	 * @param	InActor	Actor to remove from this group
	 * @param	bInformProxy Should the proxy dialog be informed of this change (necessary to stop recursion & only when it's not moved to another group)
	 * @param	bMaintainProxy Special case for when were removing the proxy from the group, but don't want to unmerge it
	 * @param	bMaintainGroup Special case for when were reverting the proxy but want to keep it's meshes part of the group
	 */
	void Remove(AActor& InActor, const UBOOL bInformProxy = TRUE, const UBOOL bMaintainProxy = FALSE, const UBOOL bMaintainGroup = FALSE);

	/**
	 * @param InActor	Actor to search for
	 * @return True if the group contains the given actor.
	 */
	UBOOL Contains(AActor& InActor) const;

	/**
	 * Searches the group for a proxy
	 * @return The proxy, if found
	 */
	AStaticMeshActor* ContainsProxy() const;

	/**
	 * @param bDeepSearch	Flag to check all subgroups as well. Defaults to TRUE.
	 * @return True if the group contains any selected actors.
	 */
	UBOOL HasSelectedActors(UBOOL bDeepSearch=TRUE) const;

	/**
	 * Detaches all children (actors and subgroups) from this group and then removes it.
	 * @param	bMaintainProxy Special case for when were removing the proxy from the group, but don't want to unmerge it
	 */
	void ClearAndRemove(const UBOOL bMaintainProxy = FALSE);

	/**
	 * Sets this group's location to the center point based on current location of its children.
	 */
	void CenterGroupLocation();
	
	/**
	 * @param	OutGroupActors	Array to fill with all actors for this group.
	 * @param	bRecurse		Flag to recurse and gather any actors in this group's subgroups.
	 */
	void GetGroupActors(TArray<AActor*>& OutGroupActors, UBOOL bRecurse=FALSE) const;

	/**
	 * @param	OutSubGroups	Array to fill with all subgroups for this group.
	 * @param	bRecurse	Flag to recurse and gather any subgroups in this group's subgroups.
	 */
	void GetSubGroups(TArray<AGroupActor*>& OutSubGroups, UBOOL bRecurse=FALSE) const;

	/**
	 * @param	OutChildren	Array to fill with all children for this group.
	 * @param	bRecurse	Flag to recurse and gather any children in this group's subgroups.
	 */
	void GetAllChildren(TArray<AActor*>& OutChildren, UBOOL bRecurse=FALSE) const;
};

class UInterpEdOptions : public UObject
{
public:
    //## BEGIN PROPS InterpEdOptions
    TArrayNoInit<FInterpEdSelKey> SelectedKeys;
    BITFIELD bAdjustingKeyframe:1;
    BITFIELD bAdjustingGroupKeyframes:1;
    SCRIPT_ALIGN;
    //## END PROPS InterpEdOptions

    DECLARE_CLASS(UInterpEdOptions,UObject,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(UInterpEdOptions)
};

class UInterpTrackHelper : public UObject
{
public:
    //## BEGIN PROPS InterpTrackHelper
    //## END PROPS InterpTrackHelper

    DECLARE_CLASS(UInterpTrackHelper,UObject,0,UnrealEd)
	/**
	 * @param  Track	The track to get the actor for.
	 * @return Returns the actor for the group's track if one exists, NULL otherwise.
	 */
	virtual AActor* GetGroupActor(const UInterpTrack* Track) const;

	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param Group The group that this track is being added to
	 * @param	Trackdef Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack Whether we are duplicating this track or creating a new one from scratch.
	 * @param bAllowPrompts When TRUE, we'll prompt for more information from the user with a dialog box if we need to
	 * @return Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( UInterpGroup* Group, const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack, UBOOL bAllowPrompts ) const { return true; }

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const { }

	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const { return true; }

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const { }
};

class UInterpTrackAnimControlHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackAnimControlHelper
    //## END PROPS InterpTrackAnimControlHelper

    DECLARE_CLASS(UInterpTrackAnimControlHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param Group The group that this track is being added to
	 * @param	Trackdef Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack Whether we are duplicating this track or creating a new one from scratch.
	 * @param bAllowPrompts When TRUE, we'll prompt for more information from the user with a dialog box if we need to
	 * @return Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( UInterpGroup* Group, const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack, UBOOL bAllowPrompts ) const;

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;


	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackBoolPropHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackBoolPropHelper
    //## END PROPS InterpTrackBoolPropHelper

    DECLARE_CLASS(UInterpTrackBoolPropHelper,UInterpTrackHelper,0,UnrealEd)
	/** 
	 * Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param   Group               The group that this track is being added to
	 * @param	Trackdef            Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack   Whether we are duplicating this track or creating a new one from scratch.
	 * @param   bAllowPrompts	    When TRUE, we'll prompt for more information from the user with a dialog box if we need to.
	 * 
	 * @return  TRUE if this track can be created; FALSE if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( UInterpGroup* Group, const UInterpTrack* TrackDef, UBOOL bDuplicatingTrack, UBOOL bAllowPrompts ) const;

	/**
	 * Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * 
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex		The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack* Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;
};

class UInterpTrackDirectorHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackDirectorHelper
    //## END PROPS InterpTrackDirectorHelper

    DECLARE_CLASS(UInterpTrackDirectorHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackEventHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackEventHelper
    //## END PROPS InterpTrackEventHelper

    DECLARE_CLASS(UInterpTrackEventHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackFaceFXHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackFaceFXHelper
    //## END PROPS InterpTrackFaceFXHelper

    DECLARE_CLASS(UInterpTrackFaceFXHelper,UInterpTrackHelper,0,UnrealEd)
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackFloatPropHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackFloatPropHelper
    //## END PROPS InterpTrackFloatPropHelper

    DECLARE_CLASS(UInterpTrackFloatPropHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param Group The group that this track is being added to
	 * @param	Trackdef Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack Whether we are duplicating this track or creating a new one from scratch.
	 * @param bAllowPrompts When TRUE, we'll prompt for more information from the user with a dialog box if we need to
	 * @return Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( UInterpGroup* Group, const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack, UBOOL bAllowPrompts ) const;

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;
};

class UInterpTrackHeadTrackingHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackHeadTrackingHelper
    //## END PROPS InterpTrackHeadTrackingHelper

    DECLARE_CLASS(UInterpTrackHeadTrackingHelper,UInterpTrackHelper,0,UnrealEd)
	/** 
	 * Checks track-dependent criteria prior to adding a new keyframe.
	 * Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	 * Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyTime	The time that this Key becomes active.
	 * @return			Returns true if this key can be created and false if some 
	 *					criteria is not met (i.e. No related item selected in browser).
	 */
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/**
	 * Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	 */
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackNotifyHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackNotifyHelper
    //## END PROPS InterpTrackNotifyHelper

    DECLARE_CLASS(UInterpTrackNotifyHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param Group The group that this track is being added to
	 * @param Trackdef Pointer to default object for this UInterpTrackClass.
	 * @param bDuplicatingTrack Whether we are duplicating this track or creating a new one from scratch.
	 * @param bAllowPrompts When TRUE, we'll prompt for more information from the user with a dialog box if we need to
	 * @return Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( UInterpGroup* Group, const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack, UBOOL bAllowPrompts ) const;

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;

	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track Pointer to the currently selected track.
	* @param KeyTime The time that this Key becomes active.
	* @return Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track Pointer to the currently selected track.
	* @param KeyIndex The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackParticleReplayHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackParticleReplayHelper
    //## END PROPS InterpTrackParticleReplayHelper

    DECLARE_CLASS(UInterpTrackParticleReplayHelper,UInterpTrackHelper,0,UnrealEd)
	/** 
	 * Checks track-dependent criteria prior to adding a new keyframe.
	 * Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	 * Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyTime	The time that this Key becomes active.
	 * @return			Returns true if this key can be created and false if some 
	 *					criteria is not met (i.e. No related item selected in browser).
	 */
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/**
	 * Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	 */
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackSoundHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackSoundHelper
    //## END PROPS InterpTrackSoundHelper

    DECLARE_CLASS(UInterpTrackSoundHelper,UInterpTrackHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new keyframe.
	* Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	* Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyTime	The time that this Key becomes active.
	* @return	Returns true if this key can be created and false if some criteria is not met (i.e. No related item selected in browser).
	*/
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/** Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	*
	* @param Track		Pointer to the currently selected track.
	* @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	*/
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackToggleHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackToggleHelper
    //## END PROPS InterpTrackToggleHelper

    DECLARE_CLASS(UInterpTrackToggleHelper,UInterpTrackHelper,0,UnrealEd)
	/** 
	 * Checks track-dependent criteria prior to adding a new keyframe.
	 * Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	 * Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyTime	The time that this Key becomes active.
	 * @return			Returns true if this key can be created and false if some 
	 *					criteria is not met (i.e. No related item selected in browser).
	 */
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/**
	 * Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	 */
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

class UInterpTrackVectorPropHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackVectorPropHelper
    //## END PROPS InterpTrackVectorPropHelper

    DECLARE_CLASS(UInterpTrackVectorPropHelper,UInterpTrackHelper,0,UnrealEd)
	/**
	 * Pops up a dialog letting user choose between a set of properties, then checks to see if that property has been bound to yet.
	 *
	 * @param PropNames		Possible property names to select from.
	 *
	 * @return TRUE if the property selected was acceptable, FALSE otherwise.
	 */
	virtual UBOOL ChooseProperty(TArray<FName> &PropNames) const;

	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param Group The group that this track is being added to
	 * @param	Trackdef Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack Whether we are duplicating this track or creating a new one from scratch.
	 * @param bAllowPrompts When TRUE, we'll prompt for more information from the user with a dialog box if we need to
	 * @return Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( UInterpGroup* Group, const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack, UBOOL bAllowPrompts ) const;

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;
};

class UInterpTrackColorPropHelper : public UInterpTrackVectorPropHelper
{
public:
    //## BEGIN PROPS InterpTrackColorPropHelper
    //## END PROPS InterpTrackColorPropHelper

    DECLARE_CLASS(UInterpTrackColorPropHelper,UInterpTrackVectorPropHelper,0,UnrealEd)
	/** Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
 	 *
	 * @param Group The group that this track is being added to
	 * @param	Trackdef Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack Whether we are duplicating this track or creating a new one from scratch.
	 * @param bAllowPrompts When TRUE, we'll prompt for more information from the user with a dialog box if we need to
	 * @return Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( UInterpGroup* Group, const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack, UBOOL bAllowPrompts ) const;

	/** Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;
};

class UInterpTrackLinearColorPropHelper : public UInterpTrackVectorPropHelper
{
public:
    //## BEGIN PROPS InterpTrackLinearColorPropHelper
    //## END PROPS InterpTrackLinearColorPropHelper

    DECLARE_CLASS(UInterpTrackLinearColorPropHelper,UInterpTrackVectorPropHelper,0,UnrealEd)
	/**
	 * Checks track-dependent criteria prior to adding a new track.
	 * Responsible for any message-boxes or dialogs for selecting track-specific parameters.
	 * Called on default object.
	 *
	 * @param Group The group that this track is being added to
	 * @param	Trackdef Pointer to default object for this UInterpTrackClass.
	 * @param	bDuplicatingTrack Whether we are duplicating this track or creating a new one from scratch.
	 * @param bAllowPrompts When TRUE, we'll prompt for more information from the user with a dialog box if we need to
	 * @return Returns true if this track can be created and false if some criteria is not met (i.e. A named property is already controlled for this group).
	 */
	virtual	UBOOL PreCreateTrack( UInterpGroup* Group, const UInterpTrack *TrackDef, UBOOL bDuplicatingTrack, UBOOL bAllowPrompts ) const;

	/**
	 * Uses the track-specific data object from PreCreateTrack to initialize the newly added Track.
	 *
	 * @param Track				Pointer to the track that was just created.
	 * @param bDuplicatingTrack	Whether we are duplicating this track or creating a new one from scratch.
	 * @param TrackIndex			The index of the Track that as just added.  This is the index returned by InterpTracks.AddItem.
	 */
	virtual void  PostCreateTrack( UInterpTrack *Track, UBOOL bDuplicatingTrack, INT TrackIndex ) const;
};

class UInterpTrackVisibilityHelper : public UInterpTrackHelper
{
public:
    //## BEGIN PROPS InterpTrackVisibilityHelper
    //## END PROPS InterpTrackVisibilityHelper

    DECLARE_CLASS(UInterpTrackVisibilityHelper,UInterpTrackHelper,0,UnrealEd)
	/** 
	 * Checks track-dependent criteria prior to adding a new keyframe.
	 * Responsible for any message-boxes or dialogs for selecting key-specific parameters.
	 * Optionally creates/references a key-specific data object to be used in PostCreateKeyframe.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyTime	The time that this Key becomes active.
	 * @return			Returns true if this key can be created and false if some 
	 *					criteria is not met (i.e. No related item selected in browser).
	 */
	virtual	UBOOL PreCreateKeyframe( UInterpTrack *Track, FLOAT KeyTime ) const;

	/**
	 * Uses the key-specific data object from PreCreateKeyframe to initialize the newly added key.
	 *
	 * @param Track		Pointer to the currently selected track.
	 * @param KeyIndex	The index of the keyframe that as just added.  This is the index returned by AddKeyframe.
	 */
	virtual void  PostCreateKeyframe( UInterpTrack *Track, INT KeyIndex ) const;
};

struct FKismetKeyBind
{
    FName Key;
    BITFIELD bControl:1;
    BITFIELD bShift:1;
    FName SeqObjClassName;

    /** Constructors */
    FKismetKeyBind() {}
    FKismetKeyBind(EEventParm)
    {
        appMemzero(this, sizeof(FKismetKeyBind));
    }
};

struct FKismetCommentPreset
{
    FName PresetName;
    INT BorderWidth;
    FColor BorderColor;
    BITFIELD bFilled:1;
    SCRIPT_ALIGN;
    FColor FillColor;

    /** Constructors */
    FKismetCommentPreset() {}
    FKismetCommentPreset(EEventParm)
    {
        appMemzero(this, sizeof(FKismetCommentPreset));
    }
};

class UKismetBindings : public UObject
{
public:
    //## BEGIN PROPS KismetBindings
    TArrayNoInit<struct FKismetKeyBind> Bindings;
#if WITH_EDITORONLY_DATA
    TArrayNoInit<struct FKismetCommentPreset> CommentPresets;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS KismetBindings

    DECLARE_CLASS(UKismetBindings,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

    NO_DEFAULT_CONSTRUCTOR(UKismetBindings)
};

class ULensFlareEditorOptions : public UObject
{
public:
    //## BEGIN PROPS LensFlareEditorOptions
    FLinearColor LFED_BackgroundColor;
    FLinearColor LFED_Empty_Background;
    FLinearColor LFED_Source_ElementEd_Background;
    FLinearColor LFED_Source_Unselected;
    FLinearColor LFED_Source_Selected;
    FLinearColor LFED_ElementEd_Background;
    FLinearColor LFED_Element_Unselected;
    FLinearColor LFED_Element_Selected;
    BITFIELD bShowGrid:1;
    SCRIPT_ALIGN;
    FColor GridColor_Hi;
    FColor GridColor_Low;
    FLOAT GridPerspectiveSize;
    FStringNoInit PostProcessChainName;
    INT ShowPPFlags;
    //## END PROPS LensFlareEditorOptions

    DECLARE_CLASS(ULensFlareEditorOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

    NO_DEFAULT_CONSTRUCTOR(ULensFlareEditorOptions)
};

class ULensFlareEditorPropertyWrapper : public UObject
{
public:
    //## BEGIN PROPS LensFlareEditorPropertyWrapper
    struct FLensFlareElement Element;
    class ULensFlare* SourceLensFlare;
    INT ElementIndex;
    //## END PROPS LensFlareEditorPropertyWrapper

    DECLARE_CLASS(ULensFlareEditorPropertyWrapper,UObject,0,UnrealEd)
	// UObject interface.
	virtual void PreEditChange(UProperty* PropertyAboutToChange);
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);
};

class ULensFlarePreviewComponent : public UPrimitiveComponent
{
public:
    //## BEGIN PROPS LensFlarePreviewComponent
    class WxLensFlareEditor* LensFlareEditorPtr;
    //## END PROPS LensFlarePreviewComponent

    DECLARE_CLASS(ULensFlarePreviewComponent,UPrimitiveComponent,0,UnrealEd)
	virtual void Render(const FSceneView* View,FPrimitiveDrawInterface* PDI);
};

class ULightingChannelsObject : public UObject
{
public:
    //## BEGIN PROPS LightingChannelsObject
    FLightingChannelContainer LightingChannels;
    //## END PROPS LightingChannelsObject

    DECLARE_CLASS(ULightingChannelsObject,UObject,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(ULightingChannelsObject)
};

class ULightmassOptionsObject : public UObject
{
public:
    //## BEGIN PROPS LightmassOptionsObject
    struct FLightmassDebugOptions DebugSettings;
    struct FSwarmDebugOptions SwarmSettings;
    //## END PROPS LightmassOptionsObject

    DECLARE_CLASS(ULightmassOptionsObject,UObject,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(ULightmassOptionsObject)
};

struct FEditorParameterGroup
{
    FName GroupName;
    TArrayNoInit<class UDEditorParameterValue*> Parameters;

    /** Constructors */
    FEditorParameterGroup() {}
    FEditorParameterGroup(EEventParm)
    {
        appMemzero(this, sizeof(FEditorParameterGroup));
    }
};

struct FEditorParameterValue
{
    BITFIELD bOverride:1;
    FName ParameterName;
    FGuid ExpressionId;

    /** Constructors */
    FEditorParameterValue() {}
    FEditorParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FEditorParameterValue));
    }
};

struct FEditorVectorParameterValue : public FEditorParameterValue
{
    FLinearColor ParameterValue;

    /** Constructors */
    FEditorVectorParameterValue() {}
    FEditorVectorParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FEditorVectorParameterValue));
    }
};

struct FEditorScalarParameterValue : public FEditorParameterValue
{
    FLOAT ParameterValue;

    /** Constructors */
    FEditorScalarParameterValue() {}
    FEditorScalarParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FEditorScalarParameterValue));
    }
};

struct FEditorTextureParameterValue : public FEditorParameterValue
{
    class UTexture* ParameterValue;

    /** Constructors */
    FEditorTextureParameterValue() {}
    FEditorTextureParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FEditorTextureParameterValue));
    }
};

struct FEditorFontParameterValue : public FEditorParameterValue
{
    class UFont* FontValue;
    INT FontPage;

    /** Constructors */
    FEditorFontParameterValue() {}
    FEditorFontParameterValue(EEventParm)
    {
        appMemzero(this, sizeof(FEditorFontParameterValue));
    }
};

struct FEditorStaticSwitchParameterValue : public FEditorParameterValue
{
    BITFIELD ParameterValue:1;
    SCRIPT_ALIGN;

	/** Constructor */
	FEditorStaticSwitchParameterValue(const FStaticSwitchParameter& InParameter) : ParameterValue(InParameter.Value)
	{
		//initialize base class members
		bOverride = InParameter.bOverride;
		ParameterName = InParameter.ParameterName;
		ExpressionId = InParameter.ExpressionGUID;
	}

};

struct FComponentMaskParameter
{
    BITFIELD R:1;
    BITFIELD G:1;
    BITFIELD B:1;
    BITFIELD A:1;
    SCRIPT_ALIGN;

	/** Constructor */
	FComponentMaskParameter(UBOOL InR, UBOOL InG, UBOOL InB, UBOOL InA) :
		R(InR),
		G(InG),
		B(InB),
		A(InA)
	{
	}

};

struct FEditorStaticComponentMaskParameterValue : public FEditorParameterValue
{
    struct FComponentMaskParameter ParameterValue;

	/** Constructor */
	FEditorStaticComponentMaskParameterValue(const FStaticComponentMaskParameter& InParameter) : ParameterValue(InParameter.R, InParameter.G, InParameter.B, InParameter.A)
	{
		//initialize base class members
		bOverride = InParameter.bOverride;
		ParameterName = InParameter.ParameterName;
		ExpressionId = InParameter.ExpressionGUID;
	}

};

class UMaterialEditorInstanceConstant : public UObject
{
public:
    //## BEGIN PROPS MaterialEditorInstanceConstant
    class UPhysicalMaterial* PhysMaterial;
    struct FPhysicalMaterialMaskSettings PhysicalMaterialMask;
    class UMaterialInterface* Parent;
    TArrayNoInit<struct FEditorParameterGroup> ParameterGroups;
    TArrayNoInit<struct FEditorParameterGroup> MobileParameterGroups;
    class UMaterialInstanceConstant* SourceInstance;
    TArrayNoInit<FGuid> VisibleExpressions;
    class UTexture* FlattenedTexture_DEPRECATED;
    class UTexture* MobileBaseTexture_DEPRECATED;
    class UTexture* MobileEmissiveTexture_DEPRECATED;
    class UTexture* MobileDetailTexture_DEPRECATED;
    class UTexture* MobileEnvironmentTexture_DEPRECATED;
    class UTexture* MobileNormalTexture_DEPRECATED;
    class UTexture* MobileMaskTexture_DEPRECATED;
    struct FLightmassParameterizedMaterialSettings LightmassSettings;
    BITFIELD bUseOldStyleMICEditorGroups:1;
    SCRIPT_ALIGN;
    //## END PROPS MaterialEditorInstanceConstant

    DECLARE_CLASS(UMaterialEditorInstanceConstant,UObject,0,UnrealEd)
	/**Fix up for deprecated properties*/
	virtual void PostLoad();

	// UObject interface.
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** Regenerates the parameter arrays. */
	void RegenerateArrays();

	/** Copies the parameter array values back to the source instance. */
	void CopyToSourceInstance();

	/** Copies static parameters to the source instance, which will be marked dirty if a compile was necessary */
	void CopyStaticParametersToSourceInstance();

	/** 
	 * Sets the source instance for this object and regenerates arrays. 
	 *
	 * @param MaterialInterface		Instance to use as the source for this material editor instance.
	 */
	void SetSourceInstance(UMaterialInstanceConstant* MaterialInterface);

	/** 
	 *  Returns group for parameter. Creates one if needed. 
	 *
	 * @param	InParameterGroupName	Name to be looked for.
	 * @param	InParameterGroups		The array of groups to look in
	 */
	FEditorParameterGroup& GetParameterGroup(FName& InParameterGroupName, TArrayNoInit<struct FEditorParameterGroup>& InParameterGroups);

	/** 
	 *  Creates/adds value to group retrieved from parent material . 
	 *
	 * @param ParentMaterial		Name of material to search for groups.
	 * @param ParameterValue		Current data to be grouped
	 */
	void AssignParameterToGroup(UMaterial* ParentMaterial, UDEditorParameterValue * ParameterValue);

	/** Regenerates the mobile parameter arrays. */
	void RegenerateMobileArrays();

	/** 
	 *	Generate the mobile parameter entries for the given group.
	 *
	 *	@param	InGroupName		The group to generate
	 */
	UBOOL GenerateMobileParameterEntries(FName& InGroupName);

	/** Copies the mobile parameter array values back to the source instance. */
	void CopyMobileParametersToSourceInstance();
};

struct FEditorParameterValueOverTime
{
    FGuid ExpressionId;
    BITFIELD bOverride:1;
    FName ParameterName;
    BITFIELD bLoop:1;
    BITFIELD bAutoActivate:1;
    FLOAT CycleTime;
    BITFIELD bNormalizeTime:1;
    FLOAT OffsetTime;
    BITFIELD bOffsetFromEnd:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FEditorParameterValueOverTime() {}
    FEditorParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FEditorParameterValueOverTime));
    }
};

struct FEditorVectorParameterValueOverTime : public FEditorParameterValueOverTime
{
    FLinearColor ParameterValue;
    FInterpCurveVector ParameterValueCurve;

    /** Constructors */
    FEditorVectorParameterValueOverTime() {}
    FEditorVectorParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FEditorVectorParameterValueOverTime));
    }
};

struct FEditorLinearColorParameterValueOverTime : public FEditorParameterValueOverTime
{
    FLinearColor ParameterValue;
    FInterpCurveLinearColor ParameterValueCurve;

    /** Constructors */
    FEditorLinearColorParameterValueOverTime() {}
    FEditorLinearColorParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FEditorLinearColorParameterValueOverTime));
    }
};

struct FEditorScalarParameterValueOverTime : public FEditorParameterValueOverTime
{
    FLOAT ParameterValue;
    FInterpCurveFloat ParameterValueCurve;

    /** Constructors */
    FEditorScalarParameterValueOverTime() {}
    FEditorScalarParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FEditorScalarParameterValueOverTime));
    }
};

struct FEditorTextureParameterValueOverTime : public FEditorParameterValueOverTime
{
    class UTexture* ParameterValue;

    /** Constructors */
    FEditorTextureParameterValueOverTime() {}
    FEditorTextureParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FEditorTextureParameterValueOverTime));
    }
};

struct FEditorFontParameterValueOverTime : public FEditorParameterValueOverTime
{
    class UFont* FontValue;
    INT FontPage;

    /** Constructors */
    FEditorFontParameterValueOverTime() {}
    FEditorFontParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FEditorFontParameterValueOverTime));
    }
};

struct FEditorStaticSwitchParameterValueOverTime : public FEditorParameterValueOverTime
{
    BITFIELD ParameterValue:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FEditorStaticSwitchParameterValueOverTime() {}
    FEditorStaticSwitchParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FEditorStaticSwitchParameterValueOverTime));
    }
};

struct FComponentMaskParameterOverTime
{
    BITFIELD R:1;
    BITFIELD G:1;
    BITFIELD B:1;
    BITFIELD A:1;
    SCRIPT_ALIGN;

    /** Constructors */
    FComponentMaskParameterOverTime() {}
    FComponentMaskParameterOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FComponentMaskParameterOverTime));
    }
};

struct FEditorStaticComponentMaskParameterValueOverTime : public FEditorParameterValueOverTime
{
    struct FComponentMaskParameterOverTime ParameterValue;

    /** Constructors */
    FEditorStaticComponentMaskParameterValueOverTime() {}
    FEditorStaticComponentMaskParameterValueOverTime(EEventParm)
    {
        appMemzero(this, sizeof(FEditorStaticComponentMaskParameterValueOverTime));
    }
};

class UMaterialEditorInstanceTimeVarying : public UObject
{
public:
    //## BEGIN PROPS MaterialEditorInstanceTimeVarying
    class UPhysicalMaterial* PhysMaterial;
    struct FPhysicalMaterialMaskSettings PhysicalMaterialMask;
    class UMaterialInterface* Parent;
    BITFIELD bAutoActivateAll:1;
    TArrayNoInit<struct FEditorLinearColorParameterValueOverTime> LinearColorParameterValues;
    TArrayNoInit<struct FEditorVectorParameterValueOverTime> VectorParameterValues;
    TArrayNoInit<struct FEditorScalarParameterValueOverTime> ScalarParameterValues;
    TArrayNoInit<struct FEditorTextureParameterValueOverTime> TextureParameterValues;
    TArrayNoInit<struct FEditorFontParameterValueOverTime> FontParameterValues;
    TArrayNoInit<struct FEditorStaticSwitchParameterValueOverTime> StaticSwitchParameterValues;
    TArrayNoInit<struct FEditorStaticComponentMaskParameterValueOverTime> StaticComponentMaskParameterValues;
    class UMaterialInstanceTimeVarying* SourceInstance;
    TArrayNoInit<FGuid> VisibleExpressions;
    struct FLightmassParameterizedMaterialSettings LightmassSettings;
    //## END PROPS MaterialEditorInstanceTimeVarying

    DECLARE_CLASS(UMaterialEditorInstanceTimeVarying,UObject,0,UnrealEd)
	// UObject interface.
	virtual void PostEditChangeProperty(FPropertyChangedEvent& PropertyChangedEvent);

	/** Regenerates the parameter arrays. */
	void RegenerateArrays();

	/** Copies the parameter array values back to the source instance. */
	void CopyToSourceInstance();

	/** Copies static parameters to the source instance, which will be marked dirty if a compile was necessary */
	void CopyStaticParametersToSourceInstance();

	/** 
	 * Sets the source instance for this object and regenerates arrays. 
	 *
	 * @param MaterialInterface		Instance to use as the source for this material editor instance.
	 */
	void SetSourceInstance(UMaterialInstanceTimeVarying* MaterialInterface);
};

class UMaterialEditorMeshComponent : public UStaticMeshComponent
{
public:
    //## BEGIN PROPS MaterialEditorMeshComponent
    FPointer MaterialEditor;
    //## END PROPS MaterialEditorMeshComponent

    DECLARE_CLASS(UMaterialEditorMeshComponent,UStaticMeshComponent,0,UnrealEd)
protected:
	// ActorComponent interface.
	virtual void Attach();
	virtual void Detach( UBOOL bWillReattach = FALSE );
};

class UMaterialEditorOptions : public UObject
{
public:
    //## BEGIN PROPS MaterialEditorOptions
    BITFIELD bShowGrid:1;
    BITFIELD bShowBackground:1;
    BITFIELD bHideUnusedConnectors:1;
    BITFIELD bDrawCurves_DEPRECATED:1;
    BITFIELD bRealtimeMaterialViewport:1;
    BITFIELD bRealtimeExpressionViewport:1;
    BITFIELD bAlwaysRefreshAllPreviews:1;
    BITFIELD bUseSortedMenus_DEPRECATED:1;
    BITFIELD bUseUnsortedMenus:1;
    TArrayNoInit<FString> FavoriteExpressions;
    //## END PROPS MaterialEditorOptions

    DECLARE_CLASS(UMaterialEditorOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

    NO_DEFAULT_CONSTRUCTOR(UMaterialEditorOptions)
};

class UMaterialEditorSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS MaterialEditorSkeletalMeshComponent
    FPointer MaterialEditor;
    //## END PROPS MaterialEditorSkeletalMeshComponent

    DECLARE_CLASS(UMaterialEditorSkeletalMeshComponent,USkeletalMeshComponent,0|CLASS_Config,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UMaterialEditorSkeletalMeshComponent)
};

class UPhATSimOptions : public UObject
{
public:
    //## BEGIN PROPS PhATSimOptions
    class UAnimSet* PreviewAnimSet;
    FLOAT PhysicsBlend;
    BITFIELD bBlendOnPoke:1;
    BITFIELD bDrawContacts:1;
    BITFIELD bPromptOnBoneDelete:1;
    BITFIELD bShowConstraintsAsPoints:1;
    BITFIELD bShowNamesInHierarchy:1;
    FLOAT PokePauseTime;
    FLOAT PokeBlendTime;
    FLOAT AngularSpringScale;
    FLOAT AngularDampingScale;
    FLOAT SimSpeed;
    FLOAT FloorGap;
    FLOAT GravScale;
    FLOAT HandleLinearDamping;
    FLOAT HandleLinearStiffness;
    FLOAT HandleAngularDamping;
    FLOAT HandleAngularStiffness;
    FLOAT PokeStrength;
    FLOAT SkyBrightness;
    FLOAT Brightness;
    FLOAT AngularSnap;
    FLOAT LinearSnap;
    FLOAT ConstraintDrawSize;
    //## END PROPS PhATSimOptions

    DECLARE_CLASS(UPhATSimOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

    NO_DEFAULT_CONSTRUCTOR(UPhATSimOptions)
};

class UPhATSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
    //## BEGIN PROPS PhATSkeletalMeshComponent
    FPointer PhATPtr;
    TArrayNoInit<FBoneAtom> AnimationSpaceBases;
    //## END PROPS PhATSkeletalMeshComponent

    DECLARE_CLASS(UPhATSkeletalMeshComponent,USkeletalMeshComponent,0|CLASS_Config,UnrealEd)
	// UPrimitiveComponent interface.
	virtual void Render(const FSceneView* View, class FPrimitiveDrawInterface* PDI);
	virtual void RenderHitTest(const FSceneView* View,class FPrimitiveDrawInterface* PDI);

	/**
	 * Creates a proxy to represent the primitive to the scene manager in the rendering thread.
	 * @return The proxy object.
	 */
	virtual FPrimitiveSceneProxy* CreateSceneProxy();

	// PhATSkeletalMeshComponent interface
	void RenderAssetTools(const FSceneView* View, class FPrimitiveDrawInterface* PDI, UBOOL bHitTest);
	void DrawHierarchy(FPrimitiveDrawInterface* PDI, UBOOL bAnimSkel);
};

class UPreviewMaterial : public UMaterial
{
public:
    //## BEGIN PROPS PreviewMaterial
    //## END PROPS PreviewMaterial

    DECLARE_CLASS(UPreviewMaterial,UMaterial,0,UnrealEd)
	/**
	 * Allocates a material resource off the heap to be stored in MaterialResource.
	 */
	virtual FMaterialResource* AllocateResource();
};

class USequenceObjectHelper : public UObject
{
public:
    //## BEGIN PROPS SequenceObjectHelper
    //## END PROPS SequenceObjectHelper

    DECLARE_CLASS(USequenceObjectHelper,UObject,0,UnrealEd)
	/**
	 * Called when the user double clicks on a sequence object, can be used to display object specific
	 * property dialogs.
	 *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 * @param InObject	Pointer to the object that was clicked on.
	 */
	virtual void  OnDoubleClick( const class WxKismet* InEditor, USequenceObject* InObject ) const { }

	/**
	 * Called when the user right clicks on a sequence object, should show a object specific context menu.
	 *
	 * @param InEditor	Pointer to the editor that initiated the callback.
	 */
	virtual void  ShowContextMenu( class WxKismet* InEditor ) const { }

	/**
	 * Called when the Kismet editor wants the object to add itself to a tree control.
	 *
	 * @param InEditor		Pointer to the editor that initiated the callback.
	 * @param InTreeCtrl	Pointer to the tree control we will be adding an item to.
	 * @param ParentItem	The parent of the item that will be added.
	 * @return				The tree item we created.
	 */
	virtual wxTreeItemId AddToTreeControl(  class WxKismet* InEditor, class wxTreeCtrl* InTreeCtrl, class wxTreeItemId& ParentItem ) const 
	{
		return wxTreeItemId();
	}
};

class USoundNodeHelper : public UObject
{
public:
    //## BEGIN PROPS SoundNodeHelper
    //## END PROPS SoundNodeHelper

    DECLARE_CLASS(USoundNodeHelper,UObject,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(USoundNodeHelper)
};

class UStaticMeshMode_Options : public UObject
{
public:
    //## BEGIN PROPS StaticMeshMode_Options
    BYTE CollisionType;
    SCRIPT_ALIGN;
    FRotator PreRotation;
    FRotator RotationMin;
    FRotator RotationMax;
    FVector Scale3DMin;
    FVector Scale3DMax;
    FLOAT ScaleMin;
    FLOAT ScaleMax;
    //## END PROPS StaticMeshMode_Options

    DECLARE_CLASS(UStaticMeshMode_Options,UObject,0,UnrealEd)
    NO_DEFAULT_CONSTRUCTOR(UStaticMeshMode_Options)
};

class UTagSuboptimalTexturesCommandlet : public UCommandlet
{
public:
    //## BEGIN PROPS TagSuboptimalTexturesCommandlet
    TArrayNoInit<BYTE> TextureGroupsToExamine;
    //## END PROPS TagSuboptimalTexturesCommandlet

    DECLARE_CLASS(UTagSuboptimalTexturesCommandlet,UCommandlet,0|CLASS_Transient|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Find textures that don't match their MaxLODSize and add them to a shared collection
	 *
	 * @param Params - the command line arguments used to run the commandlet. A map list is the only expected argument at this time
	 *
	 * @return 0 - unused
	 */
	INT Main(const FString& Params);
};

class UTemplateMapMetadata : public UObject
{
public:
    //## BEGIN PROPS TemplateMapMetadata
#if WITH_EDITORONLY_DATA
    class UTexture2D* Thumbnail;
#endif // WITH_EDITORONLY_DATA
    //## END PROPS TemplateMapMetadata

    DECLARE_CLASS(UTemplateMapMetadata,UObject,0,UnrealEd)
	/**
	 * Create a list of all current template map metadata objects.
	 * Current method for this is to add all needed metadata into packages
	 * that are always loaded in the editor so we can just iterate over all 
	 * UTemplateMapMetadata in memory.
	 *
	 * @param	Templates - list to which all metadata objects are added.
	 *			This should be empty when passed to this method.
	 */
	static void GenerateTemplateMetadataList(TArray<UTemplateMapMetadata*>& Templates);
};

class UTerrainEditOptions : public UObject
{
public:
    //## BEGIN PROPS TerrainEditOptions
    INT Solid1_Strength;
    INT Solid1_Radius;
    INT Solid1_Falloff;
    INT Solid2_Strength;
    INT Solid2_Radius;
    INT Solid2_Falloff;
    INT Solid3_Strength;
    INT Solid3_Radius;
    INT Solid3_Falloff;
    INT Solid4_Strength;
    INT Solid4_Radius;
    INT Solid4_Falloff;
    INT Solid5_Strength;
    INT Solid5_Radius;
    INT Solid5_Falloff;
    INT Noisy1_Strength;
    INT Noisy1_Radius;
    INT Noisy1_Falloff;
    INT Noisy2_Strength;
    INT Noisy2_Radius;
    INT Noisy2_Falloff;
    INT Noisy3_Strength;
    INT Noisy3_Radius;
    INT Noisy3_Falloff;
    INT Noisy4_Strength;
    INT Noisy4_Radius;
    INT Noisy4_Falloff;
    INT Noisy5_Strength;
    INT Noisy5_Radius;
    INT Noisy5_Falloff;
    INT Current_Tool;
    INT Current_Brush;
    INT Current_Strength;
    INT Current_Radius;
    INT Current_Falloff;
    BITFIELD bSoftSelectEnabled:1;
    BITFIELD bConstrainedEditing:1;
    BITFIELD bShowDecoarationMeshes:1;
    INT Current_MirrorFlag;
    INT SliderRange_Low_Strength;
    INT SliderRange_High_Strength;
    INT SliderRange_Low_Radius;
    INT SliderRange_High_Radius;
    INT SliderRange_Low_Falloff;
    INT SliderRange_High_Falloff;
    FColor TerrainLayerBrowser_BackgroundColor;
    FColor TerrainLayerBrowser_BackgroundColor2;
    FColor TerrainLayerBrowser_BackgroundColor3;
    FColor TerrainLayerBrowser_SelectedColor;
    FColor TerrainLayerBrowser_SelectedColor2;
    FColor TerrainLayerBrowser_SelectedColor3;
    FColor TerrainLayerBrowser_BorderColor;
    //## END PROPS TerrainEditOptions

    DECLARE_CLASS(UTerrainEditOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorUserSettings");}

    NO_DEFAULT_CONSTRUCTOR(UTerrainEditOptions)
};

class UThumbnailLabelRenderer : public UObject
{
public:
    //## BEGIN PROPS ThumbnailLabelRenderer
    //## END PROPS ThumbnailLabelRenderer

    DECLARE_ABSTRACT_CLASS(UThumbnailLabelRenderer,UObject,0,UnrealEd)
public:

	/** Thumbnail options */
	struct ThumbnailOptions
	{
		// Add options here!
		
		/** Constructor */
		ThumbnailOptions()
		{
		}
	};

protected:
	/**
	 * Calculates the size the thumbnail labels will be for the specified font.
	 * Note: that this is a common method for handling lists of strings. The
	 * child class is resposible for building this list of strings.
	 *
	 * @param Labels the list of strings to write out as the labels
	 * @param Font the font object to render with
	 * @param RI the render interface to use for getting the size
	 * @param OutWidth the var that gets the width of the labels
	 * @param OutHeight the var that gets the height
	 */
	void GetSizeFromLabels(const TArray<FString>& Labels,UFont* Font,
		FCanvas* Canvas,DWORD& OutWidth,
		DWORD& OutHeight);

	/**
	 * Renders the thumbnail labels for the specified object with the specified
	 * font and text color
	 * Note: that this is a common method for handling lists of strings. The
	 * child class is resposible for building this list of strings.
	 *
	 * @param Labels the list of strings to write out as the labels
	 * @param Font the font to draw with
	 * @param X the X location to start drawing at
	 * @param Y the Y location to start drawing at
	 * @param RI the render interface to draw with
	 * @param TextColor the color to draw the text with
	 */
	void DrawLabels(const TArray<FString>& Labels,UFont* Font,INT X,INT Y,
		FCanvas* Canvas,const FColor& TextColor);

public:
	/**
	 * Subclasses should implement this function to add to the list of labels
	 * for a given object.
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	virtual void BuildLabelList(UObject*, const ThumbnailOptions&, TArray<FString>&) PURE_VIRTUAL(UThumbnailLabelRenderer::BuildLabelList,);

	/**
	 * Calculates the size the thumbnail labels will be for the specified font
	 *
	 * @param Object the object the thumbnail is of
	 * @param Font the font object to render with
	 * @param RI the render interface to use for getting the size
	 * @param OutWidth the var that gets the width of the labels
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailLabelSize(UObject* Object,UFont* Font,
		FCanvas* Canvas, const ThumbnailOptions& InOptions, DWORD& OutWidth,
		DWORD& OutHeight);

	/**
	 * Renders the thumbnail labels for the specified object with the specified
	 * font and text color
	 *
	 * @param Object the object to render labels for
	 * @param Font the font to draw with
	 * @param X the X location to start drawing at
	 * @param Y the Y location to start drawing at
	 * @param RI the render interface to draw with
	 * @param TextColor the color to draw the text with
	 */
	virtual void DrawThumbnailLabels(UObject* Object,UFont* Font,INT X,INT Y,
		FCanvas* Canvas, const ThumbnailOptions& InOptions,
		const FColor& TextColor = FColor(255,255,255,255));
};

class UAnimSetLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS AnimSetLabelRenderer
    //## END PROPS AnimSetLabelRenderer

    DECLARE_CLASS(UAnimSetLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and anim set
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UAnimTreeLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS AnimTreeLabelRenderer
    //## END PROPS AnimTreeLabelRenderer

    DECLARE_CLASS(UAnimTreeLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the anim tree
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UApexClothingAssetLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS ApexClothingAssetLabelRenderer
    //## END PROPS ApexClothingAssetLabelRenderer

    DECLARE_CLASS(UApexClothingAssetLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about meshes, assets & chunks
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UApexDestructibleAssetLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS ApexDestructibleAssetLabelRenderer
    //## END PROPS ApexDestructibleAssetLabelRenderer

    DECLARE_CLASS(UApexDestructibleAssetLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about meshes, assets & chunks
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UApexGenericAssetLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS ApexGenericAssetLabelRenderer
    //## END PROPS ApexGenericAssetLabelRenderer

    DECLARE_CLASS(UApexGenericAssetLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about meshes, assets & chunks
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UFontThumbnailLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS FontThumbnailLabelRenderer
    //## END PROPS FontThumbnailLabelRenderer

    DECLARE_CLASS(UFontThumbnailLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and font import info
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UGenericThumbnailLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS GenericThumbnailLabelRenderer
    //## END PROPS GenericThumbnailLabelRenderer

    DECLARE_CLASS(UGenericThumbnailLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and the friendly class name
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels)
	{
		new(OutLabels)FString(Object->GetName());
		new(OutLabels)FString(Object->GetDesc());
	}
};

class ULandscapeLayerLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS LandscapeLayerLabelRenderer
    //## END PROPS LandscapeLayerLabelRenderer

    DECLARE_CLASS(ULandscapeLayerLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the material function.
	 *
	 * @param Object		The object to build the labels for.
	 * @param OutLabels		The array that is added to.
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UMaterialFunctionLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS MaterialFunctionLabelRenderer
    //## END PROPS MaterialFunctionLabelRenderer

    DECLARE_CLASS(UMaterialFunctionLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the material function.
	 *
	 * @param Object		The object to build the labels for.
	 * @param OutLabels		The array that is added to.
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UMaterialInstanceLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS MaterialInstanceLabelRenderer
    //## END PROPS MaterialInstanceLabelRenderer

    DECLARE_CLASS(UMaterialInstanceLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the material.
	 *
	 * @param Object		The object to build the labels for.
	 * @param OutLabels		The array that is added to.
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UMemCountThumbnailLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS MemCountThumbnailLabelRenderer
    class UThumbnailLabelRenderer* AggregatedLabelRenderer;
    //## END PROPS MemCountThumbnailLabelRenderer

    DECLARE_CLASS(UMemCountThumbnailLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and the amount of memory used to the array
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);

public:
	/**
	 * Calculates the size the thumbnail labels will be for the specified font.
	 * Doesn't serialize the object so that it's faster
	 *
	 * @param Object the object the thumbnail is of
	 * @param Font the font object to render with
	 * @param RI the render interface to use for getting the size
	 * @param OutWidth the var that gets the width of the labels
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailLabelSize(UObject* Object,UFont* Font,
		FCanvas* Canvas, const ThumbnailOptions& InOptions, DWORD& OutWidth,
		DWORD& OutHeight);
};

class UParticleSystemLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS ParticleSystemLabelRenderer
    //## END PROPS ParticleSystemLabelRenderer

    DECLARE_CLASS(UParticleSystemLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and other information
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);

};

class UPhysicsAssetLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS PhysicsAssetLabelRenderer
    //## END PROPS PhysicsAssetLabelRenderer

    DECLARE_CLASS(UPhysicsAssetLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about bodies & constraints
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UPostProcessLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS PostProcessLabelRenderer
    //## END PROPS PostProcessLabelRenderer

    DECLARE_CLASS(UPostProcessLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and anim set
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class USkeletalMeshLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS SkeletalMeshLabelRenderer
    //## END PROPS SkeletalMeshLabelRenderer

    DECLARE_CLASS(USkeletalMeshLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the mesh
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class USoundLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS SoundLabelRenderer
    //## END PROPS SoundLabelRenderer

    DECLARE_CLASS(USoundLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the sound/cue
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UStaticMeshLabelRenderer : public UThumbnailLabelRenderer
{
public:
    //## BEGIN PROPS StaticMeshLabelRenderer
    //## END PROPS StaticMeshLabelRenderer

    DECLARE_CLASS(UStaticMeshLabelRenderer,UThumbnailLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the mesh
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

class UFracturedStaticMeshLabelRenderer : public UStaticMeshLabelRenderer
{
public:
    //## BEGIN PROPS FracturedStaticMeshLabelRenderer
    //## END PROPS FracturedStaticMeshLabelRenderer

    DECLARE_CLASS(UFracturedStaticMeshLabelRenderer,UStaticMeshLabelRenderer,0,UnrealEd)
protected:
	/**
	 * Adds the name of the object and information about the mesh
	 *
	 * @param Object the object to build the labels for
	 * @param OutLabels the array that is added to
	 */
	void BuildLabelList(UObject* Object, const ThumbnailOptions& InOptions, TArray<FString>& OutLabels);
};

struct FThumbnailRenderingInfo
{
    FStringNoInit ClassNeedingThumbnailName;
    class UClass* ClassNeedingThumbnail;
    FStringNoInit RendererClassName;
    class UThumbnailRenderer* Renderer;
    FStringNoInit LabelRendererClassName;
    class UThumbnailLabelRenderer* LabelRenderer;
    FColor BorderColor;
    FStringNoInit IconName;

    /** Constructors */
    FThumbnailRenderingInfo() {}
    FThumbnailRenderingInfo(EEventParm)
    {
        appMemzero(this, sizeof(FThumbnailRenderingInfo));
    }
};

class UThumbnailManager : public UObject
{
public:
    //## BEGIN PROPS ThumbnailManager
    TArrayNoInit<struct FThumbnailRenderingInfo> RenderableThumbnailTypes;
    TArrayNoInit<struct FThumbnailRenderingInfo> ArchetypeRenderableThumbnailTypes;
    BITFIELD bIsInitialized:1;
    BITFIELD bMapNeedsUpdate:1;
    BITFIELD bPSysRealTime:1;
    SCRIPT_ALIGN;
private:
    FPointer RenderInfoMap;
    TMap<UClass *,FThumbnailRenderingInfo *>* ArchetypeRenderInfoMap;
public:
    struct FThumbnailRenderingInfo NotSupported;
    class UStaticMeshComponent* BackgroundComponent;
    class UStaticMeshComponent* SMPreviewComponent;
    class USkeletalMeshComponent* SKPreviewComponent;
    class UStaticMesh* TexPropCube;
    class UStaticMesh* TexPropSphere;
    class UStaticMesh* TexPropCylinder;
    class UStaticMesh* TexPropPlane;
    class UMaterial* ThumbnailBackground;
    class UMaterial* ThumbnailBackgroundSolid;
    class UMaterialInstanceConstant* ThumbnailBackgroundSolidMatInst;
    TArrayNoInit<class UMaterialInterface*> MeshMaterialArray;
    //## END PROPS ThumbnailManager

    DECLARE_CLASS(UThumbnailManager,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	typedef TMap<UClass*,FThumbnailRenderingInfo*> FClassToRenderInfoMap;

protected:
	/**
	 * Returns the pointer to the map as a reference. Creates it if one isn't
	 * already instanced.
	 */
	inline FClassToRenderInfoMap& GetRenderInfoMap(void)
	{
		if (RenderInfoMap == NULL)
		{
			RenderInfoMap = (void*)new FClassToRenderInfoMap();
		}
		return *(FClassToRenderInfoMap*)RenderInfoMap;
	}

	inline FClassToRenderInfoMap& GetArchetypeRenderInfoMap(void)
	{
		if ( ArchetypeRenderInfoMap == NULL )
		{
			ArchetypeRenderInfoMap = new FClassToRenderInfoMap();
		}
		return *ArchetypeRenderInfoMap;
	}

public:
	/**
	 * Returns the component to use for rendering a background. Creates one
	 * if needed.
	 */
	inline UStaticMeshComponent* GetBackgroundComponent(void)
	{
		if (BackgroundComponent == NULL)
		{
			BackgroundComponent = ConstructObject<UStaticMeshComponent>(UStaticMeshComponent::StaticClass());;
		}
		return BackgroundComponent;
	}

	/**
	 * Returns the component to use for rendering a static mesh. Creates one
	 * if needed.
	 */
	inline UStaticMeshComponent* GetStaticMeshPreviewComponent(void)
	{
		if (SMPreviewComponent == NULL)
		{
			SMPreviewComponent = ConstructObject<UStaticMeshComponent>(UStaticMeshComponent::StaticClass());;
		}
		// Reset the static-mesh's CastShadow flag to its default value.
		SMPreviewComponent->CastShadow = TRUE;
		return SMPreviewComponent;
	}

	/**
	 * Returns the component to use for rendering a skeletal mesh. Creates one
	 * if needed.
	 */
	inline USkeletalMeshComponent* GetSkeletalMeshPreviewComponent(void)
	{
		if (SKPreviewComponent == NULL)
		{
			SKPreviewComponent = ConstructObject<USkeletalMeshComponent>(USkeletalMeshComponent::StaticClass());;
		}
		return SKPreviewComponent;
	}

	/**
	 * Sets Material Array for meshes
	 */
	void SetMeshPreviewMaterial (TArray<UMaterialInterface*>& InMaterialArray)
	{
		MeshMaterialArray = InMaterialArray;
	}

	/**
	 * Gets Material Array for meshes
	 */
	TArrayNoInit <UMaterialInterface*>& GetStaticMeshMaterialArray(void)
	{
		return MeshMaterialArray;
	}

	/**
	 * Clears Material Array for meshes.  Should be called directly after 
	 */
	void ClearStaticMeshmaterialArray (void)
	{
		MeshMaterialArray.Empty();
	}

	/**
	 * Clears cached components.
	 */
	void ClearComponents(void);

	/**
	 * Cleans up any allocations that won't be GCed (UObject interface)
	 */
	void FinishDestroy(void);

	/**
	 * Serializes any object renferences and sets the map needs update flag
	 *
	 * @param Ar the archive to serialize to/from
	 */
	void Serialize(FArchive& Ar);

	/**
	 * Fixes up any classes that need to be loaded in the thumbnail types
	 */
	void Initialize(void);

	/**
	 * Returns the entry for the specified object
	 *
	 * @param Object the object to find thumbnail rendering info for
	 *
	 * @return A pointer to the rendering info if valid, otherwise NULL
	 */
	FThumbnailRenderingInfo* GetRenderingInfo(UObject* Object);

protected:
	/**
	 * Fixes up any classes that need to be loaded in the thumbnail types per-map type
	 */
	void InitializeRenderTypeArray( TArray<struct FThumbnailRenderingInfo>& ThumbnailRendererTypes, FClassToRenderInfoMap& ThumbnailMap );
};

class UThumbnailRenderer : public UObject
{
public:
    //## BEGIN PROPS ThumbnailRenderer
    //## END PROPS ThumbnailRenderer

    DECLARE_ABSTRACT_CLASS(UThumbnailRenderer,UObject,0,UnrealEd)
	/**
	 * Allows the thumbnail renderer object the chance to reject rendering a
	 * thumbnail for an object based upon the object's data. For instance, an
	 * archetype should only be rendered if it's flags have RF_ArchetypeObject.
	 *
	 * @param Object			the object to inspect
	 * @param bCheckObjectState	TRUE indicates that the object's state should be inspected to determine whether it can be supported;
	 *							FALSE indicates that only the object's type should be considered (for caching purposes)
	 *
	 * @return TRUE if it needs a thumbnail, FALSE otherwise
	 */
	virtual UBOOL SupportsThumbnailRendering(UObject*,UBOOL bCheckObjectState=TRUE)
	{
		return TRUE;
	}


	/** 
	 * Checks to see if the passed in object supports a thumbnail rendered directly into a system memory buffer for thumbnails
	 * instead of setting up a render target and rendering to a texture from the GPU. 
	 *
	 * @param InObject	The object to check
	 */
	virtual UBOOL SupportsCPUGeneratedThumbnail(UObject *InObject) const
	{
		return FALSE;
	}

	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType the primitive type to use for rendering
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType PrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight) PURE_VIRTUAL(UThumbnailRenderer::GetThumbnailSize,);

	/**
	 * Draws a thumbnail for the object that was specified.
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType the primitive to draw on (sphere, plane, etc.)
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport the viewport being drawn in
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType PrimType,
		INT X,INT Y,DWORD Width,DWORD Height,FRenderTarget* Viewport,
		FCanvas* Canvas,EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent) PURE_VIRTUAL(UThumbnailRenderer::Draw,);

	/**
	 * Draws the thumbnail directly to a CPU memory buffer
	 *
	 * @param InObject				The object to draw
	 * @param OutThumbnailBuffer	The thumbnail buffer to draw to
	 */
	virtual void DrawCPU( UObject* InObject, FObjectThumbnail& OutThumbnailBuffer) const
	{
		// Do nothing by default
	}

};

class UDefaultSizedThumbnailRenderer : public UThumbnailRenderer
{
public:
    //## BEGIN PROPS DefaultSizedThumbnailRenderer
    INT DefaultSizeX;
    INT DefaultSizeY;
    //## END PROPS DefaultSizedThumbnailRenderer

    DECLARE_ABSTRACT_CLASS(UDefaultSizedThumbnailRenderer,UThumbnailRenderer,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Calculates the size the thumbnail would be at the specified zoom level.
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);
};

class UApexDestructibleAssetThumbnailRenderer : public UDefaultSizedThumbnailRenderer
{
public:
    //## BEGIN PROPS ApexDestructibleAssetThumbnailRenderer
    //## END PROPS ApexDestructibleAssetThumbnailRenderer

    DECLARE_CLASS(UApexDestructibleAssetThumbnailRenderer,UDefaultSizedThumbnailRenderer,0|CLASS_Config,UnrealEd)
	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

class UMaterialInstanceThumbnailRenderer : public UDefaultSizedThumbnailRenderer
{
public:
    //## BEGIN PROPS MaterialInstanceThumbnailRenderer
    //## END PROPS MaterialInstanceThumbnailRenderer

    DECLARE_CLASS(UMaterialInstanceThumbnailRenderer,UDefaultSizedThumbnailRenderer,0|CLASS_Config,UnrealEd)
	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

class USkeletalMeshThumbnailRenderer : public UDefaultSizedThumbnailRenderer
{
public:
    //## BEGIN PROPS SkeletalMeshThumbnailRenderer
    //## END PROPS SkeletalMeshThumbnailRenderer

    DECLARE_CLASS(USkeletalMeshThumbnailRenderer,UDefaultSizedThumbnailRenderer,0|CLASS_Config,UnrealEd)
	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

class UStaticMeshThumbnailRenderer : public UDefaultSizedThumbnailRenderer
{
public:
    //## BEGIN PROPS StaticMeshThumbnailRenderer
    //## END PROPS StaticMeshThumbnailRenderer

    DECLARE_CLASS(UStaticMeshThumbnailRenderer,UDefaultSizedThumbnailRenderer,0|CLASS_Config,UnrealEd)
	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

class UIconThumbnailRenderer : public UThumbnailRenderer
{
public:
    //## BEGIN PROPS IconThumbnailRenderer
    FStringNoInit IconName;
    class UTexture2D* Icon;
    //## END PROPS IconThumbnailRenderer

    DECLARE_CLASS(UIconThumbnailRenderer,UThumbnailRenderer,0,UnrealEd)
protected:
	/**
	 * Returns the icon for this icon renderer instance. Loads it if it
	 * isn't already loaded
	 *
	 * @param A valid icon or the default texture if it couldn't be loaded
	 */
	inline UTexture2D* GetIcon(void)
	{
		// If this hasn't been loaded yet, load it
		if (Icon == NULL)
		{
			Icon = LoadObject<UTexture2D>(NULL,*IconName,NULL,LOAD_None,NULL);
			// Just in case the resource is bogus, check and return the default
			if (Icon == NULL)
			{
				Icon = GWorld->GetWorldInfo()->DefaultTexture;
			}
		}
		return Icon;
	}

public:
	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight)
	{
		OutWidth = appTrunc(Zoom * (FLOAT)GetIcon()->SizeX);
		OutHeight = appTrunc(Zoom * (FLOAT)GetIcon()->SizeY);
	}

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

class UArchetypeThumbnailRenderer : public UIconThumbnailRenderer
{
public:
    //## BEGIN PROPS ArchetypeThumbnailRenderer
    //## END PROPS ArchetypeThumbnailRenderer

    DECLARE_CLASS(UArchetypeThumbnailRenderer,UIconThumbnailRenderer,0,UnrealEd)
	/**
	 * Allows the thumbnail renderer object the chance to reject rendering a
	 * thumbnail for an object based upon the object's data. For instance, an
	 * archetype should only be rendered if it's flags have RF_ArchetypeObject.
	 *
	 * @param Object 			the object to inspect
	 * @param bCheckObjectState	TRUE indicates that the object's state should be inspected to determine whether it can be supported;
	 *							FALSE indicates that only the object's type should be considered (for caching purposes)
	 *
	 * @return TRUE if it needs a thumbnail, FALSE otherwise
	 */
	virtual UBOOL SupportsThumbnailRendering(UObject* Object,UBOOL bCheckObjectState=TRUE);
};

class UPrefabThumbnailRenderer : public UIconThumbnailRenderer
{
public:
    //## BEGIN PROPS PrefabThumbnailRenderer
    //## END PROPS PrefabThumbnailRenderer

    DECLARE_CLASS(UPrefabThumbnailRenderer,UIconThumbnailRenderer,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

class UTextureThumbnailRenderer : public UThumbnailRenderer
{
public:
    //## BEGIN PROPS TextureThumbnailRenderer
    //## END PROPS TextureThumbnailRenderer

    DECLARE_CLASS(UTextureThumbnailRenderer,UThumbnailRenderer,0,UnrealEd)

	/** 
	 * Checks to see if the passed in object supports a thumbnail rendered directly into a system memory buffer for thumbnails
	 * instead of setting up a render target and rendering to a texture from the GPU. 
	 *
	 * @param InObject	The object to check
	 */
	virtual UBOOL SupportsCPUGeneratedThumbnail(UObject *InObject) const;

	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);

	/**
	 * Draws the thumbnail directly to a CPU memory buffer
	 *
	 * @param InObject				The object to draw
	 * @param OutThumbnailBuffer	The thumbnail buffer to draw to
	 */
	virtual void DrawCPU( UObject* InObject, FObjectThumbnail& OutThumbnailBuffer) const;

private:
	/**
	 * Converts a 1 bit monochrome texture into a thumbnail for the content browser 
	 *
	 * @param MonochromeTexture	The texture to convert
	 * @param OutThumbnail	The thumbnail object where the thumbnail image data should be stored
	 */
	void MakeThumbnailFromMonochrome( UTexture2D* MonochromeTexture, FObjectThumbnail& OutThumbnail ) const;
};

class UFontThumbnailRenderer : public UTextureThumbnailRenderer
{
public:
    //## BEGIN PROPS FontThumbnailRenderer
    //## END PROPS FontThumbnailRenderer

    DECLARE_CLASS(UFontThumbnailRenderer,UTextureThumbnailRenderer,0,UnrealEd)
	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

class ULensFlareThumbnailRenderer : public UTextureThumbnailRenderer
{
public:
    //## BEGIN PROPS LensFlareThumbnailRenderer
    class UTexture2D* NoImage;
    class UTexture2D* OutOfDate;
    //## END PROPS LensFlareThumbnailRenderer

    DECLARE_CLASS(ULensFlareThumbnailRenderer,UTextureThumbnailRenderer,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

class UParticleSystemThumbnailRenderer : public UTextureThumbnailRenderer
{
public:
    //## BEGIN PROPS ParticleSystemThumbnailRenderer
    class UTexture2D* NoImage;
    class UTexture2D* OutOfDate;
    //## END PROPS ParticleSystemThumbnailRenderer

    DECLARE_CLASS(UParticleSystemThumbnailRenderer,UTextureThumbnailRenderer,0,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

	/**
	 * Calculates the size the thumbnail would be at the specified zoom level
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

class UTextureCubeThumbnailRenderer : public UTextureThumbnailRenderer
{
public:
    //## BEGIN PROPS TextureCubeThumbnailRenderer
    //## END PROPS TextureCubeThumbnailRenderer

    DECLARE_CLASS(UTextureCubeThumbnailRenderer,UTextureThumbnailRenderer,0,UnrealEd)
	/**
	 * Calculates the size the thumbnail would be at the specified zoom level.
	 * Grabs the texture from the first face of the cube map
	 *
	 * @param Object the object the thumbnail is of
	 * @param PrimType ignored
	 * @param Zoom the current multiplier of size
	 * @param OutWidth the var that gets the width of the thumbnail
	 * @param OutHeight the var that gets the height
	 */
	virtual void GetThumbnailSize(UObject* Object,EThumbnailPrimType,
		FLOAT Zoom,DWORD& OutWidth,DWORD& OutHeight);

	/**
	 * Draws a thumbnail for the object that was specified
	 * Grabs the texture from the first face of the cube map
	 *
	 * @param Object the object to draw the thumbnail for
	 * @param PrimType ignored
	 * @param X the X coordinate to start drawing at
	 * @param Y the Y coordinate to start drawing at
	 * @param Width the width of the thumbnail to draw
	 * @param Height the height of the thumbnail to draw
	 * @param Viewport ignored
	 * @param Canvas the render interface to draw with
	 * @param BackgroundType type of background for the thumbnail
	 * @param PreviewBackgroundColor background color for material previews
	 * @param PreviewBackgroundColorTranslucent background color for translucent material previews
	 */
	virtual void Draw(UObject* Object,EThumbnailPrimType,INT X,INT Y,
		DWORD Width,DWORD Height,FRenderTarget*,FCanvas* Canvas,
		EThumbnailBackgroundType BackgroundType,
		FColor PreviewBackgroundColor,
		FColor PreviewBackgroundColorTranslucent);
};

struct FEditorKeyBinding
{
    BITFIELD bCtrlDown:1;
    BITFIELD bAltDown:1;
    BITFIELD bShiftDown:1;
    FName Key;
    FName CommandName;

    /** Constructors */
    FEditorKeyBinding() {}
    FEditorKeyBinding(EEventParm)
    {
        appMemzero(this, sizeof(FEditorKeyBinding));
    }
};

struct FQuickActorKeyBinding
{
    BITFIELD bCtrlDown:1;
    BITFIELD bAltDown:1;
    BITFIELD bShiftDown:1;
    FName Key;
    FName ActorClassName;

    /** Constructors */
    FQuickActorKeyBinding() {}
    FQuickActorKeyBinding(EEventParm)
    {
        appMemzero(this, sizeof(FQuickActorKeyBinding));
    }
};

class UUnrealEdKeyBindings : public UObject
{
public:
    //## BEGIN PROPS UnrealEdKeyBindings
    TArrayNoInit<struct FEditorKeyBinding> KeyBindings;
    TArrayNoInit<struct FQuickActorKeyBinding> QuickActorKeyBindings;
    //## END PROPS UnrealEdKeyBindings

    DECLARE_CLASS(UUnrealEdKeyBindings,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("EditorKeyBindings");}

    NO_DEFAULT_CONSTRUCTOR(UUnrealEdKeyBindings)
};

struct FEditorCommandCategory
{
    FName Parent;
    FName Name;

    /** Constructors */
    FEditorCommandCategory() {}
    FEditorCommandCategory(EEventParm)
    {
        appMemzero(this, sizeof(FEditorCommandCategory));
    }
};

struct FEditorCommand
{
    FName Parent;
    FName CommandName;
    FStringNoInit ExecCommand;
    FStringNoInit Description;

    /** Constructors */
    FEditorCommand() {}
    FEditorCommand(EEventParm)
    {
        appMemzero(this, sizeof(FEditorCommand));
    }
};

class UUnrealEdOptions : public UObject
{
public:
    //## BEGIN PROPS UnrealEdOptions
    TArrayNoInit<struct FEditorCommandCategory> EditorCategories;
    TArrayNoInit<struct FEditorCommand> EditorCommands;
    class UUnrealEdKeyBindings* EditorKeyBindings;
    TMap< FName, INT > CommandMap;
    //## END PROPS UnrealEdOptions

    DECLARE_CLASS(UUnrealEdOptions,UObject,0|CLASS_Config,UnrealEd)
    static const TCHAR* StaticConfigName() {return TEXT("Editor");}

public:

	/**
	 * Generates a mapping from commnads to their parent sets for quick lookup.
	 */
	void GenerateCommandMap();

	/**
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @return Returns whether or not the specified key event is already bound to a command or not.
	 */
	UBOOL IsKeyBound(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName EditorSet);

	/**
	 * Binds a hotkey.
	 *
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @param Command	Command to bind to.
	 */
	void BindKey(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName Command);

	/**
	 * Attempts to execute a command bound to a hotkey.
	 *
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @param EditorSet		Set of bindings to search in.
	 */
	void ExecuteBinding(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName EditorSet);

	/**
	 * Attempts to locate a exec command bound to a hotkey.
	 *
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @param EditorSet		Set of bindings to search in.
	 */
	FString GetExecCommand(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName EditorSet);

	/**
	 * Attempts to locate a command name bound to a hotkey.
	 *
	 * @param Key			Key name
	 * @param bAltDown		Whether or not ALT is pressed.
	 * @param bCtrlDown		Whether or not CONTROL is pressed.
	 * @param bShiftDown	Whether or not SHIFT is pressed.
	 * @param EditorSet		Set of bindings to search in.
	 *
	 * @return Name of the command if found, NAME_None otherwise.
	 */
	FName GetCommand(FName Key, UBOOL bAltDown, UBOOL bCtrlDown, UBOOL bShiftDown, FName EditorSet);

	/**
	 * Retreives a editor key binding for a specified command.
	 *
	 * @param Command		Command to retrieve a key binding for.
	 *
	 * @return A pointer to a keybinding if one exists, NULL otherwise.
	 */
	FEditorKeyBinding* GetKeyBinding(FName Command);
};

#undef DECLARE_CLASS
#undef DECLARE_CASTED_CLASS
#undef DECLARE_ABSTRACT_CLASS
#undef DECLARE_ABSTRACT_CASTED_CLASS
#endif // !INCLUDED_UNREALED_CLASSES
#endif // !NAMES_ONLY

AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execPolyEnd);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execPolyi);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execPolyBegin);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execPoly4i);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execPoly3i);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execVertex3f);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execVertexv);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execBadParameters);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execGetPolyCount);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execGetVertex);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execGetVertexCount);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execEndBrush);
AUTOGENERATE_FUNCTION(UBrushBuilder,-1,execBeginBrush);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_FUNCTION
#endif

#ifdef STATIC_LINKING_MOJO
#ifndef UNREALED_NATIVE_DEFS
#define UNREALED_NATIVE_DEFS

#define AUTO_INITIALIZE_REGISTRANTS_UNREALED \
	UActorFactorySelection::StaticClass(); \
	UAnalyzeContentCommandlet::StaticClass(); \
	UAnalyzeCookedContentCommandlet::StaticClass(); \
	UAnalyzeCookedPackagesCommandlet::StaticClass(); \
	UAnalyzeCookedTextureSingleUsageCommandlet::StaticClass(); \
	UAnalyzeCookedTextureUsageCommandlet::StaticClass(); \
	UAnalyzeKismetCommandlet::StaticClass(); \
	UAnalyzeReferencedContentCommandlet::StaticClass(); \
	UAnalyzeReferencedObjectCommandlet::StaticClass(); \
	UAnalyzeScriptCommandlet::StaticClass(); \
	UAnalyzeShaderCachesCommandlet::StaticClass(); \
	UAnimNodeEditInfo::StaticClass(); \
	UAnimNodeEditInfo_AimOffset::StaticClass(); \
	UAnimSetFactoryNew::StaticClass(); \
	UAnimTreeEdSkelComponent::StaticClass(); \
	UAnimTreeFactoryNew::StaticClass(); \
	UApexDestructibleDamageParametersFactoryNew::StaticClass(); \
	UApexGenericAssetFactory::StaticClass(); \
	UReimportApexGenericAssetFactory::StaticClass(); \
	UASVSkelComponent::StaticClass(); \
	UBaseCollectionProcessingCommandlet::StaticClass(); \
	UFindBadAnimNotifyCommandlet::StaticClass(); \
	UFindOnDVDCinematicTexturesCommandlet::StaticClass(); \
	UFindOnDVDPSysDynamicParameterCommandlet::StaticClass(); \
	UFindOnDVDPSystemsCommandlet::StaticClass(); \
	UFindOnDVDPSysWithCollisionEnabledCommandlet::StaticClass(); \
	UFindOnDVDPSysWithMedDetailSpawnRateCommandlet::StaticClass(); \
	UFindOnDVDPSysWithNoFixedBoundsCommandlet::StaticClass(); \
	UBaseDatabaseCommandlet::StaticClass(); \
	UAnalyzeDVDSpaceCommandlet::StaticClass(); \
	UFindCinematicTexturesCommandlet::StaticClass(); \
	ULensFlareAuditCommandlet::StaticClass(); \
	UMaterialAuditCommandlet::StaticClass(); \
	UParticleSystemAuditCommandlet::StaticClass(); \
	UPMapForceObjectCheckCommandlet::StaticClass(); \
	UBaseObjectTagGeneratorCommandlet::StaticClass(); \
	UFindPSysWithBadAutoActivateSettingCommandlet::StaticClass(); \
	UFindPSysWithCollisionEnabledCommandlet::StaticClass(); \
	UFindPSysWithZOrientTowardsCameraCommandlet::StaticClass(); \
	UFindStaticMeshCleanIssuesCommandlet::StaticClass(); \
	UFixupMobileMaterialFogCommandlet::StaticClass(); \
	UParticleModuleAuditCommandlet::StaticClass(); \
	UBatchExportCommandlet::StaticClass(); \
	UBreakApartPackagesCommandlet::StaticClass(); \
	UBrowserManager::StaticClass(); \
	UBrushBuilder::StaticClass(); \
	GNativeLookupFuncs.Set(FName("BrushBuilder"), GUnrealEdUBrushBuilderNatives); \
	UCubeBuilder::StaticClass(); \
	UByteCodeSerializer::StaticClass(); \
	UCameraAnimFactory::StaticClass(); \
	UCascadeConfiguration::StaticClass(); \
	UCascadeOptions::StaticClass(); \
	UCascadePreviewComponent::StaticClass(); \
	UCheckForSimplifiedMeshesCommandlet::StaticClass(); \
	UCheckLightMapUVsCommandlet::StaticClass(); \
	UCheckpointGameAssetDatabaseCommandlet::StaticClass(); \
	UClassExporterUC::StaticClass(); \
	UClassFactoryUC::StaticClass(); \
	UCompressAnimationsCommandlet::StaticClass(); \
	UConformCommandlet::StaticClass(); \
	UContentAuditCommandlet::StaticClass(); \
	UContentComparisonCommandlet::StaticClass(); \
	UConvertMapToNavMesh::StaticClass(); \
	UCookPackagesCommandlet::StaticClass(); \
	UCurveEdOptions::StaticClass(); \
	UCurveEdPresetBase::StaticClass(); \
	UCurveEdPreset_CosWave::StaticClass(); \
	UCurveEdPreset_LinearDecay::StaticClass(); \
	UCurveEdPreset_Nothing::StaticClass(); \
	UCurveEdPreset_SineWave::StaticClass(); \
	UCurveEdPreset_UserSet::StaticClass(); \
	UCurveEdPresetCurveFactoryNew::StaticClass(); \
	UDecalMaterialFactoryNew::StaticClass(); \
	UDEditorParameterValue::StaticClass(); \
	UDEditorFontParameterValue::StaticClass(); \
	UDEditorScalarParameterValue::StaticClass(); \
	UDEditorStaticComponentMaskParameterValue::StaticClass(); \
	UDEditorStaticSwitchParameterValue::StaticClass(); \
	UDEditorTextureParameterValue::StaticClass(); \
	UDEditorVectorParameterValue::StaticClass(); \
	UDeleteQuarantinedContentCommandlet::StaticClass(); \
	UDiffPackagesCommandlet::StaticClass(); \
	UDumpEmittersCommandlet::StaticClass(); \
	UDumpLightmapInfoCommandlet::StaticClass(); \
	UDumpPropertiesCommandlet::StaticClass(); \
	UDumpShadersCommandlet::StaticClass(); \
	UEditorComponent::StaticClass(); \
	UEdModeComponent::StaticClass(); \
	UEditorEngine::StaticClass(); \
	UUnrealEdEngine::StaticClass(); \
	UEditorPlayer::StaticClass(); \
	UEditorUserSettings::StaticClass(); \
	UEditorViewportInput::StaticClass(); \
	UExamineOutersCommandlet::StaticClass(); \
	UExporterT3DX::StaticClass(); \
	UMaterialExporterT3D::StaticClass(); \
	UStaticMeshExporterT3D::StaticClass(); \
	UTextureExporterT3D::StaticClass(); \
	UExportLocCommandlet::StaticClass(); \
	UFaceFXStudioSkelComponent::StaticClass(); \
	UFbxFactory::StaticClass(); \
	UReimportFbxSkeletalMeshFactory::StaticClass(); \
	UReimportFbxStaticMeshFactory::StaticClass(); \
	UFbxImportUI::StaticClass(); \
	UFindAssetReferencersCommandlet::StaticClass(); \
	UFindDarkDiffuseTexturesCommandlet::StaticClass(); \
	UFindDuplicateKismetObjectsCommandlet::StaticClass(); \
	UFindDuplicateTexturesCommandlet::StaticClass(); \
	UFindEmitterMismatchedLODsCommandlet::StaticClass(); \
	UFindEmitterModifiedLODsCommandlet::StaticClass(); \
	UFindEmitterModuleLODErrorsCommandlet::StaticClass(); \
	UFindQuestionableTexturesCommandlet::StaticClass(); \
	UFindStaticMeshCanBecomeDynamicCommandlet::StaticClass(); \
	UFindStaticMeshEmptySectionsCommandlet::StaticClass(); \
	UFindTexturesWithMissingPhysicalMaterialsCommandlet::StaticClass(); \
	UFindUniqueSpecularTextureMaterialsCommandlet::StaticClass(); \
	UFindUnreferencedFunctionsCommandlet::StaticClass(); \
	UFixAdditiveReferencesCommandlet::StaticClass(); \
	UFixAmbiguousMaterialParametersCommandlet::StaticClass(); \
	UFixupEmittersCommandlet::StaticClass(); \
	UFixupRedirectsCommandlet::StaticClass(); \
	UFixupSourceUVsCommandlet::StaticClass(); \
	UFonixFactory::StaticClass(); \
	UFractureMaterialFactoryNew::StaticClass(); \
	UGenericBrowserType::StaticClass(); \
	UGenericBrowserType_Animation::StaticClass(); \
	UGenericBrowserType_AnimTree::StaticClass(); \
	UGenericBrowserType_ApexClothingAsset::StaticClass(); \
	UGenericBrowserType_ApexDestructibleAsset::StaticClass(); \
	UGenericBrowserType_ApexDestructibleDamageParameters::StaticClass(); \
	UGenericBrowserType_ApexGenericAsset::StaticClass(); \
	UGenericBrowserType_Archetype::StaticClass(); \
	UGenericBrowserType_CameraAnim::StaticClass(); \
	UGenericBrowserType_CurveEdPresetCurve::StaticClass(); \
	UGenericBrowserType_Custom::StaticClass(); \
	UGenericBrowserType_All::StaticClass(); \
	UGenericBrowserType_DecalMaterial::StaticClass(); \
	UGenericBrowserType_FaceFXAnimSet::StaticClass(); \
	UGenericBrowserType_FaceFXAsset::StaticClass(); \
	UGenericBrowserType_Font::StaticClass(); \
	UGenericBrowserType_FractureMaterial::StaticClass(); \
	UGenericBrowserType_InstancedFoliageSettings::StaticClass(); \
	UGenericBrowserType_LandscapeLayer::StaticClass(); \
	UGenericBrowserType_LensFlare::StaticClass(); \
	UGenericBrowserType_Material::StaticClass(); \
	UGenericBrowserType_MaterialFunction::StaticClass(); \
	UGenericBrowserType_MaterialInstanceConstant::StaticClass(); \
	UGenericBrowserType_MaterialInstanceTimeVarying::StaticClass(); \
	UGenericBrowserType_MorphTargetSet::StaticClass(); \
	UGenericBrowserType_MorphWeightSequence::StaticClass(); \
	UGenericBrowserType_ParticleSystem::StaticClass(); \
	UGenericBrowserType_PhysicalMaterial::StaticClass(); \
	UGenericBrowserType_PhysicsAsset::StaticClass(); \
	UGenericBrowserType_PhysXParticleSystem::StaticClass(); \
	UGenericBrowserType_PostProcess::StaticClass(); \
	UGenericBrowserType_Prefab::StaticClass(); \
	UGenericBrowserType_ProcBuildingRuleset::StaticClass(); \
	UGenericBrowserType_Sequence::StaticClass(); \
	UGenericBrowserType_SkeletalMesh::StaticClass(); \
	UGenericBrowserType_Sounds::StaticClass(); \
	UGenericBrowserType_SoundClass::StaticClass(); \
	UGenericBrowserType_SoundCue::StaticClass(); \
	UGenericBrowserType_SoundMode::StaticClass(); \
	UGenericBrowserType_SoundWave::StaticClass(); \
	UGenericBrowserType_SpeechRecognition::StaticClass(); \
	UGenericBrowserType_SpeedTree::StaticClass(); \
	UGenericBrowserType_StaticMesh::StaticClass(); \
	UGenericBrowserType_FracturedStaticMesh::StaticClass(); \
	UGenericBrowserType_TemplateMapMetadata::StaticClass(); \
	UGenericBrowserType_TerrainLayer::StaticClass(); \
	UGenericBrowserType_TerrainMaterial::StaticClass(); \
	UGenericBrowserType_Texture::StaticClass(); \
	UGenericBrowserType_RenderTexture::StaticClass(); \
	UGenericBrowserType_TextureCube::StaticClass(); \
	UGenericBrowserType_TextureMovie::StaticClass(); \
	UGeomModifier::StaticClass(); \
	UGeomModifier_Edit::StaticClass(); \
	UGeomModifier_Clip::StaticClass(); \
	UGeomModifier_Create::StaticClass(); \
	UGeomModifier_Delete::StaticClass(); \
	UGeomModifier_Extrude::StaticClass(); \
	UGeomModifier_Flip::StaticClass(); \
	UGeomModifier_Lathe::StaticClass(); \
	UGeomModifier_Optimize::StaticClass(); \
	UGeomModifier_Pen::StaticClass(); \
	UGeomModifier_Split::StaticClass(); \
	UGeomModifier_Triangulate::StaticClass(); \
	UGeomModifier_Turn::StaticClass(); \
	UGeomModifier_Weld::StaticClass(); \
	AGroupActor::StaticClass(); \
	UInterpEdOptions::StaticClass(); \
	UInterpTrackHelper::StaticClass(); \
	UInterpTrackAnimControlHelper::StaticClass(); \
	UInterpTrackBoolPropHelper::StaticClass(); \
	UInterpTrackDirectorHelper::StaticClass(); \
	UInterpTrackEventHelper::StaticClass(); \
	UInterpTrackFaceFXHelper::StaticClass(); \
	UInterpTrackFloatPropHelper::StaticClass(); \
	UInterpTrackHeadTrackingHelper::StaticClass(); \
	UInterpTrackNotifyHelper::StaticClass(); \
	UInterpTrackParticleReplayHelper::StaticClass(); \
	UInterpTrackSoundHelper::StaticClass(); \
	UInterpTrackToggleHelper::StaticClass(); \
	UInterpTrackVectorPropHelper::StaticClass(); \
	UInterpTrackColorPropHelper::StaticClass(); \
	UInterpTrackLinearColorPropHelper::StaticClass(); \
	UInterpTrackVisibilityHelper::StaticClass(); \
	UKismetBindings::StaticClass(); \
	ULensFlareEditorOptions::StaticClass(); \
	ULensFlareEditorPropertyWrapper::StaticClass(); \
	ULensFlareFactoryNew::StaticClass(); \
	ULensFlarePreviewComponent::StaticClass(); \
	ULevelExporterFBX::StaticClass(); \
	ULevelExporterLOD::StaticClass(); \
	ULevelExporterOBJ::StaticClass(); \
	ULevelExporterSTL::StaticClass(); \
	ULevelExporterT3D::StaticClass(); \
	ULevelFactory::StaticClass(); \
	ULightingChannelsObject::StaticClass(); \
	ULightmassOptionsObject::StaticClass(); \
	ULinkedObjectFactory::StaticClass(); \
	UListCorruptedComponentsCommandlet::StaticClass(); \
	UListCustomMaterialExpressionsCommandlet::StaticClass(); \
	UListDistanceCrossFadeNodesCommandlet::StaticClass(); \
	UListEmittersUsingModuleCommandlet::StaticClass(); \
	UListLoopingEmittersCommandlet::StaticClass(); \
	UListPackagesReferencingCommandlet::StaticClass(); \
	UListPhysAssetsNumBodiesCommandlet::StaticClass(); \
	UListPSysFixedBoundSettingCommandlet::StaticClass(); \
	UListScriptReferencedContentCommandlet::StaticClass(); \
	UListSoundNodeWavesCommandlet::StaticClass(); \
	ULoadPackageCommandlet::StaticClass(); \
	ULocSoundInfoCommandlet::StaticClass(); \
	UMakeCommandlet::StaticClass(); \
	UMaterialEditorInstanceConstant::StaticClass(); \
	UMaterialEditorInstanceTimeVarying::StaticClass(); \
	UMaterialEditorMeshComponent::StaticClass(); \
	UMaterialEditorOptions::StaticClass(); \
	UMaterialEditorSkeletalMeshComponent::StaticClass(); \
	UMaterialFactory::StaticClass(); \
	UMaterialFactoryNew::StaticClass(); \
	UMaterialFunctionFactoryNew::StaticClass(); \
	UMaterialInstanceConstantFactoryNew::StaticClass(); \
	UMaterialInstanceTimeVaryingFactoryNew::StaticClass(); \
	UMergeConflictingPackagesCommandlet::StaticClass(); \
	UMergePackagesCommandlet::StaticClass(); \
	UMineCookedPackagesCommandlet::StaticClass(); \
	UModelExporterT3D::StaticClass(); \
	UModelFactory::StaticClass(); \
	UObjectExporterT3D::StaticClass(); \
	UOutputAuditSummaryCommandlet::StaticClass(); \
	UPackageExporterT3D::StaticClass(); \
	UPackageFactory::StaticClass(); \
	UParticleSystemFactoryNew::StaticClass(); \
	UPerformMapCheckCommandlet::StaticClass(); \
	UFindRenamedPrefabSequencesCommandlet::StaticClass(); \
	UFindStaticActorsRefsCommandlet::StaticClass(); \
	UPerformTerrainMaterialDumpCommandlet::StaticClass(); \
	UPersistentCookerData::StaticClass(); \
	UPhATSimOptions::StaticClass(); \
	UPhATSkeletalMeshComponent::StaticClass(); \
	UPhysicalMaterialFactoryNew::StaticClass(); \
	UPhysXExporterAsset::StaticClass(); \
	UPhysXParticleSystemFactoryNew::StaticClass(); \
	UPIEToNormalCommandlet::StaticClass(); \
	UPkgInfoCommandlet::StaticClass(); \
	UPolysExporterT3D::StaticClass(); \
	UPolysFactory::StaticClass(); \
	UPostProcessFactoryNew::StaticClass(); \
	UPrecompileShadersCommandlet::StaticClass(); \
	UPreviewMaterial::StaticClass(); \
	UProcBuildingRulesetFactoryNew::StaticClass(); \
	UPropertyDrawProxy::StaticClass(); \
	UPropertyInputProxy::StaticClass(); \
	UPropertyInputArrayItemBase::StaticClass(); \
	UPropertyInputBool::StaticClass(); \
	UPropertyInputCombo::StaticClass(); \
	UPropertyInputEditInline::StaticClass(); \
	UPropertyInputText::StaticClass(); \
	UPropertyWindowManager::StaticClass(); \
	URenderTargetCubeExporterTGA::StaticClass(); \
	URenderTargetExporterTGA::StaticClass(); \
	UReplaceActorCommandlet::StaticClass(); \
	UReplaceMaterialCommandlet::StaticClass(); \
	UResavePackagesCommandlet::StaticClass(); \
	UChangePrefabSequenceClassCommandlet::StaticClass(); \
	UScaleAudioVolumeCommandlet::StaticClass(); \
	USequenceExporterT3D::StaticClass(); \
	USequenceFactory::StaticClass(); \
	USequenceObjectHelper::StaticClass(); \
	USetMaterialUsageCommandlet::StaticClass(); \
	USetPackageFlagsCommandlet::StaticClass(); \
	USetTextureLODGroupCommandlet::StaticClass(); \
	UShowObjectCountCommandlet::StaticClass(); \
	UShowPropertyFlagsCommandlet::StaticClass(); \
	UShowTaggedPropsCommandlet::StaticClass(); \
	USkeletalMeshExporterFBX::StaticClass(); \
	USkeletalMeshFactory::StaticClass(); \
	UReimportSkeletalMeshFactory::StaticClass(); \
	USoundClassFactory::StaticClass(); \
	USoundClassInfoCommandlet::StaticClass(); \
	USoundCueAuditCommandlet::StaticClass(); \
	USoundCueFactoryNew::StaticClass(); \
	USoundExporterWAV::StaticClass(); \
	USoundFactory::StaticClass(); \
	UReimportSoundFactory::StaticClass(); \
	USoundModeFactory::StaticClass(); \
	USoundNodeHelper::StaticClass(); \
	USoundSurroundExporterWAV::StaticClass(); \
	USoundSurroundFactory::StaticClass(); \
	USoundTTSFactory::StaticClass(); \
	USpeedTreeFactory::StaticClass(); \
	UStaticMeshExporterFBX::StaticClass(); \
	UStaticMeshExporterOBJ::StaticClass(); \
	UStaticMeshFactory::StaticClass(); \
	UReimportStaticMeshFactory::StaticClass(); \
	UStaticMeshMode_Options::StaticClass(); \
	UStripSourceCommandlet::StaticClass(); \
	UTagCookedReferencedAssetsCommandlet::StaticClass(); \
	UTagReferencedAssetsCommandlet::StaticClass(); \
	UTagSuboptimalTexturesCommandlet::StaticClass(); \
	UTemplateMapMetadata::StaticClass(); \
	UTemplateMapMetadataFactory::StaticClass(); \
	UTerrainEditOptions::StaticClass(); \
	UTerrainExporterT3D::StaticClass(); \
	UTerrainFactory::StaticClass(); \
	UTerrainHeightMapExporter::StaticClass(); \
	UTerrainHeightMapExporterG16BMPT3D::StaticClass(); \
	UTerrainHeightMapExporterTextT3D::StaticClass(); \
	UTerrainHeightMapFactory::StaticClass(); \
	UTerrainHeightMapFactoryG16BMP::StaticClass(); \
	UTerrainHeightMapFactoryG16BMPT3D::StaticClass(); \
	UTerrainHeightMapFactoryTextT3D::StaticClass(); \
	UTerrainLayerSetupFactoryNew::StaticClass(); \
	UTerrainMaterialFactoryNew::StaticClass(); \
	UTestCompressionCommandlet::StaticClass(); \
	UTestTextureCompressionCommandlet::StaticClass(); \
	UTestWordWrapCommandlet::StaticClass(); \
	UTextBufferExporterTXT::StaticClass(); \
	UTexture2DFactoryNew::StaticClass(); \
	UTextureCubeFactoryNew::StaticClass(); \
	UTextureExporterBMP::StaticClass(); \
	UTextureExporterPCX::StaticClass(); \
	UTextureExporterTGA::StaticClass(); \
	UTextureFactory::StaticClass(); \
	UFontFactory::StaticClass(); \
	UTrueTypeFontFactory::StaticClass(); \
	UTrueTypeMultiFontFactory::StaticClass(); \
	UReimportTextureFactory::StaticClass(); \
	UTextureMovieFactory::StaticClass(); \
	UTextureRenderTargetCubeFactoryNew::StaticClass(); \
	UTextureRenderTargetFactoryNew::StaticClass(); \
	UThumbnailLabelRenderer::StaticClass(); \
	UAnimSetLabelRenderer::StaticClass(); \
	UAnimTreeLabelRenderer::StaticClass(); \
	UApexClothingAssetLabelRenderer::StaticClass(); \
	UApexDestructibleAssetLabelRenderer::StaticClass(); \
	UApexGenericAssetLabelRenderer::StaticClass(); \
	UFontThumbnailLabelRenderer::StaticClass(); \
	UGenericThumbnailLabelRenderer::StaticClass(); \
	ULandscapeLayerLabelRenderer::StaticClass(); \
	UMaterialFunctionLabelRenderer::StaticClass(); \
	UMaterialInstanceLabelRenderer::StaticClass(); \
	UMemCountThumbnailLabelRenderer::StaticClass(); \
	UParticleSystemLabelRenderer::StaticClass(); \
	UPhysicsAssetLabelRenderer::StaticClass(); \
	UPostProcessLabelRenderer::StaticClass(); \
	USkeletalMeshLabelRenderer::StaticClass(); \
	USoundLabelRenderer::StaticClass(); \
	UStaticMeshLabelRenderer::StaticClass(); \
	UFracturedStaticMeshLabelRenderer::StaticClass(); \
	UThumbnailManager::StaticClass(); \
	UThumbnailRenderer::StaticClass(); \
	UDefaultSizedThumbnailRenderer::StaticClass(); \
	UApexDestructibleAssetThumbnailRenderer::StaticClass(); \
	UMaterialInstanceThumbnailRenderer::StaticClass(); \
	USkeletalMeshThumbnailRenderer::StaticClass(); \
	UStaticMeshThumbnailRenderer::StaticClass(); \
	UIconThumbnailRenderer::StaticClass(); \
	UArchetypeThumbnailRenderer::StaticClass(); \
	UPrefabThumbnailRenderer::StaticClass(); \
	UTextureThumbnailRenderer::StaticClass(); \
	UFontThumbnailRenderer::StaticClass(); \
	ULensFlareThumbnailRenderer::StaticClass(); \
	UParticleSystemThumbnailRenderer::StaticClass(); \
	UTextureCubeThumbnailRenderer::StaticClass(); \
	UTransactor::StaticClass(); \
	UTransBuffer::StaticClass(); \
	UUnitTestCommandlet::StaticClass(); \
	UUnrealEdKeyBindings::StaticClass(); \
	UUnrealEdOptions::StaticClass(); \
	UUnrealEdTypes::StaticClass(); \
	UUpdateKismetCommandlet::StaticClass(); \
	UUT3MapStatsCommandlet::StaticClass(); \
	UWrangleContentCommandlet::StaticClass(); \
	UWriteGameStatsReportCommandlet::StaticClass(); \

#endif // UNREALED_NATIVE_DEFS

#ifdef NATIVES_ONLY
FNativeFunctionLookup GUnrealEdUBrushBuilderNatives[] = 
{ 
	MAP_NATIVE(UBrushBuilder, execPolyEnd)
	MAP_NATIVE(UBrushBuilder, execPolyi)
	MAP_NATIVE(UBrushBuilder, execPolyBegin)
	MAP_NATIVE(UBrushBuilder, execPoly4i)
	MAP_NATIVE(UBrushBuilder, execPoly3i)
	MAP_NATIVE(UBrushBuilder, execVertex3f)
	MAP_NATIVE(UBrushBuilder, execVertexv)
	MAP_NATIVE(UBrushBuilder, execBadParameters)
	MAP_NATIVE(UBrushBuilder, execGetPolyCount)
	MAP_NATIVE(UBrushBuilder, execGetVertex)
	MAP_NATIVE(UBrushBuilder, execGetVertexCount)
	MAP_NATIVE(UBrushBuilder, execEndBrush)
	MAP_NATIVE(UBrushBuilder, execBeginBrush)
	{NULL, NULL}
};

#endif // NATIVES_ONLY
#endif // STATIC_LINKING_MOJO

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeEditInfo,AnimNodeEditInfo,AnimNodeClass)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeEditInfo)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeEditInfo_AimOffset,AnimNodeEditInfo_AimOffset,EditWindow)
VERIFY_CLASS_OFFSET_NODIE(UAnimNodeEditInfo_AimOffset,AnimNodeEditInfo_AimOffset,EditNode)
VERIFY_CLASS_SIZE_NODIE(UAnimNodeEditInfo_AimOffset)
VERIFY_CLASS_OFFSET_NODIE(UAnimTreeEdSkelComponent,AnimTreeEdSkelComponent,AnimTreeEdPtr)
VERIFY_CLASS_SIZE_NODIE(UAnimTreeEdSkelComponent)
VERIFY_CLASS_OFFSET_NODIE(UASVSkelComponent,ASVSkelComponent,AnimSetViewerPtr)
VERIFY_CLASS_OFFSET_NODIE(UASVSkelComponent,ASVSkelComponent,SkelMaterials)
VERIFY_CLASS_SIZE_NODIE(UASVSkelComponent)
VERIFY_CLASS_OFFSET_NODIE(UBrowserManager,BrowserManager,BrowserPanes)
VERIFY_CLASS_OFFSET_NODIE(UBrowserManager,BrowserManager,BrowserMenuPtr)
VERIFY_CLASS_SIZE_NODIE(UBrowserManager)
VERIFY_CLASS_OFFSET_NODIE(UBrushBuilder,BrushBuilder,BitmapFilename)
VERIFY_CLASS_OFFSET_NODIE(UBrushBuilder,BrushBuilder,Layer)
VERIFY_CLASS_SIZE_NODIE(UBrushBuilder)
VERIFY_CLASS_OFFSET_NODIE(UCubeBuilder,CubeBuilder,X)
VERIFY_CLASS_OFFSET_NODIE(UCubeBuilder,CubeBuilder,GroupName)
VERIFY_CLASS_SIZE_NODIE(UCubeBuilder)
VERIFY_CLASS_OFFSET_NODIE(UCascadeConfiguration,CascadeConfiguration,ModuleMenu_TypeDataToBaseModuleRejections)
VERIFY_CLASS_OFFSET_NODIE(UCascadeConfiguration,CascadeConfiguration,ModuleMenu_ModuleRejections)
VERIFY_CLASS_SIZE_NODIE(UCascadeConfiguration)
VERIFY_CLASS_OFFSET_NODIE(UCascadeOptions,CascadeOptions,BackgroundColor)
VERIFY_CLASS_OFFSET_NODIE(UCascadeOptions,CascadeOptions,MotionModeRadius)
VERIFY_CLASS_SIZE_NODIE(UCascadeOptions)
VERIFY_CLASS_OFFSET_NODIE(UCascadePreviewComponent,CascadePreviewComponent,CascadePtr)
VERIFY_CLASS_SIZE_NODIE(UCascadePreviewComponent)
VERIFY_CLASS_SIZE_NODIE(UConvertMapToNavMesh)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdOptions,CurveEdOptions,MinViewRange)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdOptions,CurveEdOptions,SelectedKeyColor)
VERIFY_CLASS_SIZE_NODIE(UCurveEdOptions)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPresetBase)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdPreset_CosWave,CurveEdPreset_CosWave,Frequency)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdPreset_CosWave,CurveEdPreset_CosWave,Offset)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_CosWave)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdPreset_LinearDecay,CurveEdPreset_LinearDecay,StartDecay)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdPreset_LinearDecay,CurveEdPreset_LinearDecay,EndValue)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_LinearDecay)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_Nothing)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdPreset_SineWave,CurveEdPreset_SineWave,Frequency)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdPreset_SineWave,CurveEdPreset_SineWave,Offset)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_SineWave)
VERIFY_CLASS_OFFSET_NODIE(UCurveEdPreset_UserSet,CurveEdPreset_UserSet,UserCurve)
VERIFY_CLASS_SIZE_NODIE(UCurveEdPreset_UserSet)
VERIFY_CLASS_OFFSET_NODIE(UDEditorParameterValue,DEditorParameterValue,ParameterName)
VERIFY_CLASS_OFFSET_NODIE(UDEditorParameterValue,DEditorParameterValue,ExpressionId)
VERIFY_CLASS_SIZE_NODIE(UDEditorParameterValue)
VERIFY_CLASS_OFFSET_NODIE(UDEditorFontParameterValue,DEditorFontParameterValue,FontValue)
VERIFY_CLASS_OFFSET_NODIE(UDEditorFontParameterValue,DEditorFontParameterValue,FontPage)
VERIFY_CLASS_SIZE_NODIE(UDEditorFontParameterValue)
VERIFY_CLASS_OFFSET_NODIE(UDEditorScalarParameterValue,DEditorScalarParameterValue,ParameterValue)
VERIFY_CLASS_SIZE_NODIE(UDEditorScalarParameterValue)
VERIFY_CLASS_OFFSET_NODIE(UDEditorStaticComponentMaskParameterValue,DEditorStaticComponentMaskParameterValue,ParameterValue)
VERIFY_CLASS_SIZE_NODIE(UDEditorStaticComponentMaskParameterValue)
VERIFY_CLASS_SIZE_NODIE(UDEditorStaticSwitchParameterValue)
VERIFY_CLASS_OFFSET_NODIE(UDEditorTextureParameterValue,DEditorTextureParameterValue,ParameterValue)
VERIFY_CLASS_SIZE_NODIE(UDEditorTextureParameterValue)
VERIFY_CLASS_OFFSET_NODIE(UDEditorVectorParameterValue,DEditorVectorParameterValue,ParameterValue)
VERIFY_CLASS_SIZE_NODIE(UDEditorVectorParameterValue)
VERIFY_CLASS_OFFSET_NODIE(UEditorComponent,EditorComponent,GridColorHi)
VERIFY_CLASS_OFFSET_NODIE(UEditorComponent,EditorComponent,GridColorLo)
VERIFY_CLASS_OFFSET_NODIE(UEditorComponent,EditorComponent,PerspectiveGridSize)
VERIFY_CLASS_OFFSET_NODIE(UEditorComponent,EditorComponent,PivotColor)
VERIFY_CLASS_OFFSET_NODIE(UEditorComponent,EditorComponent,PivotSize)
VERIFY_CLASS_OFFSET_NODIE(UEditorComponent,EditorComponent,BaseBoxColor)
VERIFY_CLASS_SIZE_NODIE(UEditorComponent)
VERIFY_CLASS_SIZE_NODIE(UEdModeComponent)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,TempModel)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ConversionTempModel)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,Trans)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,Results)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ActorProperties)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,LevelProperties)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,Bad)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,Bkgnd)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,BkgndHi)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,BadHighlight)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,MaterialArrow)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,MaterialBackdrop)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,EditorFont)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PreviewSoundCue)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PreviewAudioComponent)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,TexPropCube)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,TexPropSphere)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,TexPropPlane)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,TexPropCylinder)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,TerrainEditBrush)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ClickFlags)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ParentContext)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ClickLocation)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ClickPlane)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,MouseMovement)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ViewportClients)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,FarClippingPlane)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,DetailMode)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,FOVAngle)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,AutoSaveDir)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,GameCommandLine)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,EditPackages)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,EditPackagesInPath)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,EditPackagesOutPath)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,FRScriptOutputPath)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,HeightMapExportClassName)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,HiddenActorFactoryNames)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ActorFactories)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ActorsForGlobalReattach)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ClassMapPair)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,UserOpenedFile)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,InEditorGameURLOptions)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PlayWorld)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PlayWorldLocation)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PlayWorldRotation)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PlayWorldDestination)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,CurrentPlayWorldDestination)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PlayInEditorWidth)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PlayInEditorHeight)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,BuildPlayDevice)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,TemplateMapFolders)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PlayInEditorViewportIndex)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,UserEditedPlayWorldURL)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,MatineeCaptureResolutionX)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,MatineeCaptureResolutionY)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,KismetDebuggerBreakpointQueue)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,InEditorPropagator)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,RemotePropagator)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ScratchRenderTarget2048)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ScratchRenderTarget1024)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ScratchRenderTarget512)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ScratchRenderTarget256)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,StreamingBoundsTexture)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,UserSettings)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,EditorClassHierarchy)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PreviewMeshNames)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PreviewMeshComp)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,PreviewMeshIndex)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,CustomCameraAlignEmitterDistance)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,ActiveGroupActors)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,BufferLevelActors)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,LastCameraAlignTarget)
VERIFY_CLASS_OFFSET_NODIE(UEditorEngine,EditorEngine,StartupPackageToWarnState)
VERIFY_CLASS_SIZE_NODIE(UEditorEngine)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,EditorOptionsInst)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,BrowserManager)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,ThumbnailManager)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,BrowserManagerClassName)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,ThumbnailManagerClassName)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,AutoSaveIndex)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,AutosaveCount)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,MaterialCopyPasteBuffer)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,MatineeCopyPasteBuffer)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,SoundCueCopyPasteBuffer)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,SkelSocketPasteBuffer)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,AnimationCompressionAlgorithms)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,PackagesToBeFullyLoadedAtStartup)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,HiddenKismetClassNames)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,ApprovedPBRulesetCollections)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,ClassRelocationInfo)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,CurrentLODParentActor)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,PackageToNotifyState)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,PackagesCheckedForEngineVersion)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,SortedSpriteCategories)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdEngine,UnrealEdEngine,UnlocalizedCategoryToIndexMap)
VERIFY_CLASS_SIZE_NODIE(UUnrealEdEngine)
VERIFY_CLASS_OFFSET_NODIE(UEditorUserSettings,EditorUserSettings,AutoSaveTimeMinutes)
VERIFY_CLASS_OFFSET_NODIE(UEditorUserSettings,EditorUserSettings,PackagesToSave)
VERIFY_CLASS_SIZE_NODIE(UEditorUserSettings)
VERIFY_CLASS_OFFSET_NODIE(UEditorViewportInput,EditorViewportInput,Editor)
VERIFY_CLASS_SIZE_NODIE(UEditorViewportInput)
VERIFY_CLASS_OFFSET_NODIE(UFaceFXStudioSkelComponent,FaceFXStudioSkelComponent,RenderWidgetUE3Ptr)
VERIFY_CLASS_SIZE_NODIE(UFaceFXStudioSkelComponent)
VERIFY_CLASS_OFFSET_NODIE(UFbxImportUI,FbxImportUI,MeshTypeToImport)
VERIFY_CLASS_SIZE_NODIE(UFbxImportUI)
VERIFY_CLASS_OFFSET_NODIE(UFindUnreferencedFunctionsCommandlet,FindUnreferencedFunctionsCommandlet,Serializer)
VERIFY_CLASS_SIZE_NODIE(UFindUnreferencedFunctionsCommandlet)
VERIFY_CLASS_OFFSET_NODIE(UGenericBrowserType,GenericBrowserType,Description)
VERIFY_CLASS_OFFSET_NODIE(UGenericBrowserType,GenericBrowserType,BorderColor)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Animation)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_AnimTree)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_ApexClothingAsset)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_ApexDestructibleAsset)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_ApexDestructibleDamageParameters)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_ApexGenericAsset)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Archetype)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_CameraAnim)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_CurveEdPresetCurve)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Custom)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_All)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_DecalMaterial)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_FaceFXAnimSet)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_FaceFXAsset)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Font)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_FractureMaterial)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_InstancedFoliageSettings)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_LandscapeLayer)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_LensFlare)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Material)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_MaterialFunction)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_MaterialInstanceConstant)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_MaterialInstanceTimeVarying)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_MorphTargetSet)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_MorphWeightSequence)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_ParticleSystem)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_PhysicalMaterial)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_PhysicsAsset)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_PhysXParticleSystem)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_PostProcess)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Prefab)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_ProcBuildingRuleset)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Sequence)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SkeletalMesh)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Sounds)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SoundClass)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SoundCue)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SoundMode)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SoundWave)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SpeechRecognition)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_SpeedTree)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_StaticMesh)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_FracturedStaticMesh)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_TemplateMapMetadata)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_TerrainLayer)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_TerrainMaterial)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_Texture)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_RenderTexture)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_TextureCube)
VERIFY_CLASS_SIZE_NODIE(UGenericBrowserType_TextureMovie)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier,GeomModifier,Description)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier,GeomModifier,CachedPolys)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Edit)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier_Clip,GeomModifier_Clip,ClipMarkers)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier_Clip,GeomModifier_Clip,SnappedMouseWorldSpacePos)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Clip)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Create)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Delete)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier_Extrude,GeomModifier_Extrude,Length)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier_Extrude,GeomModifier_Extrude,SaveCoordSystem)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Extrude)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Flip)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier_Lathe,GeomModifier_Lathe,TotalSegments)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier_Lathe,GeomModifier_Lathe,Axis)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Lathe)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Optimize)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier_Pen,GeomModifier_Pen,ExtrudeDepth)
VERIFY_CLASS_OFFSET_NODIE(UGeomModifier_Pen,GeomModifier_Pen,MouseWorldSpacePos)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Pen)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Split)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Triangulate)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Turn)
VERIFY_CLASS_SIZE_NODIE(UGeomModifier_Weld)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AGroupActor,GroupActor,eMaterialType)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(AGroupActor,GroupActor,SubGroups)
#endif
VERIFY_CLASS_SIZE_NODIE(AGroupActor)
VERIFY_CLASS_OFFSET_NODIE(UInterpEdOptions,InterpEdOptions,SelectedKeys)
VERIFY_CLASS_SIZE_NODIE(UInterpEdOptions)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackAnimControlHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackBoolPropHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackDirectorHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackEventHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFaceFXHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackFloatPropHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackHeadTrackingHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackNotifyHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackParticleReplayHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackSoundHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackToggleHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVectorPropHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackColorPropHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackLinearColorPropHelper)
VERIFY_CLASS_SIZE_NODIE(UInterpTrackVisibilityHelper)
VERIFY_CLASS_OFFSET_NODIE(UKismetBindings,KismetBindings,Bindings)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UKismetBindings,KismetBindings,CommentPresets)
#endif
VERIFY_CLASS_SIZE_NODIE(UKismetBindings)
VERIFY_CLASS_OFFSET_NODIE(ULensFlareEditorOptions,LensFlareEditorOptions,LFED_BackgroundColor)
VERIFY_CLASS_OFFSET_NODIE(ULensFlareEditorOptions,LensFlareEditorOptions,ShowPPFlags)
VERIFY_CLASS_SIZE_NODIE(ULensFlareEditorOptions)
VERIFY_CLASS_OFFSET_NODIE(ULensFlareEditorPropertyWrapper,LensFlareEditorPropertyWrapper,Element)
VERIFY_CLASS_OFFSET_NODIE(ULensFlareEditorPropertyWrapper,LensFlareEditorPropertyWrapper,ElementIndex)
VERIFY_CLASS_SIZE_NODIE(ULensFlareEditorPropertyWrapper)
VERIFY_CLASS_OFFSET_NODIE(ULensFlarePreviewComponent,LensFlarePreviewComponent,LensFlareEditorPtr)
VERIFY_CLASS_SIZE_NODIE(ULensFlarePreviewComponent)
VERIFY_CLASS_OFFSET_NODIE(ULightingChannelsObject,LightingChannelsObject,LightingChannels)
VERIFY_CLASS_SIZE_NODIE(ULightingChannelsObject)
VERIFY_CLASS_OFFSET_NODIE(ULightmassOptionsObject,LightmassOptionsObject,DebugSettings)
VERIFY_CLASS_OFFSET_NODIE(ULightmassOptionsObject,LightmassOptionsObject,SwarmSettings)
VERIFY_CLASS_SIZE_NODIE(ULightmassOptionsObject)
VERIFY_CLASS_OFFSET_NODIE(UMaterialEditorInstanceConstant,MaterialEditorInstanceConstant,PhysMaterial)
VERIFY_CLASS_OFFSET_NODIE(UMaterialEditorInstanceConstant,MaterialEditorInstanceConstant,LightmassSettings)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorInstanceConstant)
VERIFY_CLASS_OFFSET_NODIE(UMaterialEditorInstanceTimeVarying,MaterialEditorInstanceTimeVarying,PhysMaterial)
VERIFY_CLASS_OFFSET_NODIE(UMaterialEditorInstanceTimeVarying,MaterialEditorInstanceTimeVarying,LightmassSettings)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorInstanceTimeVarying)
VERIFY_CLASS_OFFSET_NODIE(UMaterialEditorMeshComponent,MaterialEditorMeshComponent,MaterialEditor)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(UMaterialEditorOptions,MaterialEditorOptions,FavoriteExpressions)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorOptions)
VERIFY_CLASS_OFFSET_NODIE(UMaterialEditorSkeletalMeshComponent,MaterialEditorSkeletalMeshComponent,MaterialEditor)
VERIFY_CLASS_SIZE_NODIE(UMaterialEditorSkeletalMeshComponent)
VERIFY_CLASS_OFFSET_NODIE(UPhATSimOptions,PhATSimOptions,PreviewAnimSet)
VERIFY_CLASS_OFFSET_NODIE(UPhATSimOptions,PhATSimOptions,ConstraintDrawSize)
VERIFY_CLASS_SIZE_NODIE(UPhATSimOptions)
VERIFY_CLASS_OFFSET_NODIE(UPhATSkeletalMeshComponent,PhATSkeletalMeshComponent,PhATPtr)
VERIFY_CLASS_OFFSET_NODIE(UPhATSkeletalMeshComponent,PhATSkeletalMeshComponent,AnimationSpaceBases)
VERIFY_CLASS_SIZE_NODIE(UPhATSkeletalMeshComponent)
VERIFY_CLASS_SIZE_NODIE(UPreviewMaterial)
VERIFY_CLASS_SIZE_NODIE(USequenceObjectHelper)
VERIFY_CLASS_SIZE_NODIE(USoundNodeHelper)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshMode_Options,StaticMeshMode_Options,CollisionType)
VERIFY_CLASS_OFFSET_NODIE(UStaticMeshMode_Options,StaticMeshMode_Options,ScaleMax)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshMode_Options)
VERIFY_CLASS_OFFSET_NODIE(UTagSuboptimalTexturesCommandlet,TagSuboptimalTexturesCommandlet,TextureGroupsToExamine)
VERIFY_CLASS_SIZE_NODIE(UTagSuboptimalTexturesCommandlet)
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UTemplateMapMetadata,TemplateMapMetadata,Thumbnail)
#endif
#if WITH_EDITORONLY_DATA
VERIFY_CLASS_OFFSET_NODIE(UTemplateMapMetadata,TemplateMapMetadata,Thumbnail)
#endif
VERIFY_CLASS_SIZE_NODIE(UTemplateMapMetadata)
VERIFY_CLASS_OFFSET_NODIE(UTerrainEditOptions,TerrainEditOptions,Solid1_Strength)
VERIFY_CLASS_OFFSET_NODIE(UTerrainEditOptions,TerrainEditOptions,TerrainLayerBrowser_BorderColor)
VERIFY_CLASS_SIZE_NODIE(UTerrainEditOptions)
VERIFY_CLASS_SIZE_NODIE(UThumbnailLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UAnimSetLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UAnimTreeLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UApexClothingAssetLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UApexDestructibleAssetLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UApexGenericAssetLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UFontThumbnailLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UGenericThumbnailLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(ULandscapeLayerLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UMaterialFunctionLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceLabelRenderer)
VERIFY_CLASS_OFFSET_NODIE(UMemCountThumbnailLabelRenderer,MemCountThumbnailLabelRenderer,AggregatedLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UMemCountThumbnailLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UParticleSystemLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UPhysicsAssetLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UPostProcessLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(USkeletalMeshLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(USoundLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshLabelRenderer)
VERIFY_CLASS_SIZE_NODIE(UFracturedStaticMeshLabelRenderer)
VERIFY_CLASS_OFFSET_NODIE(UThumbnailManager,ThumbnailManager,RenderableThumbnailTypes)
VERIFY_CLASS_OFFSET_NODIE(UThumbnailManager,ThumbnailManager,MeshMaterialArray)
VERIFY_CLASS_SIZE_NODIE(UThumbnailManager)
VERIFY_CLASS_SIZE_NODIE(UThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(UDefaultSizedThumbnailRenderer,DefaultSizedThumbnailRenderer,DefaultSizeX)
VERIFY_CLASS_OFFSET_NODIE(UDefaultSizedThumbnailRenderer,DefaultSizedThumbnailRenderer,DefaultSizeY)
VERIFY_CLASS_SIZE_NODIE(UDefaultSizedThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UApexDestructibleAssetThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UMaterialInstanceThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(USkeletalMeshThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UStaticMeshThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(UIconThumbnailRenderer,IconThumbnailRenderer,IconName)
VERIFY_CLASS_OFFSET_NODIE(UIconThumbnailRenderer,IconThumbnailRenderer,Icon)
VERIFY_CLASS_SIZE_NODIE(UIconThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UArchetypeThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UPrefabThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UTextureThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UFontThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(ULensFlareThumbnailRenderer,LensFlareThumbnailRenderer,NoImage)
VERIFY_CLASS_OFFSET_NODIE(ULensFlareThumbnailRenderer,LensFlareThumbnailRenderer,OutOfDate)
VERIFY_CLASS_SIZE_NODIE(ULensFlareThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(UParticleSystemThumbnailRenderer,ParticleSystemThumbnailRenderer,NoImage)
VERIFY_CLASS_OFFSET_NODIE(UParticleSystemThumbnailRenderer,ParticleSystemThumbnailRenderer,OutOfDate)
VERIFY_CLASS_SIZE_NODIE(UParticleSystemThumbnailRenderer)
VERIFY_CLASS_SIZE_NODIE(UTextureCubeThumbnailRenderer)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdKeyBindings,UnrealEdKeyBindings,KeyBindings)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdKeyBindings,UnrealEdKeyBindings,QuickActorKeyBindings)
VERIFY_CLASS_SIZE_NODIE(UUnrealEdKeyBindings)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdOptions,UnrealEdOptions,EditorCategories)
VERIFY_CLASS_OFFSET_NODIE(UUnrealEdOptions,UnrealEdOptions,CommandMap)
VERIFY_CLASS_SIZE_NODIE(UUnrealEdOptions)
VERIFY_CLASS_SIZE_NODIE(UUnrealEdTypes)
#endif // VERIFY_CLASS_SIZES
#endif // !ENUMS_ONLY

#if SUPPORTS_PRAGMA_PACK
#pragma pack (pop)
#endif
