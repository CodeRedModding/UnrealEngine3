/**
 * Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
 */
/*-----------------------------------------------------------------------------
	Data structures only used for importing PSA/PSK files.
-----------------------------------------------------------------------------*/

#ifndef __SKELIMPORT_H__
#define __SKELIMPORT_H__

// Binary bone format to deal with raw animations as generated by various exporters.
struct FNamedBoneBinary
{
	ANSICHAR   Name[64];	// Bone's name
	DWORD      Flags;		// reserved
	INT        NumChildren; //
	INT		   ParentIndex;	// 0/NULL if this is the root bone.  
	VJointPos  BonePos;	    //
};


// File header structure. 
struct VChunkHeader
{
	ANSICHAR	ChunkID[20];  // string ID of up to 19 chars (usually zero-terminated)
	INT			TypeFlag;     // Flags/reserved
    INT         DataSize;     // size per struct following;
	INT         DataCount;    // number of structs/
};


// Raw data material.
struct VMaterial
{
	ANSICHAR            MaterialName[64];
	INT					TextureIndex;  // texture index ('multiskin index')
	DWORD				PolyFlags;     // ALL poly's with THIS material will have this flag.
	INT				    AuxMaterial;   // reserved: index into another material, eg. detailtexture/shininess/whatever.
	DWORD				AuxFlags;      // reserved: auxiliary flags 
	INT					LodBias;       // material-specific lod bias
	INT					LodStyle;      // material-specific lod style
};


// Raw data bone.
struct VBone
{
	ANSICHAR    Name[64];     //
	DWORD		Flags;        // reserved / 0x02 = bone where skin is to be attached...	
	INT 		NumChildren;  // children  // only needed in animation ?
	INT         ParentIndex;  // 0/NULL if this is the root bone.  
	VJointPos	BonePos;      // reference position
};

// Bone influence blending
struct VBoneInfIndex // ,, ,, contains Index, number of influences per bone (+ N detail level sizers! ..)
{
	WORD WeightIndex;
	WORD Number;	// how many to process 
	WORD DetailA;  // how many to process if we're up to 2 max influences
	WORD DetailB;  // how many to process if we're up to full 3 max influences 

	friend FArchive &operator<<( FArchive& Ar, VBoneInfIndex& V )
	{
		return Ar << V.WeightIndex << V.Number << V.DetailA << V.DetailB;
	}
};

struct VBoneInfluence // Weight and bone number
{
	WORD BoneWeight; 
	WORD BoneIndex; 
	friend FArchive &operator<<( FArchive& Ar, VBoneInfluence& V )
	{
		return Ar << V.BoneWeight << V.BoneIndex;
	}
};

// 3d vertex point index into a VBoneBlend array.
struct VWeightIndex
{
	TArray<WORD> PointIndices;
	INT  WeightBase;
	friend FArchive &operator<<( FArchive& Ar, VWeightIndex& V )
	{
		return Ar << V.PointIndices << V.WeightBase;
	}
};

// Raw data bone influence.
struct VRawBoneInfluence // just weight, vertex, and Bone, sorted later....
{
	FLOAT Weight;
	INT   VertexIndex;
	INT   BoneIndex;
};

// Vertex with texturing info, akin to Hoppe's 'Wedge' concept - import only.
struct VVertex
{
	DWORD	VertexIndex; // Index to a vertex.
	FVector2D UVs[MAX_TEXCOORDS];        // Scaled to BYTES, rather...-> Done in digestion phase, on-disk size doesn't matter here.
	FColor	Color;		 // Vertex colors
	BYTE    MatIndex;    // At runtime, this one will be implied by the face that's pointing to us.
	BYTE    Reserved;    // Top secret.

	VVertex()
	{
		appMemzero(this,sizeof(VVertex));
	}

	UBOOL operator==( const VVertex& Other ) const
	{
		UBOOL Equal = TRUE;

		Equal &= (VertexIndex == Other.VertexIndex);
		Equal &= (MatIndex == Other.MatIndex);
		Equal &= (Color == Other.Color);
		Equal &= (Reserved == Other.Reserved);

		UBOOL bUVsEqual = TRUE;
		for( UINT UVIdx = 0; UVIdx < MAX_TEXCOORDS; ++UVIdx )
		{
			if( UVs[UVIdx] != Other.UVs[UVIdx] )
			{
				bUVsEqual = FALSE;
				break;
			}
		}

		Equal &= bUVsEqual;

		return Equal;
	}

	friend DWORD GetTypeHash( const VVertex& Vertex )
	{
		return appMemCrc( &Vertex, sizeof(VVertex) );
	}
};


// Points: regular FVectors (for now..)
struct VPoint
{	
	FVector	Point; // Change into packed integer later IF necessary, for 3x size reduction...
};

//
// Bundle of raw data - from our 3DSMax plugin output.
//
struct FSkelImport 
{
	TArray <VMaterial>			Materials;		// Materials
	TArray <FVector>			Points;			// 3D Points
	TArray <VVertex>			Wedges;			// Wedges
	TArray <VTriangle>			Faces;			// Faces
	TArray <VBone>				RefBonesBinary;	// reference skeleton
	TArray <VRawBoneInfluence>	Influences;		
};

// An animation key.
struct VQuatAnimKey
{
	FVector	Position;           // relative to parent.
	FQuat	Orientation;        // relative to parent.
	FLOAT	Time;				// The duration until the next key (end key wraps to first...)

	friend FArchive &operator<<( FArchive& Ar, VQuatAnimKey& V )
	{
		return Ar << V.Position << V.Orientation << V.Time;
	}
};

// 
// Curve information for blend shape
// Name: Alias of each curve
// Weight Keys: weight of blend curve for # of frames
// 
struct VBlendCurve
{
	char			RawCurveName[128];
	TArray<FLOAT>	RawWeightKeys;
};
// Binary animation info format - used to organize raw animation keys into FAnimSeqs on rebuild
// Similar to MotionChunkDigestInfo..
struct AnimInfoBinary
{
	ANSICHAR	Name[64];			// Animation's name
	ANSICHAR	Group[64];			// Animation's group name	

	INT			TotalBones;			// TotalBones * NumRawFrames is number of animation keys to digest.

	INT			RootInclude;		// 0 none 1 included 		
	INT			KeyCompressionStyle;// Reserved: variants in tradeoffs for compression.
	INT			KeyQuotum;			// Max key quotum for compression	
	FLOAT		KeyReduction;		// desired 
	FLOAT		TrackTime;			// explicit - can be overridden by the animation rate
	FLOAT		AnimRate;			// frames per second.
	INT			StartBone;			// - Reserved: for partial animations.
	INT			FirstRawFrame;		//
	INT			NumRawFrames;		// NumRawFrames and AnimRate dictate tracktime...
};

/**
 * Container and importer for skeletal mesh (psk file) data
 **/
class FSkeletalMeshBinaryImport
{
public:
	TArray <VMaterial>			Materials;		// Materials
	TArray <FVector>			Points;			// 3D Points
	TArray <VVertex>			Wedges;			// Wedges
	TArray <VTriangle>			Faces;			// Faces
	TArray <VBone>				RefBonesBinary;	// Reference Skeleton
	TArray <VRawBoneInfluence>	Influences;		// Influences
	UINT	NumTexCoords;						// The number of texture coordinate sets
	UBOOL 	bHasVertexColors; 					// If true there are vertex colors in the imported file

	FSkeletalMeshBinaryImport()
		: NumTexCoords(0)
		, bHasVertexColors(FALSE)
	{

	}

	/**
	 * Parse skeletal mesh (psk file) from buffer into raw import data
	 * 
	 * @param BufferReadPtr	- start of data to be read
	 * @param BufferEnd - end of data to be read
	 * @param bShowSummary - if TRUE then print a summary of what was read to file
	 */
	void ImportFromFile( BYTE* BufferReadPtr, const BYTE* BufferEnd, UBOOL bShowSummary = TRUE );

	/**
 	 * Copy mesh data for importing a single LOD
	 *
	 * @param LODPoints - vertex data.
	 * @param LODWedges - wedge information to static LOD level.
	 * @param LODFaces - triangle/ face data to static LOD level.
	 * @param LODInfluences - weights/ influences to static LOD level.
	 */ 
	void CopyLODImportData( 
		TArray<FVector>& LODPoints, 
		TArray<FMeshWedge>& LODWedges,
		TArray<FMeshFace>& LODFaces,	
		TArray<FVertInfluence>& LODInfluences );

	static FString FixupBoneName( ANSICHAR *AnisBoneName );

	/**
 	 * Removes all import data
	 */
	void Empty()
	{
		Materials.Empty();
		Points.Empty();
		Wedges.Empty();
		Faces.Empty();
		RefBonesBinary.Empty();
		Influences.Empty();
	}
};

/** 
 * Optional data passed in when importing a skeletal mesh LDO
 */
class FSkelMeshOptionalImportData
{
public:
	FSkelMeshOptionalImportData() {}

	/** extra data used for importing extra weight/bone influences */
	FSkeletalMeshBinaryImport RawMeshInfluencesData;
	EInstanceWeightUsage IntendedUsage;
	INT MaxBoneCountPerChunk;
};

#endif
