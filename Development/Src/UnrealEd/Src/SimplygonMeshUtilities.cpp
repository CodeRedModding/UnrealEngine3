/*=============================================================================
	SimplygonMeshUtilities.cpp
	Simplygon middle ware integration
	Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
=============================================================================*/

#include "UnrealEd.h"
#include "Factories.h"

#if WITH_SIMPLYGON

#include "SimplygonMeshUtilities.h"
#include "SimplygonSDK.h"

#if WITH_SIMPLYGON_DLL
#include <ShlObj.h> // For SHGetFolderPath
#endif // #if WITH_SIMPLYGON_DLL

#define SIMPLYGON_COLOR_CHANNEL "VertexColors"

#if !WITH_SIMPLYGON_DLL
int InitializeSimplygonSDK( const char* LicenseData , SimplygonSDK::ISimplygonSDK** OutInterfacePtr );
void GetInterfaceVersionSimplygonSDK( char* DestString );
#endif // #if !WITH_SIMPLYGON_DLL

namespace SimplygonMeshUtilities
{
#if WITH_SIMPLYGON_DLL
	/** Interface calls and handle for the Simplygon DLL. */
	static void* GSimplygonDLL = NULL;
	typedef int (CALLBACK* LPINITIALIZESIMPLYGONSDK)( const char* LicenseData , SimplygonSDK::ISimplygonSDK** OutInterfacePtr );
	typedef void (CALLBACK* LPGETINTERFACEVERSIONSIMPLYGONSDK)( char* DestString );
	typedef void (CALLBACK* LPDEINITIALIZESIMPLYGONSDK)();
	static LPINITIALIZESIMPLYGONSDK InitializeSimplygonSDKPtr; 
	static LPGETINTERFACEVERSIONSIMPLYGONSDK GetInterfaceVersionSimplygonSDKPtr;
	static LPDEINITIALIZESIMPLYGONSDK DeinitializeSimplygonSDKPtr;
#endif // #if WITH_SIMPLYGON_DLL

	/** Global pointer to the SDK. */
	static SimplygonSDK::ISimplygonSDK* GSimplygonSDK = NULL;

	/** Receives error messages generated by Simplygon. These errors are presented via a message box. */
	class FDefaultErrorHandler : public SimplygonSDK::rerrorhandler
	{
	public :
		virtual void HandleError(
			SimplygonSDK::IObject* Object,
			const char* InterfaceName,
			const char* MethodName,
			SimplygonSDK::rid ErrorType,
			const char* ErrorText )
		{
			FString ErrorString = FString::Printf( TEXT("Simplygon Error:\n\nInterface: %s\nMethod: %s\nError: (%d) %s"),
				ANSI_TO_TCHAR( InterfaceName ),
				ANSI_TO_TCHAR( MethodName ),
				ErrorType,
				ANSI_TO_TCHAR( ErrorText ) );
			debugf( *ErrorString );
			appMsgf( AMT_OK, *ErrorString );
		}
	};
	FDefaultErrorHandler GDefaultErrorHandler;

	/** Receives progress events from Simplygon and updates the status window. */
	class FDefaultEventHandler : public SimplygonSDK::robserver
	{
	public:
		virtual void Execute(
			SimplygonSDK::IObject* Object,
			SimplygonSDK::rid EventId,
			void* EventParameterBlock,
			unsigned int EventParameterBlockSize )
		{
			if ( EventId == SimplygonSDK::SG_EVENT_PROGRESS )
			{
				check( sizeof(INT) == EventParameterBlockSize );
				INT ProgressPercent = *((INT*)EventParameterBlock);
				GWarn->UpdateProgress( ProgressPercent, 100 );

				// We are required to pass '1' back through the EventParametersBlock for the process to continue.
				*((INT*)EventParameterBlock) = 1;
			}
		}
	};

	/**
	 * Receives updates from Simplygon during processing. This object is designed
	 * to work when running Simplygon tasks asynchronously and allows the process
	 * to be abandoned.
	 */
	class FAsyncEventHandler : public SimplygonSDK::robserver
	{
	public:
		/**
		 * Default constructor.
		 */
		FAsyncEventHandler()
			: LastProgressPercent(0)
			, ProcessStage(0)
		{
		}

		/**
		 * Callback from Simplygon when an event occurs.
		 */
		virtual void Execute(
			SimplygonSDK::IObject* Object,
			SimplygonSDK::rid EventId,
			void* EventParameterBlock,
			unsigned int EventParameterBlockSize )
		{
			if ( EventId == SimplygonSDK::SG_EVENT_PROGRESS )
			{
				// Update the progress counter.
				check( sizeof(INT) == EventParameterBlockSize );
				INT ProgressPercent = *((INT*)EventParameterBlock);

				// These timings seem consistent for remeshing. Simplification does not use this event handler.
				if ( ProgressPercent < LastProgressPercent )
				{
					ProcessStage = 1;
				}
				LastProgressPercent = ProgressPercent;

				// Stage 0 accounts for ~25% of total time.
				if ( ProcessStage == 0 )
				{
					ProgressPercent = ProgressPercent / 4;
				}
				// Stage 1 only gets to 60% before it completes...
				else
				{
					ProgressPercent = 25 + (ProgressPercent * 75) / 60;
				}

				ProgressCounter.Set( ProgressPercent );

				// Check if we should abandon processing.
				const UBOOL bAbandonTask = AbandonTaskCounter.GetValue() > 0;

				// We are required to pass '1' back through the EventParametersBlock for the process to continue.
				*((INT*)EventParameterBlock) = bAbandonTask ? 0 : 1;
			}
		}

		/**
		 * Requests that Simplygon abandon its task.
		 */
		void AbandonTask()
		{
			AbandonTaskCounter.Increment();
		}

		/**
		 * Retrieves the progress of the task.
		 */
		INT GetProgress() const
		{
			return ProgressCounter.GetValue();
		}

	private:
		/** Tracks the last progress value reported by Simplygon. */
		INT LastProgressPercent;
		/** Which stage of processing are we in? */
		INT ProcessStage;
		/** A thread-safe counter used to communicate progress across threads. */
		FThreadSafeCounter ProgressCounter;
		/** A thread-safe counter used to signal that the task should be abandoned. */
		FThreadSafeCounter AbandonTaskCounter;
	};

	/**
	 * Receives errors from Simplygon during processing. This object is designed
	 * to work when running Simplygon tasks asynchronously. It caches the last error
	 * for later retrieval.
	 *
	 * Note that upon destruction this handler ensures the global default handler
	 * is reset!
	 */
	class FAsyncErrorHandler : public SimplygonSDK::rerrorhandler
	{
	public:
		/** Type of the error reported by Simplygon. */
		SimplygonSDK::rid ErrorType;
		/** Description of the error reported by Simplygon. */
		FString ErrorString;

		/** Default constructor. */
		FAsyncErrorHandler()
			: ErrorType( SimplygonSDK::SG_ERROR_NOERROR )
		{
		}

		/** Destructor. */
		~FAsyncErrorHandler()
		{
			if ( GSimplygonSDK )
			{
				GSimplygonSDK->SetErrorHandler( &GDefaultErrorHandler );
			}
		}

		/**
		 * Simplygon callback when an error is encountered.
		 */
		virtual void HandleError(
			SimplygonSDK::IObject* Object,
			const char* InterfaceName,
			const char* MethodName,
			SimplygonSDK::rid InErrorType,
			const char* ErrorText )
		{
			ErrorType = InErrorType;
			ErrorString = FString::Printf( TEXT("Simplygon Error:\n\nInterface: %s\nMethod: %s\nError: (%d) %s"),
				ANSI_TO_TCHAR( InterfaceName ),
				ANSI_TO_TCHAR( MethodName ),
				ErrorType,
				ANSI_TO_TCHAR( ErrorText ) );
			debugf( *ErrorString );
		}
	};

	/**
	 * Class that works with the async task system to offload Simplygon processing to another thread.
	 */
	class FAsyncProcessingWorker : public FNonAbandonableTask
	{
	public:
		/**
		 * Default constructor.
		 * @param InProcessor - The Simplygon processing object to run.
		 * @param InDoneEvent - Event to signal when processing completes.
		 */
		FAsyncProcessingWorker( SimplygonSDK::IProcessingObject* InProcessor, FEvent* InDoneEvent )
			: Processor( InProcessor )
			, DoneEvent( InDoneEvent )
		{
			check( Processor );
			check( DoneEvent );
		}

		/**
		 * Runs processing and signals DoneEvent when complete.
		 */
		void DoWork()
		{
			Processor->RunProcessing();
			DoneEvent->Trigger();
		}

		/**
		 * Name of the task for the async task system.
		 */
		const TCHAR* Name() const
		{
			return TEXT("SimplygonMeshUtilities::FAsyncProcessingWorker");
		}

	private:
		/** Simplygon processing object to run. */
		SimplygonSDK::IProcessingObject* Processor;
		/** Event to signal when processing completes. */
		FEvent* DoneEvent;
	};

	/**
	 * Class to handle processing an async task so that it may be canceled by the user.
	 */
	class FAsyncProcessingTask
	{
	public:
		/**
		 * Default constructor.
		 * @param InProcessor - The Simplygon processing object to run.
		 */
		explicit FAsyncProcessingTask( SimplygonSDK::IProcessingObject* InProcessor )
			: Processor( InProcessor )
		{
			DoneEvent = GSynchronizeFactory->CreateSynchEvent();
		}

		/** Destructor. */
		~FAsyncProcessingTask()
		{
			delete DoneEvent;
			DoneEvent = NULL;
		}

		/**
		 * Runs the task.
		 * @param TaskName - Name of the task to pass to GWarn. If NULL, GWarn will not be updated.
		 */
		UBOOL Run( const TCHAR* TaskName )
		{
			FAsyncTask<FAsyncProcessingWorker> Task( Processor, DoneEvent );
			FAsyncErrorHandler ErrorHandler;
			FAsyncEventHandler EventHandler;

			// Set error + event handlers.
			GSimplygonSDK->SetErrorHandler( &ErrorHandler );
			SimplygonSDK::rid ProgressObserverId = Processor->AddObserver( &EventHandler, SimplygonSDK::SG_EVENT_PROGRESS );
			SimplygonSDK::rid ProcessStartedObserverId = Processor->AddObserver( &EventHandler, SimplygonSDK::SG_EVENT_PROCESS_STARTED );

			// Begin the background task.
			Task.StartBackgroundTask();

			// Begin a slow task that can be canceled if we were given a task name.
			if ( TaskName )
			{
				GWarn->EndSlowTask();
				GWarn->BeginSlowTask( TaskName, TRUE, TRUE );
			}

			// The main thread can now sleep. Wake periodically to see if the user wishes to cancel.
			const DWORD TimeBetweenWakingUp = 100;
			while ( DoneEvent->Wait( TimeBetweenWakingUp ) == FALSE )
			{
				// Update the progress bar. This is also required to handle events sent to the status dialog.
				GWarn->UpdateProgress( EventHandler.GetProgress(), 100 );
				if ( GWarn->ReceivedUserCancel() )
				{
					// Tell Simplygon to abandon the job and wait for the task to return.
					EventHandler.AbandonTask();
					Task.EnsureCompletion();
					return FALSE;
				}
			}

			// Wait for the async task system to finish its work.
			Task.EnsureCompletion();

			// If Simplygon reported an error, report it to the user.
			if ( ErrorHandler.ErrorType != SimplygonSDK::SG_ERROR_NOERROR && ErrorHandler.ErrorString.Len() > 0 )
			{
				appMsgf( AMT_OK, *ErrorHandler.ErrorString );
				return FALSE;
			}

			// If we were given a task name, end the cancelable task and begin a normal slow task.
			if ( TaskName )
			{
				GWarn->EndSlowTask();
				GWarn->BeginSlowTask( TaskName, TRUE );
			}

			// Remove observers -- they will go out of scope and be invalid!
			Processor->RemoveObserver( ProgressObserverId );
			Processor->RemoveObserver( ProcessStartedObserverId );

			return TRUE;
		}

	private:
		/** The Simplygon processing object. */
		SimplygonSDK::IProcessingObject* Processor;
		/** A sync event that will be signaled when processing is complete. */
		FEvent* DoneEvent;
	};

#if WITH_SIMPLYGON_DLL
	/**
	 * Looks up the path to which the Simplygon SDK has been installed.
	 */
	UBOOL GetSimplygonInstallationPath( FString& OutPath )
	{
		HKEY RegistryKey;
		if ( RegOpenKey( HKEY_LOCAL_MACHINE, TEXT("Software\\DonyaLabs\\SimplygonSDK"), &RegistryKey ) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		BYTE* Buffer = NULL;
		DWORD BufferSize = 0;
		if ( RegQueryValueEx( RegistryKey, TEXT("InstallationPath"), NULL, NULL, NULL, &BufferSize ) != ERROR_SUCCESS )
		{
			return FALSE;
		}

		Buffer = new BYTE[BufferSize];
		if ( RegQueryValueEx( RegistryKey, TEXT("InstallationPath"), NULL, NULL, Buffer, &BufferSize ) != ERROR_SUCCESS )
		{
			delete [] Buffer;
			return FALSE;
		}

		OutPath = (TCHAR*)Buffer;
		delete [] Buffer;
		return TRUE;
	}

	/**
	 * Loads and initializes the Simplygon DLL.
	 */
	void InitSimplygonDLL()
	{
		check( GSimplygonDLL == NULL );
		check( GSimplygonSDK == NULL );

		// Setup paths.
		FString SimplygonPath = appRootDir() * FString( TEXT("Binaries\\Simplygon") );
		FString DLLName = 
#if _WIN64
			FString( TEXT("SimplygonSDKRuntimeReleasex64.dll") );
#else // #if _WIN64
			FString( TEXT("SimplygonSDKRuntimeReleaseWin32.dll") );
#endif // #if _WIN64
		FString DLLPath = SimplygonPath * DLLName;

		// Load the DLL.
		GSimplygonDLL = appGetDllHandle( *DLLPath );

		// If the DLL is not found, look for where the SDK has been installed.
		if ( GSimplygonDLL == NULL )
		{
			if ( GetSimplygonInstallationPath( SimplygonPath ) )
			{
				DLLPath = SimplygonPath * DLLName;
				GSimplygonDLL = appGetDllHandle( *DLLPath );
			}
		}

		// If the DLL has still not been found, bail out.
		if ( GSimplygonDLL == NULL )
		{
			appMsgf( AMT_OK, *LocalizeUnrealEd( "Simplygon_LoadDLLFailed" ) );
			return;
		}

		// Initialize library functions so we can create the SDK interface.
		InitializeSimplygonSDKPtr = (LPINITIALIZESIMPLYGONSDK)appGetDllExport( GSimplygonDLL , TEXT("InitializeSimplygonSDK") );
		GetInterfaceVersionSimplygonSDKPtr = (LPGETINTERFACEVERSIONSIMPLYGONSDK)appGetDllExport( GSimplygonDLL, TEXT("GetInterfaceVersionSimplygonSDK") );
		DeinitializeSimplygonSDKPtr = (LPDEINITIALIZESIMPLYGONSDK)appGetDllExport( GSimplygonDLL, TEXT("DeinitializeSimplygonSDK") );
		if( InitializeSimplygonSDKPtr == NULL || 
			GetInterfaceVersionSimplygonSDKPtr == NULL ||
			DeinitializeSimplygonSDKPtr == NULL )
		{
			appMsgf( AMT_OK, *LocalizeUnrealEd( "Simplygon_InitDLLFailed" ) );
			appFreeDllHandle( GSimplygonDLL );
			GSimplygonDLL = NULL;
			return;
		}

		// Verify the DLL version matches what the engine was compiled with.
		CHAR VersionHash[200];
		GetInterfaceVersionSimplygonSDKPtr( VersionHash );
		if ( appStrcmpANSI( VersionHash, SimplygonSDK::GetInterfaceVersionHash() ) != 0 )
		{
			appMsgf( AMT_OK, *FString::Printf( LocalizeSecure( LocalizeUnrealEd( "Simplygon_DLLVersionMismatch_F" ), *DLLPath ) ) );
			appFreeDllHandle( GSimplygonDLL );
			GSimplygonDLL = NULL;
			return;
		}

		// Read the license file.
		FString LicenseName( TEXT("License.dat") );
		FString LicensePath = SimplygonPath * LicenseName;
		FArchive* LicenseFile = GFileManager->CreateFileReader( *LicensePath );

		// If the license file could not be found with the DLL, look for where the installer places it.
		if ( !LicenseFile )
		{
			TCHAR AppDataPath[MAX_PATH];
			if ( SHGetFolderPath( NULL, CSIDL_COMMON_APPDATA, NULL, 0, AppDataPath ) == S_OK )
			{
				AppDataPath[MAX_PATH-1] = 0;
				LicensePath = FString( AppDataPath ) * FString( TEXT("DonyaLabs\\SimplygonSDK") ) * LicenseName;
				LicenseFile = GFileManager->CreateFileReader( *LicensePath );
			}
		}

		// If the license file still could not be found, bail out.
		if ( !LicenseFile )
		{
			appMsgf( AMT_OK, *FString::Printf( LocalizeSecure( LocalizeUnrealEd( "Simplygon_NoLicenseFile_F" ), *LicensePath ) ) );
			appFreeDllHandle( GSimplygonDLL );
			GSimplygonDLL = NULL;
			return;
		}

		// Read the license file and initialize the SDK.
		INT LicenseFileSize = LicenseFile->TotalSize();
		TArray<CHAR> LicenseData;
		LicenseData.Add( LicenseFileSize );
		LicenseFile->Serialize( LicenseData.GetTypedData(), LicenseFileSize );
		delete LicenseFile;

		INT Result = InitializeSimplygonSDKPtr( LicenseData.GetTypedData(), &GSimplygonSDK );
		if ( Result != SimplygonSDK::SG_ERROR_NOERROR && Result != SimplygonSDK::SG_ERROR_ALREADYINITIALIZED )
		{
			if ( Result == SimplygonSDK::SG_ERROR_NOLICENSE )
			{
				appMsgf( AMT_OK, *LocalizeUnrealEd( "Simplygon_InvalidLicense" ) );
			}
			else
			{
				appMsgf( AMT_OK, *FString::Printf( LocalizeSecure( LocalizeUnrealEd( "Simplygon_UnknownError" ), Result ) ) );
			}
			appFreeDllHandle( GSimplygonDLL );
			GSimplygonDLL = NULL;
			GSimplygonSDK = NULL;
			return;
		}
	}

	void ShutdownSimplygonDLL()
	{
		check( GSimplygonSDK );
		check( GSimplygonDLL );

		DeinitializeSimplygonSDKPtr();
		appFreeDllHandle( GSimplygonDLL );

		GSimplygonDLL = NULL;
		GSimplygonSDK = NULL;
		InitializeSimplygonSDKPtr = NULL;
		GetInterfaceVersionSimplygonSDKPtr = NULL;
		DeinitializeSimplygonSDKPtr = NULL;
	}
#endif // #if WITH_SIMPLYGON_DLL

	/**
	 * Initializes the Simplygon SDK.
	 */
	void InitSimplygonSDK()
	{
		if ( GSimplygonSDK )
		{
			return;
		}

#if WITH_SIMPLYGON_DLL
		GWarn->PushStatus();
		GWarn->StatusUpdatef( 0, 0, *LocalizeUnrealEd( TEXT("Simplygon_LoadDLL") ) );
		InitSimplygonDLL();
		GWarn->PopStatus();
#else // #if WITH_SIMPLYGON_DLL
		CHAR VersionHash[200];
		GetInterfaceVersionSimplygonSDK( VersionHash );
		if ( appStrcmpANSI( VersionHash, SimplygonSDK::GetInterfaceVersionHash() ) != 0 )
		{
			appMsgf( AMT_OK, *FString::Printf( TEXT("Static library version mismatch. Header=%s Lib=%s"), ANSI_TO_TCHAR(SimplygonSDK::GetInterfaceVersionHash()), ANSI_TO_TCHAR(VersionHash) ) );
			return;
		}

		INT Result = InitializeSimplygonSDK( NULL, &GSimplygonSDK );
		if ( Result != SimplygonSDK::SG_ERROR_NOERROR && Result != SimplygonSDK::SG_ERROR_ALREADYINITIALIZED )
		{
			appMsgf( AMT_OK, TEXT("Failed to initialize Simplygon. Error: %d."), Result );
			GSimplygonSDK = NULL;
			return;
		}
#endif // #if WITH_SIMPLYGON_DLL

		if( GSimplygonSDK )
		{
			GSimplygonSDK->SetErrorHandler( &GDefaultErrorHandler );
			GSimplygonSDK->SetGlobalSetting( "DefaultTBNType", SimplygonSDK::SG_TANGENTSPACEMETHOD_ORTHONORMAL );
		}
	}

	/**
	 * Winding modes.
	 */
	enum EWindingMode
	{
		/** Maintain the winding of the mesh. */
		WINDING_Keep,
		/** Reverse the winding of the mesh. */
		WINDING_Reverse,
		WINDING_MAX
	};

	/**
	 * Creates Simplygon geometry from raw triangles.
	 * @param SourceTriangles - The raw triangles of a mesh for which Simplygon geometry data will be created.
	 * @return Simplygon geometry data.
	 */
	SimplygonSDK::spGeometryData CreateGeometryFromTriangles( const FStaticMeshTriangle* RawTriangles, const UINT TriCount )
	{
		check( GSimplygonSDK );

		if ( TriCount == 0 )
		{
			return NULL;
		}

		const UINT VertexCount = TriCount * 3;
		const UBOOL bHaveTangents = RawTriangles[0].bExplicitNormals && RawTriangles[0].bOverrideTangentBasis;

		UINT TexCoordCount = 0;
		for ( UINT TriIndex = 0; TriIndex < TriCount; ++TriIndex )
		{
			TexCoordCount = Max<UINT>( TexCoordCount, RawTriangles[TriIndex].NumUVs );
		}
		TexCoordCount = Min<UINT>( TexCoordCount, 8 );

		SimplygonSDK::spGeometryData GeometryData = GSimplygonSDK->CreateGeometryData();
		GeometryData->SetVertexCount( VertexCount );
		GeometryData->SetTriangleCount( TriCount );

		// Per-vertex data.
		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();

		// Per-corner per-triangle data.
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRealArray TexCoords[8];
		for( UINT TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex )
		{
			GeometryData->AddTexCoords( TexCoordIndex );
			TexCoords[TexCoordIndex] = GeometryData->GetTexCoords( TexCoordIndex );
			check( TexCoords[TexCoordIndex]->GetTupleSize() == 2 );
		}

		GeometryData->AddColors(0);
		SimplygonSDK::spRealArray LinearColors = GeometryData->GetColors(0);
		check( LinearColors );
		check( LinearColors->GetTupleSize() == 4 );

		SimplygonSDK::spRealArray Normals, Tangents, Bitangents;
		if ( bHaveTangents )
		{
			GeometryData->AddNormals();
			GeometryData->AddTangents(0);
			GeometryData->AddBitangents(0);
			Normals = GeometryData->GetNormals();
			Tangents = GeometryData->GetTangents(0);
			Bitangents = GeometryData->GetBitangents(0);
			check( Normals && Tangents && Bitangents );
		}

		// Per-triangle data.
		GeometryData->AddMaterialIds();
		GeometryData->AddGroupIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();
		SimplygonSDK::spRidArray GroupIds = GeometryData->GetGroupIds();

		for( UINT TriIndex = 0; TriIndex < TriCount; ++TriIndex )
		{
			const FStaticMeshTriangle& Tri = RawTriangles[TriIndex];
			MaterialIndices->SetItem( TriIndex, Tri.MaterialIndex );
			GroupIds->SetItem( TriIndex, Tri.SmoothingMask );
			for( UINT CornerIndex = 0; CornerIndex < 3; ++CornerIndex )
			{
				UINT VertexIndex = TriIndex * 3 + CornerIndex;
				Positions->SetTuple( VertexIndex, (FLOAT*)&Tri.Vertices[CornerIndex] );
				Indices->SetItem( VertexIndex, VertexIndex );
				FLinearColor LinearColor( Tri.Colors[CornerIndex] );
				LinearColors->SetTuple( VertexIndex, (FLOAT*)&LinearColor );
				for( UINT TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex )
				{
					TexCoords[TexCoordIndex]->SetTuple( VertexIndex, (FLOAT *)&Tri.UVs[CornerIndex][TexCoordIndex] );
				}
				if ( bHaveTangents )
				{
					Normals->SetTuple( VertexIndex, (FLOAT*)&Tri.TangentZ[CornerIndex] );
					Tangents->SetTuple( VertexIndex, (FLOAT*)&Tri.TangentX[CornerIndex] );
					Bitangents->SetTuple( VertexIndex, (FLOAT*)&Tri.TangentY[CornerIndex] );
				}
			}
		}
		
		return GeometryData;
	}

	/**
	 * Creates Simplygon geometry from raw triangle bulk data.
	 * @param SourceTriangles - The raw triangles of a mesh for which Simplygon geometry data will be created.
	 * @return Simplygon geometry data.
	 */
	SimplygonSDK::spGeometryData CreateGeometryFromTriangleBulkData( FStaticMeshTriangleBulkData& SourceTriangles )
	{
		const FStaticMeshTriangle* RawTriangles = (const FStaticMeshTriangle*)SourceTriangles.Lock( LOCK_READ_ONLY );
		const UINT TriCount = SourceTriangles.GetElementCount();
		SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromTriangles( RawTriangles, TriCount );
		SourceTriangles.Unlock();
		return GeometryData;
	}

	/**
	 * Creates Simplygon geometry from the processed triangles in an LOD model.
	 * @param LODModel - The processed triangles of a mesh LOD for which Simplygon geometry data will be created.
	 * @return Simplygon geometry data.
	 */
	SimplygonSDK::spGeometryData CreateGeometryFromLODModel( FStaticMeshRenderData& LODModel )
	{
		check( GSimplygonSDK );

		const UINT IndexCount = LODModel.IndexBuffer.Indices.Num();
		const UINT TriCount = IndexCount / 3;
		const UINT VertexCount = LODModel.NumVertices;
		const UINT TexCoordCount = LODModel.VertexBuffer.GetNumTexCoords();
		check( TexCoordCount < 8 );

		SimplygonSDK::spGeometryData GeometryData = GSimplygonSDK->CreateGeometryData();
		GeometryData->SetVertexCount( VertexCount );
		GeometryData->SetTriangleCount( TriCount );

		// Per-vertex data.
		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();

		// Per-corner per-triangle data.
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRealArray TexCoords[8];
		for( UINT TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex )
		{
			GeometryData->AddTexCoords( TexCoordIndex );
			TexCoords[TexCoordIndex] = GeometryData->GetTexCoords( TexCoordIndex );
			check( TexCoords[TexCoordIndex]->GetTupleSize() == 2 );
		}
		GeometryData->AddNormals();
		GeometryData->AddTangents(0);
		GeometryData->AddBitangents(0);
		SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
		SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
		SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);
		
		SimplygonSDK::spRealArray Colors;
		if ( LODModel.ColorVertexBuffer.GetNumVertices() == VertexCount )
		{
			GeometryData->AddColors(0);
			Colors = GeometryData->GetColors(0);
			check( Colors );
			check( Colors->GetTupleSize() == 4 );
		}

		// Per-triangle data.
		GeometryData->AddMaterialIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();

		// Add per-vertex data.
		for ( UINT VertexIndex = 0; VertexIndex < VertexCount; ++VertexIndex )
		{
			const FVector& Position = LODModel.PositionVertexBuffer.VertexPosition( VertexIndex );
			Positions->SetTuple( VertexIndex, (FLOAT*)&Position );
		}

		// Add per-vertex per-triangle data.
		for ( UINT Index = 0; Index < IndexCount; ++Index )
		{
			WORD VertexIndex = LODModel.IndexBuffer.Indices( Index );
			FVector Normal = LODModel.VertexBuffer.VertexTangentZ( VertexIndex );
			FVector Tangent = LODModel.VertexBuffer.VertexTangentX( VertexIndex );
			FVector Bitangent = LODModel.VertexBuffer.VertexTangentY( VertexIndex );

			Indices->SetItem( Index, VertexIndex );
			Normals->SetTuple( Index, (FLOAT*)&Normal );
			Tangents->SetTuple( Index, (FLOAT*)&Tangent );
			Bitangents->SetTuple( Index, (FLOAT*)&Bitangent );

			for( UINT TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex )
			{
				FVector2D TexCoord = LODModel.VertexBuffer.GetVertexUV( VertexIndex, TexCoordIndex );
				TexCoords[TexCoordIndex]->SetTuple( Index, (FLOAT*)&TexCoord );
			}

			if ( Colors )
			{
				FLinearColor Color = FLinearColor( LODModel.ColorVertexBuffer.VertexColor( VertexIndex ) );
				Colors->SetTuple( Index, (FLOAT*)&Color );
			}
		}

		// Add per-triangle data.
		const UINT ElementCount = LODModel.Elements.Num();
		for ( UINT ElementIndex = 0; ElementIndex < ElementCount; ++ElementIndex )
		{
			const FStaticMeshElement& Element = LODModel.Elements( ElementIndex );
			const UINT FirstTriIndex = Element.FirstIndex / 3;
			const UINT LastTriIndex = FirstTriIndex + Element.NumTriangles - 1;
			for ( UINT TriIndex = FirstTriIndex; TriIndex <= LastTriIndex; ++TriIndex )
			{
				MaterialIndices->SetItem( TriIndex, ElementIndex );
			}
		}

		return GeometryData;
	}

	/**
	 * Creates raw triangles from the Simplygon geometry.
	 * @param GeometryData - Source mesh to extract from.
	 * @param WindingMode - How to handle triangle windings.
	 * @param DestTriangles - Storage for raw triangle output.
	 */
	void CreateTrianglesFromGeometry( const SimplygonSDK::spGeometryData& GeometryData, EWindingMode WindingMode, FStaticMeshTriangleBulkData& DestTriangles )
	{
		check( GeometryData );

		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();
		SimplygonSDK::spRidArray GroupIds = GeometryData->GetGroupIds();
		SimplygonSDK::spRealArray LinearColors = GeometryData->GetColors(0);
		SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
		SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
		SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);
		SimplygonSDK::spRealArray TexCoords[8];
		UINT TexCoordCount = 0;
		for( UINT TexCoordIndex = 0; TexCoordIndex < 8; ++TexCoordIndex )
		{
			TexCoords[TexCoordIndex] = GeometryData->GetTexCoords(TexCoordIndex);
			if ( TexCoords[TexCoordIndex] == NULL )
			{
				break;
			}
			TexCoordCount++;
		}

		check(Positions);
		check(Indices);

		const UBOOL bReverseWinding = (WindingMode == WINDING_Reverse);
		const UBOOL bOverrideTangentBasis = (Normals != NULL && Tangents != NULL && Bitangents != NULL);
		const UBOOL bExplicitNormals = (Normals != NULL);
		const UBOOL bHaveSmoothingMask = (GroupIds != NULL);
		const UBOOL bHaveLinearColors = (LinearColors != NULL);
		const UINT TriCount = GeometryData->GetTriangleCount();
		//debugf( TEXT("CreateTrianglesFromGeometry: TriCount=%d ReverseWinding=%d OverrideTangentBasis=%d ExplicitNormals=%d HaveSmoothingMask=%d HaveLinearColors=%d"),
		//	TriCount, bReverseWinding, bOverrideTangentBasis, bExplicitNormals, bHaveSmoothingMask, bHaveLinearColors );
		DestTriangles.Lock( LOCK_READ_WRITE );
		FStaticMeshTriangle* RawTriangleData = (FStaticMeshTriangle*)DestTriangles.Realloc( TriCount );
		for ( UINT TriIndex = 0; TriIndex < TriCount; ++TriIndex )
		{
			FStaticMeshTriangle& Tri = RawTriangleData[TriIndex];

			Tri.MaterialIndex = MaterialIndices ? MaterialIndices->GetItem( TriIndex ) : 0;
			Tri.FragmentIndex = 0;
			Tri.SmoothingMask = bHaveSmoothingMask ? GroupIds->GetItem( TriIndex ) : 0;
			Tri.NumUVs = TexCoordCount;
			Tri.bOverrideTangentBasis = bOverrideTangentBasis;
			Tri.bExplicitNormals = bExplicitNormals;

			for ( UINT CornerIndex = 0; CornerIndex < 3; ++CornerIndex )
			{
				UINT VertexId = Indices->GetItem( TriIndex * 3 + CornerIndex );
				const UINT DestIndex = bReverseWinding ? (2 - CornerIndex) : CornerIndex;

				Positions->GetTuple( VertexId, (FLOAT*)&Tri.Vertices[DestIndex] );

				UINT CornerId = TriIndex * 3 + CornerIndex;

				for ( UINT TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex )
				{
					TexCoords[TexCoordIndex]->GetTuple( CornerId, (FLOAT*)&Tri.UVs[DestIndex][TexCoordIndex] );
				}

				if ( bHaveLinearColors )
				{
					FLinearColor LinearColor;
					LinearColors->GetTuple( CornerId, (FLOAT*)&LinearColor );
					Tri.Colors[DestIndex] = LinearColor.ToFColor( TRUE );
				}
				else
				{
					Tri.Colors[DestIndex] = FColor( 255, 255, 255, 255 );
				}

				if ( bExplicitNormals )
				{
					// Swap handedness.
					Normals->GetTuple( CornerId, (FLOAT*)&Tri.TangentZ[DestIndex] );
					if ( !bReverseWinding )
					{
						Tri.TangentZ[DestIndex] = -Tri.TangentZ[DestIndex];
					}
					Tri.TangentZ[DestIndex] = Tri.TangentZ[DestIndex].SafeNormal();
				}

				if ( bOverrideTangentBasis )
				{
					Tangents->GetTuple( CornerId, (FLOAT*)&Tri.TangentX[DestIndex] );
					Bitangents->GetTuple( CornerId, (FLOAT*)&Tri.TangentY[DestIndex] );
					Tri.TangentX[DestIndex] = Tri.TangentX[DestIndex].SafeNormal();
					Tri.TangentY[DestIndex] = Tri.TangentY[DestIndex].SafeNormal();
				}
			}
		}
		DestTriangles.Unlock();
	}

	/**
	 * Creates a Simplygon scene representation of the skeletal hierarchy.
	 * @param InScene - The Simplygon scene.
	 * @param InSkeleton - The skeletal hierarchy from which to create the Simplygon representation.
	 * @param OutBoneTableIDs - A mapping of Bone IDs from RefSkeleton to Simplygon Bone Table IDs
	 */
	void CreateSkeletalHierarchy( SimplygonSDK::spScene& InScene, const TArray<FMeshBone>& InSkeleton, TArray<SimplygonSDK::rid>& OutBoneTableIDs ) 
	{
		TArray<SimplygonSDK::spSceneBone> BoneArray;
		
		//Create Simplygon scene nodes for each bone in our Skeletal Hierarchy
		for(INT BoneIndex=0; BoneIndex < InSkeleton.Num(); ++BoneIndex)
		{	
			SimplygonSDK::spSceneBone SceneBone = GSimplygonSDK->CreateSceneBone();
			BoneArray.AddItem(SceneBone);
		}

		SimplygonSDK::spSceneBoneTable BoneTable = InScene->GetBoneTable();
		for(INT BoneIndex=0; BoneIndex < InSkeleton.Num(); ++BoneIndex)
		{
			INT ParentIndex = InSkeleton(BoneIndex).ParentIndex;
			SimplygonSDK::spSceneBone CurrentBone   = BoneArray(BoneIndex);
			//We add the bone to the scene's bone table. This returns a uid that we must apply to the geometry data.
			SimplygonSDK::rid BoneID = BoneTable->AddBone(CurrentBone);
			OutBoneTableIDs.AddItem(BoneID);

			//Handle root bone. Add to Scene node.
			if(BoneIndex == 0)
			{
				InScene->GetRootNode()->AddChild(CurrentBone);
			} 
			else
			{
				SimplygonSDK::spSceneBone ParentBone = BoneArray(ParentIndex);
				ParentBone->AddChild(CurrentBone);
			}
		}
	}

	/**
	 * Creates a Simplygon geometry representation from a skeletal mesh LOD model.
	 * @param Scene - The Simplygon scene.
	 * @param LODModel - The skeletal mesh LOD model from which to create the geometry data.
	 * @param BoneIDs - A maps of Bone IDs from RefSkeleton to Simplygon BoneTable IDs
	 * @returns a Simplygon geometry data representation of the skeletal mesh LOD.
	 */
	SimplygonSDK::spGeometryData CreateGeometryFromSkeletalLODModel( SimplygonSDK::spScene& Scene, const FStaticLODModel& LODModel, const TArray<SimplygonSDK::rid>& BoneIDs )
	{
		TArray<FSoftSkinVertex> Vertices;
		FMultiSizeIndexContainerData IndexData;
		LODModel.GetVertices( Vertices );
		LODModel.MultiSizeIndexContainer.GetIndexBufferData( IndexData );

		const UINT VertexCount = LODModel.NumVertices;
		const UINT TexCoordCount = LODModel.NumTexCoords;
		check( TexCoordCount < MAX_TEXCOORDS );

		UINT TriCount = 0;
		const UINT SectionCount = LODModel.Sections.Num();
		for ( UINT SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex )
		{
			TriCount += LODModel.Sections( SectionIndex ).NumTriangles;
		}

		SimplygonSDK::spGeometryData GeometryData = GSimplygonSDK->CreateGeometryData();
		GeometryData->SetVertexCount( VertexCount );
		GeometryData->SetTriangleCount( TriCount );

		// Per-vertex data.
		GeometryData->AddBoneIds( MAX_INFLUENCES );
		GeometryData->AddBoneWeights( MAX_INFLUENCES );
		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		SimplygonSDK::spRidArray BoneIds = GeometryData->GetBoneIds();
		SimplygonSDK::spRealArray BoneWeights = GeometryData->GetBoneWeights();

		// Per-corner per-triangle data.
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRealArray TexCoords[MAX_TEXCOORDS];
		for( UINT TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex )
		{
			GeometryData->AddTexCoords( TexCoordIndex );
			TexCoords[TexCoordIndex] = GeometryData->GetTexCoords( TexCoordIndex );
			check( TexCoords[TexCoordIndex]->GetTupleSize() == 2 );
		}
		GeometryData->AddNormals();
		GeometryData->AddTangents(0);
		GeometryData->AddBitangents(0);
		SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
		SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
		SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);

		SimplygonSDK::spUnsignedCharArray Colors;
		if ( LODModel.ColorVertexBuffer.GetNumVertices() == VertexCount )
		{
			GeometryData->AddBaseTypeUserTriangleVertexField( SimplygonSDK::TYPES_ID_UCHAR, SIMPLYGON_COLOR_CHANNEL, 4 );
			SimplygonSDK::spValueArray ColorValues = GeometryData->GetUserTriangleVertexField( SIMPLYGON_COLOR_CHANNEL );
			check( ColorValues );
			Colors = SimplygonSDK::IUnsignedCharArray::SafeCast( ColorValues );
			check( Colors );
		}

		// Per-triangle data.
		GeometryData->AddMaterialIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();

		// Add per-vertex data. This data needs to be added per-chunk so that we can properly map bones.
		const INT ChunkCount = LODModel.Chunks.Num();
		UINT FirstVertex = 0;
		for ( INT ChunkIndex = 0; ChunkIndex < ChunkCount; ++ChunkIndex )
		{
			const FSkelMeshChunk& Chunk = LODModel.Chunks( ChunkIndex );
			const UINT LastVertex = FirstVertex + (UINT)Chunk.RigidVertices.Num() + (UINT)Chunk.SoftVertices.Num();
			for ( UINT VertexIndex = FirstVertex; VertexIndex < LastVertex; ++VertexIndex )
			{
				FSoftSkinVertex& Vertex = Vertices( VertexIndex );
				SimplygonSDK::rid VertexBoneIds[MAX_INFLUENCES];
				SimplygonSDK::real VertexBoneWeights[MAX_INFLUENCES];

				UINT TotalInfluence = 0;
				for ( UINT InfluenceIndex = 0; InfluenceIndex < MAX_INFLUENCES; ++InfluenceIndex )
				{
					INT BoneIndex = Vertex.InfluenceBones[InfluenceIndex];
					const BYTE BoneInfluence = Vertex.InfluenceWeights[InfluenceIndex];
					TotalInfluence += BoneInfluence;

					if ( BoneInfluence > 0 )
					{
						check( BoneIndex < Chunk.BoneMap.Num() );
						UINT BoneID = BoneIDs( Chunk.BoneMap( BoneIndex ) );
						VertexBoneIds[InfluenceIndex] = BoneID;
						VertexBoneWeights[InfluenceIndex] = BoneInfluence / 255.0f;
					}
					else
					{
						//Set BoneID and BoneWeight to -1 and 0 respectively as required by simplygon.
						VertexBoneIds[InfluenceIndex] = -1;
						VertexBoneWeights[InfluenceIndex] = 0;
					}
				}
				check( TotalInfluence == 255 );

				Positions->SetTuple( VertexIndex, (FLOAT*)&Vertex.Position );
				BoneIds->SetTuple( VertexIndex, VertexBoneIds );
				BoneWeights->SetTuple( VertexIndex, VertexBoneWeights );
			}
			FirstVertex = LastVertex;
		}

		// Add per-vertex per-triangle data.
		for ( UINT SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex )
		{
			const FSkelMeshSection& Section = LODModel.Sections( SectionIndex );
			const UINT FirstIndex = Section.BaseIndex;
			const UINT LastIndex = FirstIndex + Section.NumTriangles * 3;

			for ( UINT Index = FirstIndex; Index < LastIndex; ++Index )
			{
				DWORD VertexIndex = IndexData.Indices( Index );
				FSoftSkinVertex& Vertex = Vertices( VertexIndex );

				FVector Normal = Vertex.TangentZ;
				FVector Tangent = Vertex.TangentX;
				FVector Bitangent = Vertex.TangentY;

				Indices->SetItem( Index, VertexIndex );
				Normals->SetTuple( Index, (FLOAT*)&Normal );
				Tangents->SetTuple( Index, (FLOAT*)&Tangent );
				Bitangents->SetTuple( Index, (FLOAT*)&Bitangent );

				for( UINT TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex )
				{
					FVector2D TexCoord = Vertex.UVs[TexCoordIndex];
					TexCoords[TexCoordIndex]->SetTuple( Index, (FLOAT*)&TexCoord );
				}

				if ( Colors )
				{
					FColor Color = LODModel.ColorVertexBuffer.VertexColor( VertexIndex );
					Colors->SetTuple( Index, (UCHAR*)&Color );
				}
			}
		}

		// Add per-triangle data.
		for ( UINT SectionIndex = 0; SectionIndex < SectionCount; ++SectionIndex )
		{
			const FSkelMeshSection& Section = LODModel.Sections( SectionIndex );
			const UINT FirstTriIndex = Section.BaseIndex / 3;
			const UINT LastTriIndex = FirstTriIndex + Section.NumTriangles - 1;
			const WORD MaterialIndex = Section.MaterialIndex;
			for ( UINT TriIndex = FirstTriIndex; TriIndex <= LastTriIndex; ++TriIndex )
			{
				MaterialIndices->SetItem( TriIndex, MaterialIndex );
				check( MaterialIndices->GetItem( TriIndex) == MaterialIndex );
			}
		}

		// Create a new simplygon scene mesh object
		SimplygonSDK::spSceneMesh Mesh = GSimplygonSDK->CreateSceneMesh();

		// Assign the geometry data to the mesh
		Mesh->SetGeometry( GeometryData );

		// Add Mesh to the scene
		Scene->GetRootNode()->AddChild( Mesh );

		return GeometryData;
	}

	/**
	 * Holds data needed to create skeletal mesh skinning streams.
	 */
	struct FSkeletalMeshData
	{
		TArray<FVertInfluence> Influences;
		TArray<FMeshWedge> Wedges;
		TArray<FMeshFace> Faces;
		TArray<FVector> Points;
		UINT TexCoordCount;
	};

	/**
	 * Extracts mesh data from the Simplygon geometry representation in to a set of data usable by skeletal meshes.
	 * @param GeometryData - the Simplygon geometry.
	 * @param MeshData - the skeletal mesh output data.
	 */
	void ExtractSkeletalDataFromGeometry( const SimplygonSDK::spGeometryData& GeometryData, FSkeletalMeshData& MeshData )
	{
		TArray<FVector> PointNormals;
		TArray<UINT> PointList;
		TArray<UINT> PointInfluenceMap;

		check( GeometryData );

		SimplygonSDK::spRealArray Positions = GeometryData->GetCoords();
		SimplygonSDK::spRidArray Indices = GeometryData->GetVertexIds();
		SimplygonSDK::spRidArray MaterialIndices = GeometryData->GetMaterialIds();
		SimplygonSDK::spValueArray VertexColorValues = GeometryData->GetUserTriangleVertexField( SIMPLYGON_COLOR_CHANNEL );
		SimplygonSDK::spUnsignedCharArray VertexColors = SimplygonSDK::IUnsignedCharArray::SafeCast( VertexColorValues );
		SimplygonSDK::spRealArray Normals = GeometryData->GetNormals();
		SimplygonSDK::spRealArray Tangents = GeometryData->GetTangents(0);
		SimplygonSDK::spRealArray Bitangents = GeometryData->GetBitangents(0);
		SimplygonSDK::spRidArray BoneIds = GeometryData->GetBoneIds();
		SimplygonSDK::spRealArray BoneWeights = GeometryData->GetBoneWeights();
		SimplygonSDK::spRealArray TexCoords[MAX_TEXCOORDS];
		UINT TexCoordCount = 0;
		for( UINT TexCoordIndex = 0; TexCoordIndex < MAX_TEXCOORDS; ++TexCoordIndex )
		{
			TexCoords[TexCoordIndex] = GeometryData->GetTexCoords(TexCoordIndex);
			if ( TexCoords[TexCoordIndex] == NULL )
			{
				break;
			}
			TexCoordCount++;
		}
		MeshData.TexCoordCount = TexCoordCount;

		check( Positions );
		check( Indices );
		check( MaterialIndices );
		check( Normals );
		check( Tangents );
		check( Bitangents );
		check( BoneIds );
		check( BoneWeights );

		const UBOOL bHaveColors = (VertexColors != NULL);
		const UINT VertexCount = GeometryData->GetVertexCount();
		const UINT TriCount = GeometryData->GetTriangleCount();

		// Initialize the lists of points, wedges, and faces.
		MeshData.Points.AddZeroed( VertexCount );
		PointNormals.AddZeroed( VertexCount );
		PointList.Reserve( VertexCount );
		PointInfluenceMap.Reserve( VertexCount );
		for ( UINT PointIndex = 0; PointIndex < VertexCount; ++PointIndex )
		{
			PointList.AddItem( INDEX_NONE );
			PointInfluenceMap.AddItem( INDEX_NONE );
		}
		MeshData.Wedges.AddZeroed( TriCount * 3 );
		MeshData.Faces.AddZeroed( TriCount );

		//The number of influences may have changed if we have specified a max number of bones per vertex.
		UINT NumOfInfluences = Min<UINT>( BoneIds->GetTupleSize() , MAX_INFLUENCES );

		// Per-vertex data.
		for ( UINT VertexIndex = 0; VertexIndex < VertexCount; ++VertexIndex )
		{
			FVector& Point = MeshData.Points( VertexIndex );
			SimplygonSDK::rid VertexBoneIds[MAX_INFLUENCES];
			SimplygonSDK::real VertexBoneWeights[MAX_INFLUENCES];
			Positions->GetTuple( VertexIndex, (FLOAT*)&Point );
			BoneIds->GetTuple( VertexIndex, VertexBoneIds );
			BoneWeights->GetTuple( VertexIndex, VertexBoneWeights );
			PointInfluenceMap( VertexIndex ) = (UINT)MeshData.Influences.Num();
			for ( UINT InfluenceIndex = 0; InfluenceIndex < NumOfInfluences; ++InfluenceIndex )
			{
				const WORD BoneIndex = VertexBoneIds[InfluenceIndex];
				const FLOAT BoneWeight = VertexBoneWeights[InfluenceIndex];
				if ( InfluenceIndex == 0 || BoneWeight > 0.0f )
				{
					FVertInfluence* VertInfluence = new(MeshData.Influences) FVertInfluence;
					VertInfluence->BoneIndex = BoneIndex;
					VertInfluence->Weight = BoneWeight;
					VertInfluence->VertIndex = VertexIndex;
				}
			}
		}

		// Per-triangle and per-corner data.
		for ( UINT TriIndex = 0; TriIndex < TriCount; ++TriIndex )
		{
			// Per-triangle data.
			FMeshFace& Face = MeshData.Faces( TriIndex );
			Face.MeshMaterialIndex = MaterialIndices->GetItem( TriIndex );
			Face.bOverrideTangentBasis = FALSE;

			// Per-corner data.
			for( UINT CornerIndex = 0; CornerIndex < 3; ++CornerIndex )
			{
				const UINT WedgeIndex = TriIndex * 3 + CornerIndex;
				const UINT BasePointIndex = (UINT)Indices->GetItem( WedgeIndex );
				UINT PointIndex = BasePointIndex;

				check( BasePointIndex < (UINT)PointList.Num() );

				// Duplicate points where needed to create hard edges.
				FVector WedgeNormal;
				Normals->GetTuple( WedgeIndex, (FLOAT*)&WedgeNormal );
				WedgeNormal.Normalize();
				FVector PointNormal = PointNormals( PointIndex );
				if ( PointNormal.SizeSquared() < KINDA_SMALL_NUMBER )
				{
					PointNormals( PointIndex ) = WedgeNormal;
				}
				else
				{
					while ( (PointNormal | WedgeNormal) - 1.0f < -KINDA_SMALL_NUMBER )
					{
						PointIndex = PointList( PointIndex );
						if ( PointIndex == INDEX_NONE )
						{
							break;
						}
						check( PointIndex < (UINT)PointList.Num() );
						PointNormal = PointNormals( PointIndex );
					}

					if ( PointIndex == INDEX_NONE )
					{
						FVector Point = MeshData.Points( BasePointIndex );
						PointIndex = MeshData.Points.AddItem( Point );
						check( PointIndex == (UINT)PointList.Num() );
						check( PointIndex == (UINT)PointInfluenceMap.Num() );
						check( PointIndex == (UINT)PointNormals.Num() );
						PointNormals.AddItem( WedgeNormal );
						UINT NextPointIndex = PointList( BasePointIndex );
						check( NextPointIndex < (UINT)PointList.Num() || NextPointIndex == INDEX_NONE );
						PointList( BasePointIndex ) = PointIndex;
						PointList.AddItem( NextPointIndex );
						PointInfluenceMap.AddItem( (UINT)MeshData.Influences.Num() );

						INT InfluenceIndex = PointInfluenceMap( BasePointIndex );
						while ( MeshData.Influences( InfluenceIndex ).VertIndex == BasePointIndex )
						{
							FVertInfluence* NewVertInfluence = new( MeshData.Influences ) FVertInfluence;
							NewVertInfluence->BoneIndex = MeshData.Influences( InfluenceIndex ).BoneIndex;
							NewVertInfluence->Weight = MeshData.Influences( InfluenceIndex ).Weight;
							NewVertInfluence->VertIndex = PointIndex;
							InfluenceIndex++;
						}

						check( PointNormals.Num() == MeshData.Points.Num() );
						check( PointList.Num() == MeshData.Points.Num() );
						check( PointInfluenceMap.Num() == MeshData.Points.Num() );
					}
				}

				check( PointIndex != INDEX_NONE );
				check( ( MeshData.Points( PointIndex ) - MeshData.Points( BasePointIndex ) ).SizeSquared() == 0.0f );

				FMeshWedge& Wedge = MeshData.Wedges( WedgeIndex );
				Wedge.iVertex = PointIndex;
				for( UINT TexCoordIndex = 0; TexCoordIndex < TexCoordCount; ++TexCoordIndex )
				{
					TexCoords[TexCoordIndex]->GetTuple( WedgeIndex, (FLOAT*)&Wedge.UVs[TexCoordIndex] );
				}

				if( bHaveColors )
				{
					VertexColors->GetTuple( WedgeIndex, (BYTE *)&Wedge.Color );
				}
				else
				{
					Wedge.Color = FColor( 255, 255, 255, 255 );
				}

				Face.iWedge[CornerIndex] = WedgeIndex;
			}
		}
	}

	/**
	 * Creates a skeletal mesh LOD model from the Simplygon geometry representation.
	 * @param GeometryData - the Simplygon geometry representation from which to create a skeletal mesh LOD.
	 * @param SkeletalMesh - the skeletal mesh in to which the LOD model will be added.
	 * @param NewModel - the LOD model in to which the geometry will be stored.
	 */
	void CreateSkeletalLODModelFromGeometry( const SimplygonSDK::spGeometryData& GeometryData, USkeletalMesh* SkeletalMesh, FStaticLODModel* NewModel )
	{
		FSkeletalMeshData MeshData;

		check( GeometryData );

		ExtractSkeletalDataFromGeometry( GeometryData, MeshData );

		// Hold on to LOD0. CreateSkinningStreams only works with LOD0, so build the model in LOD0 and then move it.
		FSkeletalMeshLODInfo LODInfo0 = SkeletalMesh->LODInfo(0);
		FStaticLODModel** LODModels = SkeletalMesh->LODModels.GetTypedData();
		FStaticLODModel* LODModel0 = LODModels[0];
		LODModels[0] = NewModel;

		// Create skinning streams in LOD0.
		SkeletalMesh->CreateSkinningStreams( 
			MeshData.Influences, 
			MeshData.Wedges, 
			MeshData.Faces, 
			MeshData.Points, 
			NULL );

		// Swap LOD0 back in.
		LODModels[0] = LODModel0;
		SkeletalMesh->LODInfo(0) = LODInfo0;

		// Set vertex and texture coordinate count on the new model.
		INT TotalVertexCount = 0;
		const INT ChunkCount = NewModel->Chunks.Num();
		for ( INT ChunkIndex = 0; ChunkIndex < ChunkCount; ++ChunkIndex )
		{
			const FSkelMeshChunk& Chunk = NewModel->Chunks( ChunkIndex );
			TotalVertexCount += Chunk.NumRigidVertices;
			TotalVertexCount += Chunk.NumSoftVertices;
		}
		NewModel->NumVertices = TotalVertexCount;
		NewModel->NumTexCoords = MeshData.TexCoordCount;
		NewModel->Size = 0;
	}

	/**
	 * Sets reduction settings for Simplygon.
	 * @param Settings - The static mesh optimization settings.
	 * @param ReductionSettings - The reduction settings to set for Simplygon.
	 */
	void SetReductionSettings( const FStaticMeshOptimizationSettings& Settings, FLOAT BoundsRadius, INT SourceTriCount, SimplygonSDK::spReductionSettings ReductionSettings )
	{
		FLOAT MaxDeviation = 1.0f;
		FLOAT ReductionRatio = 1.0f;
		if(Settings.ReductionMethod == FStaticMeshOptimizationSettings::OT_MaxDeviation)
		{
			// Compute max deviation from quality.
			MaxDeviation =  Max<FLOAT>( 0.0f, Settings.MaxDeviationPercentage * BoundsRadius );

			// Set the reduction ratio such that at least 1 triangle remains.
			ReductionRatio = Max<FLOAT>( 1.0f / SourceTriCount, 0.05f );
		}
		else
		{
			MaxDeviation = SimplygonSDK::REAL_MAX;

			// Set the reduction ratio such that at least 1 triangle or 5% of the original triangles remain, whichever is larger.
			FLOAT MinTriCount =Max<FLOAT>( 1.0f / SourceTriCount, 0.05f );
			ReductionRatio = Max<FLOAT>( Settings.NumOfTrianglesPercentage, MinTriCount );
		}

		//Enable feature flags for those features where we have set an importance
		UINT FeatureFlagsMask = SimplygonSDK::SG_FEATUREFLAGS_GROUP;
		if( Settings.TextureImportance != FStaticMeshOptimizationSettings::IL_Off )
		{
			FeatureFlagsMask |= (SimplygonSDK::SG_FEATUREFLAGS_TEXTURE0 | SimplygonSDK::SG_FEATUREFLAGS_MATERIAL);
		}
		if( Settings.ShadingImportance != FStaticMeshOptimizationSettings::IL_Off )
		{
			FeatureFlagsMask |= SimplygonSDK::SG_FEATUREFLAGS_SHADING;
		}

		const FLOAT ImportanceTable[] =
		{
			0.0f,	// OFF
			0.125f,	// Lowest
			0.35f,	// Low,
			1.0f,	// Normal
			2.8f,	// High
			8.0f,	// Highest
		};

		checkAtCompileTime( ARRAY_COUNT( ImportanceTable ) == FStaticMeshOptimizationSettings::IL_Max, ImportanceTableSizeMismatch );
		check( Settings.SilhouetteImportance < FStaticMeshOptimizationSettings::IL_Max );
		check( Settings.TextureImportance < FStaticMeshOptimizationSettings::IL_Max );
		check( Settings.ShadingImportance < FStaticMeshOptimizationSettings::IL_Max);

		ReductionSettings->SetFeatureFlags( FeatureFlagsMask );
		ReductionSettings->SetMaxDeviation( MaxDeviation );
		ReductionSettings->SetReductionRatio( ReductionRatio );
		ReductionSettings->SetGeometryImportance( ImportanceTable[Settings.SilhouetteImportance] );
		ReductionSettings->SetTextureImportance( ImportanceTable[Settings.TextureImportance] );
		ReductionSettings->SetMaterialImportance( ImportanceTable[Settings.TextureImportance] );
		ReductionSettings->SetShadingImportance(  ImportanceTable[Settings.ShadingImportance] );
	}

	/**
	 * Sets reduction settings for Simplygon.
	 * @param Settings - The skeletal mesh optimization settings.
	 * @param ReductionSettings - The reduction settings to set for Simplygon.
	 */
	void SetReductionSettings( const FSkeletalMeshOptimizationSettings& Settings, FLOAT BoundsRadius, INT SourceTriCount, SimplygonSDK::spReductionSettings ReductionSettings )
	{
		FLOAT MaxDeviation = 1.0f;
		FLOAT ReductionRatio = 1.0f;
		if(Settings.ReductionMethod == SMOT_MaxDeviation)
		{
			// Compute max deviation from quality.
			MaxDeviation =  Max<FLOAT>( 0.0f, Settings.MaxDeviationPercentage * BoundsRadius );

			// Set the reduction ratio such that at least 1 triangle remains.
			ReductionRatio = Max<FLOAT>( 1.0f / SourceTriCount, 0.05f );
		}
		else
		{
			MaxDeviation = SimplygonSDK::REAL_MAX;

			// Set the reduction ratio such that at least 1 triangle or 5% of the original triangles remain, whichever is larger.
			float MinTriCount = Max<FLOAT>( 1.0f / SourceTriCount, 0.05f );
			ReductionRatio = Max<FLOAT>( Settings.NumOfTrianglesPercentage, MinTriCount );
		}

		//Enable feature flags for those features where we have set an importance
		UINT FeatureFlagsMask = SimplygonSDK::SG_FEATUREFLAGS_GROUP;
		if( Settings.TextureImportance != SMOI_Off )
		{
			FeatureFlagsMask |= (SimplygonSDK::SG_FEATUREFLAGS_TEXTURE0 | SimplygonSDK::SG_FEATUREFLAGS_MATERIAL);
		}
		if( Settings.ShadingImportance != SMOI_Off )
		{
			FeatureFlagsMask |= SimplygonSDK::SG_FEATUREFLAGS_SHADING;
		}

		const float ImportanceTable[] =
		{
			0.0f,	// OFF
			0.125f,	// Lowest
			0.35f,	// Low,
			1.0f,	// Normal
			2.8f,	// High
			8.0f,	// Highest
		};

		checkAtCompileTime( ARRAY_COUNT( ImportanceTable ) == SMOI_Max, BadImportanceTableSize );
		check( Settings.SilhouetteImportance < SMOI_Max );
		check( Settings.TextureImportance < SMOI_Max );
		check( Settings.SkinningImportance < SMOI_Max );
		check( Settings.ShadingImportance < SMOI_Max );
		
		ReductionSettings->SetFeatureFlags( FeatureFlagsMask );
		ReductionSettings->SetMaxDeviation( MaxDeviation );
		ReductionSettings->SetReductionRatio( ReductionRatio );
		ReductionSettings->SetGeometryImportance( ImportanceTable[Settings.SilhouetteImportance] );
		ReductionSettings->SetTextureImportance( ImportanceTable[Settings.TextureImportance] );
		ReductionSettings->SetMaterialImportance( ImportanceTable[Settings.TextureImportance] );
		ReductionSettings->SetShadingImportance( ImportanceTable[Settings.ShadingImportance] );
		ReductionSettings->SetSkinningImportance( ImportanceTable[Settings.SkinningImportance] );

	}

	/**
	 * Sets vertex normal settings for Simplygon.
	 * @param Settings - The static mesh optimization settings.
	 * @param NormalSettings - The normal settings to set for Simplygon.
	 */
	void SetNormalSettings( const FStaticMeshOptimizationSettings& Settings, SimplygonSDK::spNormalCalculationSettings NormalSettings )
	{
		NormalSettings->SetReplaceNormals( Settings.bRecalcNormals ? true : false );
		NormalSettings->SetScaleByArea( false );
		NormalSettings->SetScaleByAngle( false );
		NormalSettings->SetHardEdgeAngle( Settings.NormalsThreshold );
	}

	/**
	 * Sets vertex normal settings for Simplygon.
	 * @param Settings - The skeletal mesh optimization settings.
	 * @param NormalSettings - The normal settings to set for Simplygon.
	 */
	void SetNormalSettings( const FSkeletalMeshOptimizationSettings& Settings, SimplygonSDK::spNormalCalculationSettings NormalSettings )
	{
		NormalSettings->SetReplaceNormals( Settings.bRecalcNormals ? true : false );
		NormalSettings->SetScaleByArea( false );
		NormalSettings->SetScaleByAngle( false );
		NormalSettings->SetHardEdgeAngle( Settings.NormalsThreshold );
	}

	/**
	 * Sets Bone Lod settings for Simplygon.
	 * @param Settings - The skeletal mesh optimization settings.
	 * @param NormalSettings - The Bone LOD to set for Simplygon.
	 */
	void SetBoneSettings( const FSkeletalMeshOptimizationSettings& Settings, SimplygonSDK::spBoneSettings BoneSettings)
	{
		BoneSettings->SetBoneLodProcess( SimplygonSDK::SG_BONEPROCESSING_RATIO_PROCESSING );
		BoneSettings->SetBoneLodRatio ( Settings.BoneReductionRatio );
		BoneSettings->SetMaxBonePerVertex( Settings.MaxBonesPerVertex );
	}

	/**
	 * Optimizes a static mesh.
	 * @param SrcStaticMesh - The input mesh.  Can be the same as the output mesh.
	 * @param DestStaticMesh - Output mesh.  Can be the same as the input mesh.
	 * @param DestLOD - The LOD level to generate the simplified mesh for.
	 * @param Settings - The settings to use for optimizing the mesh.
	 * @returns TRUE if successful
	 */
	UBOOL OptimizeStaticMesh(
		UStaticMesh* SrcStaticMesh,
		UStaticMesh* DestStaticMesh,
		INT DestLOD,
		const FStaticMeshOptimizationSettings& InSettings )
	{
		check( SrcStaticMesh );
		check( DestStaticMesh );

		InitSimplygonSDK();
		if ( !GSimplygonSDK || SrcStaticMesh->LODModels.Num() == 0 )
		{
			return FALSE;
		}

		FStaticMeshRenderData& SourceLOD = SrcStaticMesh->PreModifyMesh();
		const INT SourceTriCount = SourceLOD.RawTriangles.GetElementCount();
		const INT ProcessedTriCount = Min( SourceLOD.NumVertices, SourceLOD.VertexBuffer.GetNumVertices() );
		if ( SourceTriCount == 0 )
		{
			// Can not continue without triangle info since building static mesh LOD resources requires this data.
			return TRUE;
		}

		FStaticMeshOptimizationSettings Settings = InSettings;

		// If we don't have raw triangles we can't preserve smoothing groups. Force normals to be recalculated by Simplygon.
		if ( Settings.bRecalcNormals == FALSE && SourceTriCount == 0 )
		{
			appMsgf( AMT_OK, *FString::Printf( LocalizeSecure( LocalizeUnrealEd( "MeshSimp_NoRawTriangles_F" ), *SrcStaticMesh->GetName() ) ) );
			Settings.bRecalcNormals = TRUE;
			Settings.NormalsThreshold = 60.0f;
		}

		SimplygonSDK::spGeometryData GeometryData;
		const bool bUsingMaxDeviation = (Settings.ReductionMethod == FStaticMeshOptimizationSettings::OT_MaxDeviation && Settings.MaxDeviationPercentage > 0.0f);
		const bool bUsingReductionRatio = (Settings.ReductionMethod == FStaticMeshOptimizationSettings::OT_NumOfTriangles && Settings.NumOfTrianglesPercentage < 1.0f);
		const bool bOptimizeMesh = ( bUsingMaxDeviation || bUsingReductionRatio );
		if ( bOptimizeMesh )
		{
			FDefaultEventHandler SimplygonEventHandler;
			if ( Settings.bRecalcNormals == FALSE )
			{
				check( SourceTriCount > 0 );
				GeometryData = CreateGeometryFromTriangleBulkData( SourceLOD.RawTriangles );
			}
			else
			{
				check( ProcessedTriCount > 0 );
				GeometryData = CreateGeometryFromLODModel( SourceLOD );
			}
			check( GeometryData );
			SimplygonSDK::spReductionProcessor ReductionProcessor = GSimplygonSDK->CreateReductionProcessor();
			ReductionProcessor->AddObserver( &SimplygonEventHandler, SimplygonSDK::SG_EVENT_PROGRESS );
			ReductionProcessor->SetGeometry( GeometryData );

			SimplygonSDK::spRepairSettings RepairSettings = ReductionProcessor->GetRepairSettings();
			RepairSettings->SetWeldDist( Settings.WeldingThreshold );
			RepairSettings->SetTjuncDist( Settings.WeldingThreshold );

			SimplygonSDK::spReductionSettings ReductionSettings = ReductionProcessor->GetReductionSettings();
			SetReductionSettings( Settings, SrcStaticMesh->Bounds.SphereRadius, GeometryData->GetTriangleCount(), ReductionSettings );

			SimplygonSDK::spNormalCalculationSettings NormalSettings = ReductionProcessor->GetNormalCalculationSettings();
			SetNormalSettings( Settings, NormalSettings );			

			ReductionProcessor->RunProcessing();

			// If we are trying to preserve smoothing groups, make sure normals don't exist.
			if ( Settings.bRecalcNormals == FALSE )
			{
				GeometryData->RemoveNormals();
			}
		}

		// Add dummy LODs if the LOD being inserted is not the next one in the array
		while( DestStaticMesh->LODModels.Num() < DestLOD )
		{
			new(DestStaticMesh->LODModels) FStaticMeshRenderData();
		}
		while( DestStaticMesh->LODInfo.Num() <= DestLOD )
		{
			DestStaticMesh->LODInfo.AddItem( FStaticMeshLODInfo() );
		}

		// Create the new LOD if necessary.
		check( DestLOD <= DestStaticMesh->LODModels.Num() );
		if ( DestStaticMesh->LODModels.Num() == DestLOD )
		{
			FStaticMeshRenderData* NewLOD = new(DestStaticMesh->LODModels) FStaticMeshRenderData();
			NewLOD->Elements = SrcStaticMesh->LODModels(0).Elements;
		}

		FStaticMeshRenderData& NewLOD = DestStaticMesh->LODModels( DestLOD );
		if ( bOptimizeMesh )
		{
			CreateTrianglesFromGeometry( GeometryData, WINDING_Keep, NewLOD.RawTriangles );
			DestStaticMesh->bHasBeenSimplified = TRUE;
		}
		else
		{
			FStaticMeshTriangleBulkData& SourceTriangles = SourceLOD.RawTriangles;
			const BYTE* SrcTriangles = (const BYTE*)SourceTriangles.Lock( LOCK_READ_ONLY );
			NewLOD.RawTriangles.Lock( LOCK_READ_WRITE );
			BYTE* DestTriangles = (BYTE*)NewLOD.RawTriangles.Realloc( SourceTriangles.GetElementCount() );
			appMemcpy( DestTriangles, SrcTriangles, SourceTriangles.GetBulkDataSize() );
			NewLOD.RawTriangles.Unlock();
			SourceTriangles.Unlock();
		}
		DestStaticMesh->Build();
		DestStaticMesh->SetOptimizationSettings( DestLOD, Settings );
		return TRUE;
	}

	/**
	 * Optimizes a skeletal mesh.
	 * @param SkeletalMesh - The skeletal mesh to optimize.
	 * @param LODIndex - The LOD to optimize.
	 * @param Settings - Settings that control the optimization process.
	 * @return TRUE if successful.
	 */
	UBOOL OptimizeSkeletalMesh(
		USkeletalMesh* SkeletalMesh,
		INT LODIndex,
		const FSkeletalMeshOptimizationSettings& Settings )
	{
		check( SkeletalMesh );
		check( LODIndex >= 0 );
		check( LODIndex <= SkeletalMesh->LODModels.Num() );
		check( LODIndex <= SkeletalMesh->LODInfo.Num() );

		InitSimplygonSDK();
		if ( !GSimplygonSDK )
		{
			return FALSE;
		}

		const UBOOL bUsingMaxDeviation = (Settings.ReductionMethod == SMOT_MaxDeviation && Settings.MaxDeviationPercentage > 0.0f);
		const UBOOL bUsingReductionRatio = (Settings.ReductionMethod == SMOT_NumOfTriangles && Settings.NumOfTrianglesPercentage < 1.0f);
		const UBOOL bProcessGeometry = ( bUsingMaxDeviation || bUsingReductionRatio );
		const UBOOL bProcessBones = (Settings.BoneReductionRatio < 1.0f || Settings.MaxBonesPerVertex < 4);
		const UBOOL bOptimizeMesh = (bProcessGeometry || bProcessBones);

		FStaticLODModel& SrcModel = SkeletalMesh->PreModifyMesh();

		const UBOOL bLODHasVertexInfluences = LODIndex < SkeletalMesh->LODModels.Num() && SkeletalMesh->LODModels( LODIndex ).VertexInfluences.Num();
		const UBOOL bSrcHasVertexInfluences = LODIndex == SkeletalMesh->LODModels.Num() && SrcModel.VertexInfluences.Num();
		if ( bOptimizeMesh && ( bLODHasVertexInfluences || bSrcHasVertexInfluences ) )
		{
			FString WarningMsg = bLODHasVertexInfluences ?
				*FString::Printf( LocalizeSecure( LocalizeUnrealEd( "MeshSimp_LODVertexInfluenceWarning" ), LODIndex, *SkeletalMesh->GetName() ) ) :
				*FString::Printf( LocalizeSecure( LocalizeUnrealEd( "MeshSimp_SrcVertexInfluenceWarning" ), *SkeletalMesh->GetName() ) );
			if ( appMsgf( AMT_OKCancel, *WarningMsg ) == 0 )
			{
				return TRUE;
			}
		}

		FSkeletalMeshComponentReattachContext ComponentReattachContext( SkeletalMesh );
		SkeletalMesh->ReleaseResources();
		SkeletalMesh->ReleaseResourcesFence.Wait();

		// Insert a new LOD model entry if needed.
		if ( LODIndex == SkeletalMesh->LODModels.Num() )
		{
			SkeletalMesh->LODModels.AddRawItem(0);
		}

		// Swap in a new model, delete the old.
		check( LODIndex < SkeletalMesh->LODModels.Num() );
		FStaticLODModel** LODModels = SkeletalMesh->LODModels.GetTypedData();
		delete LODModels[LODIndex];
		FStaticLODModel* NewModel = new FStaticLODModel();
		LODModels[LODIndex] = NewModel;

		if ( bOptimizeMesh )
		{
			//Create a simplygon scene. The scene by default contains a bone table that is required for bone reduction.
			SimplygonSDK::spScene Scene = GSimplygonSDK->CreateScene();
			check( Scene );

			// Create bone hierarchy for simplygon.
			TArray<SimplygonSDK::rid> BoneTableIDs; 
			CreateSkeletalHierarchy(Scene, SkeletalMesh->RefSkeleton, BoneTableIDs);

			// Create a new scene mesh object
			SimplygonSDK::spGeometryData GeometryData = CreateGeometryFromSkeletalLODModel( Scene, SrcModel, BoneTableIDs );
			check( GeometryData );

			FDefaultEventHandler SimplygonEventHandler;
			SimplygonSDK::spReductionProcessor ReductionProcessor = GSimplygonSDK->CreateReductionProcessor();
			ReductionProcessor->AddObserver( &SimplygonEventHandler, SimplygonSDK::SG_EVENT_PROGRESS );
			ReductionProcessor->SetSceneRoot(Scene->GetRootNode());

			SimplygonSDK::spRepairSettings RepairSettings = ReductionProcessor->GetRepairSettings();
			RepairSettings->SetWeldDist( Settings.WeldingThreshold );
			RepairSettings->SetTjuncDist( Settings.WeldingThreshold );

			SimplygonSDK::spReductionSettings ReductionSettings = ReductionProcessor->GetReductionSettings();
			SetReductionSettings( Settings, SkeletalMesh->Bounds.SphereRadius, GeometryData->GetTriangleCount(), ReductionSettings );

			SimplygonSDK::spNormalCalculationSettings NormalSettings = ReductionProcessor->GetNormalCalculationSettings();
			SetNormalSettings( Settings, NormalSettings );

			if(bProcessBones)
			{
				SimplygonSDK::spBoneSettings BoneSettings = ReductionProcessor->GetBoneSettings();
				SetBoneSettings( Settings, BoneSettings );
			}

			ReductionProcessor->RunProcessing();

			CreateSkeletalLODModelFromGeometry( GeometryData, SkeletalMesh, NewModel );

			SkeletalMesh->bHasBeenSimplified = TRUE;
		}
		else // Restore source model.
		{
			// Bulk data arrays need to be locked before a copy can be made.
			SrcModel.RawPointIndices.Lock( LOCK_READ_ONLY );
			SrcModel.LegacyRawPointIndices.Lock( LOCK_READ_ONLY );
			*NewModel = SrcModel;
			SrcModel.RawPointIndices.Unlock();
			SrcModel.LegacyRawPointIndices.Unlock();

			// The index buffer needs to be rebuilt on copy.
			FMultiSizeIndexContainerData IndexBufferData;
			SrcModel.MultiSizeIndexContainer.GetIndexBufferData( IndexBufferData );
			NewModel->MultiSizeIndexContainer.RebuildIndexBuffer( IndexBufferData );

			// Required bones are recalculated later on.
			NewModel->RequiredBones.Empty();

		}

		// Copy over LOD info from LOD0 if there is no previous info.
		if ( LODIndex == SkeletalMesh->LODInfo.Num() )
		{
			FSkeletalMeshLODInfo* NewLODInfo = new( SkeletalMesh->LODInfo ) FSkeletalMeshLODInfo;
			FSkeletalMeshLODInfo& OldLODInfo = SkeletalMesh->LODInfo(0);
			*NewLODInfo = OldLODInfo;
		}

		// Ensure the size of the bEnableShadowCasting array matches the number of sections.
		const INT NewSectionCount = NewModel->Sections.Num();
		FSkeletalMeshLODInfo& LODInfo = SkeletalMesh->LODInfo( LODIndex );
		while ( LODInfo.bEnableShadowCasting.Num() > NewSectionCount )
		{
			LODInfo.bEnableShadowCasting.RemoveSwap( LODInfo.bEnableShadowCasting.Num() - 1 );
		}
		while ( LODInfo.bEnableShadowCasting.Num() < NewSectionCount )
		{
			LODInfo.bEnableShadowCasting.AddItem( TRUE );
		}

		// Flag this LOD as having been simplified.
		SkeletalMesh->LODInfo( LODIndex ).bHasBeenSimplified = bOptimizeMesh;

		SkeletalMesh->CalculateRequiredBones( LODIndex );
		SkeletalMesh->PostEditChange();
		SkeletalMesh->InitResources();
		SkeletalMesh->SetOptimizationSettings( LODIndex, Settings );

		return TRUE;
	}

#if ENABLE_SIMPLYGON_MESH_PROXIES

	/**
	 * Returns raw triangles for the mesh component in world space.
	 * @param MeshComponent - The mesh component for which to get triangles.
	 * @param Origin - The origin at which to place transformed triangles.
	 * @param WindingMode - Whether windings need to be reversed or not.
	 * @param bIgnoreVertexColors - Ignore vertex colors on the mesh.
	 * @param OutUniqueMaterials - Unique materials used by the mesh component are added to the array.
	 * @param OutTriangles - Triangles from the mesh component transformed to world space.
	 */
	void GetTrianglesForComponent( UStaticMeshComponent* MeshComponent, const FVector& Origin, EWindingMode WindingMode, UBOOL bIgnoreVertexColors, TArray<UMaterialInterface*>& OutUniqueMaterials, TArray<FStaticMeshTriangle>& OutTriangles )
	{
		check( MeshComponent );
		check( MeshComponent->StaticMesh );
		check( MeshComponent->StaticMesh->LODModels.Num() );

		const INT TexCoordCount = 1;
		FMatrix ComponentToWorld = MeshComponent->LocalToWorld.ConcatTranslation( -Origin );
		FMatrix ComponentToWorldInverseTranspose = ComponentToWorld.Inverse().Transpose();
		const UBOOL bReverseWindingForSimplygon = (WindingMode == WINDING_Reverse);
		const UBOOL bReverseWinding = (MeshComponent->LocalToWorldDeterminant < 0.0f) ^ bReverseWindingForSimplygon;
		UStaticMesh* SrcMesh = MeshComponent->StaticMesh;
		FStaticMeshRenderData& SrcModel = SrcMesh->LODModels(0);

		const UINT VertexCount = SrcModel.NumVertices;
		const UBOOL bHaveColors = (SrcModel.ColorVertexBuffer.GetNumVertices() == VertexCount) && !bIgnoreVertexColors;
		const UBOOL bHaveTexCoord = SrcModel.VertexBuffer.GetNumTexCoords() > 0;
		const INT ElementCount = SrcModel.Elements.Num();
		for ( INT ElementIndex = 0; ElementIndex < ElementCount; ++ElementIndex )
		{
			const FStaticMeshElement& Element = SrcModel.Elements( ElementIndex );
			const INT SrcMaterialIndex = Element.MaterialIndex;
			UMaterialInterface* ElementMaterial = MeshComponent->GetMaterial( ElementIndex );
			if ( ElementMaterial )
			{
				const INT DestMaterialIndex = OutUniqueMaterials.AddUniqueItem( ElementMaterial );
				const INT TriCount = Element.NumTriangles;
				INT BaseIndex = Element.FirstIndex;
				for ( INT TriIndex = 0; TriIndex < TriCount; ++TriIndex )
				{
					FStaticMeshTriangle* DestTri = new( OutTriangles ) FStaticMeshTriangle;
					appMemZero( *DestTri );
					DestTri->MaterialIndex = DestMaterialIndex;
					DestTri->NumUVs = TexCoordCount;
					DestTri->bOverrideTangentBasis = TRUE;
					DestTri->bExplicitNormals = TRUE;
					for ( INT CornerIndex = 0; CornerIndex < 3; ++CornerIndex )
					{
						const INT IndexIndex = BaseIndex + (bReverseWinding ? (2 - CornerIndex) : (CornerIndex));
						const INT SrcIndex = SrcModel.IndexBuffer.Indices( IndexIndex );

						FVector Position = SrcModel.PositionVertexBuffer.VertexPosition( SrcIndex );
						FVector Normal = SrcModel.VertexBuffer.VertexTangentZ( SrcIndex );
						FVector Tangent = SrcModel.VertexBuffer.VertexTangentX( SrcIndex );
						FVector Bitangent = SrcModel.VertexBuffer.VertexTangentY( SrcIndex );

						DestTri->Vertices[CornerIndex] = ComponentToWorld.TransformFVector( Position );
						DestTri->TangentX[CornerIndex] = ComponentToWorldInverseTranspose.TransformNormal( Tangent ).SafeNormal();
						DestTri->TangentY[CornerIndex] = ComponentToWorldInverseTranspose.TransformNormal( Bitangent ).SafeNormal();
						DestTri->TangentZ[CornerIndex] = ComponentToWorldInverseTranspose.TransformNormal( Normal ).SafeNormal();
						DestTri->Colors[CornerIndex] = bHaveColors ? SrcModel.ColorVertexBuffer.VertexColor( SrcIndex ) : FColor( 0xffffffff );
						DestTri->UVs[CornerIndex][0] = bHaveTexCoord ? SrcModel.VertexBuffer.GetVertexUV( SrcIndex, 0 ) : FVector2D( 0.0f, 0.0f );
					}
					BaseIndex += 3;
				}
			}
		}
	}

	/**
	 * Clears the alpha channel of a texture to 255.
	 * @param TextureData - Raw texture data.
	 * @param SizeX - Width of the texture.
	 * @param SizeY - Height of the texture.
	 */
	void ClearAlphaChannel( BYTE* TextureData, INT SizeX, INT SizeY )
	{
		FColor* Texels = (FColor*)TextureData;
		const INT TexelCount = SizeX * SizeY;
		for ( INT TexelIndex = 0; TexelIndex < TexelCount; ++TexelIndex )
		{
			Texels[TexelIndex].A = 255;
		}
	}

	/**
	 * Flattens a material to a Simplygon image.
	 * @param MaterialInterface - The material to flatten.
	 * @param FlattenType - How to flatten the material.
	 * @returns the Simplygon image.
	 */
	SimplygonSDK::spImageData FlattenMaterial( UMaterialInterface* MaterialInterface, EFlattenType FlattenType )
	{
		UTexture2D* Texture = FlattenMaterialToTexture(
			MaterialInterface,
			FlattenType,
			UObject::MakeUniqueObjectName( UObject::GetTransientPackage(), UTexture2D::StaticClass() ).GetNameString(),
			UObject::GetTransientPackage(),
			0 );
		check( Texture->Mips.Num() > 0 );

		// Grab the texture data.
		FTexture2DMipMap& Mip = Texture->Mips(0);
		check( Mip.SizeX == Texture->SizeX );
		check( Mip.SizeY == Texture->SizeY );
		BYTE* TextureData = (BYTE*)Mip.Data.Lock( LOCK_READ_WRITE );

		// Remove the alpha channel if this is a normal texture.
		if ( FlattenType == FLATTEN_NormalTexture )
		{
			ClearAlphaChannel( TextureData, Mip.SizeX, Mip.SizeY );
		}

		// Convert the texture to Simplygon's internal representation.
		const INT TexelCount = Texture->SizeX * Texture->SizeY;
		const INT TexelStride = sizeof(FColor);
		const INT ChannelCount = (FlattenType == FLATTEN_NormalTexture) ? 3 : 4;
		SimplygonSDK::spImageData Image = GSimplygonSDK->CreateImageData();
		Image->AddColors( 
			SimplygonSDK::TYPES_ID_UCHAR,
			(ChannelCount == 3) ? SimplygonSDK::SG_IMAGEDATA_FORMAT_RGB : SimplygonSDK::SG_IMAGEDATA_FORMAT_RGBA
			);
		Image->Set2DSize( Texture->SizeX, Texture->SizeY );
		SimplygonSDK::spUnsignedCharArray ImageColors = SimplygonSDK::SafeCast<SimplygonSDK::IUnsignedCharArray>( Image->GetColors() );
		check( ImageColors->GetTupleSize() == ChannelCount );
		for ( INT TexelIndex = 0; TexelIndex < TexelCount; ++TexelIndex )
		{
			unsigned char DestTexel[4];

			DestTexel[0] = ((FColor*)TextureData)->R;
			DestTexel[1] = ((FColor*)TextureData)->G;
			DestTexel[2] = ((FColor*)TextureData)->B;
			if ( ChannelCount == 4 )
			{
				DestTexel[3] = ((FColor*)TextureData)->A;
			}

			ImageColors->SetTuple( TexelIndex, DestTexel );
			TextureData += TexelStride;
		}
		Mip.Data.Unlock();
		return Image;
	}

	/**
	 * Constructs a Simplygon material table using flattened versions of the source materials.
	 * @param UniqueMaterials - The set of unique materials from which to construct the table.
	 * @param MaterialType - What type of material to generate.
	 * @returns The material table.
	 */
	SimplygonSDK::spMaterialTable BuildMaterialTable( const TArray<UMaterialInterface*>& UniqueMaterials, EMeshProxyMaterialType MaterialType )
	{
		SimplygonSDK::spMaterialTable MaterialTable = GSimplygonSDK->CreateMaterialTable();
		const INT MaterialCount = UniqueMaterials.Num();
		for ( INT MaterialIndex = 0; MaterialIndex < MaterialCount; ++MaterialIndex )
		{
			SimplygonSDK::spMaterial SimplygonMaterial = GSimplygonSDK->CreateMaterial();
			SimplygonSDK::spImageData BaseImage = FlattenMaterial( UniqueMaterials(MaterialIndex), FLATTEN_DiffuseTexture );
			SimplygonMaterial->SetTextureImage( SimplygonSDK::SG_MATERIAL_TEXTURE_DIFFUSE, BaseImage );

			// Also generate a normal map if needed.
			if ( MaterialType == MPMT_DiffuseAndNormal )
			{
				SimplygonSDK::spImageData NormalImage = FlattenMaterial( UniqueMaterials(MaterialIndex), FLATTEN_NormalTexture );
				SimplygonMaterial->SetTextureImage( SimplygonSDK::SG_MATERIAL_TEXTURE_NORMALS, NormalImage );
				SimplygonMaterial->SetTangentSpaceNormals( true );
			}

			MaterialTable->AddItem( SimplygonMaterial );
		}

		return MaterialTable;
	}

	/**
	 * Creates a texture from a Simplygon image.
	 * @param Image - The Simplygon image.
	 * @param Package - The package in which to create the loaded texture.
	 * @returns The texture.
	 */
	UTexture2D* CreateTextureFromImage( SimplygonSDK::spImageData Image, UPackage* Package )
	{
		FName TextureName = UObject::MakeUniqueObjectName( Package, UTexture2D::StaticClass(), TEXT("MeshProxyTexture") );
		const INT SizeX = Image->GetXSize();
		const INT SizeY = Image->GetYSize();
		SimplygonSDK::spUnsignedCharArray ImageColors = SimplygonSDK::SafeCast<SimplygonSDK::IUnsignedCharArray>( Image->GetColors() );
		const INT ChannelCount = ImageColors->GetTupleSize();

		// Construct the texture.
		UTexture2D* Texture = ConstructObject<UTexture2D>( UTexture2D::StaticClass(), Package, TextureName, RF_Public );
		Texture->Init( SizeX, SizeY, PF_A8R8G8B8 );
		{
			check( Texture->Mips.Num() == 1 );
			FTexture2DMipMap& Mip = Texture->Mips(0);
			check( Mip.SizeX == SizeX );
			check( Mip.SizeY == SizeY );
			FColor* Texels = (FColor*)Mip.Data.Lock( LOCK_READ_WRITE );
			const INT TexelCount = SizeX * SizeY;
			for ( INT TexelIndex = 0; TexelIndex < TexelCount; ++TexelIndex )
			{
				unsigned char SrcTexel[4];
				ImageColors->GetTuple( TexelIndex, SrcTexel );

				Texels[TexelIndex].R = SrcTexel[0];
				Texels[TexelIndex].G = SrcTexel[1];
				Texels[TexelIndex].B = SrcTexel[2];
				if( ChannelCount == 4 )
				{
					Texels[TexelIndex].A = SrcTexel[3];
				}
				else
				{
					Texels[TexelIndex].A = 255;
				}
			}
			Mip.Data.Unlock();
		}
		return Texture;
	}

	/**
	 * Reprojects texture information from the original mesh to the new mesh and constructs a material with which to render the texture.
	 * @param MaterialTable - The Simplygon material table representing the original materials.
	 * @param MappingImage - The mapping image created during the remeshing process.
	 * @param MaterialType - What type of material to generate.
	 * @param BlendMode - The blend mode for the proxy material.
	 * @param Package - The package in which the material and texture will be created.
	 * @returns The material.
	 */
	UMaterial* ConstructProxyMaterial( SimplygonSDK::spMaterialTable MaterialTable, SimplygonSDK::spMappingImage MappingImage, EMeshProxyMaterialType MaterialType, EBlendMode BlendMode, UPackage* Package )
	{
		// Cast the data using a color caster
		SimplygonSDK::spColorCaster ColorCaster = GSimplygonSDK->CreateColorCaster();
		SimplygonSDK::spImageData BaseImage = GSimplygonSDK->CreateImageData();
		ColorCaster->SetColorType( SimplygonSDK::SG_MATERIAL_TEXTURE_DIFFUSE );
		ColorCaster->SetSourceMaterials( MaterialTable );
		ColorCaster->SetMappingImage( MappingImage );
		ColorCaster->SetOutputChannels( BlendMode == BLEND_Opaque ? 3 : 4 );
		ColorCaster->SetOutputChannelBitDepth( 8 );
		ColorCaster->SetDilation( 10 );
		ColorCaster->SetOutputImage( BaseImage );
		ColorCaster->CastMaterials();

		// Create a texture from the output image.
		UTexture2D* BaseTexture = CreateTextureFromImage( BaseImage, Package );
		if ( BaseTexture )
		{
			BaseTexture->SRGB = TRUE;
			BaseTexture->DeferCompression = TRUE;
			BaseTexture->CompressionSettings = TC_Default;
			BaseTexture->Filter = TF_Linear;
			BaseTexture->LODGroup = TEXTUREGROUP_World;
			BaseTexture->MipGenSettings = TMGS_FromTextureGroup;
			BaseTexture->AddressX = TA_Clamp;
			BaseTexture->AddressY = TA_Clamp;
			BaseTexture->PostEditChange();
		}

		// Generate the normal map is needed.
		UTexture2D* NormalTexture = NULL;
		if ( MaterialType == MPMT_DiffuseAndNormal )
		{
			SimplygonSDK::spNormalCaster NormalCaster = GSimplygonSDK->CreateNormalCaster();
			SimplygonSDK::spImageData NormalImage = GSimplygonSDK->CreateImageData();
			NormalCaster->SetSourceMaterials( MaterialTable );
			NormalCaster->SetMappingImage( MappingImage );
			NormalCaster->SetOutputChannels( 3 );
			NormalCaster->SetOutputChannelBitDepth( 8 );
			NormalCaster->SetDilation( 10 );
			NormalCaster->SetGenerateTangentSpaceNormals( true );
			NormalCaster->SetFlipBackfacingNormals( false );
			NormalCaster->SetOutputImage( NormalImage );
			NormalCaster->CastMaterials();

			// Open the output file.
			NormalTexture = CreateTextureFromImage( NormalImage, Package );
			if ( NormalTexture )
			{
				NormalTexture->SRGB = FALSE;
				NormalTexture->DeferCompression = TRUE;
				NormalTexture->CompressionSettings = TC_Normalmap;
				NormalTexture->Filter = TF_Linear;
				NormalTexture->LODGroup = TEXTUREGROUP_WorldNormalMap;
				NormalTexture->MipGenSettings = TMGS_FromTextureGroup;
				NormalTexture->AddressX = TA_Clamp;
				NormalTexture->AddressY = TA_Clamp;
				NormalTexture->UnpackMin[0] = -1.0f;
				NormalTexture->UnpackMin[1] = -1.0f;
				NormalTexture->UnpackMin[2] = -1.0f;
				NormalTexture->UnpackMin[3] = +0.0f;
				NormalTexture->UnpackMax[0] = +1.0f;
				NormalTexture->UnpackMax[1] = +1.0f;
				NormalTexture->UnpackMax[2] = +1.0f;
				NormalTexture->UnpackMax[3] = +1.0f;
				NormalTexture->PostEditChange();
			}
		}

		// Create the material.
		UMaterial* Material = NULL;
		if ( BaseTexture )
		{
			FName MaterialName = UObject::MakeUniqueObjectName( Package, UMaterial::StaticClass(), TEXT("MeshProxyMaterial") );

			UMaterialFactoryNew* Factory = new UMaterialFactoryNew();
			Material = (UMaterial*)Factory->FactoryCreateNew( UMaterial::StaticClass(), Package, MaterialName, RF_Public, NULL, GWarn );
			Material->TwoSided	= FALSE;
			Material->BlendMode = BlendMode;
			Material->LightingModel = MLM_Phong;

			UMaterialExpressionTextureSample* Expression = ConstructObject<UMaterialExpressionTextureSample>( UMaterialExpressionTextureSample::StaticClass(), Material );
			Expression->Texture = BaseTexture;
			Material->Expressions.AddItem( Expression );
			Material->DiffuseColor.Expression = Expression;

			TArray<FExpressionOutput> Outputs;
			Outputs = Material->DiffuseColor.Expression->GetOutputs();
			FExpressionOutput* Output = &Outputs(0);
			Material->DiffuseColor.Mask = Output->Mask;
			Material->DiffuseColor.MaskR = Output->MaskR;
			Material->DiffuseColor.MaskG = Output->MaskG;
			Material->DiffuseColor.MaskB = Output->MaskB;
			Material->DiffuseColor.MaskA = Output->MaskA;

			if ( BlendMode == BLEND_Masked )
			{
				Material->OpacityMask.Expression = Expression;
				Outputs = Material->OpacityMask.Expression->GetOutputs();
				check( Outputs.Num() >= 5 ); // Texture Expressions have 5 outputs: RGB, R, G, B, A.
				Output = &Outputs(4);
				Material->OpacityMask.Mask = Output->Mask;
				Material->OpacityMask.MaskR = Output->MaskR;
				Material->OpacityMask.MaskG = Output->MaskG;
				Material->OpacityMask.MaskB = Output->MaskB;
				Material->OpacityMask.MaskA = Output->MaskA;
			}

			if ( NormalTexture )
			{
				UMaterialExpressionTextureSample* Expression = ConstructObject<UMaterialExpressionTextureSample>( UMaterialExpressionTextureSample::StaticClass(), Material );
				Expression->Texture = NormalTexture;
				Material->Expressions.AddItem( Expression );
				Material->Normal.Expression = Expression;

				Outputs = Material->Normal.Expression->GetOutputs();
				FExpressionOutput* Output = &Outputs(0);
				Material->Normal.Mask = Output->Mask;
				Material->Normal.MaskR = Output->MaskR;
				Material->Normal.MaskG = Output->MaskG;
				Material->Normal.MaskB = Output->MaskB;
				Material->Normal.MaskA = Output->MaskA;
			}

			Material->MobileBaseTexture = BaseTexture;
			Material->MobileNormalTexture = NormalTexture;
			Material->PostEditChange();
		}

		return Material;
	}

	/**
	 * Creates a mesh proxy for the provided mesh instances.
	 * @param MeshComponentsToMerge - The mesh instances for which the proxy will be created.
	 * @param MaterialType - What type of material to generate for the mesh proxy.
	 * @param OnScreenSizeInPixels - The on-screen size in pixels at which the mesh will be viewed.
	 * @param DesiredTextureSize - The size of the texture to use for the proxy mesh.
	 * @param VertexColorMode - How to deal with the meshes vertex colors.
	 * @param MeshProxyPackage - The package in to which the mesh proxy will be created.
	 * @param OutMeshProxy - The mesh proxy that has been created.
	 * @param OutProxyLocation - The location at which to place the proxy.
	 * @return TRUE if successful.
	 */
	UBOOL CreateMeshProxy(
		const TArray<UStaticMeshComponent*> MeshComponentsToMerge,
		EMeshProxyMaterialType MaterialType,
		INT OnScreenSizeInPixels,
		INT DesiredTextureSize,
		EMeshProxyVertexColorMode VertexColorMode,
		UPackage* MeshProxyPackage,
		UStaticMesh** OutMeshProxy,
		FVector* OutProxyLocation )
	{
		check( MeshComponentsToMerge.Num() );
		check( MeshProxyPackage );
		check( OutMeshProxy );
		check( OutProxyLocation );

		InitSimplygonSDK();
		if ( GSimplygonSDK == NULL )
		{
			return FALSE;
		}

		// Determine the bounds and center location for the proxy.
		FBox ProxyBounds;
		ProxyBounds.Init();
		const INT ComponentCount = MeshComponentsToMerge.Num();
		INT SrcTriCount = 0;
		for ( INT ComponentIndex = 0; ComponentIndex < ComponentCount; ++ComponentIndex )
		{
			UStaticMeshComponent* MeshComponent = MeshComponentsToMerge( ComponentIndex );
			check( MeshComponent );
			check( MeshComponent->StaticMesh );
			check( MeshComponent->StaticMesh->LODModels.Num() );
			ProxyBounds += MeshComponent->Bounds.GetBox();
			SrcTriCount += MeshComponent->StaticMesh->LODModels(0).RawTriangles.GetElementCount();
		}
		FVector ProxyLocation = ProxyBounds.GetCenter();

		// Retrieve source triangles and a set of unique materials for the source meshes.
		TArray<UMaterialInterface*> UniqueMaterials;
		TArray<FStaticMeshTriangle> Triangles;
		Triangles.Reserve( SrcTriCount );
		for ( INT ComponentIndex = 0; ComponentIndex < ComponentCount; ++ComponentIndex )
		{
			UStaticMeshComponent* MeshComponent = MeshComponentsToMerge( ComponentIndex );
			GetTrianglesForComponent(
				MeshComponent,
				ProxyLocation,
				WINDING_Reverse,
				/*bIgnoreVertexColors=*/ (VertexColorMode == MPVCM_Ignore),
				UniqueMaterials,
				Triangles );
		}

		// Build the Simplygon geometry representation.
		SimplygonSDK::spGeometryData Geometry = CreateGeometryFromTriangles( Triangles.GetTypedData(), (UINT)Triangles.Num() );
		check( Geometry );

		// Put the aggregate mesh in to a Simplygon scene graph.
		SimplygonSDK::spScene Scene = GSimplygonSDK->CreateScene();
		SimplygonSDK::spSceneMesh SceneMesh = GSimplygonSDK->CreateSceneMesh();
		SceneMesh->SetGeometry( Geometry );
		SceneMesh->SetName( "UnrealMesh" );
		Scene->GetRootNode()->AddChild( SceneMesh );

		// Remesh.
		SimplygonSDK::spMappingImage MappingImage;
		{
			SimplygonSDK::spRemeshingProcessor Remesher = GSimplygonSDK->CreateRemeshingProcessor();
			SimplygonSDK::spRemeshingSettings RemeshSettings = Remesher->GetRemeshingSettings();
			SimplygonSDK::spMappingImageSettings MappingSettings = Remesher->GetMappingImageSettings();
			RemeshSettings->SetOnScreenSize( OnScreenSizeInPixels );
			RemeshSettings->SetGroundPlaneAxisIndex( 2 );
			RemeshSettings->SetGroundPlaneLevel( ProxyBounds.Min.Z - ProxyLocation.Z );
			MappingSettings->SetGenerateMappingImage( true );
			MappingSettings->SetGenerateTexCoords( true );
			MappingSettings->SetGenerateTangents( false );
			MappingSettings->SetWidth( DesiredTextureSize );
			MappingSettings->SetHeight( DesiredTextureSize );
			Remesher->SetSceneRoot( Scene->GetRootNode() );

			FAsyncProcessingTask AsyncTask( Remesher.GetPointer() );
			if ( AsyncTask.Run( *LocalizeUnrealEd( "MeshProxy_CreatingProxy" ) ) == FALSE )
			{
				// The task failed or was canceled.
				return FALSE;
			}
			
			MappingImage = Remesher->GetMappingImage();
		}

		// Retrieve the output mesh geometry.
		SimplygonSDK::spSceneMesh ProxySceneMesh = SimplygonSDK::Cast<SimplygonSDK::ISceneMesh>( Scene->GetRootNode()->GetChild(0) );
		check( ProxySceneMesh );
		SimplygonSDK::spGeometryData ProxyGeometry = ProxySceneMesh->GetGeometry();
		check( ProxyGeometry );

		// Create the mesh proxy object.
		UStaticMesh* MeshProxy = ConstructObject<UStaticMesh>( UStaticMesh::StaticClass(), MeshProxyPackage, UObject::MakeUniqueObjectName( MeshProxyPackage, UStaticMesh::StaticClass(), TEXT("MeshProxy") ) );
		FStaticMeshRenderData* LODModel = new ( MeshProxy->LODModels ) FStaticMeshRenderData();
		FStaticMeshLODInfo* LODInfo = new ( MeshProxy->LODInfo ) FStaticMeshLODInfo();
		check( MeshProxy->LODModels.Num() == 1 );
		check( MeshProxy->LODInfo.Num() == 1 );

		GWarn->PushStatus();
		GWarn->StatusUpdatef( 99, 100, *LocalizeUnrealEd( "MeshProxy_CreatingMaterial" ) );

		// Determine what blend mode the proxy material needs to use.
		EBlendMode BlendMode = BLEND_Opaque;
		for ( INT MaterialIndex = 0; MaterialIndex < UniqueMaterials.Num(); ++MaterialIndex )
		{
			if ( UniqueMaterials(MaterialIndex)->GetMaterial()->BlendMode == BLEND_Masked )
			{
				BlendMode = BLEND_Masked;
				break;
			}
		}

		// Remap materials in to a single texture and build the Simplygon material table.
		SimplygonSDK::spMaterialTable MaterialTable = BuildMaterialTable( UniqueMaterials, MaterialType );

		// Construct the material for the mesh proxy.
		UMaterial* Material = ConstructProxyMaterial( MaterialTable, MappingImage, MaterialType, BlendMode, MeshProxyPackage );

		// Create a single mesh element and assign the material to it.
		FStaticMeshElement* MeshElement = new(LODModel->Elements) FStaticMeshElement();
		MeshElement->Material = Material;
		MeshElement->EnableCollision = TRUE;
		MeshElement->OldEnableCollision = TRUE;
		MeshElement->bEnableShadowCasting = TRUE;

		// Build the static mesh from the Simplygon output geometry.
		CreateTrianglesFromGeometry( ProxyGeometry, WINDING_Reverse, LODModel->RawTriangles );

		MeshProxy->bHasBeenSimplified = TRUE;
		MeshProxy->bIsMeshProxy = TRUE;
		MeshProxy->LightMapCoordinateIndex = 0;
		MeshProxy->LightMapResolution = Clamp<INT>( DesiredTextureSize >> 4, 32, 128 );
		MeshProxy->Build();
		*OutMeshProxy = MeshProxy;
		*OutProxyLocation = ProxyLocation;
		GWarn->PopStatus();

		return TRUE;
	}
#endif // #if ENABLE_SIMPLYGON_MESH_PROXIES
}

#endif // #if WITH_SIMPLYGON
