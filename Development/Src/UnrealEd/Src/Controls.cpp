/*=============================================================================
	Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
=============================================================================*/

#include "UnrealEd.h"
#include "Controls.h"
#include "DlgSelectGroup.h"

UBOOL IsChildWindowOf (wxWindow* InChildWindow, wxWindow* InTestParentWindow)
{
	wxWindow* TestWindow = InChildWindow;
	while (TestWindow)
	{
		if (TestWindow == InTestParentWindow)
		{
			return TRUE;
		}
		TestWindow = TestWindow->GetParent();
	}
	return FALSE;
}

/*-----------------------------------------------------------------------------
	WxToolBar.
-----------------------------------------------------------------------------*/

BEGIN_EVENT_TABLE( WxToolBar, wxToolBar )
END_EVENT_TABLE()

/**
 * Constructor - Construct a WxToolBar object and hook up its event handler to respond
 * to the mouse entering/exiting a tool on the toolbar.
 *
 * @param	InParent	Parent window of the toolbar
 * @param	InId		Id to assign to the toolbar
 * @param	InPos		Position to assign to the toolbar
 * @param	InSize		Size to assign to the toolbar
 * @param	InStyle		Window style to assign to the toolbar (forcibly made to include wxTB_NO_TOOLTIPS)
 * @param	InName		Name to assign to the toolbar
 */
WxToolBar::WxToolBar(
	wxWindow *InParent, 
	wxWindowID InId, 
	const wxPoint& InPos /*= wxDefaultPosition*/, 
	const wxSize& InSize /*= wxDefaultSize*/, 
	LONG InStyle /*= wxTB_HORIZONTAL | wxTB_FLAT | wxTB_NO_TOOLTIPS*/, 
	const wxString &InName /*= wxToolBarNameStr*/ )
: wxToolBar( InParent, InId, InPos, InSize, InStyle | wxTB_NO_TOOLTIPS, InName )
{
	// Set-up the toolbar's event handler to respond to a tool being entered/exited by the mouse
	wxEvtHandler& EvtHandler = *GetEventHandler();
	EvtHandler.Connect( GetId(), wxEVT_COMMAND_TOOL_ENTER, wxCommandEventHandler(WxToolBar::OnToolEnter) );
}

/**
 * Initializes the toolbar when using two-stage dynamic window creation.  Must be the first function called after creation.
 * NOTE: The underlying wxToolBar implementation of this function is NOT virtual. This should not be an issue given the
 * context in which this function is used, but one must be careful to avoid behavior such as:
 * wxToolBar *ToolBar = new WxToolBar; ToolBar->Create(...); // Note a wxToolBar pointer is used to create a WxToolBar object
 *
 * @param	InParent	Parent window of the toolbar
 * @param	InId		Id to assign to the toolbar
 * @param	InPos		Position to assign to the toolbar
 * @param	InSize		Size to assign to the toolbar
 * @param	InStyle		Window style to assign to the toolbar (forcibly made to include wxTB_NO_TOOLTIPS)
 * @param	InName		Name to assign to the toolbar
 *
 * @return	TRUE if the toolbar was successfully created, FALSE otherwise
 */
UBOOL WxToolBar::Create(
	wxWindow *InParent, 
	wxWindowID InId, 
	const wxPoint& InPos /*= wxDefaultPosition*/, 
	const wxSize& InSize /*= wxDefaultSize*/, 
	LONG InStyle /*= wxTB_HORIZONTAL | wxTB_FLAT | wxTB_NO_TOOLTIPS*/, 
	const wxString &InName /*= wxToolBarNameStr*/ )
{
	// Construct the toolbar using the base wxToolBar's implementation
	UBOOL bSuccess = wxToolBar::Create( InParent, InId, InPos, InSize, InStyle | wxTB_NO_TOOLTIPS, InName );

	// Set-up the toolbar's event handler to respond to a tool being entered/exited by the mouse
	wxEvtHandler& EvtHandler = *GetEventHandler();
	EvtHandler.Connect( GetId(), wxEVT_COMMAND_TOOL_ENTER, wxCommandEventHandler(WxToolBar::OnToolEnter) );

	return bSuccess;
}

/**
 * Handles the mouse-over of a toolbar tool by setting the toolbar's tooltip to be that of the
 * hovered over tool's.
 *
 * @param	In	Command event generated by wxWidgets when the mouse enters/exits a tool on the toolbar
 */
void WxToolBar::OnToolEnter( wxCommandEvent& In )
{
	// Attempt to find the tool the mouse has entered/exited
	wxToolBarToolBase* ToolEntered = FindById( In.GetSelection() );
	
	// If the tool was found, that means the mouse has just entered it and its tooltip should become the toolbar's 
	if ( ToolEntered )
	{
		SetToolTip( ToolEntered->GetShortHelp() );
	}
	// The tool wasn't found, that means the mouse has just exited a tool and the toolbar's tooltip should be empty
	else
	{
		SetToolTip( wxEmptyString );
	}
}

/*-----------------------------------------------------------------------------
	WxStatusBar.
-----------------------------------------------------------------------------*/

WxStatusBar::WxStatusBar()
	: wxStatusBar()
{
}

WxStatusBar::WxStatusBar( wxWindow* parent, wxWindowID id )
	: wxStatusBar( parent, id )
{
}

/*-----------------------------------------------------------------------------
	WxTextCtrl.
-----------------------------------------------------------------------------*/

BEGIN_EVENT_TABLE( WxTextCtrl, wxTextCtrl )
	EVT_CHAR( WxTextCtrl::OnChar )
END_EVENT_TABLE()

WxTextCtrl::WxTextCtrl()
	: wxTextCtrl()
{
}

WxTextCtrl::WxTextCtrl( wxWindow* parent, wxWindowID id, const wxString& value, const wxPoint& pos, const wxSize& size, long style ) :
	wxTextCtrl( parent, id, value, pos, size, style )
{
}

void WxTextCtrl::OnChar( wxKeyEvent& In )
{
	switch( In.GetKeyCode() )
	{
		case WXK_DOWN:
		case WXK_UP:
		case WXK_TAB:
			GetParent()->AddPendingEvent( In );
			break;

		default:
			In.Skip();
			break;
	}
}

wxDragResult WxTextCtrl::OnEnter(wxCoord x, wxCoord y, wxDragResult def)
{
	//m_frame->SetStatusText(_T("Mouse entered the frame"));

	return OnDragOver(x, y, def);
}

void WxTextCtrl::OnLeave()
{
	//m_frame->SetStatusText(_T("Mouse left the frame"));
}

wxDragResult WxTextCtrl::OnData(wxCoord x, wxCoord y, wxDragResult def)
{
	//if( !GetData() )
	//{
	//	wxLogError(wxT("Failed to get drag and drop data"));

	//	return wxDragNone;
	//}

	//m_frame->OnDrop(x, y, ((DnDShapeDataObject *)GetDataObject())->GetShape());

	return def;
}

/**
 * Constructor
 *
 * @param	StorageLocation		a pointer to a member of the owner window where the validated text will be placed
 * @param	NameValidationMask	bitmask for the type of validation to apply
 */
WxNameTextValidator::WxNameTextValidator( wxString* StorageLocation, DWORD NameValidationMask/*=VALIDATE_PackageName*/ )
: wxTextValidator(wxFILTER_EXCLUDE_CHAR_LIST, StorageLocation)
{
	FString InvalidCharacters;
	if ( (NameValidationMask&VALIDATE_Name) != 0 )
	{
		InvalidCharacters += INVALID_NAME_CHARACTERS;
	}

	if ( (NameValidationMask&VALIDATE_ObjectName) != 0 )
	{
		InvalidCharacters += INVALID_OBJECTNAME_CHARACTERS;
	}

	if ( (NameValidationMask&VALIDATE_PackageName) != 0 )
	{
		InvalidCharacters += INVALID_PACKAGENAME_CHARACTERS;
	}

	else if ( (NameValidationMask&VALIDATE_GroupName) != 0 )
	{
		InvalidCharacters += INVALID_GROUPNAME_CHARACTERS;
	}
	
	// Create an array of single characters from the InvalidCharacters string
	wxArrayString InvalidCharactersArray;
	wxString Char;
	for ( int a = 0; a < InvalidCharacters.Len(); ++a )
	{
		Char = InvalidCharacters[a];
		if(InvalidCharactersArray.Index(Char) == wxNOT_FOUND)
		{
			InvalidCharactersArray.Add( Char );
		}
	}
	
	SetExcludes( InvalidCharactersArray );
}


/*-----------------------------------------------------------------------------
	WxPkgGrpNameCtrl.
-----------------------------------------------------------------------------*/

BEGIN_EVENT_TABLE( WxPkgGrpNameCtrl, wxPanel )
	EVT_BUTTON( IDPB_BROWSE, WxPkgGrpNameCtrl::OnBrowse )
END_EVENT_TABLE()

WxPkgGrpNameCtrl::WxPkgGrpNameCtrl( wxWindow* parent, wxWindowID id, wxSizer* InParentSizer, UBOOL bDeferLocalization )
	: wxPanel( parent, id )
{
	FlexGridSizer = new wxFlexGridSizer( 3, 3, 0, 0 );
	FlexGridSizer->AddGrowableCol( 1 );
	{
		PkgLabel = new wxStaticText( this,	 wxID_STATIC, TEXT("Package") );
		FlexGridSizer->Add(PkgLabel, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL|wxALL|wxADJUST_MINSIZE, 5);

		PkgCombo = new WxComboBox( this, IDCB_PACKAGE, TEXT(""), wxDefaultPosition, wxDefaultSize, 0, NULL, wxCB_DROPDOWN|wxCB_SORT );
		
		TArray<FString> PackageFiles = GPackageFileCache->GetPackageFileList();
		for ( TArray<FString>::TConstIterator PkgIter( PackageFiles ); PkgIter; ++PkgIter )
		{
			const FString& CurPkgFile = *PkgIter;
			PkgCombo->Append( *( FFilename( CurPkgFile ).GetBaseFilename() ) );
		}

		FlexGridSizer->Add( PkgCombo, 0, wxALIGN_LEFT|wxGROW|wxALL, 5 );

		FlexGridSizer->Add( 5, 5, 0, wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL|wxALL, 5 );

		GrpLabel = new wxStaticText( this, wxID_STATIC, TEXT("Group") );
		FlexGridSizer->Add( GrpLabel, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL|wxALL|wxADJUST_MINSIZE|wxEXPAND, 5 );

		GrpEdit = new wxTextCtrl( this, IDEC_GROUP, TEXT(""), wxDefaultPosition, wxSize(200, -1) );
		FlexGridSizer->Add( GrpEdit, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5 );

		BrowseB.Load( TEXT("Search") );
		BrowseButton = new WxBitmapButton( this, IDPB_BROWSE, BrowseB, wxDefaultPosition, wxSize(24, -1) );
		FlexGridSizer->Add( BrowseButton, 0, wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL|wxALL, 5 );

		NameLabel = new wxStaticText( this, wxID_STATIC, TEXT("Name"));
		FlexGridSizer->Add( NameLabel, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL|wxALL|wxADJUST_MINSIZE|wxEXPAND, 5 );

		NameEdit = new wxTextCtrl( this, IDEC_NAME, TEXT("") );
		FlexGridSizer->Add( NameEdit, 0, wxALIGN_LEFT|wxGROW|wxALL, 5 );
	}
	if( InParentSizer )
	{
		InParentSizer->Add( FlexGridSizer, 1, wxEXPAND|wxALL, 5 );
	}
	else
	{
		SetSizer( FlexGridSizer );
	}

	// Defer localization -- happens if eg derived classes that want to add additional localized text.
	if ( !bDeferLocalization )
	{
		FLocalizeWindow( this );
	}
}

void WxPkgGrpNameCtrl::OnBrowse( wxCommandEvent& In )
{
	const FString PkgName = (const TCHAR*)PkgCombo->GetValue();
	const FString GroupName = (const TCHAR*)GrpEdit->GetValue();

	WxDlgSelectGroup dlg( this );
	if( dlg.ShowModal( PkgName, GroupName ) == wxID_OK )
	{
		PkgCombo->SetValue( *dlg.Package );
		GrpEdit->SetValue( *dlg.Group );
	}
}

/*-----------------------------------------------------------------------------
	WxPkgGrpNameSbsCtrl.
-----------------------------------------------------------------------------*/

BEGIN_EVENT_TABLE( WxPkgGrpNameSbsCtrl, wxPanel )
	EVT_BUTTON( IDPB_BROWSE, WxPkgGrpNameSbsCtrl::OnBrowse )
END_EVENT_TABLE()

WxPkgGrpNameSbsCtrl::WxPkgGrpNameSbsCtrl(
	wxWindow* parent, 
	wxWindowID id, 
	wxSizer* InParentSizer, 
	UBOOL bDeferLocalization,
	UBOOL bShowMaterialCheckBox) : wxPanel( parent, id )
{
	FlexGridSizer = new wxFlexGridSizer( 4, 3, 0, 0 );
	FlexGridSizer->AddGrowableCol( 1 );
	{	
		PkgLabel = new wxStaticText( this,	 wxID_STATIC, TEXT("Package") );
		FlexGridSizer->Add(PkgLabel, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL|wxALL|wxADJUST_MINSIZE, 5);

		PkgCombo = new WxComboBox( this, IDCB_PACKAGE, TEXT(""), wxDefaultPosition, wxDefaultSize, 0, NULL, wxCB_DROPDOWN|wxCB_SORT );

		TArray<FString> PackageFiles = GPackageFileCache->GetPackageFileList();
		for ( TArray<FString>::TConstIterator PkgIter( PackageFiles ); PkgIter; ++PkgIter )
		{
			const FString& CurPkgFile = *PkgIter;
			PkgCombo->Append( *( FFilename( CurPkgFile ).GetBaseFilename() ) );
		}

		FlexGridSizer->Add( PkgCombo, 0, wxALIGN_LEFT|wxGROW|wxALL, 5 );

		FlexGridSizer->Add( 5, 5, 0, wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL|wxALL, 5 );

		GrpLabel = new wxStaticText( this, wxID_STATIC, TEXT("Group") );
		FlexGridSizer->Add( GrpLabel, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL|wxALL|wxADJUST_MINSIZE|wxEXPAND, 5 );

		GrpEdit = new wxTextCtrl( this, IDEC_GROUP, TEXT(""), wxDefaultPosition, wxSize(200, -1) );
		FlexGridSizer->Add( GrpEdit, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5 );

		BrowseB.Load( TEXT("Search") );
		BrowseButton = new WxBitmapButton( this, IDPB_BROWSE, BrowseB, wxDefaultPosition, wxSize(24, -1) );
		FlexGridSizer->Add( BrowseButton, 0, wxALIGN_CENTER_HORIZONTAL|wxALIGN_CENTER_VERTICAL|wxALL, 5 );

		NameLabel = new wxStaticText( this, wxID_STATIC, TEXT("Name"));
		FlexGridSizer->Add( NameLabel, 0, wxALIGN_LEFT|wxALIGN_CENTER_VERTICAL|wxALL|wxADJUST_MINSIZE|wxEXPAND, 5 );

		NameEdit = new wxTextCtrl( this, IDEC_NAME, TEXT("") );
		FlexGridSizer->Add( NameEdit, 0, wxALIGN_LEFT|wxGROW|wxALL, 5 );

		FlexGridSizer->Add(new wxStaticText(this, wxID_STATIC, TEXT("")), 0, wxEXPAND);
		
		if (bShowMaterialCheckBox)
		{
			MaterialCheckbox = new wxCheckBox(this, ID_TERRAIN_BROWSER_ADD_MATERIAL, 
				TEXT("DefaultMaterialE"));

			FlexGridSizer->Add( MaterialCheckbox, 0, wxALIGN_LEFT|wxALL, 0 );
		}
		else
		{
			MaterialCheckbox = NULL;
		}
	}

	if( InParentSizer )
	{
		InParentSizer->Add( FlexGridSizer, 1, wxEXPAND|wxALL, 5 );
	}
	else
	{
		SetSizer( FlexGridSizer );
	}
}

void WxPkgGrpNameSbsCtrl::OnBrowse( wxCommandEvent& In )
{
	const FString PkgName = (const TCHAR*)PkgCombo->GetValue();
	const FString GroupName = (const TCHAR*)GrpEdit->GetValue();

	WxDlgSelectGroup dlg( this );
	if( dlg.ShowModal( PkgName, GroupName ) == wxID_OK )
	{
		PkgCombo->SetValue( *dlg.Package );
		GrpEdit->SetValue( *dlg.Group );
	}
}

/*-----------------------------------------------------------------------------
	WxTreeCtrl.
-----------------------------------------------------------------------------*/

IMPLEMENT_DYNAMIC_CLASS(WxTreeCtrl,wxTreeCtrl)

WxTreeCtrl::WxTreeCtrl( wxWindow* InParent, wxWindowID InID, wxMenu* InMenu, LONG InStyle )
:	wxTreeCtrl( InParent, InID, wxDefaultPosition, wxDefaultSize, InStyle ),
ContextMenu( InMenu ),
bInSetFocus(FALSE)
{
	Connect(
		InID,												//	id
		wxEVT_COMMAND_TREE_ITEM_MENU,						//	event type
		wxTreeEventHandler(WxTreeCtrl::OnShowContextMenu));
}

WxTreeCtrl::~WxTreeCtrl()
{
	delete ContextMenu;
}

/**
 * Initializes this window when using two-stage dynamic window creation
 */
UBOOL WxTreeCtrl::Create( wxWindow* InParent, wxWindowID InID, wxMenu* InMenu, LONG style/*=wxTR_HAS_BUTTONS|wxTR_MULTIPLE|wxTR_LINES_AT_ROOT*/ )
{
	ContextMenu = InMenu;

	bool bResult = wxTreeCtrl::Create(InParent, InID,  wxDefaultPosition, wxDefaultSize, style);

	if ( ContextMenu != NULL )
	{
		Connect(
			InID,											//	id
			wxEVT_COMMAND_TREE_ITEM_MENU,					//	event type
			wxTreeEventHandler(WxTreeCtrl::OnShowContextMenu));
	}

	return bResult;

}

/**
 * Since we derive from wxTreeCtrl, the base code can't use the fast
 * mechanism for sorting. Therefore, we provide this method to bypass
 * the slower method.
 *
 * @param Item the tree item to sort
 */
void WxTreeCtrl::SortChildren(const wxTreeItemId& item)
{
    wxCHECK_RET( item.IsOk(), wxT("invalid tree item") );
	// Just use the default sorting code
	TreeView_SortChildren(GetHwnd(), item.m_pItem, 0);
}

/**
 * Sets all of the item's images to the same image.
 *
 *
 * @param Item	Item to modify.
 * @param Image	Index of the image in the tree control's image list.
 */
void WxTreeCtrl::SetAllItemImages(wxTreeItemId& Item, INT Image)
{
	SetItemImage(Item, Image, wxTreeItemIcon_Normal);
	SetItemImage(Item, Image, wxTreeItemIcon_Selected);
	SetItemImage(Item, Image, wxTreeItemIcon_Expanded);
	SetItemImage(Item, Image, wxTreeItemIcon_SelectedExpanded);
}

/**
 * Intercepts the set focus call in order to trap the item selection
 */
void WxTreeCtrl::SetFocus(void)
{
	bInSetFocus = TRUE;
	wxTreeCtrl::SetFocus();
	bInSetFocus = FALSE;
}

void WxTreeCtrl::OnShowContextMenu( wxTreeEvent& Event )
{
	if ( ContextMenu != NULL )
	{
// 		UnselectAll();
// 		SelectItem(Event.GetItem(), true);
// 
		wxPoint pt = Event.GetPoint();
		FTrackPopupMenu tpm(this, ContextMenu);
		tpm.Show(pt.x, pt.y);
	}
}

/**
 * Activates the context menu associated with this tree control.
 *
 * @param	ItemData	the data associated with the item that the user right-clicked on
 */
void WxTreeCtrl::ShowPopupMenu( WxTreeObjectWrapper* ItemData )
{
	if ( ContextMenu != NULL )
	{
		FTrackPopupMenu tpm( this, ContextMenu );
		tpm.Show();
	}
}


/** 
 * Loops through all of the elements of the tree and adds selected items to the selection set,
 * and expanded items to the expanded set.
 */
void WxTreeCtrl::SaveSelectionExpansionState()
{
	SavedSelections.Empty();
	SavedExpansions.Empty();

	// Recursively traverse and tree and store selection states based on the client data.
	wxTreeItemId Root = GetRootItem();

	if(Root.IsOk())
	{
		SaveSelectionExpansionStateRecurse(Root);
	}
}

/** 
 * Loops through all of the elements of the tree and sees if the client data of the item is in the 
 * selection or expansion set, and modifies the item accordingly.
 */
void WxTreeCtrl::RestoreSelectionExpansionState()
{
	// Recursively traverse and tree and restore selection states based on the client data.
	Freeze();
	{
		wxTreeItemId Root = GetRootItem();

		if(Root.IsOk())
		{
			RestoreSelectionExpansionStateRecurse(Root);
		}
	}
	Thaw();

	SavedSelections.Empty();
	SavedExpansions.Empty();
}


/** 
 * Recursion function that loops through all of the elements of the tree item provided and saves their select/expand state. 
 * 
 * @param Item Item to use for the root of this recursion.
 */
void WxTreeCtrl::SaveSelectionExpansionStateRecurse(wxTreeItemId& Item)
{
	// Expand and select this item
	WxTreeObjectWrapper* ObjectWrapper = static_cast<WxTreeObjectWrapper*>(GetItemData(Item));

	const UBOOL bIsRoot = (Item == GetRootItem());
	const UBOOL bVirtualRoot = ((GetWindowStyle() & wxTR_HIDE_ROOT) == wxTR_HIDE_ROOT);
	const UBOOL bProcessItem = (bIsRoot == FALSE) || (bVirtualRoot == FALSE);

	if( bProcessItem )
	{
		if(ObjectWrapper != NULL)
		{
			UObject* ObjectPointer = ObjectWrapper->GetObject<UObject>();

			if(IsSelected(Item))
			{
				SavedSelections.Set(ObjectPointer, ObjectPointer);
			}

			if(IsExpanded(Item))
			{
				SavedExpansions.Set(ObjectPointer, ObjectPointer);
			}
		}
	}


	// Loop through all of the item's children and store their state.
	wxTreeItemIdValue Cookie;
	wxTreeItemId ChildItem =GetFirstChild( Item, Cookie );

	while(ChildItem.IsOk())
	{
		SaveSelectionExpansionStateRecurse(ChildItem);

		ChildItem = GetNextChild(Item, Cookie);
	}
}


/** 
 * Recursion function that loops through all of the elements of the tree item provided and restores their select/expand state. 
 * 
 * @param Item Item to use for the root of this recursion.
 */
void WxTreeCtrl::RestoreSelectionExpansionStateRecurse(wxTreeItemId& Item)
{
	// Expand and select this item
	WxTreeObjectWrapper* ObjectWrapper = static_cast<WxTreeObjectWrapper*>(GetItemData(Item));

	const UBOOL bIsRoot = (Item == GetRootItem());
	const UBOOL bVirtualRoot = ((GetWindowStyle() & wxTR_HIDE_ROOT) == wxTR_HIDE_ROOT);
	const UBOOL bProcessItem = (bIsRoot == FALSE) || (bVirtualRoot == FALSE);

	if( bProcessItem )
	{
		if(ObjectWrapper != NULL)
		{
			UObject* ObjectPointer = ObjectWrapper->GetObject<UObject>();
			const UBOOL bItemSelected = SavedSelections.Find(ObjectPointer) != NULL;
			const UBOOL bItemExpanded = SavedExpansions.Find(ObjectPointer) != NULL;
				
			if(bItemSelected == TRUE)
			{
				SelectItem(Item);
			}

			if(bItemExpanded == TRUE)
			{
				Expand(Item);
			}
		}
	}

	// Loop through all of the item's children and select/expand them.
	wxTreeItemIdValue Cookie;
	wxTreeItemId ChildItem =GetFirstChild( Item, Cookie );

	while(ChildItem.IsOk())
	{
		RestoreSelectionExpansionStateRecurse(ChildItem);

		ChildItem = GetNextChild(Item, Cookie);
	}
}


/** For runtime creation of WxComboBox items */
IMPLEMENT_DYNAMIC_CLASS(WxComboBox,wxComboBox);


/*-----------------------------------------------------------------------------
WxListView.
-----------------------------------------------------------------------------*/

/**
 * Returns the text of the item.
 * @param Index Index of the item.
 * @param Column Column of the item.
 */
wxString WxListView::GetColumnItemText(long Index, long Column)
{
	wxListItem ListItem;

	ListItem.SetId(Index);
	ListItem.SetColumn(Column);
	ListItem.m_mask = wxLIST_MASK_TEXT;
	GetItem(ListItem);

	return ListItem.GetText();
}

/*-----------------------------------------------------------------------------
	WxSpinCtrlReal
-----------------------------------------------------------------------------*/

BEGIN_EVENT_TABLE(WxSpinCtrlReal, wxPanel)
	EVT_MOUSE_EVENTS(WxSpinCtrlReal::OnMouseEvent)
	EVT_TEXT_ENTER(IDT_SPINCTRLREAL, WxSpinCtrlReal::OnText)
	EVT_BUTTON(IDB_SPIN_UP, WxSpinCtrlReal::OnSpin)
	EVT_BUTTON(IDB_SPIN_DOWN, WxSpinCtrlReal::OnSpin)
END_EVENT_TABLE()

WxSpinCtrlReal::WxSpinCtrlReal(wxWindow* InParent, wxWindowID InID/* =wxID_ANY */, FLOAT Value/* =0::0f */, wxPoint Position/* =wxDefaultPosition */, wxSize Size/* =wxDefaultSize */, FLOAT InMinValue/* =-100000::0f */, FLOAT InMaxValue/* =100000::0f */) : 
wxPanel(InParent, InID, Position, Size),
bFixedIncrement(FALSE),
FixedIncrementAmount(1.0f),
MinValue(InMinValue),
MaxValue(InMaxValue)
{
	SetMinSize(wxSize(100,-1));

	// Create spinner buttons
	wxSizer* MainSizer = new wxBoxSizer(wxHORIZONTAL);
	{
		//using second parameter for wxTextValidator to remove wxWidgets assertion during code execution
		const FLOAT val = Clamp<FLOAT>(Value, MinValue, MaxValue);
		ValidatorStringValue.Printf(TEXT("%f"), val);
		TextCtrl = new wxTextCtrl(this, IDT_SPINCTRLREAL, wxEmptyString, wxDefaultPosition, wxDefaultSize, wxTE_PROCESS_ENTER, wxTextValidator(wxFILTER_NUMERIC, &ValidatorStringValue));
		MainSizer->Add(TextCtrl, 1, wxEXPAND);

		ButtonSizer = new wxBoxSizer(wxVERTICAL);
		{
			{
				WxMaskedBitmap bmp;
				bmp.Load(TEXT("Spinner_Up"));
				wxBitmapButton* SpinButton = new wxBitmapButton( this, IDB_SPIN_UP, bmp, wxDefaultPosition, wxSize(-1,1)  );
				ButtonSizer->Add(SpinButton, 1, wxEXPAND);
			}

			ButtonSizer->AddSpacer(4);

			{
				WxMaskedBitmap bmp;
				bmp.Load(TEXT("Spinner_Down"));
				wxBitmapButton* SpinButton = new wxBitmapButton( this, IDB_SPIN_DOWN, bmp, wxDefaultPosition, wxSize(-1,1) );
				ButtonSizer->Add(SpinButton, 1, wxEXPAND);
			}
		}
		MainSizer->Add(ButtonSizer,0, wxEXPAND);
	}
	SetSizer(MainSizer);
	


	// Create a Blank Cursor
	WxMaskedBitmap bitmap(TEXT("blank"));
	wxImage BlankImage = bitmap.ConvertToImage();
	BlankImage.SetMaskColour(192,192,192);
	BlankCursor = wxCursor(BlankImage);

	// Set the initial value for the spinner
	SetValue(Value);
}

void WxSpinCtrlReal::OnSize(wxSizeEvent &InEvent)
{
	wxRect Rect = InEvent.GetRect();

	TextCtrl->SetSize(Rect.x, Rect.y, Rect.width - 12, Rect.height);
	ButtonSizer->SetDimension(Rect.width + Rect.x - 12, Rect.y, 12, Rect.height);
}

/**
 * @return	Returns the current value of the spin control.
 */
FLOAT WxSpinCtrlReal::GetValue() const
{
	const FLOAT Value = appAtof(TextCtrl->GetValue());

	return Value;
}

/**
 * Sets the current value for the spin control.
 *
 * @param	Value		The new value of the spin control.
 * @param	bSendEvent	Whether or not to send a SPIN event letting bound controls know that we changed value.
 */
void WxSpinCtrlReal::SetValue(FLOAT Value, UBOOL bSendEvent)
{
	wxString NewStr;

	Value = Clamp<FLOAT>(Value, MinValue, MaxValue);
	NewStr.Printf(TEXT("%f"), Value);
	ValidatorStringValue = NewStr;
	TextCtrl->SetValue(NewStr);

	// Post a wx event.
	if(bSendEvent == TRUE)
	{
		wxSpinEvent Evt(wxEVT_COMMAND_SPINCTRL_UPDATED, GetId());
		wxPostEvent(GetParent(), Evt);
	}
}

/** Event handler for when the user enters text into the spin control textbox. */
void WxSpinCtrlReal::OnText(wxCommandEvent &InEvent)
{
	// Post a wx spinctrl changed event.
	wxSpinEvent Evt(wxEVT_COMMAND_SPINCTRL_UPDATED, GetId());
	wxPostEvent(GetParent(), Evt);	
}

void WxSpinCtrlReal::OnMouseEvent(wxMouseEvent& InEvent)
{
	const UBOOL bHasCapture = HasCapture();

	// See if we should be capturing the mouse.
	if(InEvent.LeftDown())
	{
		CaptureMouse();

		MouseDelta = 0;
		MouseStartPoint = InEvent.GetPosition();

		// Solve for the equation value and pass that value back to the property
		StartValue = GetValue();

		// Change the cursor and background color for the panel to indicate that we are dragging.
		wxSetCursor(BlankCursor);

		SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNHIGHLIGHT));
		Refresh();
	}
	else if(InEvent.LeftUp() && bHasCapture)
	{
		WarpPointer(MouseStartPoint.x, MouseStartPoint.y);
		ReleaseMouse();

		// Change the cursor back to normal and the background color of the panel back to normal.
		wxSetCursor(wxNullCursor);

		SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_3DFACE));
		Refresh();
	}
	else if(InEvent.Dragging() && bHasCapture)
	{
		const INT MoveDelta = InEvent.GetY() - MouseStartPoint.y;
		const INT DeltaSmoother = 3;

		// To keep the movement from being completely twitchy, we use a DeltaSmoother which means the mouse needs to move at least so many pixels before registering a change.
		if(Abs<INT>(MoveDelta) >= DeltaSmoother)
		{
			// Add contribution of delta to the total mouse delta, we need to invert it because Y is 0 at the top of the screen.
			MouseDelta += -(MoveDelta) / DeltaSmoother;

			// Solve for the equation value and pass that value back to the property, we always increment by 1% of the original value.
			FLOAT ChangeAmount;

			if(bFixedIncrement == FALSE)
			{
				ChangeAmount = Abs(StartValue) * 0.01f;
				const FLOAT SmallestChange = 0.01f;
				if(ChangeAmount < SmallestChange)
				{
					ChangeAmount = SmallestChange;
				}
			}
			else
			{
				ChangeAmount = FixedIncrementAmount;
			}

			WarpPointer(MouseStartPoint.x, MouseStartPoint.y);

			
			// We're spinning for a single value, so just set the new value.
			const FLOAT FinalValue = ChangeAmount * MouseDelta + StartValue;
			SetValue( FinalValue, TRUE );
		}
	}
	else if(InEvent.Moving())
	{
		// Change the cursor to a NS drag cursor when the user mouses over it so that they can tell that there is a drag opportunity here.
		wxSetCursor(wxCURSOR_SIZENS);
	}
}

void WxSpinCtrlReal::OnSpin(wxCommandEvent& InEvent)
{
	// Calculate how much to change the value by.  If there is no fixed amount set,
	// then use 1% of the current value.  Otherwise, use the fixed value that was set.

	const int WidgetId = InEvent.GetId();
	const FLOAT DirectionScale = (WidgetId == IDB_SPIN_UP) ? 1.0f : -1.0f;

	if ( bFixedIncrement )
	{
		const FLOAT ChangeAmount = FixedIncrementAmount * DirectionScale;
		const FLOAT EqResult = GetValue();
		SetValue( EqResult + ChangeAmount, TRUE );
	}
	else
	{
		const FLOAT SmallestChange = 0.01f;
		const FLOAT EqResult = GetValue();

		FLOAT ChangeAmount = Abs(EqResult) * 0.01f;
		if( ChangeAmount < SmallestChange )
		{
			ChangeAmount = SmallestChange;
		}

		SetValue( EqResult + ChangeAmount*DirectionScale, TRUE );
	}
}


/*-----------------------------------------------------------------------------
	WxCursor
-----------------------------------------------------------------------------*/

/**
 * Generates a cursor given only a local filename.  Uses the same mask as WxBitmap, (192,192,192).
 */
WxCursor::WxCursor(const char* filename)
{
	WxMaskedBitmap CursorBitmap(filename);
	wxImage CursorImage = CursorBitmap.ConvertToImage();
	CursorImage.SetMask(true);
	CursorImage.SetMaskColour(192,192,192);

	wxCursor TempCursor(CursorImage);

	*((wxCursor*)this) = TempCursor;
}

/*-----------------------------------------------------------------------------
	FCursorManager
-----------------------------------------------------------------------------*/

WxCursor& FCursorManager::GetCursor(const ANSICHAR* Filename)
{
	static TMap<const FString, WxCursor> CursorMap;
	WxCursor* Cursor = CursorMap.Find( FString( ANSI_TO_TCHAR(Filename) ) );

	if(Cursor == NULL)
	{
		FString WideFilename( ANSI_TO_TCHAR(Filename) );

		Cursor = &CursorMap.Set(WideFilename, WxCursor(Filename));

		check(Cursor);
	}

	return (*Cursor);
}

///////////////////////////////////////////////////////////////////////////////
//
// Events table for WxPassThroughStaticText
//
///////////////////////////////////////////////////////////////////////////////

BEGIN_EVENT_TABLE( WxPassThroughStaticText, wxStaticText)
	EVT_LEFT_DOWN(WxPassThroughStaticText::OnSkipMouseEvent)
	EVT_RIGHT_DOWN(WxPassThroughStaticText::OnSkipMouseEvent)
	EVT_LEFT_DCLICK(WxPassThroughStaticText::OnSkipMouseEvent)
	EVT_RIGHT_DCLICK(WxPassThroughStaticText::OnSkipMouseEvent)

	EVT_ERASE_BACKGROUND( WxPassThroughStaticText::OnEraseBackground )
END_EVENT_TABLE()

///////////////////////////////////////////////////////////////////////////////
//
// Search/Filter control
//
///////////////////////////////////////////////////////////////////////////////

#define BUTTON_SCALE			1.5f

/**
 * WxSearchTextCtrl: the text edit control the user uses to input the filter
 */
class WxSearchTextCtrl : public wxTextCtrl, public FDeferredInitializationWindow
{
	friend class WxSearchControl;

	DECLARE_DYNAMIC_CLASS(WxSearchTextCtrl);

private:
	/**
	*	Initialize this text ctrl.  Must be the first function called after creation.
	*
	* @param	parent			The parent window.
	*/
	virtual void Create( wxWindow* InParent, wxWindowID InID, wxSizer* InParentSizer)
	{
		check(InParent);
		check(InParentSizer);

		InternalString.Empty();
		TextCtrlID = InID;

		/** Text box*/
		wxTextCtrl::Create(InParent, InID, TEXT(""), wxDefaultPosition, wxDefaultSize, wxCLIP_CHILDREN | wxWANTS_CHARS);
		InParentSizer->Add(this, 1, wxALIGN_LEFT | wxGROW | wxALL, 0);

		/** InitImages */
		FString ButtonCancelFileName = TEXT("Cancel.png");
		FString ButtonSearchFileName = TEXT("FilterSearch.png");
		ButtonCancelImage.Load( ButtonCancelFileName );
		ButtonSearchImage.Load( ButtonSearchFileName );

		ensure ((ButtonCancelImage.GetWidth() == ButtonSearchImage.GetWidth()) || (ButtonCancelImage.GetHeight() == ButtonSearchImage.GetHeight()));

		wxSize ImageSize;
		INT TextCtrlHeight = GetSize().GetHeight();
		ImageSize.Set(TextCtrlHeight, TextCtrlHeight);		//lock buttons to the same size as the text ctrl
		ImageSize.Scale(BUTTON_SCALE, BUTTON_SCALE);

		/** Clear Button*/
		ButtonCancel = new WxBitmapCheckButton(InParent, InParent, ID_SEARCHTEXTCTRL_CANCEL_SEARCH_BUTTON, &ButtonCancelImage, &ButtonCancelImage);
		ButtonCancel->SetPosition(wxDefaultPosition);
		ButtonCancel->SetSize(ImageSize);
		ButtonCancel->SetToolTip(*LocalizeUnrealEd("PropertyWindow_CancelSearch"));
		InParentSizer->Add(ButtonCancel, 0, wxALIGN_RIGHT | wxALIGN_CENTER_VERTICAL, 0);// | wxSHAPED | wxGROW | wxALL, 0);

		//Search Button
		ButtonSearch = new WxBitmapCheckButton(InParent, InParent, ID_SEARCHTEXTCTRL_SEARCH_BUTTON, &ButtonSearchImage, &ButtonSearchImage);
		ButtonSearch->SetPosition(wxDefaultPosition);
		ButtonSearch->SetSize(ImageSize);
		ButtonSearch->SetToolTip(*LocalizeUnrealEd("PropertyWindow_Search"));
		InParentSizer->Add(ButtonSearch, 0, wxALIGN_RIGHT | wxALIGN_CENTER_VERTICAL, 0);// | wxSHAPED | wxGROW | wxALL, 0);

		EmptySearchLabel = new WxPassThroughStaticText(this, wxID_ANY, *LocalizeUnrealEd("PropertyWindow_SearchFor"));
		const INT LabelBorder = 2;
		wxPoint SearchLabelPosition = GetPosition();
		SearchLabelPosition.x += LabelBorder;
		SearchLabelPosition.y += LabelBorder;
		wxSize SearchLabelSize = GetSize();
		//it'll clip to the text control and it's not sized correctly yet.
		SearchLabelSize.SetWidth(500);
		SearchLabelSize.SetHeight(SearchLabelSize.GetHeight() - LabelBorder*2);
		EmptySearchLabel->SetPosition(SearchLabelPosition);
		EmptySearchLabel->SetSize(SearchLabelSize);
		EmptySearchLabel->SetBackgroundColour(GetBackgroundColour());
		EmptySearchLabel->SetForegroundColour( *wxLIGHT_GREY );

		//default to just showing the "search" icon
		ButtonCancel->Hide();
	}

	/**
	* Callback used for setting the "search"/"cancel" button and adjusting text properly
	*/
	void OnChangeFocus( wxFocusEvent& In )
	{
		if (In.GetEventObject() == this)
		{
			check(GetParent()!=NULL);
			wxSizer* SizerForRefresh = GetParent()->GetSizer();
			check(SizerForRefresh);
			SizerForRefresh->Layout();
		}
		In.Skip();		//keep executing events
	}

	//callbacks
	/*
	* Callback used for getting the key command from a TextCtrl
	*/
	void OnFilterChanged( wxCommandEvent& In )
	{
		{
			if( In.GetId() == TextCtrlID )
			{
				InternalString = In.GetString().c_str();
				if (InternalString.Len() > 0) 
				{
					//correct button/label visibility state
					EmptySearchLabel->Hide();
					ButtonCancel->Show();
					ButtonSearch->Hide();
				}
				else
				{
					EmptySearchLabel->Show();
					ButtonCancel->Hide();
					ButtonSearch->Show();
				}
				check(GetParent()!=NULL);
				wxSizer* SizerForRefresh = GetParent()->GetSizer();
				check(SizerForRefresh);
				SizerForRefresh->Layout();
				Refresh();
			}
			In.Skip(TRUE);	//if events are suppressed, call skip(false);
		}
	}

	/**
	* To pass event back up to the Host window to control tab ordering
	*/
	void OnChar( wxKeyEvent& In )
	{
		UINT KeyCode = In.GetKeyCode();
		if ((KeyCode == WXK_TAB) || (KeyCode == WXK_DOWN) || (KeyCode == WXK_UP))
		{
			In.SetEventObject(this);
			In.ResumePropagation(wxEVENT_PROPAGATE_MAX);
			In.Skip();	//let parent deal with this
			TryParent(In);
		} 
		else 
		{
			wxTextCtrl::OnChar(In);
		}
	}

	/**
	 * Mouse event that takes control for the property window (passed from pass through text control
	 */
	void OnMouseEvent(wxMouseEvent& In)
	{
		if (EmptySearchLabel->IsShown())
		{
			//assume focus of child windows (the label)
			SetFocus();
		}
		else
		{
			In.Skip(TRUE);
		}
	}


	DECLARE_EVENT_TABLE();

	//Button used to cancel the active search and reset the search text ctrl
	WxBitmapCheckButton* ButtonCancel;
	//Button that is just for show.  The search happens as you type, but gives the hint of what the text ctrl does
	WxBitmapCheckButton* ButtonSearch;

	//Label for displaying "Type to Search" text that will go over the textctrl
	WxPassThroughStaticText* EmptySearchLabel; 

	//Cancel Image
	WxBitmap	ButtonCancelImage;
	//Search Image
	WxBitmap	ButtonSearchImage;

	//A saved copy of what the internal string should be.  Helps to know if it needs to reset to the "search for" string
	FString InternalString;

	//ID of the text control (passed in to Create)
	wxWindowID TextCtrlID;
};


IMPLEMENT_DYNAMIC_CLASS(WxSearchTextCtrl,wxTextCtrl);

BEGIN_EVENT_TABLE( WxSearchTextCtrl, wxTextCtrl )
	// We don't check for the ID here as it varies based on the value passed in when creating the WxSearchControl.
	EVT_TEXT(-1,WxSearchTextCtrl::OnFilterChanged)
	EVT_SET_FOCUS ( WxSearchTextCtrl::OnChangeFocus )
	EVT_KILL_FOCUS( WxSearchTextCtrl::OnChangeFocus )
	EVT_CHAR( WxSearchTextCtrl::OnChar )

	EVT_LEFT_DOWN(WxSearchTextCtrl::OnMouseEvent)
	EVT_RIGHT_DOWN(WxSearchTextCtrl::OnMouseEvent)
	EVT_LEFT_DCLICK(WxSearchTextCtrl::OnMouseEvent)
	EVT_RIGHT_DCLICK(WxSearchTextCtrl::OnMouseEvent)
END_EVENT_TABLE()


/**
* WxSearchControl: a combined filter/search text box and X button to clear the search.
*/
IMPLEMENT_DYNAMIC_CLASS(WxSearchControl,wxControl);

BEGIN_EVENT_TABLE( WxSearchControl, wxControl )
	EVT_BUTTON( ID_SEARCHTEXTCTRL_CANCEL_SEARCH_BUTTON, WxSearchControl::OnSearchButtonClicked)
	EVT_BUTTON( ID_SEARCHTEXTCTRL_SEARCH_BUTTON, WxSearchControl::OnSearchButtonClicked)
	EVT_SIZE( WxSearchControl::OnSize )
END_EVENT_TABLE()

WxSearchControl::~WxSearchControl(void)
{
}

/**
*	Initialize this text ctrl.  Must be the first function called after creation.
*
* @param	parent			The parent window.
*/
void WxSearchControl::Create( wxWindow* InParent, wxWindowID InID )
{
	check(InParent);

	wxControl::Create(InParent, -1, wxDefaultPosition, wxDefaultSize, wxCLIP_CHILDREN|wxNO_BORDER);
	FilterSizer = new wxBoxSizer(wxHORIZONTAL);

	/** Text box*/
	FilterStringTextCtrl = new WxSearchTextCtrl;
	FilterStringTextCtrl->Create(this, InID, FilterSizer);

	SetSizer(FilterSizer);
}

/**
* Callback used for cancelling searches
*/
void WxSearchControl::OnSearchButtonClicked ( wxCommandEvent& In )
{
	if (In.GetEventType() == wxEVT_COMMAND_BUTTON_CLICKED)
	{
		check(FilterStringTextCtrl);
		FilterStringTextCtrl->SetFocus();
		FilterStringTextCtrl->SetValue(TEXT(""));		//this will reset the filter for the window as well since the event is not suppressed
	}
	In.Skip();
}

/** Rebuild the focus array to go through all open children */
void WxSearchControl::AppendFocusWindows (OUT TArray<wxWindow*>& OutFocusArray)
{
	check(FilterStringTextCtrl);
	OutFocusArray.AddItem(FilterStringTextCtrl);
}

/**
 * Force clears the filter string
 */
void WxSearchControl::ClearFilterString(void)
{
	check(FilterStringTextCtrl);
	FilterStringTextCtrl->SetValue(TEXT(""));		//this will reset the filter for the window as well since the event is not suppressed
}


/** wxControl doesn't call Layout automatically, unlike wxPanel */
void WxSearchControl::OnSize( wxSizeEvent& In )
{
	Layout();
}

wxSize WxSearchControl::DoGetBestSize() const
{
	wxSize TextSize = FilterStringTextCtrl->GetBestSize();
	wxSize ButtonSize = FilterStringTextCtrl->ButtonCancel->GetBestSize();
	return wxSize( TextSize.GetWidth() + ButtonSize.GetWidth(), ButtonSize.GetHeight() );
} 

/**
 * WxSearchControlNextPrev: version of WxSearchControl with FindNext and FindPrev buttons.
 */
IMPLEMENT_DYNAMIC_CLASS(WxSearchControlNextPrev,WxSearchControl);

void WxSearchControlNextPrev::Create( wxWindow* InParent, wxWindowID InID )
{
	WxSearchControl::Create(InParent, InID);
	
	NextButtonImage.Load( TEXT("MaterialEditor_SearchNext") );
	PrevButtonImage.Load( TEXT("MaterialEditor_SearchPrev") );

	wxSize ImageSize;
	INT TextCtrlHeight = GetSize().GetHeight();
	ImageSize.Set(TextCtrlHeight, TextCtrlHeight);		//lock buttons to the same size as the text ctrl
	ImageSize.Scale(BUTTON_SCALE, BUTTON_SCALE);

	/** Next Button*/
	ButtonNext = new WxBitmapButton(this, ID_SEARCHTEXTCTRL_FINDNEXT_BUTTON, NextButtonImage);
	ButtonNext->SetSize(ImageSize);
	ButtonNext->SetToolTip(*LocalizeUnrealEd("Search_FindNext"));
	ButtonNext->Enable(FALSE);
	FilterSizer->Add(ButtonNext, 0, wxALIGN_RIGHT | wxALIGN_CENTER_VERTICAL, 0);

	/** Prev Button*/
	ButtonPrev = new WxBitmapButton(this, ID_SEARCHTEXTCTRL_FINDPREV_BUTTON, PrevButtonImage);
	ButtonPrev->SetSize(ImageSize);
	ButtonPrev->SetToolTip(*LocalizeUnrealEd("Search_FindPrev"));
	ButtonPrev->Enable(FALSE);
	FilterSizer->Add(ButtonPrev, 0, wxALIGN_RIGHT | wxALIGN_CENTER_VERTICAL, 0);

	Layout();
}

void WxSearchControlNextPrev::EnableNextPrev( UBOOL bEnableNext, UBOOL bEnablePrev )
{
	ButtonNext->Enable(bEnableNext?TRUE:FALSE);
	ButtonPrev->Enable(bEnablePrev?TRUE:FALSE);
}

wxSize WxSearchControlNextPrev::DoGetBestSize() const
{
	wxSize ParentSize = WxSearchControl::DoGetBestSize();
	wxSize ButtonSize = ButtonNext->GetBestSize();
	return wxSize( ParentSize.GetWidth() + ButtonSize.GetWidth()*2, ParentSize.GetHeight() );
} 
