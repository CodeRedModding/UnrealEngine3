/**
 * Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
 */
#include "Stdafx.h"
#include "PlatformTarget.h"
#include "Platform.h"
#include "TOCInfo.h"
#include "TOCSettings.h"

namespace ConsoleInterface
{
	// properties

	/// <summary>
	/// Gets the native target handle.
	/// </summary>
	TargetHandle PlatformTarget::Handle::get()
	{
		return mHandle;
	}

	/// <summary>
	/// Gets the name of the target.
	/// </summary>
	String^ PlatformTarget::Name::get()
	{
		return gcnew String(mOwner->ConsoleSupport->GetTargetName(mHandle));
	}

	/// <summary>
	/// Gets Title IP Address for the target.
	/// </summary>
	Net::IPAddress^ PlatformTarget::IPAddress::get()
	{
		unsigned int Addr = mOwner->ConsoleSupport->GetIPAddress(mHandle);

		return gcnew Net::IPAddress(Addr);
	}

	/// <summary>
	/// Gets the debug channel IP address.
	/// </summary>
	Net::IPAddress^ PlatformTarget::DebugIPAddress::get()
	{
		unsigned int Addr = mOwner->ConsoleSupport->GetDebugChannelIPAddress(mHandle);

		return gcnew Net::IPAddress(Addr);
	}

	/// <summary>
	/// Gets the current state of the target.
	/// </summary>
	TargetState PlatformTarget::State::get()
	{
		return (TargetState)mOwner->ConsoleSupport->GetTargetState(mHandle);
	}

	/// <summary>
	/// Gets whether or not the target has been connected to.
	/// </summary>
	bool PlatformTarget::IsConnected::get()
	{
		return mOwner->ConsoleSupport->GetTargetState(mHandle) > FConsoleSupport::TS_Unconnected;
	}

	/// <summary>
	/// Gets the platform the target belongs to.
	/// </summary>
	Platform^ PlatformTarget::ParentPlatform::get()
	{
		return mOwner;
	}

	/// <summary>
	/// Gets the type of the target.
	/// </summary>
	TargetType PlatformTarget::ConsoleType::get()
	{
		return (TargetType)mOwner->ConsoleSupport->GetTargetType(mHandle);
	}

	/// <summary>
	/// Sets crash report filters for the target.
	/// </summary>
	void PlatformTarget::CrashFilter::set(CrashReportFilter Value)
	{
		mOwner->ConsoleSupport->SetCrashReportFilter(mHandle, (FConsoleSupport::ECrashReportFilter)Value);
	}

	/// <summary>
	/// Gets the name the target manager associates with the target.
	/// </summary>
	String^ PlatformTarget::TargetManagerName::get()
	{
		String ^TMName = gcnew String(mOwner->ConsoleSupport->GetUnresolvedTargetName(mHandle));

		TMName = ResolveIPFromHostFile(TMName);

		return TMName;
	}

	/// <summary>
	/// Gets the type of crash dumps generated by the target.
	/// </summary>
	DumpType PlatformTarget::CrashDumpType::get()
	{
		return (DumpType)mOwner->ConsoleSupport->GetDumpType(mHandle);
	}

	/// <summary>
	/// Sets the type of crash dumps generated by the target.
	/// </summary>
	void PlatformTarget::CrashDumpType::set(DumpType DmpType)
	{
		mOwner->ConsoleSupport->SetDumpType(mHandle, (FConsoleSupport::EDumpType)DmpType);
	}

	//functions

	/// <summary>
	/// Constructor.
	/// </summary>
	/// <param name="Handle">The handle to the target.</param>
	/// <param name="Owner">The platform the target belongs to.</param>
	PlatformTarget::PlatformTarget(TargetHandle Handle, Platform ^Owner)
	{
		if(Owner == nullptr)
		{
			throw gcnew ArgumentNullException(L"Owner");
		}

		mOwner = Owner;
		mHandle = Handle;
		ExistingDirectories = gcnew Dictionary<String^, String^>();

		if(!mHasParsedHosts)
		{
			ParseHostsFile();
		}
	}

	/// <summary>
	/// Establishes a debug connection with the target.
	/// </summary>
	/// <returns>True if a connection has been made with the target.</returns>
	bool PlatformTarget::Connect()
	{
		return mOwner->ConsoleSupport->ConnectToTarget(mHandle);
	}

	/// <summary>
	/// Disconnects from the target.
	/// </summary>
	void PlatformTarget::Disconnect()
	{
		mOwner->ConsoleSupport->DisconnectFromTarget(mHandle);
	}

	/// <summary>
	/// Checks if a file is up to date on the target.
	/// </summary>
	/// <param name="SourceFilename">The file to be copied.</param>
	/// <param name="DestFileName">The file to be overwritten.</param>
	/// <param name="bReverse">True if the source file and dest file are to be switched.</param>
	/// <returns>True if the source file needs to be copied.</returns>
	bool PlatformTarget::NeedsToCopyFile(String ^SourceFilename, String ^DestFileName, bool bReverse)
	{
		if(SourceFilename == nullptr)
		{
			throw gcnew ArgumentNullException(L"SourceFilename");
		}

		if(DestFileName == nullptr)
		{
			throw gcnew ArgumentNullException(L"DestFileName");
		}

		pin_ptr<const wchar_t> NativeSrcFile = PtrToStringChars(SourceFilename);
		pin_ptr<const wchar_t> NativeDestFile = PtrToStringChars(DestFileName);

		return mOwner->ConsoleSupport->NeedsToCopyFile(mHandle, NativeSrcFile, NativeDestFile, bReverse);
	}

	/// <summary>
	/// Copies a file to the target.
	/// </summary>
	/// <param name="SourceFilename">The file to be copied.</param>
	/// <param name="DestFileName">The file to be written to.</param>
	/// <returns>True if the source file was successfully copied.</returns>
	bool PlatformTarget::CopyFileToTarget(String ^SourceFilename, String ^DestFileName)
	{
		pin_ptr<const wchar_t> NativeSrcFile = PtrToStringChars(SourceFilename);
		pin_ptr<const wchar_t> NativeDestFile = PtrToStringChars(DestFileName);

		return mOwner->ConsoleSupport->CopyFileToTarget(mHandle, NativeSrcFile, NativeDestFile);
	}

	/// <summary>
	/// Copies a file from the target.
	/// </summary>
	/// <param name="SourceFilename">The file to be copied.</param>
	/// <param name="DestFileName">The file to be written to.</param>
	/// <returns>True if the source file was successfully copied.</returns>
	bool PlatformTarget::RetrieveFileFromTarget(String ^SourceFilename, String ^DestFileName)
	{
		pin_ptr<const wchar_t> NativeSrcFile = PtrToStringChars(SourceFilename);
		pin_ptr<const wchar_t> NativeDestFile = PtrToStringChars(DestFileName);

		return mOwner->ConsoleSupport->RetrieveFileFromTarget(mHandle, NativeSrcFile, NativeDestFile);
	}

	/// <summary>
	/// Reboots the target.
	/// </summary>
	/// <returns>True if the target was successfully rebooted.</returns>
	bool PlatformTarget::Reboot()
	{
		return mOwner->ConsoleSupport->ResetTargetToShell(mHandle, false);
	}

	/// <summary>
	/// Reboots the target and tells it to start loading the specified game.
	/// </summary>
	/// <param name="Configuration">The configuration the game will run on.</param>
	/// <param name="BaseDirectory">The base directory of the game on the target HD.</param>
	/// <param name="GameName">The name of the game to run.</param>
	/// <param name="URL">The URL containing extra command line parameters.</param>
	/// <param name="bForceGameName">If true then GameName must reference the full name of the executable within BaseDirectory (i.e. ExampleGame-XeDebug.xex).</param>
	/// <returns>True the target was rebooted and has started loading the game.</returns>
	bool PlatformTarget::RunGameOnTarget(String ^GameName, String ^Configuration, String ^URL, String ^BaseDirectory)
	{
		pin_ptr<const wchar_t> NativeGameName = PtrToStringChars(GameName);
		pin_ptr<const wchar_t> NativeConfig = PtrToStringChars(Configuration);
		pin_ptr<const wchar_t> NativeURL = PtrToStringChars(URL);
		pin_ptr<const wchar_t> NativeBaseDir = PtrToStringChars(BaseDirectory);

		return mOwner->ConsoleSupport->RunGameOnTarget(mHandle, NativeGameName, NativeConfig, NativeURL, NativeBaseDir);
	}

	/// <summary>
	/// Takes a screen shot.
	/// </summary>
	/// <param name="FileName">The local file name of the screen shot (.bmp).</param>
	/// <returns>True if the screen shot was taken and saved to disk.</returns>
	bool PlatformTarget::ScreenShot(String ^FileName)
	{
		pin_ptr<const wchar_t> NativeFileName = PtrToStringChars(FileName);

		return mOwner->ConsoleSupport->ScreenshotBMP(mHandle, NativeFileName);
	}

	/// <summary>
	/// Generates a string representation of the target.
	/// </summary>
	/// <returns>The name of the target.</returns>
	String^ PlatformTarget::ToString()
	{
		return this->Name;
	}

	/// <summary>
	/// Periodically let the target have some time (to keep alive, etc)
	/// </summary>
	void PlatformTarget::Heartbeat()
	{
		mOwner->ConsoleSupport->Heartbeat(mHandle);
	}

	/// <summary>
	/// Copies files needed to run a game to the target.
	/// </summary>
	/// <param name="BuildSettings">Information about the files to copy.</param>
	/// <param name="TOCInfo">Table of contents.</param>
	void PlatformTarget::Sync(TOCSettings ^BuildSettings, TOCInfo ^Entry)
	{
		bool bCopySucceeded = true;

		// skip files that don't need to be copied
		String ^DestPath = Path::Combine(BuildSettings->TargetBaseDirectory, Entry->FileName);

		if(BuildSettings->Force || this->NeedsToCopyFile(Entry->FileName, DestPath, false))
		{
			if(!BuildSettings->NoSync)
			{
				BuildSettings->WriteLine(Color::Black, L"Copying {0} to {1}: {2}", Entry->FileName, this->Name, DestPath);

				try
				{
					bCopySucceeded = this->CopyFileToTarget(Entry->FileName, DestPath);
				}
				catch (Exception^)
				{
					bCopySucceeded = false;
				}

				if(!bCopySucceeded)
				{
					BuildSettings->WriteLine(Color::Red, L"Failed copy: {0}: {1}", this->Name, DestPath);
				}
			}
			else
			{
				BuildSettings->WriteLine(Color::Blue, L"Would copy {0} to {1}: {2}", Entry->FileName, this->Name, DestPath);
			}
		}
	}

	/// <summary>
	/// Prepares the target for syncing.
	/// </summary>
	void PlatformTarget::InitializeSyncing()
	{
		ExistingDirectories->Clear();
	}

	/// <summary>
	/// Sends a debug command to the target.
	/// </summary>
	/// <param name="Cmd">The command to send.</param>
	void PlatformTarget::SendCommand(String ^Cmd)
	{
		pin_ptr<const wchar_t> NativeCmd = PtrToStringChars(Cmd);

		mOwner->ConsoleSupport->SendConsoleCommand(mHandle, NativeCmd);
	}

	/// <summary>
	/// Sets the callback function for TTY output.
	/// </summary>
	/// <param name="TTYCallback">The callback.</param>
	void PlatformTarget::SetTTYCallback(TTYOutputDelegate ^TTYCallback)
	{
		mTTYCallback = TTYCallback;

		if(TTYCallback == nullptr)
		{
			mOwner->ConsoleSupport->SetTTYCallback(mHandle, NULL);
		}
		else
		{
			mOwner->ConsoleSupport->SetTTYCallback(mHandle, (TTYEventCallbackPtr)Marshal::GetFunctionPointerForDelegate(TTYCallback).ToPointer());
		}
	}

	/// <summary>
	/// Sets the callback function for handling crashes.
	/// </summary>
	/// <param name="CrashCallback">The callback.</param>
	void PlatformTarget::SetCrashCallback(CrashCallbackDelegate ^CrashCallback)
	{
		mCrashCallback = CrashCallback;

		if(CrashCallback == nullptr)
		{
			mOwner->ConsoleSupport->SetCrashCallback(mHandle, NULL);
		}
		else
		{
			mOwner->ConsoleSupport->SetCrashCallback(mHandle, (CrashCallbackPtr)Marshal::GetFunctionPointerForDelegate(CrashCallback).ToPointer());
		}
	}

	/// <summary>
	/// Parses the hosts file for resolving IP addresses.
	/// </summary>
	void PlatformTarget::ParseHostsFile()
	{
		mHasParsedHosts = true;

		try
		{
			array<String^> ^Lines = File::ReadAllLines(Path::Combine(Environment::GetFolderPath(Environment::SpecialFolder::System), L"drivers\\etc\\hosts"));

			for each(String ^CurLine in Lines)
			{
				if(CurLine->StartsWith(L"#") || CurLine->Length == 0)
				{
					continue;
				}

				array<String^> ^Parts = CurLine->Split(gcnew array<Char> { L' ', '\t' }, StringSplitOptions::RemoveEmptyEntries);

				if(Parts->Length >= 2)
				{
					System::Net::IPAddress ^Addr;
					if(System::Net::IPAddress::TryParse(Parts[0], Addr))
					{
						mHosts[BitConverter::ToUInt32(Addr->GetAddressBytes(), 0)] = Parts[1];
					}
				}
			}
		}
		catch(Exception ^ex)
		{
			System::Diagnostics::Debug::WriteLine(ex->ToString());
		}
	}

	/// <summary>
	/// Attempts to find the supplied IP address in the host file and resolve its name.
	/// </summary>
	/// <param name="IpAddr>A string containing the IP address to resolve.</param>
	/// <returns>The resolved name if it exists otherwise IpAddr.</returns>
	String^ PlatformTarget::ResolveIPFromHostFile(String ^IpAddr)
	{
		System::Net::IPAddress ^Addr;
		if(System::Net::IPAddress::TryParse(IpAddr, Addr))
		{
			unsigned int NativeAddr = BitConverter::ToUInt32(Addr->GetAddressBytes(), 0);
			String ^HostName;

			if(mHosts->TryGetValue(NativeAddr, HostName))
			{
				IpAddr = HostName;
			}
		}

		return IpAddr;
	}
}
