/*=============================================================================
	LandscapeVertexFactory.usf: Landscape vertex factory.
	Copyright 1998-2013 Epic Games, Inc. All Rights Reserved.
=============================================================================*/

#include "DecalFactoryCommon.usf"

#define TERRAIN_ZSCALE				(1.0f/128.0f)

/* Landscape does not support adjacency information, so we must use flat tessellation without crack-free displacement */
#if USING_SM5_TESSELLATION
#undef TESSELLATION_TYPE_FLAT
#define TESSELLATION_TYPE_FLAT 1
#undef TESSELLATION_TYPE_PNTRIANGLES
#define TESSELLATION_TYPE_PNTRIANGLES 0
#undef DISPLACEMENT_ANTICRACK
#define DISPLACEMENT_ANTICRACK 0
#endif


float3x3	WorldToLocalNoScaling;
float3x3	LocalToWorldNoScaling;

float4 HeightmapUVScaleBias; 
float4 WeightmapUVScaleBias;
float4 LandscapeLightmapScaleBias;
float4 LightmapCoordinateScaleBias;
float4 ShadowmapCoordinateScaleBias;

/* x = LodMorphBias.x
   y = LodMorphBias.y
   z = Heightmap LOD bias
   w = reserved
*/
float4 LodBias;

/* x = LOD
   y = convert current LOD coordinates into highest LOD coordinates
   z = SectionSizeQuads in current LOD
   w = 1/SectionSizeQuads in current LOD
*/
float4 LodValues;

/* x = LOD in 0 location               0     -> X
   y = LOD in 1 location        1   Current  2
   z = LOD in 2 location        |      3
   w = LOD in 3 location        V Y
*/
float4 LodDistancesValues; // Change to each corner LOD value

/*
	x = SubsectionSizeVerts
	y = 1.f / SubsectionSizeQuads
	z = LayerUVPan.u
	w = LayerUVPan.w
*/
float4 SubsectionSizeVertsLayerUVPan;

sampler2D HeightmapTexture;

struct FVertexFactoryInput
{
	float2 Position: POSITION;
#if PS3
	float4 PS3Height : BLENDWEIGHT0;	
#endif
};

struct FVertexFactoryInterpolantsVSToPS
{
	float3	LayerTexCoord			: TEXCOORD0;
	float4	HeightWeightMapTexCoord	: TEXCOORD1;
#if NEEDS_LIGHTMAP_COORDINATE
	float2	LightMapCoordinate		: TEXCOORD2;
#endif
};

struct FLandscapeTexCoords
{
	float3	LayerTexCoord;
	float4	HeightWeightMapTexCoord;
#if NEEDS_LIGHTMAP_COORDINATE
	float2	LightMapCoordinate;
#endif
};

struct FVertexFactoryInterpolantsVSToDS
{
	FVertexFactoryInterpolantsVSToPS InterpolantsVSToPS;
	
#if USING_SM5_TESSELLATION
	// First row of the tangent to world matrix
	float3	TangentToWorld0	: VS_To_DS_TangentToWorld0;
	// Last row of the tangent to world matrix in xyz
	float4	TangentToWorld2	: VS_To_DS_TangentToWorld2;
#endif
};

#if USING_SM5_TESSELLATION
float2 VertexFactoryGetTextureCoordinateDS( FVertexFactoryInterpolantsVSToDS Interpolants )
{
	return Interpolants.InterpolantsVSToPS.HeightWeightMapTexCoord.xy;
}

float4 VertexFactoryGetWorldNormalDS( FVertexFactoryInterpolantsVSToDS Interpolants )
{
	return Interpolants.TangentToWorld2;
}

float3 VertexFactoryGetWorldTangentDS( FVertexFactoryInterpolantsVSToDS Interpolants )
{
	return Interpolants.TangentToWorld0;
}
#endif // #if USING_SM5_TESSELLATION

FVertexFactoryInterpolantsVSToPS VertexFactoryAssignInterpolants(FVertexFactoryInterpolantsVSToDS Input)
{
	return Input.InterpolantsVSToPS;
}

struct FVertexFactoryIntermediates
{
	float3 LocalPosition;
#if USING_SM5_TESSELLATION
	float3 WorldNormal;
#endif
};

/** Calculate the texture coordinates generated by Landscape */
FLandscapeTexCoords GetLandscapeTexCoords(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	FLandscapeTexCoords Result;

#if DECAL_FACTORY
	Result.LayerTexCoord				= float3(Intermediates.LocalPosition.xy * HeightmapUVScaleBias.xy + HeightmapUVScaleBias.zw + 0.5*HeightmapUVScaleBias.xy, 0);
#else
	Result.LayerTexCoord				= float3(Intermediates.LocalPosition.xy + SubsectionSizeVertsLayerUVPan.zw,0);
#endif
	Result.HeightWeightMapTexCoord.zw	= Intermediates.LocalPosition.xy * WeightmapUVScaleBias.xy + WeightmapUVScaleBias.zw;
	Result.HeightWeightMapTexCoord.xy	= Intermediates.LocalPosition.xy * HeightmapUVScaleBias.xy + HeightmapUVScaleBias.zw + 0.5*HeightmapUVScaleBias.xy;

#if NEEDS_LIGHTMAP_COORDINATE
	Result.LightMapCoordinate.xy		= (Intermediates.LocalPosition.xy * LandscapeLightmapScaleBias.xy + LandscapeLightmapScaleBias.wz) * LightmapCoordinateScaleBias.xy + LightmapCoordinateScaleBias.wz;
#endif

	return Result;
}

float3x3 CalcTangentBasisFromWorldNormal(float3 Normal)
{
	float3 LocalTangentX = normalize(float3(Normal.z, 0, -Normal.x));
	float3 LocalTangentY = cross(Normal, LocalTangentX);

	float3x3 LocalToTangent = float3x3(LocalTangentX,LocalTangentY,Normal);

	return LocalToTangent;
}

#if DECAL_FACTORY
float3 VertexFactoryGetWorldNormal(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	float4 SampleValue = tex2D(HeightmapTexture, Interpolants.LayerTexCoord.xy);
#if PS3
	float2 SampleNormal = SampleValue.xy; 
#else
	float2 SampleNormal = float2(SampleValue.b, SampleValue.a) * float2(2.0,2.0) - float2(1.0,1.0);
#endif
	return float3( SampleNormal, sqrt(max(1.0-dot(SampleNormal,SampleNormal),0.0)) );
}

half4 VertexFactoryGetPerPixelDecalNormalTransform(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	float3 WorldNormal = VertexFactoryGetWorldNormal(Interpolants);
	float3x3 LocalBasis = CalcTangentBasisFromWorldNormal(WorldNormal);
	return CalcDecal2x2NormalTransform(LocalBasis[0], LocalBasis[2], determinant(LocalBasis));
}
#endif

/** Lookup per-pixel tangent basis from heightmap texture */
float3x3 VertexFactoryGetPerPixelTangentBasis(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	float3x3 Result;
#if DECAL_FACTORY
	float4 SampleValue = tex2D(HeightmapTexture, Interpolants.LayerTexCoord.xy);
#else
	float4 SampleValue = tex2D(HeightmapTexture, Interpolants.HeightWeightMapTexCoord.xy);
#endif
#if PS3
	float2 SampleNormal = SampleValue.xy;
#else
	float2 SampleNormal = float2(SampleValue.b, SampleValue.a) * float2(2.0,2.0) - float2(1.0,1.0);
#endif

	float3 WorldNormal = float3( SampleNormal, sqrt(max(1.0-dot(SampleNormal,SampleNormal),0.0)) );

	Result = CalcTangentBasisFromWorldNormal(WorldNormal);
#if DECAL_FACTORY
	Result = ProjectDecalTangents(Result[2]);
#endif
	return Result;
}

/** Converts from vertex factory specific interpolants to a FMaterialTessellationParameters, which is used by material inputs. */
FMaterialTessellationParameters GetMaterialTessellationParameters(FVertexFactoryInterpolantsVSToDS Interpolants, float3 CameraLocalWorldPosition)
{
	FMaterialTessellationParameters	Result;

#if NUM_MATERIAL_TEXCOORDS
	Result.TexCoords[0] = Interpolants.InterpolantsVSToPS.HeightWeightMapTexCoord.xy;
#if NUM_MATERIAL_TEXCOORDS > 1
	Result.TexCoords[1] = Interpolants.InterpolantsVSToPS.HeightWeightMapTexCoord.zw;
#if NUM_MATERIAL_TEXCOORDS > 2
	#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[2] = Interpolants.InterpolantsVSToPS.LightMapCoordinate;
	#else
		Result.TexCoords[2] = float2(0,0);
	#endif
#if NUM_MATERIAL_TEXCOORDS > 3
	Result.TexCoords[3] = Interpolants.InterpolantsVSToPS.LayerTexCoord.xy;
#if NUM_MATERIAL_TEXCOORDS > 4
	Result.TexCoords[4] = Interpolants.InterpolantsVSToPS.LayerTexCoord.xz;
#if NUM_MATERIAL_TEXCOORDS > 5
	Result.TexCoords[5] = Interpolants.InterpolantsVSToPS.LayerTexCoord.yz;
#if NUM_MATERIAL_TEXCOORDS > 6
	UNROLL
	for(int CoordinateIndex = 6;CoordinateIndex < NUM_MATERIAL_TEXCOORDS;CoordinateIndex ++)
	{
		Result.TexCoords[CoordinateIndex] = float2(0,0);
	}
#endif	// >6
#endif	// >5
#endif	// >4
#endif	// >3
#endif	// >2
#endif	// >1
#endif

	// Use interpolated normal from VS.
#if USING_SM5_TESSELLATION
	#if DECAL_FACTORY
		Result.TangentToWorld = CalcInvTangentBasisDecal( Result.TangentToWorld[0] );
	#else
		Result.TangentToWorld = CalcTangentToWorld( Interpolants.TangentToWorld0, Interpolants.TangentToWorld2 );
	#endif
#endif

	Result.VertexColor = 1;
	Result.TangentToWorldPreScale = 1;
	Result.WorldPosition = CameraLocalWorldPosition + CameraWorldPos.xyz;

#if DOMAINSHADER
	Result.TangentCameraVector = TransformWorldVectorToTangent(Result.TangentToWorld,CameraPositionDS.xyz - CameraLocalWorldPosition.xyz * CameraPositionDS.w);
#endif // #if DOMAINSHADER

	return Result;
}

/** Converts from vertex factory specific interpolants to a FMaterialPixelParameters, which is used by material inputs. */
FMaterialPixelParameters GetMaterialPixelParameters(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	FMaterialPixelParameters	Result;

#if NUM_MATERIAL_TEXCOORDS
	Result.TexCoords[0] = Interpolants.HeightWeightMapTexCoord.xy;		// Heightmap
	UNROLL
	for(uint SampleIndex0 = 0;SampleIndex0 < NUM_TEXCOORD_SAMPLES;++SampleIndex0)
	{
		Result.SampleTexCoords[SampleIndex0][0] = EvaluateAttributeAtSample(Interpolants.HeightWeightMapTexCoord.xy,SampleIndex0);
	}
#if NUM_MATERIAL_TEXCOORDS > 1
	Result.TexCoords[1] = Interpolants.HeightWeightMapTexCoord.zw;		// Weightmap
	UNROLL
	for(uint SampleIndex1 = 0;SampleIndex1 < NUM_TEXCOORD_SAMPLES;++SampleIndex1)
	{
		Result.SampleTexCoords[SampleIndex1][1] = EvaluateAttributeAtSample(Interpolants.HeightWeightMapTexCoord.zw,SampleIndex1);
	}
#if NUM_MATERIAL_TEXCOORDS > 2
	#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[2] = Interpolants.LightMapCoordinate;			// Lightmap
		UNROLL
		for(uint SampleIndex2 = 0;SampleIndex2 < NUM_TEXCOORD_SAMPLES;++SampleIndex2)
		{
			Result.SampleTexCoords[SampleIndex2][2] = EvaluateAttributeAtSample(Interpolants.LightMapCoordinate,SampleIndex2);
		}
	#else	//#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[2] = float2(0,0);
		UNROLL
		for(uint SampleIndex2 = 0;SampleIndex2 < NUM_TEXCOORD_SAMPLES;++SampleIndex2)
		{
			Result.SampleTexCoords[SampleIndex2][2] = float2(0,0);
		}
	#endif	//#if NEEDS_LIGHTMAP_COORDINATE
#if NUM_MATERIAL_TEXCOORDS > 3
	Result.TexCoords[3] = Interpolants.LayerTexCoord.xy;				// XY layer
	UNROLL
	for(uint SampleIndex3 = 0;SampleIndex3 < NUM_TEXCOORD_SAMPLES;++SampleIndex3)
	{
		Result.SampleTexCoords[SampleIndex3][3] = EvaluateAttributeAtSample(Interpolants.LayerTexCoord.xy,SampleIndex3);
	}
#if NUM_MATERIAL_TEXCOORDS > 4
	Result.TexCoords[4] = Interpolants.LayerTexCoord.xz;				// XZ layer
	UNROLL
	for(uint SampleIndex4 = 0;SampleIndex4 < NUM_TEXCOORD_SAMPLES;++SampleIndex4)
	{
		Result.SampleTexCoords[SampleIndex4][4] = EvaluateAttributeAtSample(Interpolants.LayerTexCoord.xz,SampleIndex4);
	}
#if NUM_MATERIAL_TEXCOORDS > 5
	Result.TexCoords[5] = Interpolants.LayerTexCoord.yz;				// YZ layer
	UNROLL
	for(uint SampleIndex5 = 0;SampleIndex5 < NUM_TEXCOORD_SAMPLES;++SampleIndex5)
	{
		Result.SampleTexCoords[SampleIndex5][5] = EvaluateAttributeAtSample(Interpolants.LayerTexCoord.yz,SampleIndex5);
	}
#if NUM_MATERIAL_TEXCOORDS > 6
	UNROLL
	for(uint CoordinateIndex = 6;CoordinateIndex < NUM_MATERIAL_TEXCOORDS;CoordinateIndex++)
	{
		Result.TexCoords[CoordinateIndex] = float2(0,0);
		UNROLL
		for(uint SampleIndex6 = 0;SampleIndex6 < NUM_TEXCOORD_SAMPLES;++SampleIndex6)
		{
			Result.SampleTexCoords[SampleIndex6][CoordinateIndex] = float2(0,0);
		}
	}
#endif // 6
#endif // 5
#endif // 4
#endif // 3
#endif // 2 
#endif // 1
#endif // 0

#if ((MATERIAL_DECAL || WORLD_COORDS) && DECAL_FACTORY)
	float3 WorldNormal = VertexFactoryGetWorldNormal(Interpolants);
#endif

#if WORLD_COORDS
	#if DECAL_FACTORY
		//float3 WorldNormal = VertexFactoryGetWorldNormal(Interpolants);
		Result.TangentToWorld = CalcInvTangentBasisDecal( WorldNormal );
	#else
		// Calculate LocalToTangent directly from normal map texture.
		float3x3 LocalToTangent = VertexFactoryGetPerPixelTangentBasis(Interpolants);
		// The inverse of LocalToTangent is just the transpose because it is an orthonormal basis
		float3x3 TangentToLocal = transpose(LocalToTangent);
		#if ROW_MAJOR
			Result.TangentToWorld = mul(LocalToWorldNoScaling, TangentToLocal); 
		#else
			Result.TangentToWorld = mul(transpose(LocalToWorldNoScaling), TangentToLocal); 
		#endif
	#endif

	Result.UnMirrored = 1;
#endif

	Result.VertexColor = 1;

	Result.TangentNormal = 0;
	Result.TangentCameraVector = 0;
	Result.TangentReflectionVector = 0;
	Result.ScreenPosition = 0;
	Result.TangentLightVector = 0;

#if LIGHTMAP_UV_ACCESS
#if NEEDS_LIGHTMAP_COORDINATE	//TEXTURE_LIGHTMAP || SIMPLE_TEXTURE_LIGHTMAP
	Result.LightmapUVs = Interpolants.LightMapCoordinate.xy;
#else
	Result.LightmapUVs = float2(0, 0);
#endif
#endif

#if MATERIAL_DECAL
	#if DECAL_FACTORY
		Result.DecalAttenuation = CalcDecalAttenuation( WorldNormal );
		Result.DecalPlaneDistance = Interpolants.HeightWeightMapTexCoord.w;
	#else
		Result.DecalAttenuation = 1;
		Result.DecalPlaneDistance = 0;
	#endif
#endif

	Result.TwoSidedSign = 1;
	return Result;
}

// When we're using instancing on Xbox, the vertex attributes are in the FVertexFactoryIntermediates, rather than the VertexFactoryInput struct.
#define VertexAttributes	Input


float4 VertexFactoryGetVertexColor(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return float4(1,1,1,1);
}

/** Converts from vertex factory specific input to a FMaterialVertexParameters, which is used by vertex shader material inputs. */
FMaterialVertexParameters GetMaterialVertexParameters( FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3 WorldPosition, float3x3 TangentBasis )
{
	FMaterialVertexParameters Result;
	Result.WorldPosition = WorldPosition - PreViewTranslation.xyz;
	Result.VertexColor = VertexFactoryGetVertexColor(Input, Intermediates);

	float3x3 TangentToLocal = transpose(TangentBasis);

	#if ROW_MAJOR
		float3x3 TangentToWorld = mul((float3x3)LocalToWorld, TangentToLocal); 
	#else
		// does not handle instancing!
		float3x3 TangentToWorld = mul(transpose((float3x3)LocalToWorld), TangentToLocal); 
	#endif

	Result.TangentToWorld = TangentToWorld;

	FLandscapeTexCoords LandscapeTexCoords = GetLandscapeTexCoords(Input, Intermediates);

#if !(DECAL_FACTORY && MATERIAL_DECAL)
#if NUM_MATERIAL_TEXCOORDS
	Result.TexCoords[0] = LandscapeTexCoords.HeightWeightMapTexCoord.xy;
#if NUM_MATERIAL_TEXCOORDS > 1
	Result.TexCoords[1] = LandscapeTexCoords.HeightWeightMapTexCoord.zw;
#if NUM_MATERIAL_TEXCOORDS > 2
	#if NEEDS_LIGHTMAP_COORDINATE
		Result.TexCoords[2] = LandscapeTexCoords.LightMapCoordinate;
	#else
		Result.TexCoords[2] = float2(0,0);
	#endif
#if NUM_MATERIAL_TEXCOORDS > 3
	Result.TexCoords[3] = LandscapeTexCoords.LayerTexCoord.xy;
#if NUM_MATERIAL_TEXCOORDS > 4
	Result.TexCoords[4] = LandscapeTexCoords.LayerTexCoord.xz;
#if NUM_MATERIAL_TEXCOORDS > 5
	Result.TexCoords[5] = LandscapeTexCoords.LayerTexCoord.yz;
#if NUM_MATERIAL_TEXCOORDS > 6
	UNROLL
	for(int CoordinateIndex = 6;CoordinateIndex < NUM_MATERIAL_TEXCOORDS;CoordinateIndex ++)
	{
		Result.TexCoords[CoordinateIndex] = float2(0,0);
	}
#endif	// >6
#endif	// >5
#endif	// >4
#endif	// >3
#endif	// >2
#endif	// >1
#endif  // >0
#endif  // !(DECAL_FACTORY && MATERIAL_DECAL)

	return Result;
}

#if NEEDS_LIGHTMAP_COORDINATE
float2 GetLightMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.LightMapCoordinate.xy;
}

#if NEEDS_SHADOWMAP_COORDINATE
float2 GetShadowMapCoordinate(FVertexFactoryInterpolantsVSToPS Interpolants)
{
	return Interpolants.LightMapCoordinate.xy * ShadowmapCoordinateScaleBias.xy + ShadowmapCoordinateScaleBias.zw;
}
#endif
#endif

#if NEEDS_VERTEX_LIGHTMAP
void VertexFactoryGetVertexLightMap(FVertexFactoryInput Input,out float4 LightMapA,out float4 LightMapB)
{
	LightMapA = 1;
	LightMapB = 1;
}
#elif NEEDS_SIMPLE_VERTEX_LIGHTMAP
void VertexFactoryGetSimpleVertexLightMap(FVertexFactoryInput Input,out float4 LightMapA)
{
	LightMapA = 1;
}
#endif

FVertexFactoryIntermediates GetVertexFactoryIntermediates(FVertexFactoryInput Input)
{
	FVertexFactoryIntermediates Intermediates;

#if PS3 // Old LOD system
	// Position for current LOD in base LOD units
	float2 InputPositionLODAdjusted = Input.Position.xy * LodValues.y;

	// Position for next LOD in base LOD units
	float2 NextLODCoordsInt = floor( InputPositionLODAdjusted * LodValues.z + float2(0.5,0.5) );
	float2 InputPositionNextLOD = NextLODCoordsInt * LodValues.w;

	// calculate amount of morphing based on LOD.
	float LodDistance = length(LodDistancesValues.xy - InputPositionLODAdjusted);
	float MorphAlpha = clamp( (LodDistance - LodDistancesValues.z) / (LodDistancesValues.w - LodDistancesValues.z), 0.0, 1.0 );

	// Get the height and normal XY straight out of the SPU-generated stream.
	float Height = ((Input.PS3Height.z * 256.0 + Input.PS3Height.w) - 32768.0) * TERRAIN_ZSCALE;
	Intermediates.LocalPosition = lerp( float3(InputPositionLODAdjusted, Height), float3(InputPositionNextLOD, Height), MorphAlpha );

#else // New LOD system

	// 0 --------- 1 X  1 ----- 2  1          1 
	//   | \ 0 / |        \   /    | \      / | 
	//   | 1 + 2 |          0      |  0    0  |      0       
	//   | / 3 \ |                 | /      \ |    /   \     
	// 2 --------- 3               2          2  1 ----- 2   
	// Y

	// LOD value based on Barycentric coordinate
	float2 xy = Input.Position.xy * LodValues.w;

	float4 L0 = float4( xy.y, xy.x, (1-xy.x), (1-xy.y) ) * 2;

#if !OPENGL
	int LODIndex = (LodValues.z < Input.Position.x + Input.Position.y) * 2 + (Input.Position.x < Input.Position.y);
	float4 LODCalculated = L0 * LodValues.x + (1-L0) * LodDistancesValues;
#else
	int LODIndex = (Input.Position.x < Input.Position.y);

	// Hack for OpenGL shader compile...
	float2 LODCalculated;
	BRANCH
	if (LodValues.z < Input.Position.x + Input.Position.y)
	{
		LODCalculated = L0.zw * LodValues.x + (1-L0.zw) * LodDistancesValues.zw;
	}
	else
	{
		LODCalculated = L0.xy * LodValues.x + (1-L0.xy) * LodDistancesValues.xy;
	}
#endif

	float LodValue = floor(LODCalculated[LODIndex]);
	float MorphAlpha = frac(LODCalculated[LODIndex]);

	BRANCH
	if (LodValues.x < 1.f)
	{
		MorphAlpha = saturate((MorphAlpha - LodBias.x) * (LodValue+1) * 2.f ); // just tuned value
	}
	else
	{
		MorphAlpha = saturate((MorphAlpha - LodBias.x) * LodBias.y);
	}

	// Base to Actual LOD, Base to Next LOD
	float2 CoordTranslate = float2( SubsectionSizeVertsLayerUVPan.x * pow(2, -LodValue) - 1, max(SubsectionSizeVertsLayerUVPan.x * pow(2, -LodValue-1), 2) - 1 ) * SubsectionSizeVertsLayerUVPan.y;

	// Position for current LOD in base LOD units
	float2 InputPositionLODBase = Input.Position.xy * LodValues.y;

	// Position for actual LOD in base LOD units
	float2 ActualLODCoordsInt = floor( InputPositionLODBase * CoordTranslate.x + float2(0.5,0.5) );
	float2 InputPositionLODAdjusted = ActualLODCoordsInt / CoordTranslate.x;
	//float2 InputPositionLODAdjusted = InputPositionLODBase;

	// Get the height and normal XY for current and next LOD out of the textures
	float4 SampleCoords = float4(InputPositionLODAdjusted * HeightmapUVScaleBias.xy + HeightmapUVScaleBias.zw + 0.5*HeightmapUVScaleBias.xy, 0, LodValue-LodBias.z);
	float4 SampleValue = tex2Dlod( HeightmapTexture, SampleCoords );
	float Height = ((SampleValue.r * 255.0 * 256.0 + SampleValue.g * 255.0) - 32768.0) * TERRAIN_ZSCALE;

	// Position for next LOD in base LOD units
	float2 NextLODCoordsInt = floor( InputPositionLODBase * CoordTranslate.y + float2(0.5,0.5) );
	float2 InputPositionNextLOD = NextLODCoordsInt / CoordTranslate.y;

	float4 SampleCoordsNextLOD = float4(InputPositionNextLOD * HeightmapUVScaleBias.xy + HeightmapUVScaleBias.zw + 0.5*HeightmapUVScaleBias.xy, 0, LodValue+1-LodBias.z);
	float4 SampleValueNextLOD = tex2Dlod( HeightmapTexture, SampleCoordsNextLOD );
	float HeightNextLOD = ((SampleValueNextLOD.r * 255.0 * 256.0 + SampleValueNextLOD.g * 255.0) - 32768.0) * TERRAIN_ZSCALE;

	Intermediates.LocalPosition = lerp( float3(InputPositionLODAdjusted, Height), float3(InputPositionNextLOD, HeightNextLOD), MorphAlpha );
	//Intermediates.LocalPosition = lerp( float3(InputPositionLODAdjusted, LODCalculated[LODIndex]), float3(InputPositionNextLOD, LODCalculated[LODIndex]), MorphAlpha );

#if USING_SM5_TESSELLATION
	float2 Normal = float2(SampleValue.b, SampleValue.a);
	float2 NormalNextLOD = float2(SampleValueNextLOD.b, SampleValueNextLOD.a);
	float2 InterpNormal = lerp( Normal, NormalNextLOD, MorphAlpha ) * float2(2.0,2.0) - float2(1.0,1.0);
	Intermediates.WorldNormal = float3( InterpNormal, sqrt(max(1.0-dot(InterpNormal,InterpNormal),0.0)) );
#endif

#endif
	
	return Intermediates;
}

/**
* Get the 3x3 tangent basis vectors for this vertex factory
* this vertex factory will calculate the binormal on-the-fly
*
* @param Input - vertex input stream structure
* @return 3x3 matrix
*/
float3x3 VertexFactoryGetTangentBasis( FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates )
{
	float3x3 Result = float3x3(float3(1,0,0),float3(0,1,0),float3(0,0,1));
	return Result;
}

float4 VertexFactoryGetWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	return MulMatrix(LocalToWorld,float4(Intermediates.LocalPosition,1));
}

FVertexFactoryInterpolantsVSToPS VertexFactoryGetInterpolantsVSToPS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	FVertexFactoryInterpolantsVSToPS Interpolants;

	FLandscapeTexCoords LandscapeTexCoords = GetLandscapeTexCoords(Input, Intermediates);

	Interpolants.LayerTexCoord				= LandscapeTexCoords.LayerTexCoord;
#if MATERIAL_DECAL && DECAL_FACTORY
	float4 WorldSpacePos = VertexFactoryGetWorldPosition(Input, Intermediates);
	Interpolants.HeightWeightMapTexCoord.xy	= ComputeDecalTexCoord( WorldSpacePos );
	Interpolants.HeightWeightMapTexCoord.z = 1; // deferred calculation to pixel shader
	Interpolants.HeightWeightMapTexCoord.w = CalcDistanceToDecalOrigin(WorldSpacePos.xyz) / length(MulMatrix(LocalToWorld, float4(DecalLocalNormal, 0)));
#else
	Interpolants.HeightWeightMapTexCoord	= LandscapeTexCoords.HeightWeightMapTexCoord;
#endif

#if NEEDS_LIGHTMAP_COORDINATE
	Interpolants.LightMapCoordinate			 = LandscapeTexCoords.LightMapCoordinate;
#endif

	return Interpolants;
}

FVertexFactoryInterpolantsVSToDS VertexFactoryGetInterpolantsVSToDS(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	FVertexFactoryInterpolantsVSToDS Interpolants;
	
	Interpolants.InterpolantsVSToPS = VertexFactoryGetInterpolantsVSToPS(Input, Intermediates);
	
#if USING_SM5_TESSELLATION
	// Calculate LocalToTangent directly from normal map texture.
	float3x3 LocalToTangent = CalcTangentBasisFromWorldNormal( Intermediates.WorldNormal );
	// The inverse of LocalToTangent is just the transpose because it is an orthonormal basis
	float3x3 TangentToLocal = transpose(LocalToTangent);
	float3x3 TangentToWorld = mul(LocalToWorld, TangentToLocal); 
	
	Interpolants.TangentToWorld0 = TangentToWorld[0];
	Interpolants.TangentToWorld2 = float4(TangentToWorld[2], 1);

#endif
	
	return Interpolants;
}

float4 VertexFactoryGetPreviousWorldPosition(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	// Landscape doesn't move so use the current world position.
	return VertexFactoryGetWorldPosition(Input, Intermediates);
}

/**
* Transform a vector from world space to tangent space
*
* @param Input - vertex input stream structure
* @param TangentBasis - 3x3 matrix to transform to tangent space
* @param WorldVector - vector in world space to transform 
* @return vector in tangent space
*/
float3 VertexFactoryWorldToTangentSpace( FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates, float3x3 TangentBasis, float3 WorldVector )
{
	return mul(TangentBasis, MulMatrix(WorldToLocalNoScaling,WorldVector));
}

half3 VertexFactoryGetWorldNormal(FVertexFactoryInput Input, FVertexFactoryIntermediates Intermediates)
{
	/* This function is used only by HitMaskVertexShader, which is not supported with LandscapeVertexFactory */
	return float3(0,0,1);
}

FVertexFactoryInterpolantsVSToDS VertexFactoryInterpolate(FVertexFactoryInterpolantsVSToDS a, float aInterp, FVertexFactoryInterpolantsVSToDS b, float bInterp)
{
	FVertexFactoryInterpolantsVSToDS O;
	
#if NEEDS_LIGHTMAP_COORDINATE
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.LightMapCoordinate);
#endif

	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.LayerTexCoord);
	TESSELLATION_INTERPOLATE_MEMBER(InterpolantsVSToPS.HeightWeightMapTexCoord);

#if USING_SM5_TESSELLATION
	TESSELLATION_INTERPOLATE_MEMBER(TangentToWorld0);
	TESSELLATION_INTERPOLATE_MEMBER(TangentToWorld2);
#endif

	return O;
}

#if USING_SM5_TESSELLATION
float3x3 VertexFactoryGetTangentBasis(FVertexFactoryInterpolantsVSToDS Interpolants)
{
	float3x3 TangentToWorld;
#if DECAL_FACTORY
	TangentToWorld = CalcInvTangentBasisDecal( TangentToWorld[0] );
#else
	TangentToWorld = CalcTangentToWorld( Interpolants.TangentToWorld0, Interpolants.TangentToWorld2 );
#endif
	return TangentToWorld;
}
#endif // #if USING_SM5_TESSELLATION

float4 VertexFactoryGetWorldNormal(float3x3 TangentToWorld)
{
	return float4(mul(TangentToWorld, float3(0,0,1)), 0);
}

float4 VertexFactoryGetWorldNormal(FVertexFactoryInterpolantsVSToDS Interpolants)
{
#if USING_SM5_TESSELLATION
	return Interpolants.TangentToWorld2;
#else
	return float4(0,0,1,0);
#endif
}
